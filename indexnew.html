<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
	<title>Widget Test</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
	
	<!-- Made with Construct, the game and app creator :: https://www.construct.net -->
	

<style>
html, body {
	padding: 0;
	margin: 0;
	overflow: hidden;
	height: 100%;
}

body {
	background: #000000;
	color: white;
}

input[type="file"] {
	color: black;
}

html, body, canvas {
	touch-action-delay: none;
	touch-action: none;
}

canvas, .c3htmlwrap {
	position: absolute;
}

.c3htmlwrap {
	contain: strict;
}

.c3overlay {
	pointer-events: none;
}

.c3htmlwrap[interactive] > * {
	pointer-events: auto;
}

/* HACK - work around elements being selectable only in iOS WKWebView for some reason */
html[ioswebview] .c3htmlwrap,
html[ioswebview] canvas {
	-webkit-user-select: none;
	user-select: none;
}

html[ioswebview] .c3htmlwrap > * {
	-webkit-user-select: auto;
	user-select: auto;
}

#notSupportedWrap {
	margin: 2em auto 1em auto;
	width: 75%;
	max-width: 45em;
	border: 2px solid #aaa;
	border-radius: 1em;
	padding: 2em;
	background-color: #f0f0f0;
	font-family: "Segoe UI", Frutiger, "Frutiger Linotype", "Dejavu Sans", "Helvetica Neue", Arial, sans-serif;
	color: black;
}

#notSupportedTitle {
	font-size: 1.8em;
}

.notSupportedMessage {
	font-size: 1.2em;
}

.notSupportedMessage em {
	color: #888;
}

/* bbcode styles */
.bbCodeH1 {
	font-size: 2em;
	font-weight: bold;
}

.bbCodeH2 {
	font-size: 1.5em;
	font-weight: bold;
}

.bbCodeH3 {
	font-size: 1.25em;
	font-weight: bold;
}

.bbCodeH4 {
	font-size: 1.1em;
	font-weight: bold;
}

.bbCodeItem::before {
	content: " • ";
}

/* For text icons converted to HTML: size the height to the line height
   preserving the aspect ratio. Also add position: relative as that allows
   just adding a 'top' style for the iconoffsety style. */
.c3-text-icon {
	height: 1em;
	width: auto;
	position: relative;
}

/* screen reader text */
.c3-screen-reader-text {
	position: absolute;
	width: 1px;
    height: 1px;
    overflow: hidden;
    clip: rect(1px, 1px, 1px, 1px);
}
</style>



</head> 
 
<body>

<script>
self.c3_base64files = {
	"scripts/c3main.js": {
		"type": "application/javascript",
		"str": "// Generated by Construct, the game and animation creation tool\n// Visit: https://www.construct.net\n\n// file-map:scripts/c3runtime.js\n{\n  let setMatrixArrayType = function(t) {\n    ARRAY_TYPE = t;\n  }, toRadian = function(t) {\n    return t * degree;\n  }, equals$9 = function(t, a) {\n    return Math.abs(t - a) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(a));\n  }, create$8 = function() {\n    var t = new ARRAY_TYPE(4);\n    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;\n  }, clone$8 = function(t) {\n    var a = new ARRAY_TYPE(4);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a;\n  }, copy$8 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t;\n  }, identity$5 = function(t) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;\n  }, fromValues$8 = function(t, a, r, n) {\n    var e = new ARRAY_TYPE(4);\n    return e[0] = t, e[1] = a, e[2] = r, e[3] = n, e;\n  }, set$8 = function(t, a, r, n, e) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t;\n  }, transpose$2 = function(t, a) {\n    if (t === a) {\n      var r = a[1];\n      t[1] = a[2], t[2] = r;\n    } else t[0] = a[0], t[1] = a[2], t[2] = a[1], t[3] = a[3];\n    return t;\n  }, invert$5 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = r * o - e * n;\n    return u ? (u = 1 / u, t[0] = o * u, t[1] = -n * u, t[2] = -e * u, t[3] = r * u, t) : null;\n  }, adjoint$2 = function(t, a) {\n    var r = a[0];\n    return t[0] = a[3], t[1] = -a[1], t[2] = -a[2], t[3] = r, t;\n  }, determinant$3 = function(t) {\n    return t[0] * t[3] - t[2] * t[1];\n  }, multiply$8 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[0], i = r[1], c = r[2], l = r[3];\n    return t[0] = n * s + o * i, t[1] = e * s + u * i, t[2] = n * c + o * l, t[3] = e * c + u * l, t;\n  }, rotate$4 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = Math.sin(r), i = Math.cos(r);\n    return t[0] = n * i + o * s, t[1] = e * i + u * s, t[2] = n * -s + o * i, t[3] = e * -s + u * i, t;\n  }, scale$8 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[0], i = r[1];\n    return t[0] = n * s, t[1] = e * s, t[2] = o * i, t[3] = u * i, t;\n  }, fromRotation$4 = function(t, a) {\n    var r = Math.sin(a), n = Math.cos(a);\n    return t[0] = n, t[1] = r, t[2] = -r, t[3] = n, t;\n  }, fromScaling$3 = function(t, a) {\n    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = a[1], t;\n  }, str$8 = function(t) {\n    return \"mat2(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n  }, frob$3 = function(t) {\n    return Math.hypot(t[0], t[1], t[2], t[3]);\n  }, LDU = function(t, a, r, n) {\n    return t[2] = n[2] / n[0], r[0] = n[0], r[1] = n[1], r[3] = n[3] - t[2] * r[1], [t, a, r];\n  }, add$8 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t;\n  }, subtract$6 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t;\n  }, exactEquals$8 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3];\n  }, equals$8 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = t[3], u = a[0], s = a[1], i = a[2], c = a[3];\n    return Math.abs(r - u) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(n - s) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(e - i) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(i)) && Math.abs(o - c) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(c));\n  }, multiplyScalar$3 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t;\n  }, multiplyScalarAndAdd$3 = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t;\n  }, create$7 = function() {\n    var t = new ARRAY_TYPE(6);\n    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, t[3] = 1, t;\n  }, clone$7 = function(t) {\n    var a = new ARRAY_TYPE(6);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a;\n  }, copy$7 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t;\n  }, identity$4 = function(t) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;\n  }, fromValues$7 = function(t, a, r, n, e, o) {\n    var u = new ARRAY_TYPE(6);\n    return u[0] = t, u[1] = a, u[2] = r, u[3] = n, u[4] = e, u[5] = o, u;\n  }, set$7 = function(t, a, r, n, e, o, u) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t;\n  }, invert$4 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = r * o - n * e;\n    return i ? (i = 1 / i, t[0] = o * i, t[1] = -n * i, t[2] = -e * i, t[3] = r * i, t[4] = (e * s - o * u) * i, t[5] = (n * u - r * s) * i, t) : null;\n  }, determinant$2 = function(t) {\n    return t[0] * t[3] - t[1] * t[2];\n  }, multiply$7 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = r[0], l = r[1], $ = r[2], h = r[3], f = r[4], M = r[5];\n    return t[0] = n * c + o * l, t[1] = e * c + u * l, t[2] = n * $ + o * h, t[3] = e * $ + u * h, t[4] = n * f + o * M + s, t[5] = e * f + u * M + i, t;\n  }, rotate$3 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = Math.sin(r), l = Math.cos(r);\n    return t[0] = n * l + o * c, t[1] = e * l + u * c, t[2] = n * -c + o * l, t[3] = e * -c + u * l, t[4] = s, t[5] = i, t;\n  }, scale$7 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = r[0], l = r[1];\n    return t[0] = n * c, t[1] = e * c, t[2] = o * l, t[3] = u * l, t[4] = s, t[5] = i, t;\n  }, translate$3 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = r[0], l = r[1];\n    return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = n * c + o * l + s, t[5] = e * c + u * l + i, t;\n  }, fromRotation$3 = function(t, a) {\n    var r = Math.sin(a), n = Math.cos(a);\n    return t[0] = n, t[1] = r, t[2] = -r, t[3] = n, t[4] = 0, t[5] = 0, t;\n  }, fromScaling$2 = function(t, a) {\n    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = a[1], t[4] = 0, t[5] = 0, t;\n  }, fromTranslation$3 = function(t, a) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = a[0], t[5] = a[1], t;\n  }, str$7 = function(t) {\n    return \"mat2d(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \")\";\n  }, frob$2 = function(t) {\n    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);\n  }, add$7 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t;\n  }, subtract$5 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t;\n  }, multiplyScalar$2 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t;\n  }, multiplyScalarAndAdd$2 = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t;\n  }, exactEquals$7 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5];\n  }, equals$7 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = a[0], c = a[1], l = a[2], $ = a[3], h = a[4], f = a[5];\n    return Math.abs(r - i) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(i)) && Math.abs(n - c) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(c)) && Math.abs(e - l) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(l)) && Math.abs(o - $) <= EPSILON * Math.max(1, Math.abs(o), Math.abs($)) && Math.abs(u - h) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(h)) && Math.abs(s - f) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(f));\n  }, create$6 = function() {\n    var t = new ARRAY_TYPE(9);\n    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;\n  }, fromMat4$1 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[4], t[4] = a[5], t[5] = a[6], t[6] = a[8], t[7] = a[9], t[8] = a[10], t;\n  }, clone$6 = function(t) {\n    var a = new ARRAY_TYPE(9);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[8] = t[8], a;\n  }, copy$6 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t;\n  }, fromValues$6 = function(t, a, r, n, e, o, u, s, i) {\n    var c = new ARRAY_TYPE(9);\n    return c[0] = t, c[1] = a, c[2] = r, c[3] = n, c[4] = e, c[5] = o, c[6] = u, c[7] = s, c[8] = i, c;\n  }, set$6 = function(t, a, r, n, e, o, u, s, i, c) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t[8] = c, t;\n  }, identity$3 = function(t) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n  }, transpose$1 = function(t, a) {\n    if (t === a) {\n      var r = a[1], n = a[2], e = a[5];\n      t[1] = a[3], t[2] = a[6], t[3] = r, t[5] = a[7], t[6] = n, t[7] = e;\n    } else t[0] = a[0], t[1] = a[3], t[2] = a[6], t[3] = a[1], t[4] = a[4], t[5] = a[7], t[6] = a[2], t[7] = a[5], t[8] = a[8];\n    return t;\n  }, invert$3 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = l * u - s * c, h = -l * o + s * i, f = c * o - u * i, M = r * $ + n * h + e * f;\n    return M ? (M = 1 / M, t[0] = $ * M, t[1] = (-l * n + e * c) * M, t[2] = (s * n - e * u) * M, t[3] = h * M, t[4] = (l * r - e * i) * M, t[5] = (-s * r + e * o) * M, t[6] = f * M, t[7] = (-c * r + n * i) * M, t[8] = (u * r - n * o) * M, t) : null;\n  }, adjoint$1 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8];\n    return t[0] = u * l - s * c, t[1] = e * c - n * l, t[2] = n * s - e * u, t[3] = s * i - o * l, t[4] = r * l - e * i, t[5] = e * o - r * s, t[6] = o * c - u * i, t[7] = n * i - r * c, t[8] = r * u - n * o, t;\n  }, determinant$1 = function(t) {\n    var a = t[0], r = t[1], n = t[2], e = t[3], o = t[4], u = t[5], s = t[6], i = t[7], c = t[8];\n    return a * (c * o - u * i) + r * (-c * e + u * s) + n * (i * e - o * s);\n  }, multiply$6 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = r[0], f = r[1], M = r[2], m = r[3], d = r[4], v = r[5], b = r[6], p = r[7], A = r[8];\n    return t[0] = h * n + f * u + M * c, t[1] = h * e + f * s + M * l, t[2] = h * o + f * i + M * $, t[3] = m * n + d * u + v * c, t[4] = m * e + d * s + v * l, t[5] = m * o + d * i + v * $, t[6] = b * n + p * u + A * c, t[7] = b * e + p * s + A * l, t[8] = b * o + p * i + A * $, t;\n  }, translate$2 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = r[0], f = r[1];\n    return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = s, t[5] = i, t[6] = h * n + f * u + c, t[7] = h * e + f * s + l, t[8] = h * o + f * i + $, t;\n  }, rotate$2 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = Math.sin(r), f = Math.cos(r);\n    return t[0] = f * n + h * u, t[1] = f * e + h * s, t[2] = f * o + h * i, t[3] = f * u - h * n, t[4] = f * s - h * e, t[5] = f * i - h * o, t[6] = c, t[7] = l, t[8] = $, t;\n  }, scale$6 = function(t, a, r) {\n    var n = r[0], e = r[1];\n    return t[0] = n * a[0], t[1] = n * a[1], t[2] = n * a[2], t[3] = e * a[3], t[4] = e * a[4], t[5] = e * a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t;\n  }, fromTranslation$2 = function(t, a) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = a[0], t[7] = a[1], t[8] = 1, t;\n  }, fromRotation$2 = function(t, a) {\n    var r = Math.sin(a), n = Math.cos(a);\n    return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n  }, fromScaling$1 = function(t, a) {\n    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = a[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n  }, fromMat2d = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = 0, t[3] = a[2], t[4] = a[3], t[5] = 0, t[6] = a[4], t[7] = a[5], t[8] = 1, t;\n  }, fromQuat$1 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = r + r, s = n + n, i = e + e, c = r * u, l = n * u, $ = n * s, h = e * u, f = e * s, M = e * i, m = o * u, d = o * s, v = o * i;\n    return t[0] = 1 - $ - M, t[3] = l - v, t[6] = h + d, t[1] = l + v, t[4] = 1 - c - M, t[7] = f - m, t[2] = h - d, t[5] = f + m, t[8] = 1 - c - $, t;\n  }, normalFromMat4 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], v = a[15], b = r * s - n * u, p = r * i - e * u, A = r * c - o * u, y = n * i - e * s, g = n * c - o * s, R = e * c - o * i, E = l * m - $ * M, q = l * d - h * M, x = l * v - f * M, P = $ * d - h * m, L = $ * v - f * m, O = h * v - f * d, S = b * O - p * L + A * P + y * x - g * q + R * E;\n    return S ? (S = 1 / S, t[0] = (s * O - i * L + c * P) * S, t[1] = (i * x - u * O - c * q) * S, t[2] = (u * L - s * x + c * E) * S, t[3] = (e * L - n * O - o * P) * S, t[4] = (r * O - e * x + o * q) * S, t[5] = (n * x - r * L - o * E) * S, t[6] = (m * R - d * g + v * y) * S, t[7] = (d * A - M * R - v * p) * S, t[8] = (M * g - m * A + v * b) * S, t) : null;\n  }, projection = function(t, a, r) {\n    return t[0] = 2 / a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;\n  }, str$6 = function(t) {\n    return \"mat3(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \", \" + t[8] + \")\";\n  }, frob$1 = function(t) {\n    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);\n  }, add$6 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t[8] = a[8] + r[8], t;\n  }, subtract$4 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t[6] = a[6] - r[6], t[7] = a[7] - r[7], t[8] = a[8] - r[8], t;\n  }, multiplyScalar$1 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t[8] = a[8] * r, t;\n  }, multiplyScalarAndAdd$1 = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t[6] = a[6] + r[6] * n, t[7] = a[7] + r[7] * n, t[8] = a[8] + r[8] * n, t;\n  }, exactEquals$6 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7] && t[8] === a[8];\n  }, equals$6 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], c = t[7], l = t[8], $ = a[0], h = a[1], f = a[2], M = a[3], m = a[4], d = a[5], v = a[6], b = a[7], p = a[8];\n    return Math.abs(r - $) <= EPSILON * Math.max(1, Math.abs(r), Math.abs($)) && Math.abs(n - h) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(e - f) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(f)) && Math.abs(o - M) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(M)) && Math.abs(u - m) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(m)) && Math.abs(s - d) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(i - v) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(v)) && Math.abs(c - b) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(b)) && Math.abs(l - p) <= EPSILON * Math.max(1, Math.abs(l), Math.abs(p));\n  }, create$5 = function() {\n    var t = new ARRAY_TYPE(16);\n    return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n  }, clone$5 = function(t) {\n    var a = new ARRAY_TYPE(16);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a[8] = t[8], a[9] = t[9], a[10] = t[10], a[11] = t[11], a[12] = t[12], a[13] = t[13], a[14] = t[14], a[15] = t[15], a;\n  }, copy$5 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], t;\n  }, fromValues$5 = function(t, a, r, n, e, o, u, s, i, c, l, $, h, f, M, m) {\n    var d = new ARRAY_TYPE(16);\n    return d[0] = t, d[1] = a, d[2] = r, d[3] = n, d[4] = e, d[5] = o, d[6] = u, d[7] = s, d[8] = i, d[9] = c, d[10] = l, d[11] = $, d[12] = h, d[13] = f, d[14] = M, d[15] = m, d;\n  }, set$5 = function(t, a, r, n, e, o, u, s, i, c, l, $, h, f, M, m, d) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t[8] = c, t[9] = l, t[10] = $, t[11] = h, t[12] = f, t[13] = M, t[14] = m, t[15] = d, t;\n  }, identity$2 = function(t) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, transpose = function(t, a) {\n    if (t === a) {\n      var r = a[1], n = a[2], e = a[3], o = a[6], u = a[7], s = a[11];\n      t[1] = a[4], t[2] = a[8], t[3] = a[12], t[4] = r, t[6] = a[9], t[7] = a[13], t[8] = n, t[9] = o, t[11] = a[14], t[12] = e, t[13] = u, t[14] = s;\n    } else t[0] = a[0], t[1] = a[4], t[2] = a[8], t[3] = a[12], t[4] = a[1], t[5] = a[5], t[6] = a[9], t[7] = a[13], t[8] = a[2], t[9] = a[6], t[10] = a[10], t[11] = a[14], t[12] = a[3], t[13] = a[7], t[14] = a[11], t[15] = a[15];\n    return t;\n  }, invert$2 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], v = a[15], b = r * s - n * u, p = r * i - e * u, A = r * c - o * u, y = n * i - e * s, g = n * c - o * s, R = e * c - o * i, E = l * m - $ * M, q = l * d - h * M, x = l * v - f * M, P = $ * d - h * m, L = $ * v - f * m, O = h * v - f * d, S = b * O - p * L + A * P + y * x - g * q + R * E;\n    return S ? (S = 1 / S, t[0] = (s * O - i * L + c * P) * S, t[1] = (e * L - n * O - o * P) * S, t[2] = (m * R - d * g + v * y) * S, t[3] = (h * g - $ * R - f * y) * S, t[4] = (i * x - u * O - c * q) * S, t[5] = (r * O - e * x + o * q) * S, t[6] = (d * A - M * R - v * p) * S, t[7] = (l * R - h * A + f * p) * S, t[8] = (u * L - s * x + c * E) * S, t[9] = (n * x - r * L - o * E) * S, t[10] = (M * g - m * A + v * b) * S, t[11] = ($ * A - l * g - f * b) * S, t[12] = (s * q - u * P - i * E) * S, t[13] = (r * P - n * q + e * E) * S, t[14] = (m * p - M * y - d * b) * S, t[15] = (l * y - $ * p + h * b) * S, t) : null;\n  }, adjoint = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = a[4], s = a[5], i = a[6], c = a[7], l = a[8], $ = a[9], h = a[10], f = a[11], M = a[12], m = a[13], d = a[14], v = a[15], b = r * s - n * u, p = r * i - e * u, A = r * c - o * u, y = n * i - e * s, g = n * c - o * s, R = e * c - o * i, E = l * m - $ * M, q = l * d - h * M, x = l * v - f * M, P = $ * d - h * m, L = $ * v - f * m, O = h * v - f * d;\n    return t[0] = s * O - i * L + c * P, t[1] = e * L - n * O - o * P, t[2] = m * R - d * g + v * y, t[3] = h * g - $ * R - f * y, t[4] = i * x - u * O - c * q, t[5] = r * O - e * x + o * q, t[6] = d * A - M * R - v * p, t[7] = l * R - h * A + f * p, t[8] = u * L - s * x + c * E, t[9] = n * x - r * L - o * E, t[10] = M * g - m * A + v * b, t[11] = $ * A - l * g - f * b, t[12] = s * q - u * P - i * E, t[13] = r * P - n * q + e * E, t[14] = m * p - M * y - d * b, t[15] = l * y - $ * p + h * b, t;\n  }, determinant = function(t) {\n    var a = t[0], r = t[1], n = t[2], e = t[3], o = t[4], u = t[5], s = t[6], i = t[7], c = t[8], l = t[9], $ = t[10], h = t[11], f = t[12], M = t[13], m = t[14], d = a * u - r * o, v = a * s - n * o, b = r * s - n * u, p = c * M - l * f, A = c * m - $ * f, y = l * m - $ * M;\n    return i * (a * y - r * A + n * p) - e * (o * y - u * A + s * p) + t[15] * (c * b - l * v + $ * d) - h * (f * b - M * v + m * d);\n  }, multiply$5 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = a[9], f = a[10], M = a[11], m = a[12], d = a[13], v = a[14], b = a[15], p = r[0], A = r[1], y = r[2], g = r[3];\n    return t[0] = p * n + A * s + y * $ + g * m, t[1] = p * e + A * i + y * h + g * d, t[2] = p * o + A * c + y * f + g * v, t[3] = p * u + A * l + y * M + g * b, p = r[4], A = r[5], y = r[6], g = r[7], t[4] = p * n + A * s + y * $ + g * m, t[5] = p * e + A * i + y * h + g * d, t[6] = p * o + A * c + y * f + g * v, t[7] = p * u + A * l + y * M + g * b, p = r[8], A = r[9], y = r[10], g = r[11], t[8] = p * n + A * s + y * $ + g * m, t[9] = p * e + A * i + y * h + g * d, t[10] = p * o + A * c + y * f + g * v, t[11] = p * u + A * l + y * M + g * b, p = r[12], A = r[13], y = r[14], g = r[15], t[12] = p * n + A * s + y * $ + g * m, t[13] = p * e + A * i + y * h + g * d, t[14] = p * o + A * c + y * f + g * v, t[15] = p * u + A * l + y * M + g * b, t;\n  }, translate$1 = function(t, a, r) {\n    var n, e, o, u, s, i, c, l, $, h, f, M, m = r[0], d = r[1], v = r[2];\n    return a === t ? (t[12] = a[0] * m + a[4] * d + a[8] * v + a[12], t[13] = a[1] * m + a[5] * d + a[9] * v + a[13], t[14] = a[2] * m + a[6] * d + a[10] * v + a[14], t[15] = a[3] * m + a[7] * d + a[11] * v + a[15]) : (n = a[0], e = a[1], o = a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = a[8], h = a[9], f = a[10], M = a[11], t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = s, t[5] = i, t[6] = c, t[7] = l, t[8] = $, t[9] = h, t[10] = f, t[11] = M, t[12] = n * m + s * d + $ * v + a[12], t[13] = e * m + i * d + h * v + a[13], t[14] = o * m + c * d + f * v + a[14], t[15] = u * m + l * d + M * v + a[15]), t;\n  }, scale$5 = function(t, a, r) {\n    var n = r[0], e = r[1], o = r[2];\n    return t[0] = a[0] * n, t[1] = a[1] * n, t[2] = a[2] * n, t[3] = a[3] * n, t[4] = a[4] * e, t[5] = a[5] * e, t[6] = a[6] * e, t[7] = a[7] * e, t[8] = a[8] * o, t[9] = a[9] * o, t[10] = a[10] * o, t[11] = a[11] * o, t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], t;\n  }, rotate$1 = function(t, a, r, n) {\n    var e, o, u, s, i, c, l, $, h, f, M, m, d, v, b, p, A, y, g, R, E, q, x, P, L = n[0], O = n[1], S = n[2], Y = Math.hypot(L, O, S);\n    return Y < EPSILON ? null : (L *= Y = 1 / Y, O *= Y, S *= Y, e = Math.sin(r), u = 1 - (o = Math.cos(r)), s = a[0], i = a[1], c = a[2], l = a[3], $ = a[4], h = a[5], f = a[6], M = a[7], m = a[8], d = a[9], v = a[10], b = a[11], p = L * L * u + o, A = O * L * u + S * e, y = S * L * u - O * e, g = L * O * u - S * e, R = O * O * u + o, E = S * O * u + L * e, q = L * S * u + O * e, x = O * S * u - L * e, P = S * S * u + o, t[0] = s * p + $ * A + m * y, t[1] = i * p + h * A + d * y, t[2] = c * p + f * A + v * y, t[3] = l * p + M * A + b * y, t[4] = s * g + $ * R + m * E, t[5] = i * g + h * R + d * E, t[6] = c * g + f * R + v * E, t[7] = l * g + M * R + b * E, t[8] = s * q + $ * x + m * P, t[9] = i * q + h * x + d * P, t[10] = c * q + f * x + v * P, t[11] = l * q + M * x + b * P, a !== t && (t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t);\n  }, rotateX$3 = function(t, a, r) {\n    var n = Math.sin(r), e = Math.cos(r), o = a[4], u = a[5], s = a[6], i = a[7], c = a[8], l = a[9], $ = a[10], h = a[11];\n    return a !== t && (t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[4] = o * e + c * n, t[5] = u * e + l * n, t[6] = s * e + $ * n, t[7] = i * e + h * n, t[8] = c * e - o * n, t[9] = l * e - u * n, t[10] = $ * e - s * n, t[11] = h * e - i * n, t;\n  }, rotateY$3 = function(t, a, r) {\n    var n = Math.sin(r), e = Math.cos(r), o = a[0], u = a[1], s = a[2], i = a[3], c = a[8], l = a[9], $ = a[10], h = a[11];\n    return a !== t && (t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[0] = o * e - c * n, t[1] = u * e - l * n, t[2] = s * e - $ * n, t[3] = i * e - h * n, t[8] = o * n + c * e, t[9] = u * n + l * e, t[10] = s * n + $ * e, t[11] = i * n + h * e, t;\n  }, rotateZ$3 = function(t, a, r) {\n    var n = Math.sin(r), e = Math.cos(r), o = a[0], u = a[1], s = a[2], i = a[3], c = a[4], l = a[5], $ = a[6], h = a[7];\n    return a !== t && (t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15]), t[0] = o * e + c * n, t[1] = u * e + l * n, t[2] = s * e + $ * n, t[3] = i * e + h * n, t[4] = c * e - o * n, t[5] = l * e - u * n, t[6] = $ * e - s * n, t[7] = h * e - i * n, t;\n  }, fromTranslation$1 = function(t, a) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = a[0], t[13] = a[1], t[14] = a[2], t[15] = 1, t;\n  }, fromScaling = function(t, a) {\n    return t[0] = a[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = a[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, fromRotation$1 = function(t, a, r) {\n    var n, e, o, u = r[0], s = r[1], i = r[2], c = Math.hypot(u, s, i);\n    return c < EPSILON ? null : (u *= c = 1 / c, s *= c, i *= c, n = Math.sin(a), o = 1 - (e = Math.cos(a)), t[0] = u * u * o + e, t[1] = s * u * o + i * n, t[2] = i * u * o - s * n, t[3] = 0, t[4] = u * s * o - i * n, t[5] = s * s * o + e, t[6] = i * s * o + u * n, t[7] = 0, t[8] = u * i * o + s * n, t[9] = s * i * o - u * n, t[10] = i * i * o + e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);\n  }, fromXRotation = function(t, a) {\n    var r = Math.sin(a), n = Math.cos(a);\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n, t[6] = r, t[7] = 0, t[8] = 0, t[9] = -r, t[10] = n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, fromYRotation = function(t, a) {\n    var r = Math.sin(a), n = Math.cos(a);\n    return t[0] = n, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = r, t[9] = 0, t[10] = n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, fromZRotation = function(t, a) {\n    var r = Math.sin(a), n = Math.cos(a);\n    return t[0] = n, t[1] = r, t[2] = 0, t[3] = 0, t[4] = -r, t[5] = n, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, fromRotationTranslation$1 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = n + n, i = e + e, c = o + o, l = n * s, $ = n * i, h = n * c, f = e * i, M = e * c, m = o * c, d = u * s, v = u * i, b = u * c;\n    return t[0] = 1 - (f + m), t[1] = $ + b, t[2] = h - v, t[3] = 0, t[4] = $ - b, t[5] = 1 - (l + m), t[6] = M + d, t[7] = 0, t[8] = h + v, t[9] = M - d, t[10] = 1 - (l + f), t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;\n  }, fromQuat2 = function(t, a) {\n    var r = new ARRAY_TYPE(3), n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = n * n + e * e + o * o + u * u;\n    return $ > 0 ? (r[0] = 2 * (s * u + l * n + i * o - c * e) / $, r[1] = 2 * (i * u + l * e + c * n - s * o) / $, r[2] = 2 * (c * u + l * o + s * e - i * n) / $) : (r[0] = 2 * (s * u + l * n + i * o - c * e), r[1] = 2 * (i * u + l * e + c * n - s * o), r[2] = 2 * (c * u + l * o + s * e - i * n)), fromRotationTranslation$1(t, a, r), t;\n  }, getTranslation$1 = function(t, a) {\n    return t[0] = a[12], t[1] = a[13], t[2] = a[14], t;\n  }, getScaling = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[4], u = a[5], s = a[6], i = a[8], c = a[9], l = a[10];\n    return t[0] = Math.hypot(r, n, e), t[1] = Math.hypot(o, u, s), t[2] = Math.hypot(i, c, l), t;\n  }, getRotation = function(t, a) {\n    var r = new ARRAY_TYPE(3);\n    getScaling(r, a);\n    var n = 1 / r[0], e = 1 / r[1], o = 1 / r[2], u = a[0] * n, s = a[1] * e, i = a[2] * o, c = a[4] * n, l = a[5] * e, $ = a[6] * o, h = a[8] * n, f = a[9] * e, M = a[10] * o, m = u + l + M, d = 0;\n    return m > 0 ? (d = 2 * Math.sqrt(m + 1), t[3] = 0.25 * d, t[0] = ($ - f) / d, t[1] = (h - i) / d, t[2] = (s - c) / d) : u > l && u > M ? (d = 2 * Math.sqrt(1 + u - l - M), t[3] = ($ - f) / d, t[0] = 0.25 * d, t[1] = (s + c) / d, t[2] = (h + i) / d) : l > M ? (d = 2 * Math.sqrt(1 + l - u - M), t[3] = (h - i) / d, t[0] = (s + c) / d, t[1] = 0.25 * d, t[2] = ($ + f) / d) : (d = 2 * Math.sqrt(1 + M - u - l), t[3] = (s - c) / d, t[0] = (h + i) / d, t[1] = ($ + f) / d, t[2] = 0.25 * d), t;\n  }, decompose = function(t, a, r, n) {\n    a[0] = n[12], a[1] = n[13], a[2] = n[14];\n    var e = n[0], o = n[1], u = n[2], s = n[4], i = n[5], c = n[6], l = n[8], $ = n[9], h = n[10];\n    r[0] = Math.hypot(e, o, u), r[1] = Math.hypot(s, i, c), r[2] = Math.hypot(l, $, h);\n    var f = 1 / r[0], M = 1 / r[1], m = 1 / r[2], d = e * f, v = o * M, b = u * m, p = s * f, A = i * M, y = c * m, g = l * f, R = $ * M, E = h * m, q = d + A + E, x = 0;\n    return q > 0 ? (x = 2 * Math.sqrt(q + 1), t[3] = 0.25 * x, t[0] = (y - R) / x, t[1] = (g - b) / x, t[2] = (v - p) / x) : d > A && d > E ? (x = 2 * Math.sqrt(1 + d - A - E), t[3] = (y - R) / x, t[0] = 0.25 * x, t[1] = (v + p) / x, t[2] = (g + b) / x) : A > E ? (x = 2 * Math.sqrt(1 + A - d - E), t[3] = (g - b) / x, t[0] = (v + p) / x, t[1] = 0.25 * x, t[2] = (y + R) / x) : (x = 2 * Math.sqrt(1 + E - d - A), t[3] = (v - p) / x, t[0] = (g + b) / x, t[1] = (y + R) / x, t[2] = 0.25 * x), t;\n  }, fromRotationTranslationScale = function(t, a, r, n) {\n    var e = a[0], o = a[1], u = a[2], s = a[3], i = e + e, c = o + o, l = u + u, $ = e * i, h = e * c, f = e * l, M = o * c, m = o * l, d = u * l, v = s * i, b = s * c, p = s * l, A = n[0], y = n[1], g = n[2];\n    return t[0] = (1 - (M + d)) * A, t[1] = (h + p) * A, t[2] = (f - b) * A, t[3] = 0, t[4] = (h - p) * y, t[5] = (1 - ($ + d)) * y, t[6] = (m + v) * y, t[7] = 0, t[8] = (f + b) * g, t[9] = (m - v) * g, t[10] = (1 - ($ + M)) * g, t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;\n  }, fromRotationTranslationScaleOrigin = function(t, a, r, n, e) {\n    var o = a[0], u = a[1], s = a[2], i = a[3], c = o + o, l = u + u, $ = s + s, h = o * c, f = o * l, M = o * $, m = u * l, d = u * $, v = s * $, b = i * c, p = i * l, A = i * $, y = n[0], g = n[1], R = n[2], E = e[0], q = e[1], x = e[2], P = (1 - (m + v)) * y, L = (f + A) * y, O = (M - p) * y, S = (f - A) * g, Y = (1 - (h + v)) * g, T = (d + b) * g, N = (M + p) * R, _ = (d - b) * R, I = (1 - (h + m)) * R;\n    return t[0] = P, t[1] = L, t[2] = O, t[3] = 0, t[4] = S, t[5] = Y, t[6] = T, t[7] = 0, t[8] = N, t[9] = _, t[10] = I, t[11] = 0, t[12] = r[0] + E - (P * E + S * q + N * x), t[13] = r[1] + q - (L * E + Y * q + _ * x), t[14] = r[2] + x - (O * E + T * q + I * x), t[15] = 1, t;\n  }, fromQuat = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = r + r, s = n + n, i = e + e, c = r * u, l = n * u, $ = n * s, h = e * u, f = e * s, M = e * i, m = o * u, d = o * s, v = o * i;\n    return t[0] = 1 - $ - M, t[1] = l + v, t[2] = h - d, t[3] = 0, t[4] = l - v, t[5] = 1 - c - M, t[6] = f + m, t[7] = 0, t[8] = h + d, t[9] = f - m, t[10] = 1 - c - $, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }, frustum = function(t, a, r, n, e, o, u) {\n    var s = 1 / (r - a), i = 1 / (e - n), c = 1 / (o - u);\n    return t[0] = 2 * o * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * o * i, t[6] = 0, t[7] = 0, t[8] = (r + a) * s, t[9] = (e + n) * i, t[10] = (u + o) * c, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = u * o * 2 * c, t[15] = 0, t;\n  }, perspectiveNO = function(t, a, r, n, e) {\n    var o = 1 / Math.tan(a / 2);\n    if (t[0] = o / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0) {\n      var u = 1 / (n - e);\n      t[10] = (e + n) * u, t[14] = 2 * e * n * u;\n    } else t[10] = -1, t[14] = -2 * n;\n    return t;\n  }, perspectiveZO = function(t, a, r, n, e) {\n    var o = 1 / Math.tan(a / 2);\n    if (t[0] = o / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0) {\n      var u = 1 / (n - e);\n      t[10] = e * u, t[14] = e * n * u;\n    } else t[10] = -1, t[14] = -n;\n    return t;\n  }, perspectiveFromFieldOfView = function(t, a, r, n) {\n    var e = Math.tan(a.upDegrees * Math.PI / 180), o = Math.tan(a.downDegrees * Math.PI / 180), u = Math.tan(a.leftDegrees * Math.PI / 180), s = Math.tan(a.rightDegrees * Math.PI / 180), i = 2 / (u + s), c = 2 / (e + o);\n    return t[0] = i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = c, t[6] = 0, t[7] = 0, t[8] = -(u - s) * i * 0.5, t[9] = (e - o) * c * 0.5, t[10] = n / (r - n), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = n * r / (r - n), t[15] = 0, t;\n  }, orthoNO = function(t, a, r, n, e, o, u) {\n    var s = 1 / (a - r), i = 1 / (n - e), c = 1 / (o - u);\n    return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * i, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * c, t[11] = 0, t[12] = (a + r) * s, t[13] = (e + n) * i, t[14] = (u + o) * c, t[15] = 1, t;\n  }, orthoZO = function(t, a, r, n, e, o, u) {\n    var s = 1 / (a - r), i = 1 / (n - e), c = 1 / (o - u);\n    return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * i, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = c, t[11] = 0, t[12] = (a + r) * s, t[13] = (e + n) * i, t[14] = o * c, t[15] = 1, t;\n  }, lookAt = function(t, a, r, n) {\n    var e, o, u, s, i, c, l, $, h, f, M = a[0], m = a[1], d = a[2], v = n[0], b = n[1], p = n[2], A = r[0], y = r[1], g = r[2];\n    return Math.abs(M - A) < EPSILON && Math.abs(m - y) < EPSILON && Math.abs(d - g) < EPSILON ? identity$2(t) : (l = M - A, $ = m - y, h = d - g, e = b * (h *= f = 1 / Math.hypot(l, $, h)) - p * ($ *= f), o = p * (l *= f) - v * h, u = v * $ - b * l, (f = Math.hypot(e, o, u)) ? (e *= f = 1 / f, o *= f, u *= f) : (e = 0, o = 0, u = 0), s = $ * u - h * o, i = h * e - l * u, c = l * o - $ * e, (f = Math.hypot(s, i, c)) ? (s *= f = 1 / f, i *= f, c *= f) : (s = 0, i = 0, c = 0), t[0] = e, t[1] = s, t[2] = l, t[3] = 0, t[4] = o, t[5] = i, t[6] = $, t[7] = 0, t[8] = u, t[9] = c, t[10] = h, t[11] = 0, t[12] = -(e * M + o * m + u * d), t[13] = -(s * M + i * m + c * d), t[14] = -(l * M + $ * m + h * d), t[15] = 1, t);\n  }, targetTo = function(t, a, r, n) {\n    var e = a[0], o = a[1], u = a[2], s = n[0], i = n[1], c = n[2], l = e - r[0], $ = o - r[1], h = u - r[2], f = l * l + $ * $ + h * h;\n    f > 0 && (l *= f = 1 / Math.sqrt(f), $ *= f, h *= f);\n    var M = i * h - c * $, m = c * l - s * h, d = s * $ - i * l;\n    return (f = M * M + m * m + d * d) > 0 && (M *= f = 1 / Math.sqrt(f), m *= f, d *= f), t[0] = M, t[1] = m, t[2] = d, t[3] = 0, t[4] = $ * d - h * m, t[5] = h * M - l * d, t[6] = l * m - $ * M, t[7] = 0, t[8] = l, t[9] = $, t[10] = h, t[11] = 0, t[12] = e, t[13] = o, t[14] = u, t[15] = 1, t;\n  }, str$5 = function(t) {\n    return \"mat4(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \", \" + t[8] + \", \" + t[9] + \", \" + t[10] + \", \" + t[11] + \", \" + t[12] + \", \" + t[13] + \", \" + t[14] + \", \" + t[15] + \")\";\n  }, frob = function(t) {\n    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);\n  }, add$5 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t[8] = a[8] + r[8], t[9] = a[9] + r[9], t[10] = a[10] + r[10], t[11] = a[11] + r[11], t[12] = a[12] + r[12], t[13] = a[13] + r[13], t[14] = a[14] + r[14], t[15] = a[15] + r[15], t;\n  }, subtract$3 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t[4] = a[4] - r[4], t[5] = a[5] - r[5], t[6] = a[6] - r[6], t[7] = a[7] - r[7], t[8] = a[8] - r[8], t[9] = a[9] - r[9], t[10] = a[10] - r[10], t[11] = a[11] - r[11], t[12] = a[12] - r[12], t[13] = a[13] - r[13], t[14] = a[14] - r[14], t[15] = a[15] - r[15], t;\n  }, multiplyScalar = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t[8] = a[8] * r, t[9] = a[9] * r, t[10] = a[10] * r, t[11] = a[11] * r, t[12] = a[12] * r, t[13] = a[13] * r, t[14] = a[14] * r, t[15] = a[15] * r, t;\n  }, multiplyScalarAndAdd = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t[4] = a[4] + r[4] * n, t[5] = a[5] + r[5] * n, t[6] = a[6] + r[6] * n, t[7] = a[7] + r[7] * n, t[8] = a[8] + r[8] * n, t[9] = a[9] + r[9] * n, t[10] = a[10] + r[10] * n, t[11] = a[11] + r[11] * n, t[12] = a[12] + r[12] * n, t[13] = a[13] + r[13] * n, t[14] = a[14] + r[14] * n, t[15] = a[15] + r[15] * n, t;\n  }, exactEquals$5 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7] && t[8] === a[8] && t[9] === a[9] && t[10] === a[10] && t[11] === a[11] && t[12] === a[12] && t[13] === a[13] && t[14] === a[14] && t[15] === a[15];\n  }, equals$5 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], c = t[7], l = t[8], $ = t[9], h = t[10], f = t[11], M = t[12], m = t[13], d = t[14], v = t[15], b = a[0], p = a[1], A = a[2], y = a[3], g = a[4], R = a[5], E = a[6], q = a[7], x = a[8], P = a[9], L = a[10], O = a[11], S = a[12], Y = a[13], T = a[14], N = a[15];\n    return Math.abs(r - b) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(b)) && Math.abs(n - p) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(p)) && Math.abs(e - A) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(A)) && Math.abs(o - y) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(u - g) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(g)) && Math.abs(s - R) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(R)) && Math.abs(i - E) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(E)) && Math.abs(c - q) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(q)) && Math.abs(l - x) <= EPSILON * Math.max(1, Math.abs(l), Math.abs(x)) && Math.abs($ - P) <= EPSILON * Math.max(1, Math.abs($), Math.abs(P)) && Math.abs(h - L) <= EPSILON * Math.max(1, Math.abs(h), Math.abs(L)) && Math.abs(f - O) <= EPSILON * Math.max(1, Math.abs(f), Math.abs(O)) && Math.abs(M - S) <= EPSILON * Math.max(1, Math.abs(M), Math.abs(S)) && Math.abs(m - Y) <= EPSILON * Math.max(1, Math.abs(m), Math.abs(Y)) && Math.abs(d - T) <= EPSILON * Math.max(1, Math.abs(d), Math.abs(T)) && Math.abs(v - N) <= EPSILON * Math.max(1, Math.abs(v), Math.abs(N));\n  }, create$4 = function() {\n    var t = new ARRAY_TYPE(3);\n    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;\n  }, clone$4 = function(t) {\n    var a = new ARRAY_TYPE(3);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a;\n  }, length$4 = function(t) {\n    var a = t[0], r = t[1], n = t[2];\n    return Math.hypot(a, r, n);\n  }, fromValues$4 = function(t, a, r) {\n    var n = new ARRAY_TYPE(3);\n    return n[0] = t, n[1] = a, n[2] = r, n;\n  }, copy$4 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t;\n  }, set$4 = function(t, a, r, n) {\n    return t[0] = a, t[1] = r, t[2] = n, t;\n  }, add$4 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t;\n  }, subtract$2 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t;\n  }, multiply$4 = function(t, a, r) {\n    return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t[2] = a[2] * r[2], t;\n  }, divide$2 = function(t, a, r) {\n    return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t[2] = a[2] / r[2], t;\n  }, ceil$2 = function(t, a) {\n    return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t[2] = Math.ceil(a[2]), t;\n  }, floor$2 = function(t, a) {\n    return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t[2] = Math.floor(a[2]), t;\n  }, min$2 = function(t, a, r) {\n    return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t[2] = Math.min(a[2], r[2]), t;\n  }, max$2 = function(t, a, r) {\n    return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t[2] = Math.max(a[2], r[2]), t;\n  }, round$2 = function(t, a) {\n    return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t[2] = Math.round(a[2]), t;\n  }, scale$4 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t;\n  }, scaleAndAdd$2 = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t;\n  }, distance$2 = function(t, a) {\n    var r = a[0] - t[0], n = a[1] - t[1], e = a[2] - t[2];\n    return Math.hypot(r, n, e);\n  }, squaredDistance$2 = function(t, a) {\n    var r = a[0] - t[0], n = a[1] - t[1], e = a[2] - t[2];\n    return r * r + n * n + e * e;\n  }, squaredLength$4 = function(t) {\n    var a = t[0], r = t[1], n = t[2];\n    return a * a + r * r + n * n;\n  }, negate$2 = function(t, a) {\n    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t;\n  }, inverse$2 = function(t, a) {\n    return t[0] = 1 / a[0], t[1] = 1 / a[1], t[2] = 1 / a[2], t;\n  }, normalize$4 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = r * r + n * n + e * e;\n    return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = a[0] * o, t[1] = a[1] * o, t[2] = a[2] * o, t;\n  }, dot$4 = function(t, a) {\n    return t[0] * a[0] + t[1] * a[1] + t[2] * a[2];\n  }, cross$2 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = r[0], s = r[1], i = r[2];\n    return t[0] = e * i - o * s, t[1] = o * u - n * i, t[2] = n * s - e * u, t;\n  }, lerp$4 = function(t, a, r, n) {\n    var e = a[0], o = a[1], u = a[2];\n    return t[0] = e + n * (r[0] - e), t[1] = o + n * (r[1] - o), t[2] = u + n * (r[2] - u), t;\n  }, slerp$1 = function(t, a, r, n) {\n    var e = Math.acos(Math.min(Math.max(dot$4(a, r), -1), 1)), o = Math.sin(e), u = Math.sin((1 - n) * e) / o, s = Math.sin(n * e) / o;\n    return t[0] = u * a[0] + s * r[0], t[1] = u * a[1] + s * r[1], t[2] = u * a[2] + s * r[2], t;\n  }, hermite = function(t, a, r, n, e, o) {\n    var u = o * o, s = u * (2 * o - 3) + 1, i = u * (o - 2) + o, c = u * (o - 1), l = u * (3 - 2 * o);\n    return t[0] = a[0] * s + r[0] * i + n[0] * c + e[0] * l, t[1] = a[1] * s + r[1] * i + n[1] * c + e[1] * l, t[2] = a[2] * s + r[2] * i + n[2] * c + e[2] * l, t;\n  }, bezier = function(t, a, r, n, e, o) {\n    var u = 1 - o, s = u * u, i = o * o, c = s * u, l = 3 * o * s, $ = 3 * i * u, h = i * o;\n    return t[0] = a[0] * c + r[0] * l + n[0] * $ + e[0] * h, t[1] = a[1] * c + r[1] * l + n[1] * $ + e[1] * h, t[2] = a[2] * c + r[2] * l + n[2] * $ + e[2] * h, t;\n  }, random$3 = function(t, a) {\n    a = a || 1;\n    var r = 2 * RANDOM() * Math.PI, n = 2 * RANDOM() - 1, e = Math.sqrt(1 - n * n) * a;\n    return t[0] = Math.cos(r) * e, t[1] = Math.sin(r) * e, t[2] = n * a, t;\n  }, transformMat4$2 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = r[3] * n + r[7] * e + r[11] * o + r[15];\n    return u = u || 1, t[0] = (r[0] * n + r[4] * e + r[8] * o + r[12]) / u, t[1] = (r[1] * n + r[5] * e + r[9] * o + r[13]) / u, t[2] = (r[2] * n + r[6] * e + r[10] * o + r[14]) / u, t;\n  }, transformMat3$1 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2];\n    return t[0] = n * r[0] + e * r[3] + o * r[6], t[1] = n * r[1] + e * r[4] + o * r[7], t[2] = n * r[2] + e * r[5] + o * r[8], t;\n  }, transformQuat$1 = function(t, a, r) {\n    var n = r[0], e = r[1], o = r[2], u = r[3], s = a[0], i = a[1], c = a[2], l = e * c - o * i, $ = o * s - n * c, h = n * i - e * s, f = e * h - o * $, M = o * l - n * h, m = n * $ - e * l, d = 2 * u;\n    return l *= d, $ *= d, h *= d, f *= 2, M *= 2, m *= 2, t[0] = s + l + f, t[1] = i + $ + M, t[2] = c + h + m, t;\n  }, rotateX$2 = function(t, a, r, n) {\n    var e = [], o = [];\n    return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[0], o[1] = e[1] * Math.cos(n) - e[2] * Math.sin(n), o[2] = e[1] * Math.sin(n) + e[2] * Math.cos(n), t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;\n  }, rotateY$2 = function(t, a, r, n) {\n    var e = [], o = [];\n    return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[2] * Math.sin(n) + e[0] * Math.cos(n), o[1] = e[1], o[2] = e[2] * Math.cos(n) - e[0] * Math.sin(n), t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;\n  }, rotateZ$2 = function(t, a, r, n) {\n    var e = [], o = [];\n    return e[0] = a[0] - r[0], e[1] = a[1] - r[1], e[2] = a[2] - r[2], o[0] = e[0] * Math.cos(n) - e[1] * Math.sin(n), o[1] = e[0] * Math.sin(n) + e[1] * Math.cos(n), o[2] = e[2], t[0] = o[0] + r[0], t[1] = o[1] + r[1], t[2] = o[2] + r[2], t;\n  }, angle$1 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = a[0], u = a[1], s = a[2], i = Math.sqrt((r * r + n * n + e * e) * (o * o + u * u + s * s)), c = i && dot$4(t, a) / i;\n    return Math.acos(Math.min(Math.max(c, -1), 1));\n  }, zero$2 = function(t) {\n    return t[0] = 0, t[1] = 0, t[2] = 0, t;\n  }, str$4 = function(t) {\n    return \"vec3(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \")\";\n  }, exactEquals$4 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2];\n  }, equals$4 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = a[0], u = a[1], s = a[2];\n    return Math.abs(r - o) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - u) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(e - s) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(s));\n  }, create$3 = function() {\n    var t = new ARRAY_TYPE(4);\n    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;\n  }, clone$3 = function(t) {\n    var a = new ARRAY_TYPE(4);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a;\n  }, fromValues$3 = function(t, a, r, n) {\n    var e = new ARRAY_TYPE(4);\n    return e[0] = t, e[1] = a, e[2] = r, e[3] = n, e;\n  }, copy$3 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t;\n  }, set$3 = function(t, a, r, n, e) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t;\n  }, add$3 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t;\n  }, subtract$1 = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t[2] = a[2] - r[2], t[3] = a[3] - r[3], t;\n  }, multiply$3 = function(t, a, r) {\n    return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t[2] = a[2] * r[2], t[3] = a[3] * r[3], t;\n  }, divide$1 = function(t, a, r) {\n    return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t[2] = a[2] / r[2], t[3] = a[3] / r[3], t;\n  }, ceil$1 = function(t, a) {\n    return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t[2] = Math.ceil(a[2]), t[3] = Math.ceil(a[3]), t;\n  }, floor$1 = function(t, a) {\n    return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t[2] = Math.floor(a[2]), t[3] = Math.floor(a[3]), t;\n  }, min$1 = function(t, a, r) {\n    return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t[2] = Math.min(a[2], r[2]), t[3] = Math.min(a[3], r[3]), t;\n  }, max$1 = function(t, a, r) {\n    return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t[2] = Math.max(a[2], r[2]), t[3] = Math.max(a[3], r[3]), t;\n  }, round$1 = function(t, a) {\n    return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t[2] = Math.round(a[2]), t[3] = Math.round(a[3]), t;\n  }, scale$3 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t;\n  }, scaleAndAdd$1 = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t[2] = a[2] + r[2] * n, t[3] = a[3] + r[3] * n, t;\n  }, distance$1 = function(t, a) {\n    var r = a[0] - t[0], n = a[1] - t[1], e = a[2] - t[2], o = a[3] - t[3];\n    return Math.hypot(r, n, e, o);\n  }, squaredDistance$1 = function(t, a) {\n    var r = a[0] - t[0], n = a[1] - t[1], e = a[2] - t[2], o = a[3] - t[3];\n    return r * r + n * n + e * e + o * o;\n  }, length$3 = function(t) {\n    var a = t[0], r = t[1], n = t[2], e = t[3];\n    return Math.hypot(a, r, n, e);\n  }, squaredLength$3 = function(t) {\n    var a = t[0], r = t[1], n = t[2], e = t[3];\n    return a * a + r * r + n * n + e * e;\n  }, negate$1 = function(t, a) {\n    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = -a[3], t;\n  }, inverse$1 = function(t, a) {\n    return t[0] = 1 / a[0], t[1] = 1 / a[1], t[2] = 1 / a[2], t[3] = 1 / a[3], t;\n  }, normalize$3 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = r * r + n * n + e * e + o * o;\n    return u > 0 && (u = 1 / Math.sqrt(u)), t[0] = r * u, t[1] = n * u, t[2] = e * u, t[3] = o * u, t;\n  }, dot$3 = function(t, a) {\n    return t[0] * a[0] + t[1] * a[1] + t[2] * a[2] + t[3] * a[3];\n  }, cross$1 = function(t, a, r, n) {\n    var e = r[0] * n[1] - r[1] * n[0], o = r[0] * n[2] - r[2] * n[0], u = r[0] * n[3] - r[3] * n[0], s = r[1] * n[2] - r[2] * n[1], i = r[1] * n[3] - r[3] * n[1], c = r[2] * n[3] - r[3] * n[2], l = a[0], $ = a[1], h = a[2], f = a[3];\n    return t[0] = $ * c - h * i + f * s, t[1] = -l * c + h * u - f * o, t[2] = l * i - $ * u + f * e, t[3] = -l * s + $ * o - h * e, t;\n  }, lerp$3 = function(t, a, r, n) {\n    var e = a[0], o = a[1], u = a[2], s = a[3];\n    return t[0] = e + n * (r[0] - e), t[1] = o + n * (r[1] - o), t[2] = u + n * (r[2] - u), t[3] = s + n * (r[3] - s), t;\n  }, random$2 = function(t, a) {\n    var r, n, e, o, u, s;\n    a = a || 1;\n    do {\n      u = (r = 2 * RANDOM() - 1) * r + (n = 2 * RANDOM() - 1) * n;\n    } while (u >= 1);\n    do {\n      s = (e = 2 * RANDOM() - 1) * e + (o = 2 * RANDOM() - 1) * o;\n    } while (s >= 1);\n    var i = Math.sqrt((1 - u) / s);\n    return t[0] = a * r, t[1] = a * n, t[2] = a * e * i, t[3] = a * o * i, t;\n  }, transformMat4$1 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3];\n    return t[0] = r[0] * n + r[4] * e + r[8] * o + r[12] * u, t[1] = r[1] * n + r[5] * e + r[9] * o + r[13] * u, t[2] = r[2] * n + r[6] * e + r[10] * o + r[14] * u, t[3] = r[3] * n + r[7] * e + r[11] * o + r[15] * u, t;\n  }, transformQuat = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = r[0], s = r[1], i = r[2], c = r[3], l = c * n + s * o - i * e, $ = c * e + i * n - u * o, h = c * o + u * e - s * n, f = -u * n - s * e - i * o;\n    return t[0] = l * c + f * -u + $ * -i - h * -s, t[1] = $ * c + f * -s + h * -u - l * -i, t[2] = h * c + f * -i + l * -s - $ * -u, t[3] = a[3], t;\n  }, zero$1 = function(t) {\n    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t;\n  }, str$3 = function(t) {\n    return \"vec4(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n  }, exactEquals$3 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3];\n  }, equals$3 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = t[3], u = a[0], s = a[1], i = a[2], c = a[3];\n    return Math.abs(r - u) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(n - s) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(e - i) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(i)) && Math.abs(o - c) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(c));\n  }, create$2 = function() {\n    var t = new ARRAY_TYPE(4);\n    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;\n  }, identity$1 = function(t) {\n    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;\n  }, setAxisAngle = function(t, a, r) {\n    r *= 0.5;\n    var n = Math.sin(r);\n    return t[0] = n * a[0], t[1] = n * a[1], t[2] = n * a[2], t[3] = Math.cos(r), t;\n  }, getAxisAngle = function(t, a) {\n    var r = 2 * Math.acos(a[3]), n = Math.sin(r / 2);\n    return n > EPSILON ? (t[0] = a[0] / n, t[1] = a[1] / n, t[2] = a[2] / n) : (t[0] = 1, t[1] = 0, t[2] = 0), r;\n  }, getAngle = function(t, a) {\n    var r = dot$2(t, a);\n    return Math.acos(2 * r * r - 1);\n  }, multiply$2 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[0], i = r[1], c = r[2], l = r[3];\n    return t[0] = n * l + u * s + e * c - o * i, t[1] = e * l + u * i + o * s - n * c, t[2] = o * l + u * c + n * i - e * s, t[3] = u * l - n * s - e * i - o * c, t;\n  }, rotateX$1 = function(t, a, r) {\n    r *= 0.5;\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = Math.sin(r), i = Math.cos(r);\n    return t[0] = n * i + u * s, t[1] = e * i + o * s, t[2] = o * i - e * s, t[3] = u * i - n * s, t;\n  }, rotateY$1 = function(t, a, r) {\n    r *= 0.5;\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = Math.sin(r), i = Math.cos(r);\n    return t[0] = n * i - o * s, t[1] = e * i + u * s, t[2] = o * i + n * s, t[3] = u * i - e * s, t;\n  }, rotateZ$1 = function(t, a, r) {\n    r *= 0.5;\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = Math.sin(r), i = Math.cos(r);\n    return t[0] = n * i + e * s, t[1] = e * i - n * s, t[2] = o * i + u * s, t[3] = u * i - o * s, t;\n  }, calculateW = function(t, a) {\n    var r = a[0], n = a[1], e = a[2];\n    return t[0] = r, t[1] = n, t[2] = e, t[3] = Math.sqrt(Math.abs(1 - r * r - n * n - e * e)), t;\n  }, exp = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = Math.sqrt(r * r + n * n + e * e), s = Math.exp(o), i = u > 0 ? s * Math.sin(u) / u : 0;\n    return t[0] = r * i, t[1] = n * i, t[2] = e * i, t[3] = s * Math.cos(u), t;\n  }, ln = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = Math.sqrt(r * r + n * n + e * e), s = u > 0 ? Math.atan2(u, o) / u : 0;\n    return t[0] = r * s, t[1] = n * s, t[2] = e * s, t[3] = 0.5 * Math.log(r * r + n * n + e * e + o * o), t;\n  }, pow = function(t, a, r) {\n    return ln(t, a), scale$2(t, t, r), exp(t, t), t;\n  }, slerp = function(t, a, r, n) {\n    var e, o, u, s, i, c = a[0], l = a[1], $ = a[2], h = a[3], f = r[0], M = r[1], m = r[2], d = r[3];\n    return (o = c * f + l * M + $ * m + h * d) < 0 && (o = -o, f = -f, M = -M, m = -m, d = -d), 1 - o > EPSILON ? (e = Math.acos(o), u = Math.sin(e), s = Math.sin((1 - n) * e) / u, i = Math.sin(n * e) / u) : (s = 1 - n, i = n), t[0] = s * c + i * f, t[1] = s * l + i * M, t[2] = s * $ + i * m, t[3] = s * h + i * d, t;\n  }, random$1 = function(t) {\n    var a = RANDOM(), r = RANDOM(), n = RANDOM(), e = Math.sqrt(1 - a), o = Math.sqrt(a);\n    return t[0] = e * Math.sin(2 * Math.PI * r), t[1] = e * Math.cos(2 * Math.PI * r), t[2] = o * Math.sin(2 * Math.PI * n), t[3] = o * Math.cos(2 * Math.PI * n), t;\n  }, invert$1 = function(t, a) {\n    var r = a[0], n = a[1], e = a[2], o = a[3], u = r * r + n * n + e * e + o * o, s = u ? 1 / u : 0;\n    return t[0] = -r * s, t[1] = -n * s, t[2] = -e * s, t[3] = o * s, t;\n  }, conjugate$1 = function(t, a) {\n    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = a[3], t;\n  }, fromMat3 = function(t, a) {\n    var r, n = a[0] + a[4] + a[8];\n    if (n > 0) r = Math.sqrt(n + 1), t[3] = 0.5 * r, r = 0.5 / r, t[0] = (a[5] - a[7]) * r, t[1] = (a[6] - a[2]) * r, t[2] = (a[1] - a[3]) * r;\n    else {\n      var e = 0;\n      a[4] > a[0] && (e = 1), a[8] > a[3 * e + e] && (e = 2);\n      var o = (e + 1) % 3, u = (e + 2) % 3;\n      r = Math.sqrt(a[3 * e + e] - a[3 * o + o] - a[3 * u + u] + 1), t[e] = 0.5 * r, r = 0.5 / r, t[3] = (a[3 * o + u] - a[3 * u + o]) * r, t[o] = (a[3 * o + e] + a[3 * e + o]) * r, t[u] = (a[3 * u + e] + a[3 * e + u]) * r;\n    }\n    return t;\n  }, fromEuler = function(t, a, r, n) {\n    var e = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : ANGLE_ORDER, o = Math.PI / 360;\n    a *= o, n *= o, r *= o;\n    var u = Math.sin(a), s = Math.cos(a), i = Math.sin(r), c = Math.cos(r), l = Math.sin(n), $ = Math.cos(n);\n    switch (e) {\n      case \"xyz\":\n        t[0] = u * c * $ + s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ - u * i * l;\n        break;\n      case \"xzy\":\n        t[0] = u * c * $ - s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ + u * i * l;\n        break;\n      case \"yxz\":\n        t[0] = u * c * $ + s * i * l, t[1] = s * i * $ - u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ + u * i * l;\n        break;\n      case \"yzx\":\n        t[0] = u * c * $ + s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ - u * i * l;\n        break;\n      case \"zxy\":\n        t[0] = u * c * $ - s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l + u * i * $, t[3] = s * c * $ - u * i * l;\n        break;\n      case \"zyx\":\n        t[0] = u * c * $ - s * i * l, t[1] = s * i * $ + u * c * l, t[2] = s * c * l - u * i * $, t[3] = s * c * $ + u * i * l;\n        break;\n      default:\n        throw new Error(\"Unknown angle order \" + e);\n    }\n    return t;\n  }, str$2 = function(t) {\n    return \"quat(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n  }, equals$2 = function(t, a) {\n    return Math.abs(dot$3(t, a)) >= 1 - EPSILON;\n  }, create$1 = function() {\n    var t = new ARRAY_TYPE(8);\n    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[3] = 1, t;\n  }, clone$1 = function(t) {\n    var a = new ARRAY_TYPE(8);\n    return a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = t[3], a[4] = t[4], a[5] = t[5], a[6] = t[6], a[7] = t[7], a;\n  }, fromValues$1 = function(t, a, r, n, e, o, u, s) {\n    var i = new ARRAY_TYPE(8);\n    return i[0] = t, i[1] = a, i[2] = r, i[3] = n, i[4] = e, i[5] = o, i[6] = u, i[7] = s, i;\n  }, fromRotationTranslationValues = function(t, a, r, n, e, o, u) {\n    var s = new ARRAY_TYPE(8);\n    s[0] = t, s[1] = a, s[2] = r, s[3] = n;\n    var i = 0.5 * e, c = 0.5 * o, l = 0.5 * u;\n    return s[4] = i * n + c * r - l * a, s[5] = c * n + l * t - i * r, s[6] = l * n + i * a - c * t, s[7] = -i * t - c * a - l * r, s;\n  }, fromRotationTranslation = function(t, a, r) {\n    var n = 0.5 * r[0], e = 0.5 * r[1], o = 0.5 * r[2], u = a[0], s = a[1], i = a[2], c = a[3];\n    return t[0] = u, t[1] = s, t[2] = i, t[3] = c, t[4] = n * c + e * i - o * s, t[5] = e * c + o * u - n * i, t[6] = o * c + n * s - e * u, t[7] = -n * u - e * s - o * i, t;\n  }, fromTranslation = function(t, a) {\n    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0.5 * a[0], t[5] = 0.5 * a[1], t[6] = 0.5 * a[2], t[7] = 0, t;\n  }, fromRotation = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;\n  }, fromMat4 = function(t, a) {\n    var r = create$2();\n    getRotation(r, a);\n    var n = new ARRAY_TYPE(3);\n    return getTranslation$1(n, a), fromRotationTranslation(t, r, n), t;\n  }, copy$1 = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t;\n  }, identity = function(t) {\n    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;\n  }, set$1 = function(t, a, r, n, e, o, u, s, i) {\n    return t[0] = a, t[1] = r, t[2] = n, t[3] = e, t[4] = o, t[5] = u, t[6] = s, t[7] = i, t;\n  }, getDual = function(t, a) {\n    return t[0] = a[4], t[1] = a[5], t[2] = a[6], t[3] = a[7], t;\n  }, setDual = function(t, a) {\n    return t[4] = a[0], t[5] = a[1], t[6] = a[2], t[7] = a[3], t;\n  }, getTranslation = function(t, a) {\n    var r = a[4], n = a[5], e = a[6], o = a[7], u = -a[0], s = -a[1], i = -a[2], c = a[3];\n    return t[0] = 2 * (r * c + o * u + n * i - e * s), t[1] = 2 * (n * c + o * s + e * u - r * i), t[2] = 2 * (e * c + o * i + r * s - n * u), t;\n  }, translate = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = 0.5 * r[0], i = 0.5 * r[1], c = 0.5 * r[2], l = a[4], $ = a[5], h = a[6], f = a[7];\n    return t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = u * s + e * c - o * i + l, t[5] = u * i + o * s - n * c + $, t[6] = u * c + n * i - e * s + h, t[7] = -n * s - e * i - o * c + f, t;\n  }, rotateX = function(t, a, r) {\n    var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, M = l * u - s * n - i * e - c * o;\n    return rotateX$1(t, a, r), n = t[0], e = t[1], o = t[2], u = t[3], t[4] = $ * u + M * n + h * o - f * e, t[5] = h * u + M * e + f * n - $ * o, t[6] = f * u + M * o + $ * e - h * n, t[7] = M * u - $ * n - h * e - f * o, t;\n  }, rotateY = function(t, a, r) {\n    var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, M = l * u - s * n - i * e - c * o;\n    return rotateY$1(t, a, r), n = t[0], e = t[1], o = t[2], u = t[3], t[4] = $ * u + M * n + h * o - f * e, t[5] = h * u + M * e + f * n - $ * o, t[6] = f * u + M * o + $ * e - h * n, t[7] = M * u - $ * n - h * e - f * o, t;\n  }, rotateZ = function(t, a, r) {\n    var n = -a[0], e = -a[1], o = -a[2], u = a[3], s = a[4], i = a[5], c = a[6], l = a[7], $ = s * u + l * n + i * o - c * e, h = i * u + l * e + c * n - s * o, f = c * u + l * o + s * e - i * n, M = l * u - s * n - i * e - c * o;\n    return rotateZ$1(t, a, r), n = t[0], e = t[1], o = t[2], u = t[3], t[4] = $ * u + M * n + h * o - f * e, t[5] = h * u + M * e + f * n - $ * o, t[6] = f * u + M * o + $ * e - h * n, t[7] = M * u - $ * n - h * e - f * o, t;\n  }, rotateByQuatAppend = function(t, a, r) {\n    var n = r[0], e = r[1], o = r[2], u = r[3], s = a[0], i = a[1], c = a[2], l = a[3];\n    return t[0] = s * u + l * n + i * o - c * e, t[1] = i * u + l * e + c * n - s * o, t[2] = c * u + l * o + s * e - i * n, t[3] = l * u - s * n - i * e - c * o, s = a[4], i = a[5], c = a[6], l = a[7], t[4] = s * u + l * n + i * o - c * e, t[5] = i * u + l * e + c * n - s * o, t[6] = c * u + l * o + s * e - i * n, t[7] = l * u - s * n - i * e - c * o, t;\n  }, rotateByQuatPrepend = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[0], i = r[1], c = r[2], l = r[3];\n    return t[0] = n * l + u * s + e * c - o * i, t[1] = e * l + u * i + o * s - n * c, t[2] = o * l + u * c + n * i - e * s, t[3] = u * l - n * s - e * i - o * c, s = r[4], i = r[5], c = r[6], l = r[7], t[4] = n * l + u * s + e * c - o * i, t[5] = e * l + u * i + o * s - n * c, t[6] = o * l + u * c + n * i - e * s, t[7] = u * l - n * s - e * i - o * c, t;\n  }, rotateAroundAxis = function(t, a, r, n) {\n    if (Math.abs(n) < EPSILON) return copy$1(t, a);\n    var e = Math.hypot(r[0], r[1], r[2]);\n    n *= 0.5;\n    var o = Math.sin(n), u = o * r[0] / e, s = o * r[1] / e, i = o * r[2] / e, c = Math.cos(n), l = a[0], $ = a[1], h = a[2], f = a[3];\n    t[0] = l * c + f * u + $ * i - h * s, t[1] = $ * c + f * s + h * u - l * i, t[2] = h * c + f * i + l * s - $ * u, t[3] = f * c - l * u - $ * s - h * i;\n    var M = a[4], m = a[5], d = a[6], v = a[7];\n    return t[4] = M * c + v * u + m * i - d * s, t[5] = m * c + v * s + d * u - M * i, t[6] = d * c + v * i + M * s - m * u, t[7] = v * c - M * u - m * s - d * i, t;\n  }, add$1 = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t[3] = a[3] + r[3], t[4] = a[4] + r[4], t[5] = a[5] + r[5], t[6] = a[6] + r[6], t[7] = a[7] + r[7], t;\n  }, multiply$1 = function(t, a, r) {\n    var n = a[0], e = a[1], o = a[2], u = a[3], s = r[4], i = r[5], c = r[6], l = r[7], $ = a[4], h = a[5], f = a[6], M = a[7], m = r[0], d = r[1], v = r[2], b = r[3];\n    return t[0] = n * b + u * m + e * v - o * d, t[1] = e * b + u * d + o * m - n * v, t[2] = o * b + u * v + n * d - e * m, t[3] = u * b - n * m - e * d - o * v, t[4] = n * l + u * s + e * c - o * i + $ * b + M * m + h * v - f * d, t[5] = e * l + u * i + o * s - n * c + h * b + M * d + f * m - $ * v, t[6] = o * l + u * c + n * i - e * s + f * b + M * v + $ * d - h * m, t[7] = u * l - n * s - e * i - o * c + M * b - $ * m - h * d - f * v, t;\n  }, scale$1 = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = a[3] * r, t[4] = a[4] * r, t[5] = a[5] * r, t[6] = a[6] * r, t[7] = a[7] * r, t;\n  }, lerp$1 = function(t, a, r, n) {\n    var e = 1 - n;\n    return dot$1(a, r) < 0 && (n = -n), t[0] = a[0] * e + r[0] * n, t[1] = a[1] * e + r[1] * n, t[2] = a[2] * e + r[2] * n, t[3] = a[3] * e + r[3] * n, t[4] = a[4] * e + r[4] * n, t[5] = a[5] * e + r[5] * n, t[6] = a[6] * e + r[6] * n, t[7] = a[7] * e + r[7] * n, t;\n  }, invert = function(t, a) {\n    var r = squaredLength$1(a);\n    return t[0] = -a[0] / r, t[1] = -a[1] / r, t[2] = -a[2] / r, t[3] = a[3] / r, t[4] = -a[4] / r, t[5] = -a[5] / r, t[6] = -a[6] / r, t[7] = a[7] / r, t;\n  }, conjugate = function(t, a) {\n    return t[0] = -a[0], t[1] = -a[1], t[2] = -a[2], t[3] = a[3], t[4] = -a[4], t[5] = -a[5], t[6] = -a[6], t[7] = a[7], t;\n  }, normalize$1 = function(t, a) {\n    var r = squaredLength$1(a);\n    if (r > 0) {\n      r = Math.sqrt(r);\n      var n = a[0] / r, e = a[1] / r, o = a[2] / r, u = a[3] / r, s = a[4], i = a[5], c = a[6], l = a[7], $ = n * s + e * i + o * c + u * l;\n      t[0] = n, t[1] = e, t[2] = o, t[3] = u, t[4] = (s - n * $) / r, t[5] = (i - e * $) / r, t[6] = (c - o * $) / r, t[7] = (l - u * $) / r;\n    }\n    return t;\n  }, str$1 = function(t) {\n    return \"quat2(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \")\";\n  }, exactEquals$1 = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1] && t[2] === a[2] && t[3] === a[3] && t[4] === a[4] && t[5] === a[5] && t[6] === a[6] && t[7] === a[7];\n  }, equals$1 = function(t, a) {\n    var r = t[0], n = t[1], e = t[2], o = t[3], u = t[4], s = t[5], i = t[6], c = t[7], l = a[0], $ = a[1], h = a[2], f = a[3], M = a[4], m = a[5], d = a[6], v = a[7];\n    return Math.abs(r - l) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(n - $) <= EPSILON * Math.max(1, Math.abs(n), Math.abs($)) && Math.abs(e - h) <= EPSILON * Math.max(1, Math.abs(e), Math.abs(h)) && Math.abs(o - f) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(u - M) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(M)) && Math.abs(s - m) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(i - d) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(d)) && Math.abs(c - v) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(v));\n  }, create = function() {\n    var t = new ARRAY_TYPE(2);\n    return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0), t;\n  }, clone = function(t) {\n    var a = new ARRAY_TYPE(2);\n    return a[0] = t[0], a[1] = t[1], a;\n  }, fromValues = function(t, a) {\n    var r = new ARRAY_TYPE(2);\n    return r[0] = t, r[1] = a, r;\n  }, copy = function(t, a) {\n    return t[0] = a[0], t[1] = a[1], t;\n  }, set = function(t, a, r) {\n    return t[0] = a, t[1] = r, t;\n  }, add = function(t, a, r) {\n    return t[0] = a[0] + r[0], t[1] = a[1] + r[1], t;\n  }, subtract = function(t, a, r) {\n    return t[0] = a[0] - r[0], t[1] = a[1] - r[1], t;\n  }, multiply = function(t, a, r) {\n    return t[0] = a[0] * r[0], t[1] = a[1] * r[1], t;\n  }, divide = function(t, a, r) {\n    return t[0] = a[0] / r[0], t[1] = a[1] / r[1], t;\n  }, ceil = function(t, a) {\n    return t[0] = Math.ceil(a[0]), t[1] = Math.ceil(a[1]), t;\n  }, floor = function(t, a) {\n    return t[0] = Math.floor(a[0]), t[1] = Math.floor(a[1]), t;\n  }, min = function(t, a, r) {\n    return t[0] = Math.min(a[0], r[0]), t[1] = Math.min(a[1], r[1]), t;\n  }, max = function(t, a, r) {\n    return t[0] = Math.max(a[0], r[0]), t[1] = Math.max(a[1], r[1]), t;\n  }, round = function(t, a) {\n    return t[0] = Math.round(a[0]), t[1] = Math.round(a[1]), t;\n  }, scale = function(t, a, r) {\n    return t[0] = a[0] * r, t[1] = a[1] * r, t;\n  }, scaleAndAdd = function(t, a, r, n) {\n    return t[0] = a[0] + r[0] * n, t[1] = a[1] + r[1] * n, t;\n  }, distance = function(t, a) {\n    var r = a[0] - t[0], n = a[1] - t[1];\n    return Math.hypot(r, n);\n  }, squaredDistance = function(t, a) {\n    var r = a[0] - t[0], n = a[1] - t[1];\n    return r * r + n * n;\n  }, length = function(t) {\n    var a = t[0], r = t[1];\n    return Math.hypot(a, r);\n  }, squaredLength = function(t) {\n    var a = t[0], r = t[1];\n    return a * a + r * r;\n  }, negate = function(t, a) {\n    return t[0] = -a[0], t[1] = -a[1], t;\n  }, inverse = function(t, a) {\n    return t[0] = 1 / a[0], t[1] = 1 / a[1], t;\n  }, normalize = function(t, a) {\n    var r = a[0], n = a[1], e = r * r + n * n;\n    return e > 0 && (e = 1 / Math.sqrt(e)), t[0] = a[0] * e, t[1] = a[1] * e, t;\n  }, dot = function(t, a) {\n    return t[0] * a[0] + t[1] * a[1];\n  }, cross = function(t, a, r) {\n    var n = a[0] * r[1] - a[1] * r[0];\n    return t[0] = t[1] = 0, t[2] = n, t;\n  }, lerp = function(t, a, r, n) {\n    var e = a[0], o = a[1];\n    return t[0] = e + n * (r[0] - e), t[1] = o + n * (r[1] - o), t;\n  }, random = function(t, a) {\n    a = a || 1;\n    var r = 2 * RANDOM() * Math.PI;\n    return t[0] = Math.cos(r) * a, t[1] = Math.sin(r) * a, t;\n  }, transformMat2 = function(t, a, r) {\n    var n = a[0], e = a[1];\n    return t[0] = r[0] * n + r[2] * e, t[1] = r[1] * n + r[3] * e, t;\n  }, transformMat2d = function(t, a, r) {\n    var n = a[0], e = a[1];\n    return t[0] = r[0] * n + r[2] * e + r[4], t[1] = r[1] * n + r[3] * e + r[5], t;\n  }, transformMat3 = function(t, a, r) {\n    var n = a[0], e = a[1];\n    return t[0] = r[0] * n + r[3] * e + r[6], t[1] = r[1] * n + r[4] * e + r[7], t;\n  }, transformMat4 = function(t, a, r) {\n    var n = a[0], e = a[1];\n    return t[0] = r[0] * n + r[4] * e + r[12], t[1] = r[1] * n + r[5] * e + r[13], t;\n  }, rotate = function(t, a, r, n) {\n    var e = a[0] - r[0], o = a[1] - r[1], u = Math.sin(n), s = Math.cos(n);\n    return t[0] = e * s - o * u + r[0], t[1] = e * u + o * s + r[1], t;\n  }, angle = function(t, a) {\n    var r = t[0], n = t[1], e = a[0], o = a[1], u = Math.sqrt((r * r + n * n) * (e * e + o * o)), s = u && (r * e + n * o) / u;\n    return Math.acos(Math.min(Math.max(s, -1), 1));\n  }, zero = function(t) {\n    return t[0] = 0, t[1] = 0, t;\n  }, str = function(t) {\n    return \"vec2(\" + t[0] + \", \" + t[1] + \")\";\n  }, exactEquals = function(t, a) {\n    return t[0] === a[0] && t[1] === a[1];\n  }, equals = function(t, a) {\n    var r = t[0], n = t[1], e = a[0], o = a[1];\n    return Math.abs(r - e) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(e)) && Math.abs(n - o) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(o));\n  };\n  setMatrixArrayType2 = setMatrixArrayType, toRadian2 = toRadian, equals$92 = equals$9, create$82 = create$8, clone$82 = clone$8, copy$82 = copy$8, identity$52 = identity$5, fromValues$82 = fromValues$8, set$82 = set$8, transpose$22 = transpose$2, invert$52 = invert$5, adjoint$22 = adjoint$2, determinant$32 = determinant$3, multiply$82 = multiply$8, rotate$42 = rotate$4, scale$82 = scale$8, fromRotation$42 = fromRotation$4, fromScaling$32 = fromScaling$3, str$82 = str$8, frob$32 = frob$3, LDU2 = LDU, add$82 = add$8, subtract$62 = subtract$6, exactEquals$82 = exactEquals$8, equals$82 = equals$8, multiplyScalar$32 = multiplyScalar$3, multiplyScalarAndAdd$32 = multiplyScalarAndAdd$3, create$72 = create$7, clone$72 = clone$7, copy$72 = copy$7, identity$42 = identity$4, fromValues$72 = fromValues$7, set$72 = set$7, invert$42 = invert$4, determinant$22 = determinant$2, multiply$72 = multiply$7, rotate$32 = rotate$3, scale$72 = scale$7, translate$32 = translate$3, fromRotation$32 = fromRotation$3, fromScaling$22 = fromScaling$2, fromTranslation$32 = fromTranslation$3, str$72 = str$7, frob$22 = frob$2, add$72 = add$7, subtract$52 = subtract$5, multiplyScalar$22 = multiplyScalar$2, multiplyScalarAndAdd$22 = multiplyScalarAndAdd$2, exactEquals$72 = exactEquals$7, equals$72 = equals$7, create$62 = create$6, fromMat4$12 = fromMat4$1, clone$62 = clone$6, copy$62 = copy$6, fromValues$62 = fromValues$6, set$62 = set$6, identity$32 = identity$3, transpose$12 = transpose$1, invert$32 = invert$3, adjoint$12 = adjoint$1, determinant$12 = determinant$1, multiply$62 = multiply$6, translate$22 = translate$2, rotate$22 = rotate$2, scale$62 = scale$6, fromTranslation$22 = fromTranslation$2, fromRotation$22 = fromRotation$2, fromScaling$12 = fromScaling$1, fromMat2d2 = fromMat2d, fromQuat$12 = fromQuat$1, normalFromMat42 = normalFromMat4, projection2 = projection, str$62 = str$6, frob$12 = frob$1, add$62 = add$6, subtract$42 = subtract$4, multiplyScalar$12 = multiplyScalar$1, multiplyScalarAndAdd$12 = multiplyScalarAndAdd$1, exactEquals$62 = exactEquals$6, equals$62 = equals$6, create$52 = create$5, clone$52 = clone$5, copy$52 = copy$5, fromValues$52 = fromValues$5, set$52 = set$5, identity$22 = identity$2, transpose2 = transpose, invert$22 = invert$2, adjoint2 = adjoint, determinant2 = determinant, multiply$52 = multiply$5, translate$12 = translate$1, scale$52 = scale$5, rotate$12 = rotate$1, rotateX$32 = rotateX$3, rotateY$32 = rotateY$3, rotateZ$32 = rotateZ$3, fromTranslation$12 = fromTranslation$1, fromScaling2 = fromScaling, fromRotation$12 = fromRotation$1, fromXRotation2 = fromXRotation, fromYRotation2 = fromYRotation, fromZRotation2 = fromZRotation, fromRotationTranslation$12 = fromRotationTranslation$1, fromQuat22 = fromQuat2, getTranslation$12 = getTranslation$1, getScaling2 = getScaling, getRotation2 = getRotation, decompose2 = decompose, fromRotationTranslationScale2 = fromRotationTranslationScale, fromRotationTranslationScaleOrigin2 = fromRotationTranslationScaleOrigin, fromQuat3 = fromQuat, frustum2 = frustum, perspectiveNO2 = perspectiveNO, perspectiveZO2 = perspectiveZO, perspectiveFromFieldOfView2 = perspectiveFromFieldOfView, orthoNO2 = orthoNO, orthoZO2 = orthoZO, lookAt2 = lookAt, targetTo2 = targetTo, str$52 = str$5, frob2 = frob, add$52 = add$5, subtract$32 = subtract$3, multiplyScalar2 = multiplyScalar, multiplyScalarAndAdd2 = multiplyScalarAndAdd, exactEquals$52 = exactEquals$5, equals$52 = equals$5, create$42 = create$4, clone$42 = clone$4, length$42 = length$4, fromValues$42 = fromValues$4, copy$42 = copy$4, set$42 = set$4, add$42 = add$4, subtract$22 = subtract$2, multiply$42 = multiply$4, divide$22 = divide$2, ceil$22 = ceil$2, floor$22 = floor$2, min$22 = min$2, max$22 = max$2, round$22 = round$2, scale$42 = scale$4, scaleAndAdd$22 = scaleAndAdd$2, distance$22 = distance$2, squaredDistance$22 = squaredDistance$2, squaredLength$42 = squaredLength$4, negate$22 = negate$2, inverse$22 = inverse$2, normalize$42 = normalize$4, dot$42 = dot$4, cross$22 = cross$2, lerp$42 = lerp$4, slerp$12 = slerp$1, hermite2 = hermite, bezier2 = bezier, random$32 = random$3, transformMat4$22 = transformMat4$2, transformMat3$12 = transformMat3$1, transformQuat$12 = transformQuat$1, rotateX$22 = rotateX$2, rotateY$22 = rotateY$2, rotateZ$22 = rotateZ$2, angle$12 = angle$1, zero$22 = zero$2, str$42 = str$4, exactEquals$42 = exactEquals$4, equals$42 = equals$4, create$32 = create$3, clone$32 = clone$3, fromValues$32 = fromValues$3, copy$32 = copy$3, set$32 = set$3, add$32 = add$3, subtract$12 = subtract$1, multiply$32 = multiply$3, divide$12 = divide$1, ceil$12 = ceil$1, floor$12 = floor$1, min$12 = min$1, max$12 = max$1, round$12 = round$1, scale$32 = scale$3, scaleAndAdd$12 = scaleAndAdd$1, distance$12 = distance$1, squaredDistance$12 = squaredDistance$1, length$32 = length$3, squaredLength$32 = squaredLength$3, negate$12 = negate$1, inverse$12 = inverse$1, normalize$32 = normalize$3, dot$32 = dot$3, cross$12 = cross$1, lerp$32 = lerp$3, random$22 = random$2, transformMat4$12 = transformMat4$1, transformQuat2 = transformQuat, zero$12 = zero$1, str$32 = str$3, exactEquals$32 = exactEquals$3, equals$32 = equals$3, create$22 = create$2, identity$12 = identity$1, setAxisAngle2 = setAxisAngle, getAxisAngle2 = getAxisAngle, getAngle2 = getAngle, multiply$22 = multiply$2, rotateX$12 = rotateX$1, rotateY$12 = rotateY$1, rotateZ$12 = rotateZ$1, calculateW2 = calculateW, exp2 = exp, ln2 = ln, pow2 = pow, slerp2 = slerp, random$12 = random$1, invert$12 = invert$1, conjugate$12 = conjugate$1, fromMat32 = fromMat3, fromEuler2 = fromEuler, str$22 = str$2, equals$22 = equals$2, create$12 = create$1, clone$12 = clone$1, fromValues$12 = fromValues$1, fromRotationTranslationValues2 = fromRotationTranslationValues, fromRotationTranslation2 = fromRotationTranslation, fromTranslation2 = fromTranslation, fromRotation2 = fromRotation, fromMat42 = fromMat4, copy$12 = copy$1, identity2 = identity, set$12 = set$1, getDual2 = getDual, setDual2 = setDual, getTranslation2 = getTranslation, translate2 = translate, rotateX2 = rotateX, rotateY2 = rotateY, rotateZ2 = rotateZ, rotateByQuatAppend2 = rotateByQuatAppend, rotateByQuatPrepend2 = rotateByQuatPrepend, rotateAroundAxis2 = rotateAroundAxis, add$12 = add$1, multiply$12 = multiply$1, scale$12 = scale$1, lerp$12 = lerp$1, invert2 = invert, conjugate2 = conjugate, normalize$12 = normalize$1, str$12 = str$1, exactEquals$12 = exactEquals$1, equals$12 = equals$1, create2 = create, clone2 = clone, fromValues2 = fromValues, copy2 = copy, set2 = set, add2 = add, subtract2 = subtract, multiply2 = multiply, divide2 = divide, ceil2 = ceil, floor2 = floor, min2 = min, max2 = max, round2 = round, scale2 = scale, scaleAndAdd2 = scaleAndAdd, distance2 = distance, squaredDistance2 = squaredDistance, length2 = length, squaredLength2 = squaredLength, negate2 = negate, inverse2 = inverse, normalize2 = normalize, dot2 = dot, cross2 = cross, lerp2 = lerp, random2 = random, transformMat22 = transformMat2, transformMat2d2 = transformMat2d, transformMat32 = transformMat3, transformMat42 = transformMat4, rotate2 = rotate, angle2 = angle, zero2 = zero, str2 = str, exactEquals2 = exactEquals, equals2 = equals;\n  EPSILON = 1e-6, ARRAY_TYPE = \"undefined\" != typeof Float32Array ? Float32Array : Array, RANDOM = Math.random, ANGLE_ORDER = \"zyx\";\n  degree = Math.PI / 180;\n  Math.hypot || (Math.hypot = function() {\n    for (var t = 0, a = arguments.length; a--; ) t += arguments[a] * arguments[a];\n    return Math.sqrt(t);\n  });\n  common = { __proto__: null, EPSILON, get ARRAY_TYPE() {\n    return ARRAY_TYPE;\n  }, RANDOM, ANGLE_ORDER, setMatrixArrayType, toRadian, equals: equals$9 };\n  mul$8 = multiply$8, sub$6 = subtract$6, mat2 = Object.freeze({ __proto__: null, create: create$8, clone: clone$8, copy: copy$8, identity: identity$5, fromValues: fromValues$8, set: set$8, transpose: transpose$2, invert: invert$5, adjoint: adjoint$2, determinant: determinant$3, multiply: multiply$8, rotate: rotate$4, scale: scale$8, fromRotation: fromRotation$4, fromScaling: fromScaling$3, str: str$8, frob: frob$3, LDU, add: add$8, subtract: subtract$6, exactEquals: exactEquals$8, equals: equals$8, multiplyScalar: multiplyScalar$3, multiplyScalarAndAdd: multiplyScalarAndAdd$3, mul: mul$8, sub: sub$6 });\n  mul$7 = multiply$7, sub$5 = subtract$5, mat2d = Object.freeze({ __proto__: null, create: create$7, clone: clone$7, copy: copy$7, identity: identity$4, fromValues: fromValues$7, set: set$7, invert: invert$4, determinant: determinant$2, multiply: multiply$7, rotate: rotate$3, scale: scale$7, translate: translate$3, fromRotation: fromRotation$3, fromScaling: fromScaling$2, fromTranslation: fromTranslation$3, str: str$7, frob: frob$2, add: add$7, subtract: subtract$5, multiplyScalar: multiplyScalar$2, multiplyScalarAndAdd: multiplyScalarAndAdd$2, exactEquals: exactEquals$7, equals: equals$7, mul: mul$7, sub: sub$5 });\n  mul$6 = multiply$6, sub$4 = subtract$4, mat3 = Object.freeze({ __proto__: null, create: create$6, fromMat4: fromMat4$1, clone: clone$6, copy: copy$6, fromValues: fromValues$6, set: set$6, identity: identity$3, transpose: transpose$1, invert: invert$3, adjoint: adjoint$1, determinant: determinant$1, multiply: multiply$6, translate: translate$2, rotate: rotate$2, scale: scale$6, fromTranslation: fromTranslation$2, fromRotation: fromRotation$2, fromScaling: fromScaling$1, fromMat2d, fromQuat: fromQuat$1, normalFromMat4, projection, str: str$6, frob: frob$1, add: add$6, subtract: subtract$4, multiplyScalar: multiplyScalar$1, multiplyScalarAndAdd: multiplyScalarAndAdd$1, exactEquals: exactEquals$6, equals: equals$6, mul: mul$6, sub: sub$4 });\n  perspective = perspectiveNO;\n  ortho = orthoNO;\n  mul$5 = multiply$5, sub$3 = subtract$3, mat4 = Object.freeze({ __proto__: null, create: create$5, clone: clone$5, copy: copy$5, fromValues: fromValues$5, set: set$5, identity: identity$2, transpose, invert: invert$2, adjoint, determinant, multiply: multiply$5, translate: translate$1, scale: scale$5, rotate: rotate$1, rotateX: rotateX$3, rotateY: rotateY$3, rotateZ: rotateZ$3, fromTranslation: fromTranslation$1, fromScaling, fromRotation: fromRotation$1, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation: fromRotationTranslation$1, fromQuat2, getTranslation: getTranslation$1, getScaling, getRotation, decompose, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspectiveNO, perspective, perspectiveZO, perspectiveFromFieldOfView, orthoNO, ortho, orthoZO, lookAt, targetTo, str: str$5, frob, add: add$5, subtract: subtract$3, multiplyScalar, multiplyScalarAndAdd, exactEquals: exactEquals$5, equals: equals$5, mul: mul$5, sub: sub$3 });\n  sub$2 = subtract$2, mul$4 = multiply$4, div$2 = divide$2, dist$2 = distance$2, sqrDist$2 = squaredDistance$2, len$4 = length$4, sqrLen$4 = squaredLength$4, forEach$2 = function() {\n    var t = create$4();\n    return function(a, r, n, e, o, u) {\n      var s, i;\n      for (r || (r = 3), n || (n = 0), i = e ? Math.min(e * r + n, a.length) : a.length, s = n; s < i; s += r) t[0] = a[s], t[1] = a[s + 1], t[2] = a[s + 2], o(t, t, u), a[s] = t[0], a[s + 1] = t[1], a[s + 2] = t[2];\n      return a;\n    };\n  }(), vec3 = Object.freeze({ __proto__: null, create: create$4, clone: clone$4, length: length$4, fromValues: fromValues$4, copy: copy$4, set: set$4, add: add$4, subtract: subtract$2, multiply: multiply$4, divide: divide$2, ceil: ceil$2, floor: floor$2, min: min$2, max: max$2, round: round$2, scale: scale$4, scaleAndAdd: scaleAndAdd$2, distance: distance$2, squaredDistance: squaredDistance$2, squaredLength: squaredLength$4, negate: negate$2, inverse: inverse$2, normalize: normalize$4, dot: dot$4, cross: cross$2, lerp: lerp$4, slerp: slerp$1, hermite, bezier, random: random$3, transformMat4: transformMat4$2, transformMat3: transformMat3$1, transformQuat: transformQuat$1, rotateX: rotateX$2, rotateY: rotateY$2, rotateZ: rotateZ$2, angle: angle$1, zero: zero$2, str: str$4, exactEquals: exactEquals$4, equals: equals$4, sub: sub$2, mul: mul$4, div: div$2, dist: dist$2, sqrDist: sqrDist$2, len: len$4, sqrLen: sqrLen$4, forEach: forEach$2 });\n  sub$1 = subtract$1, mul$3 = multiply$3, div$1 = divide$1, dist$1 = distance$1, sqrDist$1 = squaredDistance$1, len$3 = length$3, sqrLen$3 = squaredLength$3, forEach$1 = function() {\n    var t = create$3();\n    return function(a, r, n, e, o, u) {\n      var s, i;\n      for (r || (r = 4), n || (n = 0), i = e ? Math.min(e * r + n, a.length) : a.length, s = n; s < i; s += r) t[0] = a[s], t[1] = a[s + 1], t[2] = a[s + 2], t[3] = a[s + 3], o(t, t, u), a[s] = t[0], a[s + 1] = t[1], a[s + 2] = t[2], a[s + 3] = t[3];\n      return a;\n    };\n  }(), vec4 = Object.freeze({ __proto__: null, create: create$3, clone: clone$3, fromValues: fromValues$3, copy: copy$3, set: set$3, add: add$3, subtract: subtract$1, multiply: multiply$3, divide: divide$1, ceil: ceil$1, floor: floor$1, min: min$1, max: max$1, round: round$1, scale: scale$3, scaleAndAdd: scaleAndAdd$1, distance: distance$1, squaredDistance: squaredDistance$1, length: length$3, squaredLength: squaredLength$3, negate: negate$1, inverse: inverse$1, normalize: normalize$3, dot: dot$3, cross: cross$1, lerp: lerp$3, random: random$2, transformMat4: transformMat4$1, transformQuat, zero: zero$1, str: str$3, exactEquals: exactEquals$3, equals: equals$3, sub: sub$1, mul: mul$3, div: div$1, dist: dist$1, sqrDist: sqrDist$1, len: len$3, sqrLen: sqrLen$3, forEach: forEach$1 });\n  clone$2 = clone$3, fromValues$2 = fromValues$3, copy$2 = copy$3, set$2 = set$3, add$2 = add$3, mul$2 = multiply$2, scale$2 = scale$3, dot$2 = dot$3, lerp$2 = lerp$3, length$2 = length$3, len$2 = length$2, squaredLength$2 = squaredLength$3, sqrLen$2 = squaredLength$2, normalize$2 = normalize$3, exactEquals$2 = exactEquals$3;\n  rotationTo = function() {\n    var t = create$4(), a = fromValues$4(1, 0, 0), r = fromValues$4(0, 1, 0);\n    return function(n, e, o) {\n      var u = dot$4(e, o);\n      return u < -0.999999 ? (cross$2(t, a, e), len$4(t) < 1e-6 && cross$2(t, r, e), normalize$4(t, t), setAxisAngle(n, t, Math.PI), n) : u > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (cross$2(t, e, o), n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = 1 + u, normalize$2(n, n));\n    };\n  }(), sqlerp = function() {\n    var t = create$2(), a = create$2();\n    return function(r, n, e, o, u, s) {\n      return slerp(t, n, u, s), slerp(a, e, o, s), slerp(r, t, a, 2 * s * (1 - s)), r;\n    };\n  }(), setAxes = function() {\n    var t = create$6();\n    return function(a, r, n, e) {\n      return t[0] = n[0], t[3] = n[1], t[6] = n[2], t[1] = e[0], t[4] = e[1], t[7] = e[2], t[2] = -r[0], t[5] = -r[1], t[8] = -r[2], normalize$2(a, fromMat3(a, t));\n    };\n  }(), quat = Object.freeze({ __proto__: null, create: create$2, identity: identity$1, setAxisAngle, getAxisAngle, getAngle, multiply: multiply$2, rotateX: rotateX$1, rotateY: rotateY$1, rotateZ: rotateZ$1, calculateW, exp, ln, pow, slerp, random: random$1, invert: invert$1, conjugate: conjugate$1, fromMat3, fromEuler, str: str$2, clone: clone$2, fromValues: fromValues$2, copy: copy$2, set: set$2, add: add$2, mul: mul$2, scale: scale$2, dot: dot$2, lerp: lerp$2, length: length$2, len: len$2, squaredLength: squaredLength$2, sqrLen: sqrLen$2, normalize: normalize$2, exactEquals: exactEquals$2, equals: equals$2, rotationTo, sqlerp, setAxes });\n  getReal = copy$2;\n  setReal = copy$2;\n  mul$1 = multiply$1;\n  dot$1 = dot$2;\n  length$1 = length$2, len$1 = length$1, squaredLength$1 = squaredLength$2, sqrLen$1 = squaredLength$1;\n  quat2 = Object.freeze({ __proto__: null, create: create$1, clone: clone$1, fromValues: fromValues$1, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy: copy$1, identity, set: set$1, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add: add$1, multiply: multiply$1, mul: mul$1, scale: scale$1, dot: dot$1, lerp: lerp$1, invert, conjugate, length: length$1, len: len$1, squaredLength: squaredLength$1, sqrLen: sqrLen$1, normalize: normalize$1, str: str$1, exactEquals: exactEquals$1, equals: equals$1 });\n  len = length, sub = subtract, mul = multiply, div = divide, dist = distance, sqrDist = squaredDistance, sqrLen = squaredLength, forEach = function() {\n    var t = create();\n    return function(a, r, n, e, o, u) {\n      var s, i;\n      for (r || (r = 2), n || (n = 0), i = e ? Math.min(e * r + n, a.length) : a.length, s = n; s < i; s += r) t[0] = a[s], t[1] = a[s + 1], o(t, t, u), a[s] = t[0], a[s + 1] = t[1];\n      return a;\n    };\n  }(), vec2 = Object.freeze({ __proto__: null, create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach });\n  globalThis.glMatrix = common, globalThis.glMatrix.mat2 = mat2, globalThis.glMatrix.mat2d = mat2d, globalThis.glMatrix.mat3 = mat3, globalThis.glMatrix.mat4 = mat4, globalThis.glMatrix.quat = quat, globalThis.glMatrix.quat2 = quat2, globalThis.glMatrix.vec2 = vec2, globalThis.glMatrix.vec3 = vec3, globalThis.glMatrix.vec4 = vec4;\n}\nvar EPSILON;\nvar ARRAY_TYPE;\nvar RANDOM;\nvar ANGLE_ORDER;\nvar degree;\nvar common;\nvar mul$8;\nvar sub$6;\nvar mat2;\nvar mul$7;\nvar sub$5;\nvar mat2d;\nvar mul$6;\nvar sub$4;\nvar mat3;\nvar perspective;\nvar ortho;\nvar mul$5;\nvar sub$3;\nvar mat4;\nvar sub$2;\nvar mul$4;\nvar div$2;\nvar dist$2;\nvar sqrDist$2;\nvar len$4;\nvar sqrLen$4;\nvar forEach$2;\nvar vec3;\nvar sub$1;\nvar mul$3;\nvar div$1;\nvar dist$1;\nvar sqrDist$1;\nvar len$3;\nvar sqrLen$3;\nvar forEach$1;\nvar vec4;\nvar clone$2;\nvar fromValues$2;\nvar copy$2;\nvar set$2;\nvar add$2;\nvar mul$2;\nvar scale$2;\nvar dot$2;\nvar lerp$2;\nvar length$2;\nvar len$2;\nvar squaredLength$2;\nvar sqrLen$2;\nvar normalize$2;\nvar exactEquals$2;\nvar rotationTo;\nvar sqlerp;\nvar setAxes;\nvar quat;\nvar getReal;\nvar setReal;\nvar mul$1;\nvar dot$1;\nvar length$1;\nvar len$1;\nvar squaredLength$1;\nvar sqrLen$1;\nvar quat2;\nvar len;\nvar sub;\nvar mul;\nvar div;\nvar dist;\nvar sqrDist;\nvar sqrLen;\nvar forEach;\nvar vec2;\nvar setMatrixArrayType2;\nvar toRadian2;\nvar equals$92;\nvar create$82;\nvar clone$82;\nvar copy$82;\nvar identity$52;\nvar fromValues$82;\nvar set$82;\nvar transpose$22;\nvar invert$52;\nvar adjoint$22;\nvar determinant$32;\nvar multiply$82;\nvar rotate$42;\nvar scale$82;\nvar fromRotation$42;\nvar fromScaling$32;\nvar str$82;\nvar frob$32;\nvar LDU2;\nvar add$82;\nvar subtract$62;\nvar exactEquals$82;\nvar equals$82;\nvar multiplyScalar$32;\nvar multiplyScalarAndAdd$32;\nvar create$72;\nvar clone$72;\nvar copy$72;\nvar identity$42;\nvar fromValues$72;\nvar set$72;\nvar invert$42;\nvar determinant$22;\nvar multiply$72;\nvar rotate$32;\nvar scale$72;\nvar translate$32;\nvar fromRotation$32;\nvar fromScaling$22;\nvar fromTranslation$32;\nvar str$72;\nvar frob$22;\nvar add$72;\nvar subtract$52;\nvar multiplyScalar$22;\nvar multiplyScalarAndAdd$22;\nvar exactEquals$72;\nvar equals$72;\nvar create$62;\nvar fromMat4$12;\nvar clone$62;\nvar copy$62;\nvar fromValues$62;\nvar set$62;\nvar identity$32;\nvar transpose$12;\nvar invert$32;\nvar adjoint$12;\nvar determinant$12;\nvar multiply$62;\nvar translate$22;\nvar rotate$22;\nvar scale$62;\nvar fromTranslation$22;\nvar fromRotation$22;\nvar fromScaling$12;\nvar fromMat2d2;\nvar fromQuat$12;\nvar normalFromMat42;\nvar projection2;\nvar str$62;\nvar frob$12;\nvar add$62;\nvar subtract$42;\nvar multiplyScalar$12;\nvar multiplyScalarAndAdd$12;\nvar exactEquals$62;\nvar equals$62;\nvar create$52;\nvar clone$52;\nvar copy$52;\nvar fromValues$52;\nvar set$52;\nvar identity$22;\nvar transpose2;\nvar invert$22;\nvar adjoint2;\nvar determinant2;\nvar multiply$52;\nvar translate$12;\nvar scale$52;\nvar rotate$12;\nvar rotateX$32;\nvar rotateY$32;\nvar rotateZ$32;\nvar fromTranslation$12;\nvar fromScaling2;\nvar fromRotation$12;\nvar fromXRotation2;\nvar fromYRotation2;\nvar fromZRotation2;\nvar fromRotationTranslation$12;\nvar fromQuat22;\nvar getTranslation$12;\nvar getScaling2;\nvar getRotation2;\nvar decompose2;\nvar fromRotationTranslationScale2;\nvar fromRotationTranslationScaleOrigin2;\nvar fromQuat3;\nvar frustum2;\nvar perspectiveNO2;\nvar perspectiveZO2;\nvar perspectiveFromFieldOfView2;\nvar orthoNO2;\nvar orthoZO2;\nvar lookAt2;\nvar targetTo2;\nvar str$52;\nvar frob2;\nvar add$52;\nvar subtract$32;\nvar multiplyScalar2;\nvar multiplyScalarAndAdd2;\nvar exactEquals$52;\nvar equals$52;\nvar create$42;\nvar clone$42;\nvar length$42;\nvar fromValues$42;\nvar copy$42;\nvar set$42;\nvar add$42;\nvar subtract$22;\nvar multiply$42;\nvar divide$22;\nvar ceil$22;\nvar floor$22;\nvar min$22;\nvar max$22;\nvar round$22;\nvar scale$42;\nvar scaleAndAdd$22;\nvar distance$22;\nvar squaredDistance$22;\nvar squaredLength$42;\nvar negate$22;\nvar inverse$22;\nvar normalize$42;\nvar dot$42;\nvar cross$22;\nvar lerp$42;\nvar slerp$12;\nvar hermite2;\nvar bezier2;\nvar random$32;\nvar transformMat4$22;\nvar transformMat3$12;\nvar transformQuat$12;\nvar rotateX$22;\nvar rotateY$22;\nvar rotateZ$22;\nvar angle$12;\nvar zero$22;\nvar str$42;\nvar exactEquals$42;\nvar equals$42;\nvar create$32;\nvar clone$32;\nvar fromValues$32;\nvar copy$32;\nvar set$32;\nvar add$32;\nvar subtract$12;\nvar multiply$32;\nvar divide$12;\nvar ceil$12;\nvar floor$12;\nvar min$12;\nvar max$12;\nvar round$12;\nvar scale$32;\nvar scaleAndAdd$12;\nvar distance$12;\nvar squaredDistance$12;\nvar length$32;\nvar squaredLength$32;\nvar negate$12;\nvar inverse$12;\nvar normalize$32;\nvar dot$32;\nvar cross$12;\nvar lerp$32;\nvar random$22;\nvar transformMat4$12;\nvar transformQuat2;\nvar zero$12;\nvar str$32;\nvar exactEquals$32;\nvar equals$32;\nvar create$22;\nvar identity$12;\nvar setAxisAngle2;\nvar getAxisAngle2;\nvar getAngle2;\nvar multiply$22;\nvar rotateX$12;\nvar rotateY$12;\nvar rotateZ$12;\nvar calculateW2;\nvar exp2;\nvar ln2;\nvar pow2;\nvar slerp2;\nvar random$12;\nvar invert$12;\nvar conjugate$12;\nvar fromMat32;\nvar fromEuler2;\nvar str$22;\nvar equals$22;\nvar create$12;\nvar clone$12;\nvar fromValues$12;\nvar fromRotationTranslationValues2;\nvar fromRotationTranslation2;\nvar fromTranslation2;\nvar fromRotation2;\nvar fromMat42;\nvar copy$12;\nvar identity2;\nvar set$12;\nvar getDual2;\nvar setDual2;\nvar getTranslation2;\nvar translate2;\nvar rotateX2;\nvar rotateY2;\nvar rotateZ2;\nvar rotateByQuatAppend2;\nvar rotateByQuatPrepend2;\nvar rotateAroundAxis2;\nvar add$12;\nvar multiply$12;\nvar scale$12;\nvar lerp$12;\nvar invert2;\nvar conjugate2;\nvar normalize$12;\nvar str$12;\nvar exactEquals$12;\nvar equals$12;\nvar create2;\nvar clone2;\nvar fromValues2;\nvar copy2;\nvar set2;\nvar add2;\nvar subtract2;\nvar multiply2;\nvar divide2;\nvar ceil2;\nvar floor2;\nvar min2;\nvar max2;\nvar round2;\nvar scale2;\nvar scaleAndAdd2;\nvar distance2;\nvar squaredDistance2;\nvar length2;\nvar squaredLength2;\nvar negate2;\nvar inverse2;\nvar normalize2;\nvar dot2;\nvar cross2;\nvar lerp2;\nvar random2;\nvar transformMat22;\nvar transformMat2d2;\nvar transformMat32;\nvar transformMat42;\nvar rotate2;\nvar angle2;\nvar zero2;\nvar str2;\nvar exactEquals2;\nvar equals2;\n{\n  let lineInt = function(o, n, t) {\n    t = t || 0;\n    var e, l, p, g, r, i, y, u = [0, 0];\n    return e = o[1][1] - o[0][1], l = o[0][0] - o[1][0], p = e * o[0][0] + l * o[0][1], g = n[1][1] - n[0][1], r = n[0][0] - n[1][0], i = g * n[0][0] + r * n[0][1], scalar_eq(y = e * r - g * l, 0, t) || (u[0] = (r * p - l * i) / y, u[1] = (e * i - g * p) / y), u;\n  }, lineSegmentsIntersect = function(o, n, t, e) {\n    var l = n[0] - o[0], p = n[1] - o[1], g = e[0] - t[0], r = e[1] - t[1];\n    if (g * p - r * l == 0) return false;\n    var i = (l * (t[1] - o[1]) + p * (o[0] - t[0])) / (g * p - r * l), y = (g * (o[1] - t[1]) + r * (t[0] - o[0])) / (r * l - g * p);\n    return i >= 0 && i <= 1 && y >= 0 && y <= 1;\n  }, triangleArea = function(o, n, t) {\n    return (n[0] - o[0]) * (t[1] - o[1]) - (t[0] - o[0]) * (n[1] - o[1]);\n  }, isLeft = function(o, n, t) {\n    return triangleArea(o, n, t) > 0;\n  }, isLeftOn = function(o, n, t) {\n    return triangleArea(o, n, t) >= 0;\n  }, isRight = function(o, n, t) {\n    return triangleArea(o, n, t) < 0;\n  }, isRightOn = function(o, n, t) {\n    return triangleArea(o, n, t) <= 0;\n  }, collinear = function(o, n, t, e) {\n    if (e) {\n      var l = tmpPoint1, p = tmpPoint2;\n      l[0] = n[0] - o[0], l[1] = n[1] - o[1], p[0] = t[0] - n[0], p[1] = t[1] - n[1];\n      var g = l[0] * p[0] + l[1] * p[1], r = Math.sqrt(l[0] * l[0] + l[1] * l[1]), i = Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n      return Math.acos(g / (r * i)) < e;\n    }\n    return 0 === triangleArea(o, n, t);\n  }, sqdist = function(o, n) {\n    var t = n[0] - o[0], e = n[1] - o[1];\n    return t * t + e * e;\n  }, polygonAt = function(o, n) {\n    var t = o.length;\n    return o[n < 0 ? n % t + t : n % t];\n  }, polygonClear = function(o) {\n    o.length = 0;\n  }, polygonAppend = function(o, n, t, e) {\n    for (var l = t; l < e; l++) o.push(n[l]);\n  }, polygonMakeCCW = function(o) {\n    for (var n = 0, t = o, e = 1; e < o.length; ++e) (t[e][1] < t[n][1] || t[e][1] === t[n][1] && t[e][0] > t[n][0]) && (n = e);\n    return !isLeft(polygonAt(o, n - 1), polygonAt(o, n), polygonAt(o, n + 1)) && (polygonReverse(o), true);\n  }, polygonReverse = function(o) {\n    for (var n = [], t = o.length, e = 0; e !== t; e++) n.push(o.pop());\n    for (e = 0; e !== t; e++) o[e] = n[e];\n  }, polygonIsReflex = function(o, n) {\n    return isRight(polygonAt(o, n - 1), polygonAt(o, n), polygonAt(o, n + 1));\n  }, polygonCanSee = function(o, n, t) {\n    var e, l, p = tmpLine1, g = tmpLine2;\n    if (isLeftOn(polygonAt(o, n + 1), polygonAt(o, n), polygonAt(o, t)) && isRightOn(polygonAt(o, n - 1), polygonAt(o, n), polygonAt(o, t))) return false;\n    l = sqdist(polygonAt(o, n), polygonAt(o, t));\n    for (var r = 0; r !== o.length; ++r) if ((r + 1) % o.length !== n && r !== n && isLeftOn(polygonAt(o, n), polygonAt(o, t), polygonAt(o, r + 1)) && isRightOn(polygonAt(o, n), polygonAt(o, t), polygonAt(o, r)) && (p[0] = polygonAt(o, n), p[1] = polygonAt(o, t), g[0] = polygonAt(o, r), g[1] = polygonAt(o, r + 1), e = lineInt(p, g), sqdist(polygonAt(o, n), e) < l)) return false;\n    return true;\n  }, polygonCanSee2 = function(o, n, t) {\n    for (var e = 0; e !== o.length; ++e) if (e !== n && e !== t && (e + 1) % o.length !== n && (e + 1) % o.length !== t && lineSegmentsIntersect(polygonAt(o, n), polygonAt(o, t), polygonAt(o, e), polygonAt(o, e + 1))) return false;\n    return true;\n  }, polygonCopy = function(o, n, t, e) {\n    var l = e || [];\n    if (polygonClear(l), n < t) for (var p = n; p <= t; p++) l.push(o[p]);\n    else {\n      for (p = 0; p <= t; p++) l.push(o[p]);\n      for (p = n; p < o.length; p++) l.push(o[p]);\n    }\n    return l;\n  }, polygonGetCutEdges = function(o) {\n    for (var n = [], t = [], e = [], l = [], p = Number.MAX_VALUE, g = 0; g < o.length; ++g) if (polygonIsReflex(o, g)) {\n      for (var r = 0; r < o.length; ++r) if (polygonCanSee(o, g, r)) {\n        t = polygonGetCutEdges(polygonCopy(o, g, r, l)), e = polygonGetCutEdges(polygonCopy(o, r, g, l));\n        for (var i = 0; i < e.length; i++) t.push(e[i]);\n        t.length < p && (n = t, p = t.length, n.push([polygonAt(o, g), polygonAt(o, r)]));\n      }\n    }\n    return n;\n  }, polygonDecomp = function(o) {\n    var n = polygonGetCutEdges(o);\n    return n.length > 0 ? polygonSlice(o, n) : [o];\n  }, polygonSlice = function(o, n) {\n    if (0 === n.length) return [o];\n    if (n instanceof Array && n.length && n[0] instanceof Array && 2 === n[0].length && n[0][0] instanceof Array) {\n      for (var t = [o], e = 0; e < n.length; e++) for (var l = n[e], p = 0; p < t.length; p++) {\n        var g = polygonSlice(t[p], l);\n        if (g) {\n          t.splice(p, 1), t.push(g[0], g[1]);\n          break;\n        }\n      }\n      return t;\n    }\n    l = n, e = o.indexOf(l[0]), p = o.indexOf(l[1]);\n    return -1 !== e && -1 !== p && [polygonCopy(o, e, p), polygonCopy(o, p, e)];\n  }, polygonIsSimple = function(o) {\n    var n, t = o;\n    for (n = 0; n < t.length - 1; n++) for (var e = 0; e < n - 1; e++) if (lineSegmentsIntersect(t[n], t[n + 1], t[e], t[e + 1])) return false;\n    for (n = 1; n < t.length - 2; n++) if (lineSegmentsIntersect(t[0], t[t.length - 1], t[n], t[n + 1])) return false;\n    return true;\n  }, getIntersectionPoint = function(o, n, t, e, l) {\n    l = l || 0;\n    var p = n[1] - o[1], g = o[0] - n[0], r = p * o[0] + g * o[1], i = e[1] - t[1], y = t[0] - e[0], u = i * t[0] + y * t[1], s = p * y - i * g;\n    return scalar_eq(s, 0, l) ? [0, 0] : [(y * r - g * u) / s, (p * u - i * r) / s];\n  }, polygonQuickDecomp = function(o, n, t, e, l, p, g) {\n    p = p || 100, g = g || 0, l = l || 25, n = void 0 !== n ? n : [], t = t || [], e = e || [];\n    var r = [0, 0], i = [0, 0], y = [0, 0], u = 0, s = 0, A = 0, a = 0, f = 0, c = 0, h = 0, v = [], m = [], d = o, C = o;\n    if (C.length < 3) return n;\n    if (++g > p) return console.warn(\"quickDecomp: max level (\" + p + \") reached.\"), n;\n    for (var R = 0; R < o.length; ++R) if (polygonIsReflex(d, R)) {\n      t.push(d[R]), u = s = Number.MAX_VALUE;\n      for (var q = 0; q < o.length; ++q) isLeft(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q)) && isRightOn(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q - 1)) && (y = getIntersectionPoint(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q), polygonAt(d, q - 1)), isRight(polygonAt(d, R + 1), polygonAt(d, R), y) && (A = sqdist(d[R], y)) < s && (s = A, i = y, c = q)), isLeft(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q + 1)) && isRightOn(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q)) && (y = getIntersectionPoint(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q), polygonAt(d, q + 1)), isLeft(polygonAt(d, R - 1), polygonAt(d, R), y) && (A = sqdist(d[R], y)) < u && (u = A, r = y, f = q));\n      if (c === (f + 1) % o.length) y[0] = (i[0] + r[0]) / 2, y[1] = (i[1] + r[1]) / 2, e.push(y), R < f ? (polygonAppend(v, d, R, f + 1), v.push(y), m.push(y), 0 !== c && polygonAppend(m, d, c, d.length), polygonAppend(m, d, 0, R + 1)) : (0 !== R && polygonAppend(v, d, R, d.length), polygonAppend(v, d, 0, f + 1), v.push(y), m.push(y), polygonAppend(m, d, c, R + 1));\n      else {\n        if (c > f && (f += o.length), a = Number.MAX_VALUE, f < c) return n;\n        for (q = c; q <= f; ++q) isLeftOn(polygonAt(d, R - 1), polygonAt(d, R), polygonAt(d, q)) && isRightOn(polygonAt(d, R + 1), polygonAt(d, R), polygonAt(d, q)) && (A = sqdist(polygonAt(d, R), polygonAt(d, q))) < a && polygonCanSee2(d, R, q) && (a = A, h = q % o.length);\n        R < h ? (polygonAppend(v, d, R, h + 1), 0 !== h && polygonAppend(m, d, h, C.length), polygonAppend(m, d, 0, R + 1)) : (0 !== R && polygonAppend(v, d, R, C.length), polygonAppend(v, d, 0, h + 1), polygonAppend(m, d, h, R + 1));\n      }\n      return v.length < m.length ? (polygonQuickDecomp(v, n, t, e, l, p, g), polygonQuickDecomp(m, n, t, e, l, p, g)) : (polygonQuickDecomp(m, n, t, e, l, p, g), polygonQuickDecomp(v, n, t, e, l, p, g)), n;\n    }\n    return n.push(o), n;\n  }, polygonRemoveCollinearPoints = function(o, n) {\n    for (var t = 0, e = o.length - 1; o.length > 3 && e >= 0; --e) collinear(polygonAt(o, e - 1), polygonAt(o, e), polygonAt(o, e + 1), n) && (o.splice(e % o.length, 1), t++);\n    return t;\n  }, polygonRemoveDuplicatePoints = function(o, n) {\n    for (var t = o.length - 1; t >= 1; --t) for (var e = o[t], l = t - 1; l >= 0; --l) points_eq(e, o[l], n) && o.splice(t, 1);\n  }, scalar_eq = function(o, n, t) {\n    return t = t || 0, Math.abs(o - n) <= t;\n  }, points_eq = function(o, n, t) {\n    return scalar_eq(o[0], n[0], t) && scalar_eq(o[1], n[1], t);\n  };\n  lineInt2 = lineInt, lineSegmentsIntersect2 = lineSegmentsIntersect, triangleArea2 = triangleArea, isLeft2 = isLeft, isLeftOn2 = isLeftOn, isRight2 = isRight, isRightOn2 = isRightOn, collinear2 = collinear, sqdist2 = sqdist, polygonAt2 = polygonAt, polygonClear2 = polygonClear, polygonAppend2 = polygonAppend, polygonMakeCCW2 = polygonMakeCCW, polygonReverse2 = polygonReverse, polygonIsReflex2 = polygonIsReflex, polygonCanSee3 = polygonCanSee, polygonCanSee22 = polygonCanSee2, polygonCopy2 = polygonCopy, polygonGetCutEdges2 = polygonGetCutEdges, polygonDecomp2 = polygonDecomp, polygonSlice2 = polygonSlice, polygonIsSimple2 = polygonIsSimple, getIntersectionPoint2 = getIntersectionPoint, polygonQuickDecomp2 = polygonQuickDecomp, polygonRemoveCollinearPoints2 = polygonRemoveCollinearPoints, polygonRemoveDuplicatePoints2 = polygonRemoveDuplicatePoints, scalar_eq2 = scalar_eq, points_eq2 = points_eq;\n  tmpPoint1 = [], tmpPoint2 = [];\n  tmpLine1 = [], tmpLine2 = [];\n  self.polyDecomp = { decomp: polygonDecomp, quickDecomp: polygonQuickDecomp, isSimple: polygonIsSimple, removeCollinearPoints: polygonRemoveCollinearPoints, removeDuplicatePoints: polygonRemoveDuplicatePoints, makeCCW: polygonMakeCCW };\n}\nvar tmpPoint1;\nvar tmpPoint2;\nvar tmpLine1;\nvar tmpLine2;\nvar lineInt2;\nvar lineSegmentsIntersect2;\nvar triangleArea2;\nvar isLeft2;\nvar isLeftOn2;\nvar isRight2;\nvar isRightOn2;\nvar collinear2;\nvar sqdist2;\nvar polygonAt2;\nvar polygonClear2;\nvar polygonAppend2;\nvar polygonMakeCCW2;\nvar polygonReverse2;\nvar polygonIsReflex2;\nvar polygonCanSee3;\nvar polygonCanSee22;\nvar polygonCopy2;\nvar polygonGetCutEdges2;\nvar polygonDecomp2;\nvar polygonSlice2;\nvar polygonIsSimple2;\nvar getIntersectionPoint2;\nvar polygonQuickDecomp2;\nvar polygonRemoveCollinearPoints2;\nvar polygonRemoveDuplicatePoints2;\nvar scalar_eq2;\nvar points_eq2;\n{\n  let isReady = false, hasAppStarted = false, buildMode = \"dev\";\n  const internalApiToken = Symbol(\"Construct internal API token\");\n  let internalApiTokenAccessesRemaining = 16;\n  const C33 = self.C3 = class {\n    constructor() {\n      throw TypeError(\"static class can't be instantiated\");\n    }\n    static _GetInternalAPIToken() {\n      if (internalApiTokenAccessesRemaining <= 0) throw new Error(\"cannot obtain internal API token\");\n      return --internalApiTokenAccessesRemaining, internalApiToken;\n    }\n    static SetReady() {\n      isReady = true;\n    }\n    static IsReady() {\n      return isReady;\n    }\n    static SetAppStarted() {\n      hasAppStarted = true;\n    }\n    static HasAppStarted() {\n      return hasAppStarted;\n    }\n    static SetBuildMode(e) {\n      buildMode = e;\n    }\n    static GetBuildMode() {\n      return buildMode;\n    }\n    static IsReleaseBuild() {\n      return \"final\" === buildMode;\n    }\n  };\n  C33.isDebug = false, C33.isDebugDefend = false, C33.hardwareConcurrency = navigator.hardwareConcurrency || 2, self.C3X = {};\n}\n{\n  const C33 = self.C3;\n  C33.QueryParser = class {\n    constructor(e) {\n      this._queryString = e, this._parameters = /* @__PURE__ */ new Map(), this._Parse();\n    }\n    _Parse() {\n      let e = this._queryString;\n      (e.startsWith(\"?\") || e.startsWith(\"#\")) && (e = e.substr(1));\n      const r = e.split(\"&\");\n      for (const e2 of r) this._ParseParameter(e2);\n    }\n    _ParseParameter(e) {\n      if (!e) return;\n      if (!e.includes(\"=\")) return void this._parameters.set(e, null);\n      const r = e.indexOf(\"=\"), t = decodeURIComponent(e.substring(0, r)), s = decodeURIComponent(e.substring(r + 1));\n      this._parameters.set(t, s);\n    }\n    LogAll() {\n      for (const e of this._parameters) console.log(\"[QueryParser] Parameter '\" + e[0] + \"' = \" + (null === e[1] ? \"null\" : \"'\" + e[1] + \"'\"));\n    }\n    Has(e) {\n      return this._parameters.has(e);\n    }\n    Get(e) {\n      const r = this._parameters.get(e);\n      return void 0 === r ? null : r;\n    }\n    ClearHash() {\n      history.replaceState(\"\", document.title, location.pathname + location.search);\n    }\n    Reparse(e) {\n      this._queryString = e, this._parameters.clear(), this._Parse();\n    }\n  }, C33.QueryString = new C33.QueryParser(location.search), C33.LocationHashString = new C33.QueryParser(location.hash), C33.QueryString.Has(\"perf\") && (C33.isPerformanceProfiling = true), \"dev\" !== C33.QueryString.Get(\"mode\") && C33.SetBuildMode(\"final\");\n}\n{\n  let GetWindowsNTVersionName = function(r) {\n    const o = parseFloat(r), e = windowsNTVerMap.get(o);\n    return e || (o >= 13 ? \"11\" : \"NT \" + r);\n  };\n  GetWindowsNTVersionName2 = GetWindowsNTVersionName;\n  const C33 = self.C3, UNKNOWN = \"(unknown)\";\n  C33.Platform = { OS: UNKNOWN, OSVersion: UNKNOWN, Browser: UNKNOWN, BrowserVersion: UNKNOWN, BrowserVersionNumber: NaN, BrowserEngine: UNKNOWN, Context: \"browser\", IsDesktop: true, IsMobile: false, IsAppleOS: false, IsIpadOS: false, GetDetailedInfo: async () => {\n  } };\n  const windowsNTVerMap = /* @__PURE__ */ new Map([[5, \"2000\"], [5.1, \"XP\"], [5.2, \"XP\"], [6, \"Vista\"], [6.1, \"7\"], [6.2, \"8\"], [6.3, \"8.1\"], [10, \"10\"]]);\n  const uaStr = navigator.userAgent, uaData = navigator[\"userAgentData\"];\n  if (uaData && uaData[\"brands\"].length > 0) {\n    let ReadBrandList = function(e2) {\n      let t = \"\", a = \"\", s = \"\", n = \"\";\n      for (const i of e2) {\n        const e3 = r.get(i[\"brand\"]);\n        !t && e3 && (t = e3, a = i[\"version\"]);\n        const m = o.get(i[\"brand\"]);\n        !s && m && (s = m, n = i[\"version\"]);\n      }\n      t || \"Chromium\" !== s || (C33.Platform.Browser = \"Chromium\", C33.Platform.BrowserVersion = n), C33.Platform.Browser = t || UNKNOWN, C33.Platform.BrowserVersion = a || UNKNOWN, C33.Platform.BrowserEngine = s || UNKNOWN;\n    };\n    ReadBrandList2 = ReadBrandList;\n    C33.Platform.OS = uaData[\"platform\"], C33.Platform.IsMobile = uaData[\"mobile\"], C33.Platform.IsDesktop = !C33.Platform.IsMobile;\n    const r = /* @__PURE__ */ new Map([[\"Google Chrome\", \"Chrome\"], [\"Microsoft Edge\", \"Edge\"], [\"Opera\", \"Opera\"], [\"Opera GX\", \"Opera GX\"], [\"Mozilla Firefox\", \"Firefox\"], [\"Apple Safari\", \"Safari\"], [\"NW.js\", \"NW.js\"]]), o = /* @__PURE__ */ new Map([[\"Chromium\", \"Chromium\"], [\"Gecko\", \"Gecko\"], [\"WebKit\", \"WebKit\"]]);\n    ReadBrandList(uaData[\"brands\"]);\n    let e = false;\n    C33.Platform.GetDetailedInfo = async () => {\n      if (!e) try {\n        const r2 = await navigator[\"userAgentData\"][\"getHighEntropyValues\"]([\"platformVersion\", \"fullVersionList\"]);\n        ReadBrandList(r2[\"fullVersionList\"]), \"Windows\" === C33.Platform.OS ? C33.Platform.OSVersion = GetWindowsNTVersionName(r2[\"platformVersion\"]) : C33.Platform.OSVersion = r2[\"platformVersion\"], e = true;\n      } catch (r2) {\n        console.warn(\"Failed to get detailed user agent information: \", r2);\n      }\n    };\n  } else {\n    let RunTest = function(r, o) {\n      const e = Array.isArray(r) ? r : [r];\n      for (const r2 of e) {\n        const e2 = r2.exec(uaStr);\n        if (e2) {\n          o(e2);\n          break;\n        }\n      }\n    };\n    RunTest2 = RunTest;\n    RunTest(/windows\\s+nt\\s+([\\d\\.]+)/i, (r) => {\n      C33.Platform.OS = \"Windows\";\n      const o = r[1];\n      C33.Platform.OSVersion = GetWindowsNTVersionName(o);\n    }), RunTest(/mac\\s+os\\s+x\\s+([\\d\\._]+)/i, (r) => {\n      C33.Platform.OS = \"macOS\", C33.Platform.OSVersion = r[1].replace(/_/g, \".\");\n    }), RunTest(/CrOS/, () => {\n      C33.Platform.OS = \"Chrome OS\";\n    }), RunTest(/linux|openbsd|freebsd|netbsd/i, () => {\n      C33.Platform.OS = \"Linux\";\n    }), RunTest(/android/i, () => {\n      C33.Platform.OS = \"Android\";\n    }), RunTest(/android\\s+([\\d\\.]+)/i, (r) => {\n      C33.Platform.OS = \"Android\", C33.Platform.OSVersion = r[1];\n    }), C33.Platform.OS === UNKNOWN && (RunTest(/(iphone|ipod|ipad)/i, (r) => {\n      C33.Platform.OS = \"iOS\";\n    }), RunTest([/iphone\\s+os\\s+([\\d\\._]+)/i, /ipad[^)]*os\\s+([\\d\\._]+)/i], (r) => {\n      C33.Platform.OS = \"iOS\", C33.Platform.OSVersion = r[1].replace(/_/g, \".\");\n    }));\n    const t = /chrome\\//i.test(uaStr), a = /chromium\\//i.test(uaStr), s = /edg\\//i.test(uaStr), n = /OPR\\//.test(uaStr), i = /nwjs/i.test(uaStr), m = /safari\\//i.test(uaStr), l = /webkit/i.test(uaStr);\n    s || n || RunTest(/chrome\\/([\\d\\.]+)/i, (r) => {\n      C33.Platform.Browser = \"Chrome\", C33.Platform.BrowserVersion = r[1], C33.Platform.BrowserEngine = \"Chromium\";\n    }), RunTest(/edg\\/([\\d\\.]+)/i, (r) => {\n      C33.Platform.Browser = \"Edge\", C33.Platform.BrowserVersion = r[1], C33.Platform.BrowserEngine = \"Chromium\";\n    }), RunTest(/OPR\\/([\\d\\.]+)/, (r) => {\n      C33.Platform.Browser = \"Opera\", C33.Platform.BrowserVersion = r[1], C33.Platform.BrowserEngine = \"Chromium\";\n    }), RunTest(/chromium\\/([\\d\\.]+)/i, (r) => {\n      C33.Platform.Browser = \"Chromium\", C33.Platform.BrowserVersion = r[1], C33.Platform.BrowserEngine = \"Chromium\";\n    }), RunTest(/nwjs\\/[0-9.]+/i, (r) => {\n      C33.Platform.Browser = \"NW.js\", C33.Platform.BrowserVersion = r[1], C33.Platform.BrowserEngine = \"Chromium\", C33.Platform.Context = \"nwjs\";\n    }), RunTest(/firefox\\/([\\d\\.]+)/i, (r) => {\n      C33.Platform.Browser = \"Firefox\", C33.Platform.BrowserVersion = r[1], C33.Platform.BrowserEngine = \"Gecko\";\n    }), !m || t || a || s || n || i || (C33.Platform.Browser = \"Safari\", C33.Platform.BrowserEngine = \"WebKit\", RunTest(/version\\/([\\d\\.]+)/i, (r) => {\n      C33.Platform.BrowserVersion = r[1];\n    }), RunTest(/crios\\/([\\d\\.]+)/i, (r) => {\n      C33.Platform.Browser = \"Chrome for iOS\", C33.Platform.BrowserVersion = r[1];\n    }), RunTest(/fxios\\/([\\d\\.]+)/i, (r) => {\n      C33.Platform.Browser = \"Firefox for iOS\", C33.Platform.BrowserVersion = r[1];\n    }), RunTest(/edgios\\/([\\d\\.]+)/i, (r) => {\n      C33.Platform.Browser = \"Edge for iOS\", C33.Platform.BrowserVersion = r[1];\n    })), C33.Platform.BrowserEngine === UNKNOWN && l && (C33.Platform.BrowserEngine = \"WebKit\"), \"Android\" === C33.Platform.OS && \"Safari\" === C33.Platform.Browser && (C33.Platform.Browser = \"Stock\");\n    const f = (/* @__PURE__ */ new Set([\"Windows\", \"macOS\", \"Linux\", \"Chrome OS\"])).has(C33.Platform.OS) || \"nwjs\" === C33.Platform.Context;\n    C33.Platform.IsDesktop = f, C33.Platform.IsMobile = !f;\n  }\n  \"Chrome\" === C33.Platform.Browser && \"browser\" === C33.Platform.Context && /wv\\)/.test(uaStr) && (C33.Platform.Context = \"webview\"), \"nwjs\" !== C33.Platform.Context && \"undefined\" != typeof window && (window.matchMedia && window.matchMedia(\"(display-mode: standalone)\").matches || navigator[\"standalone\"]) && (C33.Platform.Context = \"webapp\"), C33.Platform.BrowserVersionNumber = parseFloat(C33.Platform.BrowserVersion);\n  const looksLikeIPadOS = \"macOS\" === C33.Platform.OS && navigator[\"maxTouchPoints\"] && navigator[\"maxTouchPoints\"] > 2;\n  looksLikeIPadOS && (C33.Platform.OS = \"iOS\", C33.Platform.OSVersion = C33.Platform.BrowserVersion, C33.Platform.IsDesktop = false, C33.Platform.IsMobile = true, C33.Platform.IsIpadOS = true), C33.Platform.IsAppleOS = \"macOS\" === C33.Platform.OS || \"iOS\" === C33.Platform.OS;\n}\nvar ReadBrandList2;\nvar RunTest2;\nvar GetWindowsNTVersionName2;\n{\n  \"use strict\";\n  {\n    let s = function(e2) {\n      return new Promise((t2, r2) => {\n        e2.onsuccess = () => t2(e2.result), e2.onerror = () => r2(e2.error);\n      });\n    }, a = function(e2) {\n      return new Promise((t2, r2) => {\n        e2.oncomplete = () => t2(), e2.onerror = () => r2(e2.error), e2.onabort = () => r2(e2.error);\n      });\n    }, c = function(e2, t2) {\n      return u(e2, t2);\n    }, i = function(e2, t2) {\n      return u(e2, t2, true);\n    }, l = function(e2) {\n      f(e2);\n      let t2 = r.get(e2);\n      return t2 instanceof Promise || (t2 = y(e2), r.set(e2, t2), t2.catch((t3) => r.delete(e2))), t2;\n    }, f = function(e2) {\n      if (\"string\" != typeof e2) throw new TypeError(\"expected string\");\n    }, d = function(e2, r2) {\n      const n2 = e2.objectStore(t).openCursor();\n      return new Promise((e3) => {\n        const t2 = [];\n        n2.onsuccess = (n3) => {\n          const o2 = n3.target.result;\n          if (o2) {\n            switch (r2) {\n              case \"entries\":\n                t2.push([o2.key, o2.value]);\n                break;\n              case \"keys\":\n                t2.push(o2.key);\n                break;\n              case \"values\":\n                t2.push(o2.value);\n            }\n            o2.continue();\n          } else e3(t2);\n        };\n      });\n    };\n    s2 = s, a2 = a, c2 = c, i2 = i, l2 = l, f2 = f, d2 = d;\n    const e = 2, t = \"keyvaluepairs\", r = /* @__PURE__ */ new Map(), n = \"undefined\" != typeof IDBObjectStore && \"function\" == typeof IDBObjectStore.prototype.getAll, o = \"undefined\" != typeof IDBObjectStore && \"function\" == typeof IDBObjectStore.prototype.getAllKeys;\n    async function u(e2, n2, o2 = false, s3 = true) {\n      const a3 = await l(e2);\n      try {\n        return n2(a3.transaction([t], o2 ? \"readwrite\" : \"readonly\"));\n      } catch (t2) {\n        if (s3 && \"InvalidStateError\" === t2[\"name\"]) return r.delete(e2), u(e2, n2, o2, false);\n        throw t2;\n      }\n    }\n    async function y(r2) {\n      f(r2);\n      const n2 = indexedDB.open(r2, e);\n      return n2.addEventListener(\"upgradeneeded\", (e2) => {\n        try {\n          e2.target.result.createObjectStore(t);\n        } catch (e3) {\n          console.error(`Failed to create objectstore for database ${r2}`, e3);\n        }\n      }), s(n2);\n    }\n    class m {\n      constructor(e2) {\n        f(e2), this.name = e2;\n      }\n      async ready() {\n        await l(this.name);\n      }\n      set(e2, r2) {\n        return f(e2), i(this.name, async (n2) => {\n          const o2 = s(n2.objectStore(t).put(r2, e2)), c3 = a(n2);\n          await Promise.all([c3, o2]);\n        });\n      }\n      get(e2) {\n        return f(e2), c(this.name, async (r2) => {\n          const n2 = s(r2.objectStore(t).get(e2)), o2 = a(r2), [c3, i3] = await Promise.all([o2, n2]);\n          return i3;\n        });\n      }\n      delete(e2) {\n        return f(e2), i(this.name, async (r2) => {\n          const n2 = s(r2.objectStore(t).delete(e2)), o2 = a(r2);\n          await Promise.all([o2, n2]);\n        });\n      }\n      clear() {\n        return i(this.name, async (e2) => {\n          const r2 = s(e2.objectStore(t).clear()), n2 = a(e2);\n          await Promise.all([n2, r2]);\n        });\n      }\n      keys() {\n        return c(this.name, async (e2) => {\n          let r2;\n          if (o) {\n            r2 = s(e2.objectStore(t).getAllKeys());\n          } else r2 = d(e2, \"keys\");\n          const n2 = a(e2), [c3, i3] = await Promise.all([n2, r2]);\n          return i3;\n        });\n      }\n      values() {\n        return c(this.name, async (e2) => {\n          let r2;\n          if (n) {\n            r2 = s(e2.objectStore(t).getAll());\n          } else r2 = d(e2, \"values\");\n          const o2 = a(e2), [c3, i3] = await Promise.all([o2, r2]);\n          return i3;\n        });\n      }\n      entries() {\n        return c(this.name, async (e2) => {\n          const t2 = d(e2, \"entries\"), r2 = a(e2), [n2, o2] = await Promise.all([r2, t2]);\n          return o2;\n        });\n      }\n    }\n    self.KVStorageContainer = m;\n  }\n}\nvar s2;\nvar a2;\nvar c2;\nvar i2;\nvar l2;\nvar f2;\nvar d2;\n{\n  \"use strict\";\n  {\n    let r = function(e2) {\n      throw new Error(`\"${e2}\" is not implemented`);\n    }, a = function(e2) {\n      if (\"function\" == typeof e2) throw new Error(\"localforage callback API is not implemented; please use the promise API instead\");\n    }, o = function(e2) {\n      return \"object\" == typeof e2 ? new Promise((t2) => {\n        const { port1: r3, port2: a2 } = new MessageChannel();\n        a2.onmessage = (e3) => t2(e3.data), r3.postMessage(e2);\n      }) : Promise.resolve(e2);\n    };\n    r2 = r, a2 = a, o2 = o;\n    const e = self.KVStorageContainer, t = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\\.open\\(\\) called in an invalid security context/i];\n    /* @__PURE__ */ new WeakMap();\n    class s {\n      constructor(e2) {\n        this._inst = e2, this._isInMemory = !this._inst, this._isInMemory || \"undefined\" != typeof indexedDB || (this._isInMemory = true, console.warn(\"Unable to use local storage because IndexedDB API is not available\")), this._memoryStorage = /* @__PURE__ */ new Map();\n      }\n      _MaybeSwitchToMemoryFallback(e2) {\n        if (!this._isInMemory) {\n          for (const r3 of t) if (e2 && r3.test(e2.message)) {\n            console.error(\"Unable to use local storage, reverting to in-memory store: \", e2, e2.message), this._isInMemory = true;\n            break;\n          }\n        }\n      }\n      async _getItemFallback(e2) {\n        const t2 = this._memoryStorage.get(e2), r3 = await o(t2);\n        return void 0 === r3 ? null : r3;\n      }\n      async _setItemFallback(e2, t2) {\n        t2 = await o(t2), this._memoryStorage.set(e2, t2);\n      }\n      _removeItemFallback(e2) {\n        this._memoryStorage.delete(e2);\n      }\n      _clearFallback() {\n        this._memoryStorage.clear();\n      }\n      _keysFallback() {\n        return Array.from(this._memoryStorage.keys());\n      }\n      IsInMemory() {\n        return this._isInMemory;\n      }\n      GetMemoryStorage() {\n        return this._memoryStorage;\n      }\n      SetMemoryStorage(e2) {\n        this._memoryStorage = e2;\n      }\n      async getItem(e2, t2) {\n        if (a(t2), this._isInMemory) return await this._getItemFallback(e2);\n        let r3;\n        try {\n          r3 = await this._inst.get(e2);\n        } catch (t3) {\n          return this._MaybeSwitchToMemoryFallback(t3), this._isInMemory ? await this._getItemFallback(e2) : (console.error(`Error reading '${e2}' from storage, returning null: `, t3), null);\n        }\n        return void 0 === r3 ? null : r3;\n      }\n      async setItem(e2, t2, r3) {\n        if (a(r3), void 0 === t2 && (t2 = null), this._isInMemory) await this._setItemFallback(e2, t2);\n        else try {\n          await this._inst.set(e2, t2);\n        } catch (r4) {\n          if (this._MaybeSwitchToMemoryFallback(r4), !this._isInMemory) throw r4;\n          await this._setItemFallback(e2, t2);\n        }\n      }\n      async removeItem(e2, t2) {\n        if (a(t2), this._isInMemory) this._removeItemFallback(e2);\n        else try {\n          await this._inst.delete(e2);\n        } catch (t3) {\n          this._MaybeSwitchToMemoryFallback(t3), this._isInMemory ? this._removeItemFallback(e2) : console.error(`Error removing '${e2}' from storage: `, t3);\n        }\n      }\n      async clear(e2) {\n        if (a(e2), this._isInMemory) this._clearFallback();\n        else try {\n          await this._inst.clear();\n        } catch (e3) {\n          this._MaybeSwitchToMemoryFallback(e3), this._isInMemory ? this._clearFallback() : console.error(\"Error clearing storage: \", e3);\n        }\n      }\n      async keys(e2) {\n        if (a(e2), this._isInMemory) return this._keysFallback();\n        let t2 = [];\n        try {\n          t2 = await this._inst.keys();\n        } catch (e3) {\n          if (this._MaybeSwitchToMemoryFallback(e3), this._isInMemory) return this._keysFallback();\n          console.error(\"Error getting storage keys: \", e3);\n        }\n        return t2;\n      }\n      ready(e2) {\n        return a(e2), this._isInMemory ? Promise.resolve(true) : this._inst.ready();\n      }\n      createInstance(t2) {\n        if (t2.forceInMemoryFallback) return new s(null);\n        {\n          const r3 = t2.name;\n          if (\"string\" != typeof r3) throw new TypeError(\"invalid store name\");\n          const a2 = new e(r3);\n          return new s(a2);\n        }\n      }\n      length(e2) {\n        r(\"localforage.length()\");\n      }\n      key(e2, t2) {\n        r(\"localforage.key()\");\n      }\n      iterate(e2, t2) {\n        r(\"localforage.iterate()\");\n      }\n      setDriver(e2) {\n        r(\"localforage.setDriver()\");\n      }\n      config(e2) {\n        r(\"localforage.config()\");\n      }\n      defineDriver(e2) {\n        r(\"localforage.defineDriver()\");\n      }\n      driver() {\n        r(\"localforage.driver()\");\n      }\n      supports(e2) {\n        r(\"localforage.supports()\");\n      }\n      dropInstance() {\n        r(\"localforage.dropInstance()\");\n      }\n    }\n    self[\"localforage\"] = new s(new e(\"localforage\"));\n  }\n}\nvar r2;\nvar a2;\nvar o2;\n{\n  const C33 = self.C3;\n  if (C33.Supports = {}, C33.Supports.WebAnimations = (() => {\n    try {\n      if (\"undefined\" == typeof document) return false;\n      const e = document.createElement(\"div\");\n      if (void 0 === e.animate) return false;\n      return void 0 !== e.animate([{ opacity: \"0\" }, { opacity: \"1\" }], 1e3).reverse;\n    } catch (e) {\n      return false;\n    }\n  })(), C33.Supports.DialogElement = \"undefined\" != typeof HTMLDialogElement, C33.Supports.RequestIdleCallback = !!self.requestIdleCallback, C33.Supports.ImageBitmap = !!self.createImageBitmap, C33.Supports.ImageBitmapOptions = false, C33.Supports.ImageBitmapOptionsResize = false, C33.Supports.ImageBitmap) {\n    try {\n      self.createImageBitmap(new ImageData(32, 32), { \"premultiplyAlpha\": \"none\" }).then(() => {\n        C33.Supports.ImageBitmapOptions = true;\n      }).catch(() => {\n        C33.Supports.ImageBitmapOptions = false;\n      });\n    } catch (e) {\n      C33.Supports.ImageBitmapOptions = false;\n    }\n    try {\n      self.createImageBitmap(new ImageData(32, 32), { \"resizeWidth\": 10, \"resizeHeight\": 10 }).then((e) => {\n        C33.Supports.ImageBitmapOptionsResize = 10 === e.width && 10 === e.height;\n      }).catch(() => {\n        C33.Supports.ImageBitmapOptionsResize = false;\n      });\n    } catch (e) {\n      C33.Supports.ImageBitmapOptionsResize = false;\n    }\n  }\n  if (C33.Supports.ClipboardReadText = !(!navigator[\"clipboard\"] || !navigator[\"clipboard\"][\"readText\"]), C33.Supports.PermissionsQuery = !(!navigator[\"permissions\"] || !navigator[\"permissions\"][\"query\"]), C33.Supports.ClipboardPermissionsQuery = false, C33.Supports.PermissionsQuery) {\n    const e = { \"name\": \"clipboard-read\" };\n    navigator[\"permissions\"][\"query\"](e).then(() => {\n      C33.Supports.ClipboardPermissionsQuery = true;\n    }).catch(() => {\n      C33.Supports.ClipboardPermissionsQuery = false;\n    });\n  }\n  C33.Supports.AsyncClipboardApi = !!(navigator[\"permissions\"] && navigator[\"clipboard\"] && self[\"ClipboardItem\"]), C33.Supports.Proxies = \"undefined\" != typeof Proxy, C33.Supports.DownloadAttribute = (() => {\n    if (\"undefined\" == typeof document) return false;\n    return void 0 !== document.createElement(\"a\").download;\n  })(), C33.Supports.Fetch = \"function\" == typeof fetch, C33.Supports.PersistentStorage = !!(self.isSecureContext && \"Opera\" !== C33.Platform.Browser && navigator[\"storage\"] && navigator[\"storage\"][\"persist\"]), C33.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator[\"storage\"] && navigator[\"storage\"][\"estimate\"]), C33.Supports.Fullscreen = (() => {\n    if (\"undefined\" == typeof document) return false;\n    if (\"iOS\" === C33.Platform.OS) return false;\n    const e = document.documentElement;\n    return !!(e.requestFullscreen || e.msRequestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullscreen);\n  })(), C33.Supports.ImageDecoder = void 0 !== self[\"ImageDecoder\"], C33.Supports.WebCodecs = !!self[\"VideoEncoder\"], C33.Supports.NativeFileSystemAPI = !!self[\"showOpenFilePicker\"], C33.Supports.QueryLocalFonts = !!self[\"queryLocalFonts\"], C33.Supports.UserActivation = !!navigator[\"userActivation\"], C33.Supports.CanvasToBlobWebP = false, (async () => {\n    let e;\n    \"undefined\" == typeof document ? e = new OffscreenCanvas(32, 32) : (e = document.createElement(\"canvas\"), e.width = 32, e.height = 32);\n    const t = e.getContext(\"2d\");\n    t.fillStyle = \"blue\", t.fillRect(0, 0, 32, 32);\n    let o = null;\n    try {\n      e[\"convertToBlob\"] ? o = await e[\"convertToBlob\"]({ \"type\": \"image/webp\", \"quality\": 1 }) : e.toBlob && (o = await new Promise((t2) => e.toBlob(t2, \"image/webp\", 1))), C33.Supports.CanvasToBlobWebP = o && \"image/webp\" === o.type;\n    } catch (e2) {\n      C33.Supports.CanvasToBlobWebP = false;\n    }\n  })();\n}\n{\n  const C33 = self.C3;\n  if (!String.prototype.trimStart) {\n    const t = /^[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]*/;\n    String.prototype.trimStart = function() {\n      return this.replace(t, \"\");\n    };\n  }\n  if (!String.prototype.trimEnd) {\n    const r = /[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]*$/;\n    String.prototype.trimEnd = function() {\n      return this.replace(r, \"\");\n    };\n  }\n  if (String.prototype.replaceAll || (String.prototype.replaceAll = function(t, r) {\n    return this.replace(new RegExp(C33.EscapeRegex(t), \"g\"), r);\n  }), Array.prototype.values || (Array.prototype.values = function* () {\n    for (const t of this) yield t;\n  }), !Array.prototype.flat) {\n    let arrayFlat = function(t, r) {\n      return t.reduce((t2, e) => r > 0 && Array.isArray(e) ? (Array.prototype.push.apply(t2, arrayFlat(e, r - 1)), t2) : (t2.push(e), t2), []);\n    };\n    arrayFlat2 = arrayFlat;\n    Array.prototype.flat = function(t = 1) {\n      return arrayFlat(this, t);\n    };\n  }\n  Array.prototype.at || (Array.prototype.at = function(t) {\n    if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];\n  }), String.prototype.at || (String.prototype.at = function(t) {\n    if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];\n  }), RegExp.escape || (RegExp.escape = function(t) {\n    return String(t).replace(/[\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n  }), Set.prototype.isSubsetOf || (Set.prototype.isSubsetOf = function(t) {\n    if (!(t instanceof Set)) throw new TypeError(\"argument must be a Set\");\n    for (const r of this) if (!t.has(r)) return false;\n    return true;\n  }), navigator[\"storage\"] && !navigator[\"storage\"][\"estimate\"] && navigator[\"webkitTemporaryStorage\"] && navigator[\"webkitTemporaryStorage\"][\"queryUsageAndQuota\"] && (navigator[\"storage\"][\"estimate\"] = function() {\n    return new Promise((t, r) => navigator[\"webkitTemporaryStorage\"][\"queryUsageAndQuota\"]((r2, e) => t({ \"usage\": r2, \"quota\": e }), r));\n  }), void 0 === self.isSecureContext && (self.isSecureContext = \"https:\" === location.protocol), void 0 === self[\"globalThis\"] && (self[\"globalThis\"] = self);\n}\nvar arrayFlat2;\n{\n  let assertFail = function(e) {\n    let s = \"Assertion failure: \" + e + \"\\n\\nStack trace:\\n\" + C33.GetCallStack();\n    console.error(s);\n  };\n  assertFail2 = assertFail;\n  const C33 = self.C3;\n  self.assert = function(e, s) {\n    e || assertFail(s);\n  };\n}\nvar assertFail2;\n{\n  const C33 = self.C3, C3X = self.C3X;\n  C33.IsNumber = function(e) {\n    return \"number\" == typeof e;\n  }, C33.IsFiniteNumber = function(e) {\n    return C33.IsNumber(e) && isFinite(e);\n  }, C33.RequireNumber = function(e) {\n    if (!C33.IsNumber(e)) throw new TypeError(\"expected number\");\n  }, C33.RequireOptionalNumber = function(e) {\n    C33.IsNullOrUndefined(e);\n  }, C33.RequireNumberInRange = function(e, n, r) {\n    if (!C33.IsNumber(e) || isNaN(e) || n > e || r < e) throw new RangeError(\"number outside of range\");\n  }, C33.RequireAllNumber = function(...e) {\n    for (let n of e) ;\n  }, C33.RequireFiniteNumber = function(e) {\n    if (!C33.IsFiniteNumber(e)) throw new TypeError(\"expected finite number\");\n  }, C33.RequireOptionalFiniteNumber = function(e) {\n    C33.IsNullOrUndefined(e);\n  }, C33.RequireAllFiniteNumber = function(...e) {\n    for (let n of e) ;\n  }, C33.IsString = function(e) {\n    return \"string\" == typeof e;\n  }, C33.RequireString = function(e) {\n    if (!C33.IsString(e)) throw new TypeError(\"expected string\");\n  }, C33.RequireOptionalString = function(e) {\n    C33.IsNullOrUndefined(e);\n  }, C33.RequireAllString = function(...e) {\n    for (let n of e) ;\n  }, C33.IsSimpleObject = function(e) {\n    if (\"object\" != typeof e || null === e) return false;\n    let n = Object.getPrototypeOf(e);\n    return n ? n.constructor === Object : null === n;\n  }, C33.RequireSimpleObject = function(e) {\n    if (!C33.IsSimpleObject(e)) throw new TypeError(\"expected simple object\");\n  }, C33.RequireOptionalSimpleObject = function(e) {\n    if (!C33.IsNullOrUndefined(e) && !C33.IsSimpleObject(e)) throw new TypeError(\"expected simple object\");\n  }, C33.IsObject = function(e) {\n    return \"object\" == typeof e && null !== e && !Array.isArray(e);\n  }, C33.RequireObject = function(e) {\n    if (!C33.IsObject(e)) throw new TypeError(\"expected object\");\n  }, C33.RequireOptionalObject = function(e) {\n    C33.IsNullOrUndefined(e);\n  }, C33.RequireAllObject = function(...e) {\n    for (let n of e) ;\n  }, C33.IsFileLike = function(e) {\n    return C33.WeakIsInstanceOf(e, Blob) && \"string\" == typeof e[\"name\"];\n  }, C33.RequireFileLike = function(e) {\n    if (!C33.IsFileLike(e)) throw new TypeError(\"expected file\");\n  }, C33.RequireOptionalFileLike = function(e) {\n    C33.IsNullOrUndefined(e);\n  }, C33.IsArray = function(e) {\n    return Array.isArray(e);\n  }, C33.RequireArray = function(e) {\n    if (!C33.IsArray(e)) throw new TypeError(\"expected array\");\n  }, C33.RequireOptionalArray = function(e) {\n    C33.IsNullOrUndefined(e);\n  }, C33.RequireAllArray = function(...e) {\n    for (let n of e) ;\n  }, C33.Is2DArray = function(e) {\n    return !!C33.IsArray(e) && (!e.length || !!C33.IsArray(e[0]));\n  }, C33.Require2DArray = function(e) {\n    if (!C33.Is2DArray(e)) throw new TypeError(\"expected 2d array\");\n    for (let n of e) if (!C33.IsArray(n)) throw new TypeError(\"expected 2d array\");\n  }, C33.RequireOptional2DArray = function(e) {\n    C33.IsNullOrUndefined(e);\n  }, C33.IsFunction = function(e) {\n    return \"function\" == typeof e;\n  }, C33.RequireFunction = function(e, n) {\n    if (!C33.IsFunction(e)) throw new TypeError(\"expected function\");\n    if (!C33.IsNullOrUndefined(n) && e !== n) throw new TypeError(\"expected same function reference\");\n  }, C33.RequireOptionalFunction = function(e) {\n    C33.IsNullOrUndefined(e);\n  }, C33.RequireAllFunction = function(...e) {\n    for (let n of e) ;\n  }, C33.RequireAnyFunction = function(e, ...n) {\n    if (!C33.IsFunction(e)) throw new TypeError(\"expected function\");\n    if (!n.length) throw new Error(\"missing comparison functions\");\n    for (let r of n) if (!C33.IsNullOrUndefined(r) && e === r) return;\n    throw new TypeError(\"expected same function reference\");\n  }, C33.RequireOptionalAllFunction = function(...e) {\n    if (!C33.IsNullOrUndefined(e)) for (let n of e) ;\n  }, C33.IsInstanceOf = function(e, n) {\n    return e instanceof n;\n  }, C33.IsInstanceOfAny = function(e, ...n) {\n    for (let r of n) if (C33.IsInstanceOf(e, r)) return true;\n    return false;\n  }, C33.RequireInstanceOf = function(e, n) {\n    if (!C33.IsInstanceOf(e, n)) throw new TypeError(\"unexpected type\");\n  }, C33.RequireOptionalInstanceOf = function(e, n) {\n    C33.IsNullOrUndefined(e);\n  }, C33.RequireAllInstanceOf = function(e, ...n) {\n    for (let e2 of n) ;\n  }, C33.RequireAnyInstanceOf = function(e, ...n) {\n    if (!C33.IsInstanceOfAny(e, ...n)) throw new TypeError(\"unexpected type\");\n  }, C33.RequireAnyOptionalInstanceOf = function(e, ...n) {\n    if (!C33.IsNullOrUndefined(e) && !C33.IsInstanceOfAny(e, ...n)) throw new TypeError(\"unexpected type\");\n  }, C33.IsArrayOf = function(e, n) {\n    for (let r of e) if (!C33.IsInstanceOf(r, n)) return false;\n    return true;\n  }, C33.IsArrayOfFiniteNumbers = function(e) {\n    for (let n of e) if (!C33.IsFiniteNumber(n)) return false;\n    return true;\n  }, C33.RequireArrayOf = function(e, n) {\n    for (let n2 of e) ;\n  }, C33.RequireOptionalArrayOf = function(e, n) {\n    if (!C33.IsNullOrUndefined(e)) for (let n2 of e) ;\n  }, C33.RequireOptionalArrayOfFunctions = function(e, n) {\n    if (!C33.IsNullOrUndefined(e)) for (let n2 of e) ;\n  }, C33.RequireArrayOfAny = function(e, ...n) {\n    for (let n2 of e) ;\n  }, C33.RequireOptionalArrayOfAny = function(e, ...n) {\n    if (!C33.IsNullOrUndefined(e)) for (let n2 of e) ;\n  }, C33.IsDOMNode = function(e, n) {\n    return !(C33.IsNullOrUndefined(e) || !C33.IsString(e.nodeName)) && (!n || C33.equalsNoCase(e.nodeName, n));\n  }, C33.RequireDOMNode = function(e, n) {\n    if (C33.IsNullOrUndefined(e) || !C33.IsString(e.nodeName)) throw new TypeError(\"expected DOM node\");\n    if (n && !C33.equalsNoCase(e.nodeName, n)) throw new TypeError(`expected DOM '${n}' node`);\n  }, C33.RequireOptionalDOMNode = function(e, n) {\n    C33.IsNullOrUndefined(e);\n  }, C33.IsHTMLElement = function(e, n) {\n    return !(C33.IsNullOrUndefined(e) || !C33.IsString(e.tagName)) && (!n || C33.equalsNoCase(e.tagName, n));\n  }, C33.RequireHTMLElement = function(e, n) {\n    if (C33.IsNullOrUndefined(e) || !C33.IsString(e.tagName)) throw new TypeError(\"expected HTML element\");\n    if (n && !C33.equalsNoCase(e.tagName, n)) throw new TypeError(`expected HTML '${n}' element`);\n  }, C33.RequireOptionalHTMLElement = function(e, n) {\n    C33.IsNullOrUndefined(e);\n  }, C33.IsDrawable = function(e) {\n    return C33.IsHTMLElement(e, \"img\") || C33.IsHTMLElement(e, \"canvas\") || C33.IsHTMLElement(e, \"video\") || \"undefined\" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || \"undefined\" != typeof ImageBitmap && e instanceof ImageBitmap;\n  }, C33.RequireDrawable = function(e) {\n    if (!C33.IsDrawable(e)) throw new TypeError(\"expected drawable\");\n  }, C33.RequireOptionalDrawable = function(e) {\n    C33.IsNullOrUndefined(e);\n  }, C33.IsDrawableOrImageData = function(e) {\n    return e instanceof ImageData || C33.IsDrawable(e);\n  }, C33.RequireDrawableOrImageData = function(e) {\n    if (!C33.IsDrawableOrImageData(e)) throw new TypeError(\"expected drawable or image data\");\n  }, C33.RequireOptionalDrawableOrImageData = function(e) {\n    if (!C33.IsNullOrUndefined(e) && !C33.IsDrawableOrImageData(e)) throw new TypeError(\"expected drawable or image data\");\n  }, C33.IsStringLike = function(e) {\n    return \"string\" == typeof e || C33.HtmlString && e instanceof C33.HtmlString || e instanceof C33.BBString;\n  }, C33.RequireStringLike = function(e) {\n    if (!C33.IsStringLike(e)) throw new TypeError(\"expected string-like\");\n  }, C33.RequireOptionalStringLike = function(e) {\n    C33.IsNullOrUndefined(e);\n  }, C33.RequireAllStringLike = function(...e) {\n    for (let n of e) ;\n  }, C33.RequireOverride = function() {\n    throw new Error(\"must be overridden\");\n  }, C33.NotYetImplemented = function() {\n    throw new Error(\"not yet implemented\");\n  }, C33.IsGeneratorFunction = function(e) {\n    return e.constructor === function* () {\n    }.constructor;\n  }, C33.RequireGeneratorFunction = function(e) {\n    if (!C33.IsGeneratorFunction(e)) throw new Error(\"expected generator function\");\n  }, C33.IsIterable = function(e) {\n    return \"function\" === e[Symbol.iterator];\n  }, C33.RequireIterable = function(e) {\n    if (!C33.IsIterable(e)) throw new Error(\"expected iterable\");\n  }, C33.IsDefined = function(e) {\n    return !C33.IsNullOrUndefined(e);\n  }, C33.IsNullOrUndefined = function(e) {\n    return null == e;\n  }, C33.AreArrayElementsOfSameType = function(e) {\n    let n = e[0].constructor;\n    for (let r of e) if (r.constructor !== n) return false;\n    return n;\n  }, C33.AreArrayElementsOfType = function(e, n) {\n    for (let r of e) if (!(r instanceof n)) return false;\n    return true;\n  };\n  const TypedArray = Object.getPrototypeOf(Uint8Array);\n  C33.IsTypedArray = function(e) {\n    return C33.IsInstanceOf(e, TypedArray);\n  }, C33.RequireTypedArray = function(e) {\n  }, C33.WeakRequireTypedArray = function(e) {\n    C33.WeakRequireInstanceOf(e, TypedArray);\n  }, C33.WeakRequireAnyInstanceOf = function(e, ...n) {\n    if (!C33.WeakIsAnyInstanceOf(e, ...n)) throw new TypeError(\"unexpected type\");\n  }, C33.WeakIsAnyInstanceOf = function(e, ...n) {\n    for (const r of n) if (C33.WeakIsInstanceOf(e, r)) return true;\n    return false;\n  }, C33.WeakRequireInstanceOf = function(e, n) {\n    if (!C33.WeakIsInstanceOf(e, n)) throw new TypeError(\"unexpected type\");\n  }, C33.WeakIsInstanceOf = function(e, n) {\n    for (; e = Object.getPrototypeOf(e); ) if (e.constructor.name === n.name) return true;\n    return false;\n  }, C3X.RequireNumber = C33.RequireNumber, C3X.RequireOptionalNumber = C33.RequireOptionalNumber, C3X.RequireFiniteNumber = C33.RequireFiniteNumber, C3X.RequireOptionalFiniteNumber = C33.RequireOptionalFiniteNumber, C3X.RequireString = C33.RequireString, C3X.RequireOptionalString = C33.RequireOptionalString, C3X.RequireObject = C33.RequireObject, C3X.RequireOptionalObject = C33.RequireOptionalObject, C3X.RequireArray = C33.RequireArray, C3X.RequireOptionalArray = C33.RequireOptionalArray, C3X.RequireFunction = C33.RequireFunction, C3X.RequireOptionalFunction = C33.RequireOptionalFunction, C3X.RequireInstanceOf = C33.RequireInstanceOf, C3X.RequireOptionalInstanceOf = C33.RequireOptionalInstanceOf, C3X.IsNullOrUndefined = C33.IsNullOrUndefined;\n}\n{\n  let isValidTypeChange = function(e, t) {\n    let r = C33.getType(e), n = C33.getType(t);\n    return \"null\" === r || \"null\" === n || \"undefined\" !== r && \"undefined\" !== n && r === n;\n  }, logDefendedObjectWarning = function(e) {\n    console.warn(\"[Defence] \" + e + \" @\", C33.GetCallStack());\n  }, CheckDefendedObjectsUsedCorrectly = function() {\n    if (checkRafId = -1, ctorObjectToProxy.size > 0 || ctorProxyToObject.size > 0) {\n      let e = [...new Set([...ctorObjectToProxy.keys()].map((e2) => C33.getName(e2)))].join(\",\");\n      console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${e}`), ctorObjectToProxy.clear(), ctorProxyToObject.clear();\n    }\n  }, getObjectPropertySet = function(e) {\n    let t = /* @__PURE__ */ new Set();\n    for (let r in e) t.add(r);\n    return t;\n  }, VerifyObjectPropertiesConsistent = function(e, t) {\n    let r = getObjectPropertySet(t), n = typeProperties.get(e);\n    if (n) {\n      let t2 = [];\n      for (let e2 of n.values()) r.has(e2) ? r.delete(e2) : t2.push(e2);\n      C33.appendArray(t2, [...r]), t2.length && console.warn(`[Defence] '${C33.getName(e)}' constructor creates inconsistent properties: ${t2.join(\", \")}`);\n    } else typeProperties.set(e, r);\n  };\n  isValidTypeChange2 = isValidTypeChange, logDefendedObjectWarning2 = logDefendedObjectWarning, CheckDefendedObjectsUsedCorrectly2 = CheckDefendedObjectsUsedCorrectly, getObjectPropertySet2 = getObjectPropertySet, VerifyObjectPropertiesConsistent2 = VerifyObjectPropertiesConsistent;\n  const C33 = self.C3, logRafIds = /* @__PURE__ */ new Map();\n  let measures;\n  C33.ColorLog = function(e, t) {\n    console.log(`%c${e}`, `font-weight: bold; color:${t}`);\n  }, C33.RafLog = function(e, ...t) {\n    logRafIds.has(e) || logRafIds.set(e, -1), -1 === logRafIds.get(e) && logRafIds.set(e, requestAnimationFrame(() => {\n      console.log(`%c${e}`, \"font-weight: bold\", ...t), logRafIds.set(e, -1);\n    }));\n  }, C33.StartMeasure = function(e) {\n    performance.mark(e), measures || (measures = /* @__PURE__ */ new Map()), measures.has(e) || measures.set(e, { current: 0, total: 0, average: 0, calls: 1, toString: function() {\n      return `${e} :: current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ${this.calls}`;\n    } });\n  }, C33.EndMeasure = function(e) {\n    performance.measure(`measure-${e}`, e);\n    const t = performance.getEntriesByName(`measure-${e}`)[0], r = measures.get(e);\n    r.current = t.duration, r.total += r.current, r.average = r.total / r.calls, console.log(r.toString()), r.calls++, performance.clearMarks(e), performance.clearMeasures(`measure-${e}`);\n  }, C33.GetCallStack = function() {\n    return new Error().stack;\n  }, C33.Debugger = function() {\n  }, C33.cast = function(e, t) {\n    return e && e instanceof t ? e : null;\n  }, C33.getName = function(e) {\n    return void 0 === e ? \"undefined\" : null === e ? \"null\" : \"boolean\" == typeof e ? \"<boolean>\" : C33.IsNumber(e) ? \"<number>\" : C33.IsString(e) ? \"<string>\" : C33.IsArray(e) ? \"<array>\" : \"symbol\" == typeof e ? \"<\" + e.toString() + \">\" : C33.IsFunction(e) ? e.name && \"Function\" !== e.name ? e.name : \"<anonymous function>\" : \"object\" == typeof e ? e.constructor && e.constructor.name && \"Object\" !== e.constructor.name ? e.constructor.name : \"<anonymous object>\" : \"<unknown>\";\n  }, C33.getType = function(e) {\n    return null === e ? \"null\" : Array.isArray(e) ? \"array\" : typeof e;\n  }, C33.range = function* (e, t) {\n    if (!isFinite(Math.abs(e - t))) throw new Error(\"Invalid parameters\");\n    if (e > t) for (let r = e - 1; r >= t; r--) yield r;\n    else for (let r = e; r < t; r++) yield r;\n  };\n  let ctorObjectToProxy = /* @__PURE__ */ new Map(), ctorProxyToObject = /* @__PURE__ */ new Map(), proxyToObject = /* @__PURE__ */ new WeakMap(), releasedObjects = /* @__PURE__ */ new WeakMap();\n  C33.DefendHandler = {};\n  const VALID_GET_MISSING_KEYS = /* @__PURE__ */ new Set([\"then\", \"splice\"]);\n  C33.DefendHandler.get = function(e, t) {\n    return t in e || \"symbol\" == typeof t || VALID_GET_MISSING_KEYS.has(t) || logDefendedObjectWarning(`Accessed missing property '${t}' from defended object '${C33.getName(e)}', returning undefined`), releasedObjects.has(e) && \"symbol\" != typeof t && !VALID_GET_MISSING_KEYS.has(t) && logDefendedObjectWarning(`Accessed property '${t}' on a released object '${C33.getName(e)}'\nObject was originally released at: ${releasedObjects.get(e)})\nCall stack at access: `), e[t];\n  }, C33.DefendHandler.set = function(e, t, r) {\n    return t in e || ctorObjectToProxy.has(e) || logDefendedObjectWarning(`Set non-existent property '${t}' to '${r}' on defended object '${C33.getName(e)}'`), isValidTypeChange(e[t], r) || ctorObjectToProxy.has(e) || logDefendedObjectWarning(`Set '${C33.getType(e[t])}' property '${t}' to type '${C33.getType(r)}' on defended object '${C33.getName(e)}'`), releasedObjects.has(e) && logDefendedObjectWarning(`Set property '${t}' on a released object '${C33.getName(e)}'\nObject was originally released at: ${releasedObjects.get(e)})\nCall stack at access: `), e[t] = r, true;\n  }, C33.DefendHandler.deleteProperty = function(e, t) {\n    throw new ReferenceError(`Cannot delete property '${t}' from defended object '${C33.getName(e)}'`);\n  }, C33.DefendHandler.defineProperty = function(e, t, r) {\n    throw new ReferenceError(`Cannot define property '${t}' on defended object '${C33.getName(e)}'`);\n  }, C33.DefendHandler.enumerate = function(e) {\n    throw new ReferenceError(`Cannot enumerate defended object '${C33.getName(e)}'`);\n  };\n  let checkRafId = -1;\n  C33.DefendedBase = class {\n    constructor() {\n      if (!C33.isDebugDefend || !C33.Supports.Proxies) return;\n      let e = new.target, t = Object.create(e.prototype), r = new Proxy(t, C33.DefendHandler);\n      return ctorObjectToProxy.set(t, r), ctorProxyToObject.set(r, t), proxyToObject.set(r, t), -1 === checkRafId && (checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly)), r;\n    }\n  }, C33.debugDefend = function(e) {\n    if (C33.isDebugDefend && C33.Supports.Proxies && e instanceof C33.DefendedBase) {\n      if (!ctorProxyToObject.has(e)) return e;\n      let t = ctorProxyToObject.get(e);\n      return ctorProxyToObject.delete(e), ctorObjectToProxy.delete(t), e;\n    }\n    return C33.isDebug ? Object.seal(e) : e;\n  }, C33.New = function(e, ...t) {\n    let r;\n    try {\n      r = new e(...t);\n    } catch (e2) {\n      throw ctorProxyToObject.clear(), ctorObjectToProxy.clear(), e2;\n    }\n    return C33.isDebugDefend && VerifyObjectPropertiesConsistent(e, r), C33.debugDefend(r);\n  }, C33.Release = function(e) {\n    let t = proxyToObject.get(e);\n    t && releasedObjects.set(t, C33.GetCallStack());\n  }, C33.WasReleased = function(e) {\n    let t = proxyToObject.get(e);\n    return !!t && !!releasedObjects.get(t);\n  };\n  let typeProperties = /* @__PURE__ */ new Map();\n  C33.PerfMark = class {\n    constructor(e) {\n      this._name = \"\", e && this.start(e);\n    }\n    start(e) {\n      C33.isPerformanceProfiling && (this._name = e, performance.mark(this._name + \"-Start\"));\n    }\n    end() {\n      C33.isPerformanceProfiling && (performance.mark(this._name + \"-End\"), performance.measure(this._name, this._name + \"-Start\", this._name + \"-End\"));\n    }\n    next(e) {\n      C33.isPerformanceProfiling && (this.end(), this._name = e, performance.mark(this._name + \"-Start\"));\n    }\n  };\n}\nvar isValidTypeChange2;\nvar logDefendedObjectWarning2;\nvar CheckDefendedObjectsUsedCorrectly2;\nvar getObjectPropertySet2;\nvar VerifyObjectPropertiesConsistent2;\n{\n  let isNegativeZero = function(t) {\n    return 0 === t && 1 / t < 0;\n  };\n  isNegativeZero2 = isNegativeZero;\n  const C33 = self.C3, TWO_PI = 2 * Math.PI, D_TO_R = Math.PI / 180, R_TO_D = 180 / Math.PI;\n  C33.wrap = function(t, n, e) {\n    t = Math.floor(t), n = Math.floor(n);\n    const r = (e = Math.floor(e)) - n;\n    if (0 === r) return e;\n    if (t < n) {\n      const a = e - (n - t) % r;\n      return a === e ? 0 : a;\n    }\n    return n + (t - n) % r;\n  }, C33.mapToRange = function(t, n, e, r, a) {\n    const o = e - n;\n    if (0 === o && 0 === r) return t;\n    return (t - n) * (a - r) / o + r;\n  }, C33.normalize = function(t, n, e) {\n    return n - e == 0 ? 1 : (t - n) / (e - n);\n  }, C33.clamp = function(t, n, e) {\n    return t < n ? n : t > e ? e : t;\n  }, C33.clampAngle = function(t) {\n    return (t %= TWO_PI) < 0 && (t += TWO_PI), t;\n  }, C33.toRadians = function(t) {\n    return t * D_TO_R;\n  }, C33.toDegrees = function(t) {\n    return t * R_TO_D;\n  }, C33.hypot2DFast = function(t, n) {\n    return Math.sqrt(t * t + n * n);\n  }, C33.hypot3DFast = function(t, n, e) {\n    return Math.sqrt(t * t + n * n + e * e);\n  }, C33.distanceTo = function(t, n, e, r) {\n    return C33.hypot2DFast(e - t, r - n);\n  }, C33.distanceSquared = function(t, n, e, r) {\n    const a = e - t, o = r - n;\n    return a * a + o * o;\n  }, C33.angleTo = function(t, n, e, r) {\n    return Math.atan2(r - n, e - t);\n  }, C33.angleDiff = function(t, n) {\n    if (t === n) return 0;\n    let e = Math.sin(t), r = Math.cos(t), a = e * Math.sin(n) + r * Math.cos(n);\n    return a >= 1 ? 0 : a <= -1 ? Math.PI : Math.acos(a);\n  }, C33.angleRotate = function(t, n, e) {\n    let r = Math.sin(t), a = Math.cos(t), o = Math.sin(n), c = Math.cos(n);\n    return Math.acos(r * o + a * c) > e ? a * o - r * c > 0 ? C33.clampAngle(t + e) : C33.clampAngle(t - e) : C33.clampAngle(n);\n  }, C33.angleClockwise = function(t, n) {\n    let e = Math.sin(t);\n    return Math.cos(t) * Math.sin(n) - e * Math.cos(n) <= 0;\n  }, C33.angleLerp = function(t, n, e, r = 0) {\n    let a = C33.angleDiff(t, n);\n    const o = TWO_PI * r;\n    return C33.angleClockwise(n, t) ? C33.clampAngle(t + (a + o) * e) : C33.clampAngle(t - (a + o) * e);\n  }, C33.angleLerpClockwise = function(t, n, e, r = 0) {\n    const a = C33.angleDiff(t, n), o = TWO_PI * r;\n    return C33.angleClockwise(n, t) ? C33.clampAngle(t + (a + o) * e) : C33.clampAngle(t + (TWO_PI - a + o) * e);\n  }, C33.angleLerpAntiClockwise = function(t, n, e, r = 0) {\n    const a = C33.angleDiff(t, n), o = TWO_PI * r;\n    return C33.angleClockwise(n, t) ? C33.clampAngle(t - (-TWO_PI + a - o) * e) : C33.clampAngle(t - (a + o) * e);\n  }, C33.angleReflect = function(t, n) {\n    const e = C33.angleDiff(t, n);\n    return C33.angleClockwise(t, n) ? C33.clampAngle(n - e) : C33.clampAngle(n + e);\n  }, C33.lerp = function(t, n, e) {\n    return t + e * (n - t);\n  }, C33.unlerp = function(t, n, e) {\n    return t === n ? 0 : (e - t) / (n - t);\n  }, C33.relerp = function(t, n, e, r, a) {\n    return C33.lerp(r, a, C33.unlerp(t, n, e));\n  }, C33.qarp = function(t, n, e, r) {\n    return C33.lerp(C33.lerp(t, n, r), C33.lerp(n, e, r), r);\n  }, C33.cubic = function(t, n, e, r, a) {\n    return C33.lerp(C33.qarp(t, n, e, a), C33.qarp(n, e, r, a), a);\n  }, C33.cosp = function(t, n, e) {\n    return (t + n + (t - n) * Math.cos(e * Math.PI)) / 2;\n  }, C33.isPOT = function(t) {\n    return t > 0 && !(t - 1 & t);\n  }, C33.nextHighestPowerOfTwo = function(t) {\n    --t;\n    for (let n = 1; n < 32; n <<= 1) t |= t >> n;\n    return t + 1;\n  }, C33.roundToNearestFraction = function(t, n) {\n    return Math.round(t * n) / n;\n  }, C33.floorToNearestFraction = function(t, n) {\n    return Math.floor(t * n) / n;\n  }, C33.roundToDp = function(t, n) {\n    n = Math.max(Math.floor(n), 0);\n    const e = Math.pow(10, n);\n    return Math.round(t * e) / e;\n  }, C33.countDecimals = function(t) {\n    return Math.floor(t) !== t && t.toString().split(\".\")[1].length || 0;\n  }, C33.toFixed = function(t, n) {\n    let e = t.toFixed(n), r = e.length - 1;\n    for (; r >= 0 && \"0\" === e.charAt(r); --r) ;\n    return r >= 0 && \".\" === e.charAt(r) && --r, r < 0 ? e : e.substr(0, r + 1);\n  }, C33.PackRGB = function(t, n, e) {\n    return C33.clamp(t, 0, 255) | C33.clamp(n, 0, 255) << 8 | C33.clamp(e, 0, 255) << 16;\n  };\n  const ALPHAEX_SHIFT = 1024, ALPHAEX_MAX = 1023, RGBEX_SHIFT = 16384, RGBEX_MAX = 8191, RGBEX_MIN = -8192;\n  C33.PackRGBAEx = function(t, n, e, r) {\n    return (t = C33.clamp(Math.floor(1024 * t), -8192, 8191)) < 0 && (t += 16384), (n = C33.clamp(Math.floor(1024 * n), -8192, 8191)) < 0 && (n += 16384), (e = C33.clamp(Math.floor(1024 * e), -8192, 8191)) < 0 && (e += 16384), -(16384 * t * 16384 * 1024 + 16384 * n * 1024 + 1024 * e + (r = C33.clamp(Math.floor(1023 * r), 0, 1023)));\n  }, C33.PackRGBEx = function(t, n, e) {\n    return C33.PackRGBAEx(t, n, e, 1);\n  }, C33.GetRValue = function(t) {\n    if (t >= 0) return (255 & t) / 255;\n    {\n      let n = Math.floor(-t / 274877906944);\n      return n > 8191 && (n -= 16384), n / 1024;\n    }\n  }, C33.GetGValue = function(t) {\n    if (t >= 0) return ((65280 & t) >> 8) / 255;\n    {\n      let n = Math.floor(-t % 274877906944 / 16777216);\n      return n > 8191 && (n -= 16384), n / 1024;\n    }\n  }, C33.GetBValue = function(t) {\n    if (t >= 0) return ((16711680 & t) >> 16) / 255;\n    {\n      let n = Math.floor(-t % 16777216 / 1024);\n      return n > 8191 && (n -= 16384), n / 1024;\n    }\n  }, C33.GetAValue = function(t) {\n    if (isNegativeZero(t)) return 0;\n    if (t >= 0) return 1;\n    return Math.floor(-t % 1024) / 1023;\n  }, C33.greatestCommonDivisor = function(t, n) {\n    for (t = Math.floor(t), n = Math.floor(n); 0 !== n; ) {\n      let e = n;\n      n = t % n, t = e;\n    }\n    return t;\n  };\n  const COMMON_ASPECT_RATIOS = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];\n  C33.getAspectRatio = function(t, n) {\n    if ((t = Math.floor(t)) === (n = Math.floor(n))) return [1, 1];\n    for (let e2 of COMMON_ASPECT_RATIOS) {\n      let r = t / e2[0] * e2[1];\n      if (Math.abs(n - r) < 1) return e2.slice(0);\n      if (r = t / e2[1] * e2[0], Math.abs(n - r) < 1) return [e2[1], e2[0]];\n    }\n    let e = C33.greatestCommonDivisor(t, n);\n    return [t / e, n / e];\n  }, C33.segmentsIntersect = function(t, n, e, r, a, o, c, u) {\n    const i = Math.min(t, e), l = Math.max(t, e), s = Math.min(a, c), C = Math.max(a, c);\n    if (l < s || i > C) return false;\n    const f = Math.min(n, r), h = Math.max(n, r), M = Math.min(o, u), g = Math.max(o, u);\n    if (h < M || f > g) return false;\n    const m = a - t + c - e, p = o - n + u - r, I = e - t, T = r - n, P = c - a, A = u - o, _ = Math.abs(T * P - A * I), x = P * p - A * m;\n    if (Math.abs(x) > _) return false;\n    const O = I * p - T * m;\n    return Math.abs(O) <= _;\n  }, C33.segmentsIntersectPreCalc = function(t, n, e, r, a, o, c, u, i, l, s, C) {\n    const f = Math.min(i, s), h = Math.max(i, s);\n    if (o < f || a > h) return false;\n    const M = Math.min(l, C), g = Math.max(l, C);\n    if (u < M || c > g) return false;\n    const m = i - t + s - e, p = l - n + C - r, I = e - t, T = r - n, P = s - i, A = C - l, _ = Math.abs(T * P - A * I), x = P * p - A * m;\n    if (Math.abs(x) > _) return false;\n    const O = I * p - T * m;\n    return Math.abs(O) <= _;\n  }, C33.segmentIntersectsQuad = function(t, n, e, r, a) {\n    const o = Math.min(t, e), c = Math.max(t, e), u = Math.min(n, r), i = Math.max(n, r), l = a.getTlx(), s = a.getTly(), C = a.getTrx(), f = a.getTry(), h = a.getBrx(), M = a.getBry(), g = a.getBlx(), m = a.getBly();\n    return C33.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, l, s, C, f) || C33.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, C, f, h, M) || C33.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, h, M, g, m) || C33.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, g, m, l, s);\n  }, C33.segmentIntersectsAnyN = function(t, n, e, r, a) {\n    const o = Math.min(t, e), c = Math.max(t, e), u = Math.min(n, r), i = Math.max(n, r);\n    let l = 0;\n    for (let s = a.length - 4; l <= s; l += 2) if (C33.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, a[l], a[l + 1], a[l + 2], a[l + 3])) return true;\n    return C33.segmentsIntersectPreCalc(t, n, e, r, o, c, u, i, a[l], a[l + 1], a[0], a[1]);\n  };\n  const NO_HIT = 2, PADDING = 1e-6;\n  C33.rayIntersect = function(t, n, e, r, a, o, c, u) {\n    const i = e - t, l = u - o, s = i * l - (r - n) * (c - a);\n    if (0 === s) return 2;\n    const C = ((n - r) * (c - t) + i * (u - n)) / s;\n    return 0 < C && C < 1.000001 ? (l * (c - t) + (a - c) * (u - n)) / s : 2;\n  }, C33.rayIntersectExtended = function(t, n, e, r, a, o, c, u, i) {\n    const l = (c - a) * i, s = (u - o) * i;\n    return C33.rayIntersect(t, n, e, r, a - l, o - s, c + l, u + s);\n  }, C33.isPointInTriangleInclusive = function(t, n, e, r, a, o, c, u) {\n    const i = a - e, l = o - r, s = c - e, C = u - r, f = t - e, h = n - r, M = i * i + l * l, g = i * s + l * C, m = i * f + l * h, p = s * s + C * C, I = s * f + C * h, T = 1 / (M * p - g * g), P = (p * m - g * I) * T, A = (M * I - g * m) * T;\n    return P >= 0 && A >= 0 && P + A <= 1;\n  }, C33.triangleCartesianToBarycentric = function(t, n, e, r, a, o, c, u) {\n    const i = a - e, l = o - r, s = c - e, C = u - r, f = t - e, h = n - r, M = i * i + l * l, g = i * s + l * C, m = s * s + C * C, p = f * i + h * l, I = f * s + h * C, T = M * m - g * g, P = (m * p - g * I) / T, A = (M * I - g * p) / T;\n    return [1 - P - A, P, A];\n  }, C33.triangleBarycentricToCartesian3d = function(t, n, e, r, a, o, c, u, i, l, s, C) {\n    return [t * r + n * c + e * l, t * a + n * u + e * s, t * o + n * i + e * C];\n  };\n}\nvar isNegativeZero2;\n{\n  const C33 = self.C3;\n  let mainDocument = null, baseHref = \"\";\n  if (\"undefined\" != typeof document) {\n    mainDocument = document;\n    const e = document.querySelector(\"base\");\n    baseHref = e && e.hasAttribute(\"href\") ? e.getAttribute(\"href\") : \"\", baseHref && (baseHref.startsWith(\"/\") && (baseHref = baseHref.substr(1)), baseHref.endsWith(\"/\") || (baseHref += \"/\"));\n  }\n  C33.GetBaseHref = function() {\n    return baseHref;\n  }, C33.GetBaseURL = function() {\n    if (!mainDocument) return \"\";\n    const e = mainDocument.location;\n    return C33.GetPathFromURL(e.origin + e.pathname) + baseHref;\n  }, C33.GetPathFromURL = function(e) {\n    if (!e.length) return e;\n    if (e.endsWith(\"/\") || e.endsWith(\"\\\\\")) return e;\n    const t = Math.max(e.lastIndexOf(\"/\"), e.lastIndexOf(\"\\\\\"));\n    return -1 === t ? \"\" : e.substr(0, t + 1);\n  }, C33.GetFilenameFromURL = function(e) {\n    if (!e.length) return e;\n    if (e.endsWith(\"/\") || e.endsWith(\"\\\\\")) return \"\";\n    const t = Math.max(e.lastIndexOf(\"/\"), e.lastIndexOf(\"\\\\\"));\n    return -1 === t ? e : e.substr(t + 1);\n  }, C33.GetFileExtension = function(e) {\n    let t = e.lastIndexOf(\".\");\n    return t < 1 ? \"\" : e.substr(t);\n  }, C33.SetFileExtension = function(e, t) {\n    const n = e.lastIndexOf(\".\");\n    return -1 === n ? e + \".\" + t : e.substr(0, n + 1) + t;\n  }, C33.GetFileNamePart = function(e) {\n    let t = e.lastIndexOf(\".\");\n    return t < 1 ? e : e.substr(0, t);\n  }, C33.NormalizeFileSeparator = function(e) {\n    return e.replace(/\\\\/g, \"/\");\n  }, C33.IsFileExtension = function(e, t) {\n    return t === (e ? C33.GetFileExtension(e).slice(1) : \"\");\n  }, C33.FileNameEquals = function(e, t) {\n    let n, r;\n    return C33.IsFileLike(e) && (n = C33.GetFileNamePart(e[\"name\"])), C33.IsString(e) && (n = C33.GetFileNamePart(e)), C33.IsFileLike(t) && (r = C33.GetFileNamePart(t[\"name\"])), C33.IsString(t) && (r = C33.GetFileNamePart(t)), n === r;\n  }, C33.ParseFilePath = function(e) {\n    e = C33.NormalizeFileSeparator(e);\n    let t = /^\\w\\:\\//.exec(e);\n    t ? (t = t[0], \"/\" !== (e = e.slice(3))[0] && (e = \"/\" + e)) : t = \"\", (e = e.replace(/\\/{2,}/g, \"/\")).length > 1 && \"/\" === e.slice(-1) && (e = e.slice(0, -1));\n    const n = e.lastIndexOf(\"/\") + 1;\n    let r, a = \"\", o = e, s = \"\";\n    n > 0 && (a = e.slice(0, n), o = e.slice(n)), r = o;\n    const i = o.lastIndexOf(\".\");\n    i > 0 && (s = o.slice(i), r = o.slice(0, -s.length));\n    return { dir: a, base: o, name: r, root: t, ext: s, full: t + a + o };\n  }, C33.Wait = function(e, t) {\n    return new Promise((n, r) => {\n      self.setTimeout(n, e, t);\n    });\n  }, C33.swallowException = function(e) {\n    try {\n      e();\n    } catch (e2) {\n      C33.isDebug && console.warn(\"Swallowed exception: \", e2);\n    }\n  }, C33.noop = function() {\n  }, C33.equalsNoCase = function(e, t) {\n    return \"string\" == typeof e && \"string\" == typeof t && (e === t || e.normalize().toLowerCase() === t.normalize().toLowerCase());\n  }, C33.equalsCase = function(e, t) {\n    return \"string\" == typeof e && \"string\" == typeof t && (e === t || e.normalize() === t.normalize());\n  }, C33.typedArraySet16 = function(e, t, n) {\n    e[n++] = t[0], e[n++] = t[1], e[n++] = t[2], e[n++] = t[3], e[n++] = t[4], e[n++] = t[5], e[n++] = t[6], e[n++] = t[7], e[n++] = t[8], e[n++] = t[9], e[n++] = t[10], e[n++] = t[11], e[n++] = t[12], e[n++] = t[13], e[n++] = t[14], e[n] = t[15];\n  }, C33.truncateArray = function(e, t) {\n    e.length = t;\n  }, C33.clearArray = function(e) {\n    e && 0 !== e.length && C33.truncateArray(e, 0);\n  }, C33.clear2DArray = function(e) {\n    if (e) {\n      for (let t = 0; t < e.length; t++) {\n        let n = e[t];\n        C33.truncateArray(n, 0);\n      }\n      C33.truncateArray(e, 0);\n    }\n  }, C33.extendArray = function(e, t, n) {\n    t |= 0;\n    const r = e.length;\n    if (!(t <= r)) for (let a = r; a < t; ++a) e.push(n);\n  }, C33.resizeArray = function(e, t, n) {\n    t |= 0;\n    const r = e.length;\n    t < r ? C33.truncateArray(e, t) : t > r && C33.extendArray(e, t, n);\n  }, C33.shallowAssignArray = function(e, t) {\n    C33.clearArray(e), C33.appendArray(e, t);\n  }, C33.appendArray = function(e, t) {\n    if (t.length < 1e4) e.push(...t);\n    else for (let n = 0, r = t.length; n < r; ++n) e.push(t[n]);\n  }, C33.arrayRemove = function(e, t) {\n    if ((t = Math.floor(t)) < 0 || t >= e.length) return;\n    let n = e.length - 1;\n    for (let r = t; r < n; ++r) e[r] = e[r + 1];\n    C33.truncateArray(e, n);\n  }, C33.arrayFindRemove = function(e, t) {\n    let n = e.indexOf(t);\n    n >= 0 && e.splice(n, 1);\n  }, C33.arraysEqual = function(e, t) {\n    let n = e.length;\n    if (t.length !== n) return false;\n    for (let r = 0; r < n; ++r) if (e[r] !== t[r]) return false;\n    return true;\n  }, C33.arrayFilterOut = function(e, t) {\n    let n = [], r = 0;\n    for (let a = 0, o = e.length; a < o; ++a) {\n      let o2 = e[a];\n      t(o2) ? n.push(o2) : (e[r] = o2, ++r);\n    }\n    return C33.truncateArray(e, r), n;\n  }, C33.arrayRemoveAllInSet = function(e, t) {\n    const n = e.length;\n    let r = 0;\n    for (let n2 = 0, a = e.length; n2 < a; ++n2) {\n      let a2 = e[n2];\n      t.has(a2) || (e[r++] = a2);\n    }\n    return C33.truncateArray(e, r), n - r;\n  }, C33.isArrayIndexInBounds = function(e, t) {\n    return e === Math.floor(e) && (e >= 0 && e < t.length);\n  }, C33.validateArrayIndex = function(e, t) {\n    if (!C33.isArrayIndexInBounds(e, t)) throw new RangeError(\"array index out of bounds\");\n  }, C33.cloneArray = function(e) {\n    return e.slice();\n  }, C33.deepCloneArray = function(e, t) {\n    let n = [];\n    for (let r of e) if (C33.IsObject(r)) {\n      let e2 = t(r);\n      if (!e2) throw new Error(\"missing clone\");\n      if (e2.constructor !== r.constructor) throw new Error(\"object is not a clone\");\n      n.push(e2);\n    } else C33.IsArray(r) ? n.push(C33.deepCloneArray(r, t)) : n.push(r);\n    return n;\n  }, C33.clone2DArray = function(e) {\n    let t = [];\n    for (let n of e) t.push(n.slice());\n    return t;\n  }, C33.splitStringAndNormalize = function(e, t = \" \") {\n    return e ? e.split(t).map((e2) => e2.trim()).filter((e2) => !!e2) : [];\n  }, C33.filterSet = function(e, t, n) {\n    const r = /* @__PURE__ */ new Set();\n    for (const a of e.values()) t(a) && (n ? r.add(n(a)) : r.add(a));\n    return r;\n  }, C33.mergeSets = function(e, t) {\n    return e[\"union\"] ? e[\"union\"](t) : /* @__PURE__ */ new Set([...e, ...t]);\n  }, C33.mergeSetsInPlace = function(e, t) {\n    for (const n of t) e.add(n);\n    return e;\n  }, C33.first = function(e) {\n    for (let t of e) return t;\n    return null;\n  }, C33.xor = function(e, t) {\n    return !e != !t;\n  }, C33.compare = function(e, t, n) {\n    switch (t) {\n      case 0:\n        return e === n;\n      case 1:\n        return e !== n;\n      case 2:\n        return e < n;\n      case 3:\n        return e <= n;\n      case 4:\n        return e > n;\n      case 5:\n        return e >= n;\n      default:\n        return false;\n    }\n  }, C33.hasAnyOwnProperty = function(e) {\n    for (let t in e) if (e.hasOwnProperty(t)) return true;\n    return false;\n  }, C33.PromiseAllWithProgress = function(e, t) {\n    return e.length ? new Promise((n, r) => {\n      const a = [];\n      let o = 0, s = false;\n      for (let i = 0, l = e.length; i < l; ++i) a.push(void 0), e[i].then((r2) => {\n        s || (a[i] = r2, ++o, o === e.length ? n(a) : t(o, e.length));\n      }).catch((e2) => {\n        s = true, r(e2);\n      });\n    }) : Promise.resolve([]);\n  };\n  let memoryCallbacks = [];\n  C33.AddLibraryMemoryCallback = function(e) {\n    memoryCallbacks.push(e);\n  }, C33.GetEstimatedLibraryMemoryUsage = function() {\n    let e = 0;\n    for (let t of memoryCallbacks) {\n      e += t();\n    }\n    return Math.floor(e);\n  };\n  let nextTaskId = 1;\n  const activeTaskIds = /* @__PURE__ */ new Map(), taskMessageChannel = new MessageChannel();\n  taskMessageChannel.port2.onmessage = function(e) {\n    const t = e.data, n = activeTaskIds.get(t);\n    activeTaskIds.delete(t), n && n(performance.now());\n  }, C33.RequestUnlimitedAnimationFrame = function(e) {\n    const t = nextTaskId++;\n    return activeTaskIds.set(t, e), taskMessageChannel.port1.postMessage(t), t;\n  }, C33.CancelUnlimitedAnimationFrame = function(e) {\n    activeTaskIds.delete(e);\n  }, C33.PostTask = C33.RequestUnlimitedAnimationFrame, C33.WaitForNextTask = function() {\n    return new Promise((e) => C33.PostTask(e));\n  };\n  const activeRPAFids = /* @__PURE__ */ new Set();\n  C33.RequestPostAnimationFrame = function(e) {\n    const t = self.requestAnimationFrame(async (n) => {\n      await C33.WaitForNextTask(), activeRPAFids.has(t) && (activeRPAFids.delete(t), e(n));\n    });\n    return activeRPAFids.add(t), t;\n  }, C33.CancelPostAnimationFrame = function(e) {\n    activeRPAFids.has(e) && (self.cancelAnimationFrame(e), activeRPAFids.delete(e));\n  };\n}\n{\n  const C33 = self.C3;\n  C33.IsAbsoluteURL = function(e) {\n    return /^(?:[a-z\\-]+:)?\\/\\//.test(e) || \"data:\" === e.substr(0, 5) || \"blob:\" === e.substr(0, 5);\n  }, C33.IsRelativeURL = function(e) {\n    return !C33.IsAbsoluteURL(e);\n  }, C33.ThrowIfNotOk = function(e) {\n    if (!e.ok) throw new Error(`fetch '${e.url}' response returned ${e.status} ${e.statusText}`);\n  }, C33.FetchOk = function(e, t) {\n    return fetch(e, t).then((e2) => (C33.ThrowIfNotOk(e2), e2));\n  }, C33.FetchText = function(e) {\n    return C33.FetchOk(e).then((e2) => e2.text());\n  }, C33.FetchJson = function(e) {\n    return C33.FetchOk(e).then((e2) => e2.json());\n  }, C33.FetchBlob = function(e) {\n    return C33.FetchOk(e).then((e2) => e2.blob());\n  }, C33.FetchArrayBuffer = function(e) {\n    return C33.FetchOk(e).then((e2) => e2.arrayBuffer());\n  }, C33.FetchImage = function(e) {\n    return new Promise((t, n) => {\n      const r = new Image();\n      r.onload = () => t(r), r.onerror = (e2) => n(e2), r.src = e;\n    });\n  }, C33.BlobToArrayBuffer = function(e) {\n    return \"function\" == typeof e[\"arrayBuffer\"] ? e[\"arrayBuffer\"]() : new Promise((t, n) => {\n      const r = new FileReader();\n      r.onload = () => t(r.result), r.onerror = () => n(r.error), r.readAsArrayBuffer(e);\n    });\n  }, C33.BlobToString = function(e) {\n    return \"function\" == typeof e[\"text\"] ? e[\"text\"]() : new Promise((t, n) => {\n      const r = new FileReader();\n      r.onload = () => t(r.result), r.onerror = () => n(r.error), r.readAsText(e);\n    });\n  }, C33.BlobToJson = function(e) {\n    return C33.BlobToString(e).then((e2) => JSON.parse(e2));\n  }, C33.BlobToImage = async function(e, t) {\n    let n = URL.createObjectURL(e);\n    try {\n      const e2 = await C33.FetchImage(n);\n      return URL.revokeObjectURL(n), n = \"\", t && \"function\" == typeof e2[\"decode\"] && await e2[\"decode\"](), e2;\n    } finally {\n      n && URL.revokeObjectURL(n);\n    }\n  }, C33.CreateCanvas = function(e, t) {\n    if (\"undefined\" != typeof document && \"function\" == typeof document.createElement) {\n      const n = document.createElement(\"canvas\");\n      return n.width = e, n.height = t, n;\n    }\n    return new OffscreenCanvas(e, t);\n  }, C33.CanvasToBlob = function(e, t, n) {\n    if (\"number\" != typeof n && (n = 1), t = t || \"image/png\", n = C33.clamp(n, 0, 1), e[\"convertToBlob\"]) return e[\"convertToBlob\"]({ \"type\": t, \"quality\": n });\n    if (e.toBlob) return new Promise((r) => e.toBlob(r, t, n));\n    throw new Error(\"could not convert canvas to blob\");\n  }, C33.DrawableToBlob = function(e, t, n) {\n    const r = C33.CreateCanvas(e.width, e.height);\n    return r.getContext(\"2d\").drawImage(e, 0, 0), C33.CanvasToBlob(r, t, n);\n  }, C33.ImageDataToBlob = function(e, t, n) {\n    if (C33.Supports.ImageBitmapOptions) return createImageBitmap(e, { \"premultiplyAlpha\": \"none\" }).then((e2) => C33.DrawableToBlob(e2, t, n));\n    if (C33.Supports.ImageBitmap) return createImageBitmap(e).then((e2) => C33.DrawableToBlob(e2, t, n));\n    {\n      const r = C33.CreateCanvas(e.width, e.height);\n      return r.getContext(\"2d\").putImageData(e, 0, 0), C33.CanvasToBlob(r, t, n);\n    }\n  }, C33.CopySet = function(e, t) {\n    e.clear();\n    for (const n of t) e.add(n);\n  }, C33.MapToObject = function(e) {\n    const t = /* @__PURE__ */ Object.create(null);\n    for (const [n, r] of e.entries()) t[n] = r;\n    return t;\n  }, C33.ObjectToMap = function(e, t) {\n    t.clear();\n    for (const [n, r] of Object.entries(e)) t.set(n, r);\n  }, C33.ToSuperJSON = function e(t) {\n    if (\"object\" == typeof t && null !== t) {\n      if (t instanceof Set) return { \"_c3type_\": \"set\", \"data\": [...t].map((t2) => e(t2)) };\n      if (t instanceof Map) return { \"_c3type_\": \"map\", \"data\": [...t].map((t2) => [t2[0], e(t2[1])]) };\n      {\n        const n = /* @__PURE__ */ Object.create(null);\n        for (const [r, o] of Object.entries(t)) n[r] = e(o);\n        return n;\n      }\n    }\n    return t;\n  }, C33.FromSuperJSON = function e(t) {\n    if (\"object\" == typeof t & null !== t) {\n      if (\"set\" === t[\"_c3type_\"]) return new Set(t[\"data\"].map((t2) => e(t2)));\n      if (\"map\" === t[\"_c3type_\"]) return new Map(t[\"data\"].map((t2) => [t2[0], e(t2[1])]));\n      {\n        const n = /* @__PURE__ */ Object.create(null);\n        for (const [r, o] of Object.entries(t)) n[r] = e(o);\n        return n;\n      }\n    }\n    return t;\n  }, C33.CSSToCamelCase = function(e) {\n    if (e.startsWith(\"--\")) return e;\n    let t = \"\", n = false, r = 0;\n    for (const o of e) \"-\" === o ? r > 0 && (n = true) : n ? (t += o.toUpperCase(), n = false) : t += o, ++r;\n    return t;\n  }, C33.IsIterator = function(e) {\n    return \"object\" == typeof e && \"function\" == typeof e.next;\n  }, C33.MakeFilledArray = function(e, t) {\n    const n = [];\n    if (\"function\" == typeof t) for (let r = 0; r < e; ++r) n.push(t());\n    else for (let r = 0; r < e; ++r) n.push(t);\n    return n;\n  };\n}\n{\n  let padTwoDigits = function(t) {\n    return 0 === t.length ? \"00\" : 1 === t.length ? \"0\" + t : t;\n  }, hueToRGB = function(t, s, e) {\n    return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? t + 6 * (s - t) * e : e < 0.5 ? s : e < 2 / 3 ? t + (s - t) * (2 / 3 - e) * 6 : t;\n  };\n  padTwoDigits2 = padTwoDigits, hueToRGB2 = hueToRGB;\n  const C33 = self.C3, HSL_TEST = /([0-9.]+),([0-9.]+)\\%?,([0-9.]+)\\%?/i, HSLA_TEST = /([0-9.]+),([0-9.]+)\\%?,([0-9.]+)\\%?,([0-9.])/i;\n  C33.Color = class {\n    constructor(t, s, e, r) {\n      this._r = NaN, this._g = NaN, this._b = NaN, this._a = NaN, this._r = 0, this._g = 0, this._b = 0, this._a = 0, t instanceof C33.Color ? this.set(t) : this.setRgba(t || 0, s || 0, e || 0, r || 0);\n    }\n    setRgb(t, s, e) {\n      return this._r = +t, this._g = +s, this._b = +e, this.clamp(), this;\n    }\n    setRgba(t, s, e, r) {\n      return this._r = +t, this._g = +s, this._b = +e, this._a = +r, this.clamp(), this;\n    }\n    set(t) {\n      return this._r = t._r, this._g = t._g, this._b = t._b, this._a = t._a, this;\n    }\n    copy(t) {\n      return this.set(t);\n    }\n    add(t) {\n      this._r += t._r, this._g += t._g, this._b += t._b, this._a += t._a, this.clamp();\n    }\n    addRgb(t, s, e, r = 0) {\n      this._r += +t, this._g += +s, this._b += +e, this._a += +r, this.clamp();\n    }\n    diff(t) {\n      this.setR(Math.max(this._r, t._r) - Math.min(this._r, t._r)), this.setG(Math.max(this._g, t._g) - Math.min(this._g, t._g)), this.setB(Math.max(this._b, t._b) - Math.min(this._b, t._b)), this.setA(Math.max(this._a, t._a) - Math.min(this._a, t._a)), this.clamp();\n    }\n    copyRgb(t) {\n      this._r = t._r, this._g = t._g, this._b = t._b;\n    }\n    setR(t) {\n      this._r = C33.clamp(+t, 0, 1);\n    }\n    getR() {\n      return this._r;\n    }\n    setG(t) {\n      this._g = C33.clamp(+t, 0, 1);\n    }\n    getG() {\n      return this._g;\n    }\n    setB(t) {\n      this._b = C33.clamp(+t, 0, 1);\n    }\n    getB() {\n      return this._b;\n    }\n    setA(t) {\n      this._a = C33.clamp(+t, 0, 1);\n    }\n    getA() {\n      return this._a;\n    }\n    clone() {\n      return C33.New(C33.Color, this._r, this._g, this._b, this._a);\n    }\n    toArray() {\n      return [this._r, this._g, this._b, this._a];\n    }\n    toTypedArray() {\n      return new Float64Array(this.toArray());\n    }\n    writeToTypedArray(t, s) {\n      t[s++] = this._r, t[s++] = this._g, t[s++] = this._b, t[s] = this._a;\n    }\n    writeRGBToTypedArray(t, s) {\n      t[s++] = this._r, t[s++] = this._g, t[s] = this._b;\n    }\n    equals(t) {\n      return this._r === t._r && this._g === t._g && this._b === t._b && this._a === t._a;\n    }\n    equalsIgnoringAlpha(t) {\n      return this._r === t._r && this._g === t._g && this._b === t._b;\n    }\n    equalsRgb(t, s, e) {\n      return this._r === t && this._g === s && this._b === e;\n    }\n    equalsRgba(t, s, e, r) {\n      return this._r === t && this._g === s && this._b === e && this._a === r;\n    }\n    equalsF32Array(t, s) {\n      return t[s] === Math.fround(this._r) && t[s + 1] === Math.fround(this._g) && t[s + 2] === Math.fround(this._b) && t[s + 3] === Math.fround(this._a);\n    }\n    equalsRGBF32Array(t, s) {\n      return t[s] === Math.fround(this._r) && t[s + 1] === Math.fround(this._g) && t[s + 2] === Math.fround(this._b);\n    }\n    multiply(t) {\n      this._r *= t._r, this._g *= t._g, this._b *= t._b, this._a *= t._a;\n    }\n    multiplyAlpha(t) {\n      this._r *= t, this._g *= t, this._b *= t, this._a *= t;\n    }\n    premultiply() {\n      return this._r *= this._a, this._g *= this._a, this._b *= this._a, this;\n    }\n    unpremultiply() {\n      return this._r /= this._a, this._g /= this._a, this._b /= this._a, this;\n    }\n    clamp() {\n      return this._r = C33.clamp(this._r, 0, 1), this._g = C33.clamp(this._g, 0, 1), this._b = C33.clamp(this._b, 0, 1), this._a = C33.clamp(this._a, 0, 1), this;\n    }\n    setFromRgbValue(t) {\n      this._r = C33.GetRValue(t), this._g = C33.GetGValue(t), this._b = C33.GetBValue(t), this._a = C33.GetAValue(t);\n    }\n    getCssRgb(t, s, e) {\n      return `rgb(${100 * (C33.IsFiniteNumber(t) ? t : this.getR())}%, ${100 * (C33.IsFiniteNumber(s) ? s : this.getG())}%, ${100 * (C33.IsFiniteNumber(e) ? e : this.getB())}%)`;\n    }\n    getCssRgba(t, s, e, r) {\n      return `rgba(${100 * (C33.IsFiniteNumber(t) ? t : this.getR())}%, ${100 * (C33.IsFiniteNumber(s) ? s : this.getG())}%, ${100 * (C33.IsFiniteNumber(e) ? e : this.getB())}%, ${C33.IsFiniteNumber(r) ? r : this.getA()})`;\n    }\n    toHexString() {\n      const t = Math.round(255 * this.getR()), s = Math.round(255 * this.getG()), e = Math.round(255 * this.getB());\n      return \"#\" + padTwoDigits(t.toString(16)) + padTwoDigits(s.toString(16)) + padTwoDigits(e.toString(16));\n    }\n    parseHexString(t) {\n      if (\"string\" != typeof t) return false;\n      let s, e, r;\n      if (\"#\" === (t = t.trim()).charAt(0) && (t = t.substr(1)), 3 === t.length) s = parseInt(t[0], 16) / 15, e = parseInt(t[1], 16) / 15, r = parseInt(t[2], 16) / 15;\n      else {\n        if (6 !== t.length) return false;\n        s = parseInt(t.substr(0, 2), 16) / 255, e = parseInt(t.substr(2, 2), 16) / 255, r = parseInt(t.substr(4, 2), 16) / 255;\n      }\n      return isFinite(s) && this.setR(s), isFinite(e) && this.setG(e), isFinite(r) && this.setB(r), this.setA(1), true;\n    }\n    toCommaSeparatedRgb() {\n      return `${Math.round(255 * this.getR())}, ${Math.round(255 * this.getG())}, ${Math.round(255 * this.getB())}`;\n    }\n    toRgbArray() {\n      return [Math.round(255 * this.getR()), Math.round(255 * this.getG()), Math.round(255 * this.getB())];\n    }\n    parseCommaSeparatedRgb(t) {\n      if (\"string\" != typeof t) return false;\n      const s = (t = t.replace(/^rgb\\(|\\)|%/, \"\")).split(\",\");\n      if (s.length < 3) return false;\n      const e = parseInt(s[0].trim(), 10) / 255, r = parseInt(s[1].trim(), 10) / 255, i = parseInt(s[2].trim(), 10) / 255;\n      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), this.setA(1), true;\n    }\n    parseCommaSeparatedPercentageRgb(t) {\n      if (\"string\" != typeof t) return false;\n      const s = (t = t.replace(/^rgb\\(|\\)|%/, \"\")).split(\",\");\n      if (s.length < 3) return false;\n      const e = parseInt(s[0].trim(), 10) / 100, r = parseInt(s[1].trim(), 10) / 100, i = parseInt(s[2].trim(), 10) / 100;\n      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), this.setA(1), true;\n    }\n    parseCommaSeparatedRgba(t) {\n      if (\"string\" != typeof t) return false;\n      const s = (t = t.replace(/^rgba\\(|\\)|%/, \"\")).split(\",\");\n      if (s.length < 4) return false;\n      const e = parseInt(s[0].trim(), 10) / 255, r = parseInt(s[1].trim(), 10) / 255, i = parseInt(s[2].trim(), 10) / 255, a = parseFloat(s[3].trim());\n      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), isFinite(a) && this.setA(a), true;\n    }\n    parseCommaSeparatedPercentageRgba(t) {\n      if (\"string\" != typeof t) return false;\n      const s = (t = t.replace(/^rgba\\(|\\)|%/, \"\")).split(\",\");\n      if (s.length < 4) return false;\n      const e = parseInt(s[0].trim(), 10) / 100, r = parseInt(s[1].trim(), 10) / 100, i = parseInt(s[2].trim(), 10) / 100, a = parseFloat(s[3].trim());\n      return isFinite(e) && this.setR(e), isFinite(r) && this.setG(r), isFinite(i) && this.setB(i), isFinite(a) && this.setA(a), true;\n    }\n    parseString(t) {\n      if (\"string\" != typeof t) return false;\n      if ((t = t.replace(/\\s+/, \"\")).includes(\",\")) {\n        if (t.startsWith(\"rgb(\")) return t.includes(\"%\") ? this.parseCommaSeparatedPercentageRgb(t) : this.parseCommaSeparatedRgb(t);\n        if (t.startsWith(\"rgba(\")) return t.includes(\"%\") ? this.parseCommaSeparatedPercentageRgba(t) : this.parseCommaSeparatedRgba(t);\n        if (t.startsWith(\"hsl(\") || t.startsWith(\"hsla(\")) return this.parseHSLString(t);\n        {\n          const s = t.split(\",\");\n          return t.includes(\"%\") ? 3 === s.length ? this.parseCommaSeparatedPercentageRgb(t) : 4 === s.length && this.parseCommaSeparatedPercentageRgba(t) : 3 === s.length ? this.parseCommaSeparatedRgb(t) : 4 === s.length && this.parseCommaSeparatedRgba(t);\n        }\n      }\n      return this.parseHexString(t);\n    }\n    toJSON() {\n      return [this._r, this._g, this._b, this._a];\n    }\n    setFromHSLA(t, s, e, r) {\n      let i, a, h;\n      if (t %= 360, s = C33.clamp(s, 0, 100), e = C33.clamp(e, 0, 100), r = C33.clamp(r, 0, 1), t /= 360, e /= 100, 0 === (s /= 100)) i = a = h = e;\n      else {\n        const r2 = e < 0.5 ? e * (1 + s) : e + s - e * s, n = 2 * e - r2;\n        i = hueToRGB(n, r2, t + 1 / 3), a = hueToRGB(n, r2, t), h = hueToRGB(n, r2, t - 1 / 3);\n      }\n      return this.setR(i), this.setG(a), this.setB(h), this.setA(r), this;\n    }\n    parseHSLString(t) {\n      const s = t.replace(/ |hsl|hsla|\\(|\\)|;/gi, \"\"), e = HSL_TEST.exec(s), r = HSLA_TEST.exec(s);\n      return e && 4 === e.length ? (this.setFromHSLA(+e[1], +e[2], +e[3], 1), true) : !(!r || 5 !== r.length) && (this.setFromHSLA(+e[1], +e[2], +e[3], +e[4]), true);\n    }\n    toHSLAString() {\n      const t = this._r, s = this._g, e = this._b, r = this._a;\n      return `hsla(${C33.Color.GetHue(t, s, e)}, ${C33.Color.GetSaturation(t, s, e)}%, ${C33.Color.GetLuminosity(t, s, e)}%, ${r})`;\n    }\n    toHSLAArray() {\n      const t = this._r, s = this._g, e = this._b;\n      return [C33.Color.GetHue(t, s, e), C33.Color.GetSaturation(t, s, e), C33.Color.GetLuminosity(t, s, e), this._a];\n    }\n    setFromJSON(t) {\n      Array.isArray(t) && (t.length < 3 || (this._r = t[0], this._g = t[1], this._b = t[2], t.length >= 4 ? this._a = t[3] : this._a = 1));\n    }\n    set r(t) {\n      this.setR(t);\n    }\n    get r() {\n      return this.getR();\n    }\n    set g(t) {\n      this.setG(t);\n    }\n    get g() {\n      return this.getG();\n    }\n    set b(t) {\n      this.setB(t);\n    }\n    get b() {\n      return this.getB();\n    }\n    set a(t) {\n      this.setA(t);\n    }\n    get a() {\n      return this.getA();\n    }\n    setAtIndex(t, s) {\n      switch (t) {\n        case 0:\n          this.setR(s);\n          break;\n        case 1:\n          this.setG(s);\n          break;\n        case 2:\n          this.setB(s);\n          break;\n        case 3:\n          this.setA(s);\n          break;\n        default:\n          throw new RangeError(\"invalid color index\");\n      }\n    }\n    getAtIndex(t) {\n      switch (t) {\n        case 0:\n          return this.getR();\n        case 1:\n          return this.getG();\n        case 2:\n          return this.getB();\n        case 3:\n          return this.getA();\n        default:\n          throw new RangeError(\"invalid color index\");\n      }\n    }\n    static Equals(t, s) {\n      let e, r;\n      if (Array.isArray(t)) e = new C33.Color(), e.setFromJSON(t);\n      else {\n        if (!(t instanceof C33.Color)) throw new Error(\"unexpected type\");\n        e = t;\n      }\n      if (Array.isArray(s)) r = new C33.Color(), r.setFromJSON(s);\n      else {\n        if (!(s instanceof C33.Color)) throw new Error(\"unexpected type\");\n        r = s;\n      }\n      return e.equals(r);\n    }\n    static DiffChannel(t, s) {\n      return C33.clamp(Math.max(t, s) - Math.min(t, s), 0, 1);\n    }\n    static Diff(t, s) {\n      const e = new C33.Color();\n      return e.setR(Math.max(t._r, s._r) - Math.min(t._r, s._r)), e.setG(Math.max(t._g, s._g) - Math.min(t._g, s._g)), e.setB(Math.max(t._b, s._b) - Math.min(t._b, s._b)), e.setA(Math.max(t._a, s._a) - Math.min(t._a, s._a)), e;\n    }\n    static DiffNoAlpha(t, s) {\n      const e = new C33.Color(0, 0, 0, 1);\n      return e.setR(Math.max(t._r, s._r) - Math.min(t._r, s._r)), e.setG(Math.max(t._g, s._g) - Math.min(t._g, s._g)), e.setB(Math.max(t._b, s._b) - Math.min(t._b, s._b)), e;\n    }\n    static GetHue(t, s, e) {\n      const r = Math.max(t, s, e), i = Math.min(t, s, e);\n      if (r === i) return 0;\n      let a = 0;\n      switch (r) {\n        case t:\n          a = (s - e) / (r - i) + (s < e ? 6 : 0);\n          break;\n        case s:\n          a = (e - t) / (r - i) + 2;\n          break;\n        case e:\n          a = (t - s) / (r - i) + 4;\n      }\n      return Math.round(a / 6 * 360);\n    }\n    static GetSaturation(t, s, e) {\n      const r = Math.max(t, s, e), i = Math.min(t, s, e);\n      if (r === i) return 0;\n      const a = r - i, h = (r + i) / 2 > 0.5 ? a / (2 - r - i) : a / (r + i);\n      return Math.round(100 * h);\n    }\n    static GetLuminosity(t, s, e) {\n      const r = Math.max(t, s, e), i = (r + Math.min(t, s, e)) / 2;\n      return r ? Math.round(100 * i) : 0;\n    }\n  }, C33.Color.White = Object.freeze(C33.New(C33.Color, 1, 1, 1, 1)), C33.Color.Black = Object.freeze(C33.New(C33.Color, 0, 0, 0, 1)), C33.Color.TransparentBlack = Object.freeze(C33.New(C33.Color, 0, 0, 0, 0));\n}\nvar padTwoDigits2;\nvar hueToRGB2;\n{\n  const C33 = self.C3;\n  C33.Vector2 = class {\n    constructor(t, s) {\n      this._x = 0, this._y = 0, t instanceof C33.Vector2 ? this.copy(t) : this.set(t || 0, s || 0);\n    }\n    set(t, s) {\n      this._x = +t, this._y = +s;\n    }\n    copy(t) {\n      this._x = t._x, this._y = t._y;\n    }\n    equals(t) {\n      return this._x === t._x && this._y === t._y;\n    }\n    equalsValues(t, s) {\n      return this._x === t && this._y === s;\n    }\n    equalsF32Array(t, s) {\n      return t[s] === Math.fround(this._x) && t[s + 1] === Math.fround(this._y);\n    }\n    setX(t) {\n      this._x = +t;\n    }\n    getX() {\n      return this._x;\n    }\n    setY(t) {\n      this._y = +t;\n    }\n    getY() {\n      return this._y;\n    }\n    toArray() {\n      return [this._x, this._y];\n    }\n    toTypedArray() {\n      return new Float64Array(this.toArray());\n    }\n    writeToTypedArray(t, s) {\n      t[s++] = this._x, t[s] = this._y;\n    }\n    offset(t, s) {\n      this._x += +t, this._y += +s;\n    }\n    scale(t, s) {\n      this._x *= t, this._y *= s;\n    }\n    divide(t, s) {\n      this._x /= t, this._y /= s;\n    }\n    round() {\n      this._x = Math.round(this._x), this._y = Math.round(this._y);\n    }\n    floor() {\n      this._x = Math.floor(this._x), this._y = Math.floor(this._y);\n    }\n    ceil() {\n      this._x = Math.ceil(this._x), this._y = Math.ceil(this._y);\n    }\n    angle() {\n      return C33.angleTo(0, 0, this._x, this._y);\n    }\n    lengthSquared() {\n      return this._x * this._x + this._y * this._y;\n    }\n    length() {\n      return C33.hypot2DFast(this._x, this._y);\n    }\n    rotatePrecalc(t, s) {\n      const h = this._x * s - this._y * t;\n      this._y = this._y * s + this._x * t, this._x = h;\n    }\n    rotate(t) {\n      0 !== t && this.rotatePrecalc(Math.sin(t), Math.cos(t));\n    }\n    rotateAbout(t, s, h) {\n      0 === t || s === this._x && h === this._y || (this._x -= s, this._y -= h, this.rotatePrecalc(Math.sin(t), Math.cos(t)), this._x += +s, this._y += +h);\n    }\n    move(t, s) {\n      0 !== s && (this._x += Math.cos(t) * s, this._y += Math.sin(t) * s);\n    }\n    normalize() {\n      const t = this.length();\n      0 !== t && 1 !== t && (this._x /= t, this._y /= t);\n    }\n    clamp(t, s) {\n      this._x = C33.clamp(this._x, t, s), this._y = C33.clamp(this._y, t, s);\n    }\n    dot(t) {\n      return this._x * t._x + this._y * t._y;\n    }\n    reverse() {\n      this._x = -this._x, this._y = -this._y;\n    }\n    perp() {\n      let t = this._x;\n      return this._x = this._y, this._y = -t, this;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Rect = class {\n    constructor(t, h, i, o) {\n      this._left = NaN, this._top = NaN, this._right = NaN, this._bottom = NaN, this._left = 0, this._top = 0, this._right = 0, this._bottom = 0, t instanceof C33.Rect ? this.copy(t) : this.set(t || 0, h || 0, i || 0, o || 0);\n    }\n    set(t, h, i, o) {\n      this._left = +t, this._top = +h, this._right = +i, this._bottom = +o;\n    }\n    setWH(t, h, i, o) {\n      t = +t, h = +h, this._left = t, this._top = h, this._right = t + +i, this._bottom = h + +o;\n    }\n    copy(t) {\n      this._left = +t._left, this._top = +t._top, this._right = +t._right, this._bottom = +t._bottom;\n    }\n    clone() {\n      return new C33.Rect(this._left, this._top, this._right, this._bottom);\n    }\n    static Merge(t, h) {\n      const i = new C33.Rect();\n      return i.setLeft(Math.min(t._left, h._left)), i.setTop(Math.min(t._top, h._top)), i.setRight(Math.max(t._right, h._right)), i.setBottom(Math.max(t._bottom, h._bottom)), i;\n    }\n    static FromObject(t) {\n      return new C33.Rect(t.left, t.top, t.right, t.bottom);\n    }\n    equals(t) {\n      return this._left === t._left && this._top === t._top && this._right === t._right && this._bottom === t._bottom;\n    }\n    equalsWH(t, h, i, o) {\n      return this._left === t && this._top === h && this.width() === i && this.height() === o;\n    }\n    equalsF32Array(t, h) {\n      return t[h] === Math.fround(this._left) && t[h + 1] === Math.fround(this._top) && t[h + 2] === Math.fround(this._right) && t[h + 3] === Math.fround(this._bottom);\n    }\n    setLeft(t) {\n      this._left = +t;\n    }\n    getLeft() {\n      return this._left;\n    }\n    setTop(t) {\n      this._top = +t;\n    }\n    getTop() {\n      return this._top;\n    }\n    setRight(t) {\n      this._right = +t;\n    }\n    getRight() {\n      return this._right;\n    }\n    setBottom(t) {\n      this._bottom = +t;\n    }\n    getBottom() {\n      return this._bottom;\n    }\n    toArray() {\n      return [this._left, this._top, this._right, this._bottom];\n    }\n    toTypedArray() {\n      return new Float64Array(this.toArray());\n    }\n    toDOMRect() {\n      return new DOMRect(this._left, this._top, this.width(), this.height());\n    }\n    static fromDOMRect(t) {\n      return C33.New(C33.Rect, t.left, t.top, t.right, t.bottom);\n    }\n    writeToTypedArray(t, h) {\n      t[h++] = this._left, t[h++] = this._top, t[h++] = this._right, t[h] = this._bottom;\n    }\n    writeAsQuadToTypedArray(t, h) {\n      t[h++] = this._left, t[h++] = this._top, t[h++] = this._right, t[h++] = this._top, t[h++] = this._right, t[h++] = this._bottom, t[h++] = this._left, t[h] = this._bottom;\n    }\n    writeAsQuadToTypedArray3D(t, h, i) {\n      t[h++] = this._left, t[h++] = this._top, t[h++] = i, t[h++] = this._right, t[h++] = this._top, t[h++] = i, t[h++] = this._right, t[h++] = this._bottom, t[h++] = i, t[h++] = this._left, t[h++] = this._bottom, t[h] = i;\n    }\n    width() {\n      return this._right - this._left;\n    }\n    height() {\n      return this._bottom - this._top;\n    }\n    midX() {\n      return (this._left + this._right) / 2;\n    }\n    midY() {\n      return (this._top + this._bottom) / 2;\n    }\n    offset(t, h) {\n      t = +t, h = +h, this._left += t, this._top += h, this._right += t, this._bottom += h;\n    }\n    offsetLeft(t) {\n      this._left += +t;\n    }\n    offsetTop(t) {\n      this._top += +t;\n    }\n    offsetRight(t) {\n      this._right += +t;\n    }\n    offsetBottom(t) {\n      this._bottom += +t;\n    }\n    toSquare(t) {\n      if (\"x\" !== t) throw new Error(\"invalid axis, only 'x' supported\");\n      this._top < this._bottom ? this._left < this._right ? this._bottom = this._top + this.width() : this._bottom = this._top - this.width() : this._left < this._right ? this._bottom = this._top - this.width() : this._bottom = this._top + this.width();\n    }\n    inflate(t, h) {\n      t = +t, h = +h, this._left -= t, this._top -= h, this._right += t, this._bottom += h;\n    }\n    deflate(t, h) {\n      t = +t, h = +h, this._left += t, this._top += h, this._right -= t, this._bottom -= h;\n    }\n    multiply(t, h) {\n      this._left *= t, this._top *= h, this._right *= t, this._bottom *= h;\n    }\n    divide(t, h) {\n      this._left /= t, this._top /= h, this._right /= t, this._bottom /= h;\n    }\n    mirrorAround(t) {\n      this._left = +t - this._left, this._right = +t - this._right;\n    }\n    flipAround(t) {\n      this._top = +t - this._top, this._bottom = +t - this._bottom;\n    }\n    rotate90DegreesAround(t, h) {\n      const i = this.width(), o = this.height(), s = this.getLeft() + i * t, _ = this.getTop() + o * h;\n      this.setWH(s - o * h, _ - i * t, o, i);\n    }\n    swapLeftRight() {\n      const t = this._left;\n      this._left = this._right, this._right = t;\n    }\n    swapTopBottom() {\n      const t = this._top;\n      this._top = this._bottom, this._bottom = t;\n    }\n    shuntY(t) {\n      const h = this._top;\n      this._top = +t - this._bottom, this._bottom = +t - h;\n    }\n    round() {\n      this._left = Math.round(this._left), this._top = Math.round(this._top), this._right = Math.round(this._right), this._bottom = Math.round(this._bottom);\n    }\n    roundInner() {\n      this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);\n    }\n    roundOuter() {\n      this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);\n    }\n    floor() {\n      this._left = Math.floor(this._left), this._top = Math.floor(this._top), this._right = Math.floor(this._right), this._bottom = Math.floor(this._bottom);\n    }\n    ceil() {\n      this._left = Math.ceil(this._left), this._top = Math.ceil(this._top), this._right = Math.ceil(this._right), this._bottom = Math.ceil(this._bottom);\n    }\n    clamp(t, h, i, o) {\n      this._left = Math.max(this._left, +t), this._top = Math.max(this._top, +h), this._right = Math.min(this._right, +i), this._bottom = Math.min(this._bottom, +o);\n    }\n    clampBoth(t, h, i, o) {\n      t = +t, h = +h, i = +i, o = +o, this._left = C33.clamp(this._left, t, i), this._top = C33.clamp(this._top, h, o), this._right = C33.clamp(this._right, t, i), this._bottom = C33.clamp(this._bottom, h, o);\n    }\n    normalize() {\n      this._left > this._right && this.swapLeftRight(), this._top > this._bottom && this.swapTopBottom();\n    }\n    intersectsRect(t) {\n      return !(t._right < this._left || t._bottom < this._top || t._left > this._right || t._top > this._bottom);\n    }\n    intersectsRectOffset(t, h, i) {\n      return !(t._right + h < this._left || t._bottom + i < this._top || t._left + h > this._right || t._top + i > this._bottom);\n    }\n    containsPoint(t, h) {\n      return t >= this._left && t <= this._right && h >= this._top && h <= this._bottom;\n    }\n    containsRect(t) {\n      return t._left >= this._left && t._top >= this._top && t._right <= this._right && t._bottom <= this._bottom;\n    }\n    expandToContain(t) {\n      t._left < this._left && (this._left = +t._left), t._top < this._top && (this._top = +t._top), t._right > this._right && (this._right = +t._right), t._bottom > this._bottom && (this._bottom = +t._bottom);\n    }\n    lerpInto(t) {\n      this._left = C33.lerp(t._left, t._right, this._left), this._top = C33.lerp(t._top, t._bottom, this._top), this._right = C33.lerp(t._left, t._right, this._right), this._bottom = C33.lerp(t._top, t._bottom, this._bottom);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Quad = class {\n    constructor(t, s, i, h, _, r, l, e) {\n      this._tlx = NaN, this._tly = NaN, this._trx = NaN, this._try = NaN, this._brx = NaN, this._bry = NaN, this._blx = NaN, this._bly = NaN, this._tlx = 0, this._tly = 0, this._trx = 0, this._try = 0, this._brx = 0, this._bry = 0, this._blx = 0, this._bly = 0, t instanceof C33.Quad ? this.copy(t) : this.set(t || 0, s || 0, i || 0, h || 0, _ || 0, r || 0, l || 0, e || 0);\n    }\n    set(t, s, i, h, _, r, l, e) {\n      this._tlx = +t, this._tly = +s, this._trx = +i, this._try = +h, this._brx = +_, this._bry = +r, this._blx = +l, this._bly = +e;\n    }\n    setRect(t, s, i, h) {\n      this.set(t, s, i, s, i, h, t, h);\n    }\n    copy(t) {\n      this._tlx = t._tlx, this._tly = t._tly, this._trx = t._trx, this._try = t._try, this._brx = t._brx, this._bry = t._bry, this._blx = t._blx, this._bly = t._bly;\n    }\n    equals(t) {\n      return this._tlx === t._tlx && this._tly === t._tly && this._trx === t._trx && this._try === t._try && this._brx === t._brx && this._bry === t._bry && this._blx === t._blx && this._bly === t._bly;\n    }\n    setTlx(t) {\n      this._tlx = +t;\n    }\n    getTlx() {\n      return this._tlx;\n    }\n    setTly(t) {\n      this._tly = +t;\n    }\n    getTly() {\n      return this._tly;\n    }\n    setTrx(t) {\n      this._trx = +t;\n    }\n    getTrx() {\n      return this._trx;\n    }\n    setTry(t) {\n      this._try = +t;\n    }\n    getTry() {\n      return this._try;\n    }\n    setBrx(t) {\n      this._brx = +t;\n    }\n    getBrx() {\n      return this._brx;\n    }\n    setBry(t) {\n      this._bry = +t;\n    }\n    getBry() {\n      return this._bry;\n    }\n    setBlx(t) {\n      this._blx = +t;\n    }\n    getBlx() {\n      return this._blx;\n    }\n    setBly(t) {\n      this._bly = +t;\n    }\n    getBly() {\n      return this._bly;\n    }\n    toDOMQuad() {\n      return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly));\n    }\n    static fromDOMQuad(t) {\n      return C33.New(C33.Quad, t.p1.x, t.p1.y, t.p2.x, t.p2.y, t.p3.x, t.p3.y, t.p4.x, t.p4.y);\n    }\n    toArray() {\n      return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly];\n    }\n    toTypedArray() {\n      return new Float64Array(this.toArray());\n    }\n    writeToTypedArray(t, s) {\n      t[s++] = this._tlx, t[s++] = this._tly, t[s++] = this._trx, t[s++] = this._try, t[s++] = this._brx, t[s++] = this._bry, t[s++] = this._blx, t[s] = this._bly;\n    }\n    writeToTypedArray3D(t, s, i) {\n      t[s++] = this._tlx, t[s++] = this._tly, t[s++] = i, t[s++] = this._trx, t[s++] = this._try, t[s++] = i, t[s++] = this._brx, t[s++] = this._bry, t[s++] = i, t[s++] = this._blx, t[s++] = this._bly, t[s] = i;\n    }\n    offset(t, s) {\n      t = +t, s = +s, this._tlx += t, this._tly += s, this._trx += t, this._try += s, this._brx += t, this._bry += s, this._blx += t, this._bly += s;\n    }\n    round() {\n      this._tlx = Math.round(this._tlx), this._tly = Math.round(this._tly), this._trx = Math.round(this._trx), this._try = Math.round(this._try), this._brx = Math.round(this._brx), this._bry = Math.round(this._bry), this._blx = Math.round(this._blx), this._bly = Math.round(this._bly);\n    }\n    floor() {\n      this._tlx = Math.floor(this._tlx), this._tly = Math.floor(this._tly), this._trx = Math.floor(this._trx), this._try = Math.floor(this._try), this._brx = Math.floor(this._brx), this._bry = Math.floor(this._bry), this._blx = Math.floor(this._blx), this._bly = Math.floor(this._bly);\n    }\n    ceil() {\n      this._tlx = Math.ceil(this._tlx), this._tly = Math.ceil(this._tly), this._trx = Math.ceil(this._trx), this._try = Math.ceil(this._try), this._brx = Math.ceil(this._brx), this._bry = Math.ceil(this._bry), this._blx = Math.ceil(this._blx), this._bly = Math.ceil(this._bly);\n    }\n    setFromRect(t) {\n      this._tlx = t._left, this._tly = t._top, this._trx = t._right, this._try = t._top, this._brx = t._right, this._bry = t._bottom, this._blx = t._left, this._bly = t._bottom;\n    }\n    setFromRotatedRect(t, s) {\n      0 === s ? this.setFromRect(t) : this.setFromRotatedRectPrecalc(t, Math.sin(s), Math.cos(s));\n    }\n    setFromRotatedRectPrecalc(t, s, i) {\n      const h = t._left * s, _ = t._top * s, r = t._right * s, l = t._bottom * s, e = t._left * i, x = t._top * i, y = t._right * i, b = t._bottom * i;\n      this._tlx = e - _, this._tly = x + h, this._trx = y - _, this._try = x + r, this._brx = y - l, this._bry = b + r, this._blx = e - l, this._bly = b + h;\n    }\n    getBoundingBox(t) {\n      t.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly));\n    }\n    containsPoint(t, s) {\n      let i = this._trx - this._tlx, h = this._try - this._tly;\n      const _ = this._brx - this._tlx, r = this._bry - this._tly, l = t - this._tlx, e = s - this._tly;\n      let x = i * i + h * h, y = i * _ + h * r, b = i * l + h * e;\n      const a = _ * _ + r * r, n = _ * l + r * e;\n      let o = 1 / (x * a - y * y), c = (a * b - y * n) * o, u = (x * n - y * b) * o;\n      return c >= 0 && u > 0 && c + u < 1 || (i = this._blx - this._tlx, h = this._bly - this._tly, x = i * i + h * h, y = i * _ + h * r, b = i * l + h * e, o = 1 / (x * a - y * y), c = (a * b - y * n) * o, u = (x * n - y * b) * o, c >= 0 && u > 0 && c + u < 1);\n    }\n    midX() {\n      return (this._tlx + this._trx + this._brx + this._blx) / 4;\n    }\n    midY() {\n      return (this._tly + this._try + this._bry + this._bly) / 4;\n    }\n    intersectsSegment(t, s, i, h) {\n      return !(!this.containsPoint(t, s) && !this.containsPoint(i, h)) || C33.segmentIntersectsQuad(t, s, i, h, this);\n    }\n    intersectsQuad(t) {\n      let s = t.midX(), i = t.midY();\n      if (this.containsPoint(s, i)) return true;\n      if (s = this.midX(), i = this.midY(), t.containsPoint(s, i)) return true;\n      const h = this._tlx, _ = this._tly, r = this._trx, l = this._try, e = this._brx, x = this._bry, y = this._blx, b = this._bly;\n      return C33.segmentIntersectsQuad(h, _, r, l, t) || C33.segmentIntersectsQuad(r, l, e, x, t) || C33.segmentIntersectsQuad(e, x, y, b, t) || C33.segmentIntersectsQuad(y, b, h, _, t);\n    }\n    rotatePointsAnticlockwise() {\n      const t = this._tlx, s = this._tly;\n      this._tlx = this._trx, this._tly = this._try, this._trx = this._brx, this._try = this._bry, this._brx = this._blx, this._bry = this._bly, this._blx = t, this._bly = s;\n    }\n    mirror() {\n      this._swap(0, 2), this._swap(1, 3), this._swap(6, 4), this._swap(7, 5);\n    }\n    flip() {\n      this._swap(0, 6), this._swap(1, 7), this._swap(2, 4), this._swap(3, 5);\n    }\n    diag() {\n      this._swap(2, 6), this._swap(3, 7);\n    }\n    _swap(t, s) {\n      const i = this._getAtIndex(t);\n      this._setAtIndex(t, this._getAtIndex(s)), this._setAtIndex(s, i);\n    }\n    _getAtIndex(t) {\n      switch (t) {\n        case 0:\n          return this._tlx;\n        case 1:\n          return this._tly;\n        case 2:\n          return this._trx;\n        case 3:\n          return this._try;\n        case 4:\n          return this._brx;\n        case 5:\n          return this._bry;\n        case 6:\n          return this._blx;\n        case 7:\n          return this._bly;\n        default:\n          throw new RangeError(\"invalid quad point index\");\n      }\n    }\n    _setAtIndex(t, s) {\n      switch (s = +s, t) {\n        case 0:\n          this._tlx = s;\n          break;\n        case 1:\n          this._tly = s;\n          break;\n        case 2:\n          this._trx = s;\n          break;\n        case 3:\n          this._try = s;\n          break;\n        case 4:\n          this._brx = s;\n          break;\n        case 5:\n          this._bry = s;\n          break;\n        case 6:\n          this._blx = s;\n          break;\n        case 7:\n          this._bly = s;\n          break;\n        default:\n          throw new RangeError(\"invalid quad point index\");\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3, assert = self.assert, DEFAULT_POLY_POINTS = [0, 0, 1, 0, 1, 1, 0, 1], tempQuad = C33.New(C33.Quad);\n  C33.CollisionPoly = class extends C33.DefendedBase {\n    constructor(t, s = true) {\n      super(), t || (t = DEFAULT_POLY_POINTS), this._ptsArr = Float64Array.from(t), this._bbox = new C33.Rect(), this._isBboxChanged = true, this._enabled = s;\n    }\n    Release() {\n    }\n    pointsArr() {\n      return this._ptsArr;\n    }\n    pointCount() {\n      return this._ptsArr.length / 2;\n    }\n    setPoints(t) {\n      this._ptsArr.length === t.length ? this._ptsArr.set(t) : this._ptsArr = Float64Array.from(t), this._isBboxChanged = true;\n    }\n    setDefaultPoints() {\n      this.setPoints(DEFAULT_POLY_POINTS);\n    }\n    copy(t) {\n      this.setPoints(t._ptsArr);\n    }\n    setBboxChanged() {\n      this._isBboxChanged = true;\n    }\n    _updateBbox() {\n      if (!this._isBboxChanged) return;\n      const t = this._ptsArr;\n      let s = t[0], e = t[1], r = s, n = e;\n      for (let o = 0, i = t.length; o < i; o += 2) {\n        const i2 = t[o], h = t[o + 1];\n        i2 < s && (s = i2), i2 > r && (r = i2), h < e && (e = h), h > n && (n = h);\n      }\n      this._bbox.set(s, e, r, n), this._isBboxChanged = false;\n    }\n    setFromRect(t, s, e) {\n      let r = this._ptsArr;\n      8 !== r.length && (r = new Float64Array(8), this._ptsArr = r), r[0] = t.getLeft() - s, r[1] = t.getTop() - e, r[2] = t.getRight() - s, r[3] = t.getTop() - e, r[4] = t.getRight() - s, r[5] = t.getBottom() - e, r[6] = t.getLeft() - s, r[7] = t.getBottom() - e, this._bbox.copy(t), 0 === s && 0 === e || this._bbox.offset(-s, -e), this._isBboxChanged = false;\n    }\n    setFromQuad(t, s, e) {\n      tempQuad.copy(t), tempQuad.offset(s, e), this.setPoints(tempQuad.toArray()), this._isBboxChanged = true;\n    }\n    transform(t, s, e) {\n      let r = 0, n = 1;\n      0 !== e && (r = Math.sin(e), n = Math.cos(e)), this.transformPrecalc(t, s, r, n);\n    }\n    transformPrecalc(t, s, e, r) {\n      const n = this._ptsArr;\n      for (let o = 0, i = n.length; o < i; o += 2) {\n        const i2 = o + 1, h = n[o] * t, l = n[i2] * s;\n        n[o] = h * r - l * e, n[i2] = l * r + h * e;\n      }\n      this._isBboxChanged = true;\n    }\n    offset(t, s) {\n      const e = this._ptsArr;\n      for (let r = 0, n = e.length; r < n; r += 2) e[r] += t, e[r + 1] += s;\n    }\n    containsPoint(t, s) {\n      const e = this._ptsArr;\n      if (t === e[0] && s === e[1]) return true;\n      this._updateBbox();\n      const r = this._bbox, n = r.getLeft() - 110, o = r.getTop() - 101, i = r.getRight() + 131, h = r.getBottom() + 120;\n      let l = 0, a = 0, c = 0, g = 0, _ = 0, p = 0, f = 0, u = 0;\n      n < t ? (l = n, c = t) : (l = t, c = n), o < s ? (a = o, g = s) : (a = s, g = o), i < t ? (_ = i, f = t) : (_ = t, f = i), h < s ? (p = h, u = s) : (p = s, u = h);\n      let C = 0, A = 0;\n      for (let r2 = 0, d = e.length; r2 < d; r2 += 2) {\n        const b = (r2 + 2) % d, P = e[r2], m = e[r2 + 1], x = e[b], B = e[b + 1];\n        C33.segmentsIntersectPreCalc(n, o, t, s, l, c, a, g, P, m, x, B) && ++C, C33.segmentsIntersectPreCalc(i, h, t, s, _, f, p, u, P, m, x, B) && ++A;\n      }\n      return C % 2 == 1 || A % 2 == 1;\n    }\n    intersectsPoly(t, s, e) {\n      const r = t._ptsArr, n = this._ptsArr;\n      if (this.containsPoint(r[0] + s, r[1] + e)) return true;\n      if (t.containsPoint(n[0] - s, n[1] - e)) return true;\n      for (let t2 = 0, o = n.length; t2 < o; t2 += 2) {\n        const i = (t2 + 2) % o, h = n[t2], l = n[t2 + 1], a = n[i], c = n[i + 1];\n        let g = 0, _ = 0, p = 0, f = 0;\n        h < a ? (g = h, p = a) : (g = a, p = h), l < c ? (_ = l, f = c) : (_ = c, f = l);\n        for (let t3 = 0, n2 = r.length; t3 < n2; t3 += 2) {\n          const o2 = (t3 + 2) % n2, i2 = r[t3] + s, u = r[t3 + 1] + e, C = r[o2] + s, A = r[o2 + 1] + e;\n          if (C33.segmentsIntersectPreCalc(h, l, a, c, g, p, _, f, i2, u, C, A)) return true;\n        }\n      }\n      return false;\n    }\n    intersectsSegment(t, s, e, r, n, o) {\n      if (this.containsPoint(e - t, r - s)) return true;\n      if (this.containsPoint(n - t, o - s)) return true;\n      let i = 0, h = 0, l = 0, a = 0;\n      e < n ? (i = e, l = n) : (i = n, l = e), r < o ? (h = r, a = o) : (h = o, a = r);\n      const c = this._ptsArr;\n      for (let g = 0, _ = c.length; g < _; g += 2) {\n        const p = (g + 2) % _, f = c[g] + t, u = c[g + 1] + s, C = c[p] + t, A = c[p + 1] + s;\n        if (C33.segmentsIntersectPreCalc(e, r, n, o, i, l, h, a, f, u, C, A)) return true;\n      }\n      return false;\n    }\n    mirror(t) {\n      const s = this._ptsArr;\n      for (let e = 0, r = s.length; e < r; e += 2) s[e] = 2 * t - s[e];\n      this._isBboxChanged = true;\n    }\n    flip(t) {\n      const s = this._ptsArr;\n      for (let e = 0, r = s.length; e < r; e += 2) {\n        const r2 = e + 1;\n        s[r2] = 2 * t - s[r2];\n      }\n      this._isBboxChanged = true;\n    }\n    diag() {\n      const t = this._ptsArr;\n      for (let s = 0, e = t.length; s < e; s += 2) {\n        const e2 = s + 1, r = t[s];\n        t[s] = t[e2], t[e2] = r;\n      }\n      this._isBboxChanged = true;\n    }\n    GetMidX() {\n      const t = this._ptsArr;\n      let s = 0;\n      for (let e = 0, r = t.length; e < r; e += 2) s += t[e];\n      return s / this.pointCount();\n    }\n    GetMidY() {\n      const t = this._ptsArr;\n      let s = 0;\n      for (let e = 0, r = t.length; e < r; e += 2) s += t[e + 1];\n      return s / this.pointCount();\n    }\n    GetPointsArray() {\n      return this._ptsArr;\n    }\n    GetPointCount() {\n      return this.pointCount();\n    }\n    IsEnabled() {\n      return this._enabled;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.PairMap = class extends C33.DefendedBase {\n    constructor(e) {\n      if (super(), this._firstMap = /* @__PURE__ */ new Map(), e) for (const [t, s, r] of e) this.Set(t, s, r);\n    }\n    Release() {\n      this.Clear(), this._firstMap = null;\n    }\n    IsEmpty() {\n      return 0 === this._firstMap.size;\n    }\n    Clear() {\n      const e = this._firstMap;\n      for (const t of e.values()) t.clear();\n      e.clear();\n    }\n    Set(e, t, s) {\n      const r = this._firstMap;\n      let i = r.get(e);\n      i || (i = /* @__PURE__ */ new Map(), r.set(e, i)), i.set(t, s);\n    }\n    Get(e, t) {\n      const s = this._firstMap.get(e);\n      return s ? s.get(t) : s;\n    }\n    Has(e, t) {\n      const s = this._firstMap.get(e);\n      return !!s && s.has(t);\n    }\n    Delete(e, t) {\n      const s = this._firstMap, r = s.get(e);\n      if (!r) return false;\n      const i = r.delete(t);\n      return i && 0 === r.size && s.delete(e), i;\n    }\n    DeleteEither(e) {\n      const t = this._firstMap, s = t.get(e);\n      s && (s.clear(), t.delete(e));\n      for (const [s2, r] of t.entries()) r.delete(e) && 0 === r.size && t.delete(s2);\n    }\n    GetSize() {\n      let e = 0;\n      for (const t of this._firstMap.values()) e += t.size;\n      return e;\n    }\n    *values() {\n      for (const e of this._firstMap.values()) yield* e.values();\n    }\n    *keyPairs() {\n      for (const [e, t] of this._firstMap.entries()) for (const s of t.keys()) yield [e, s];\n    }\n    *entries() {\n      for (const [e, t] of this._firstMap.entries()) for (const [s, r] of t.entries()) yield [e, s, r];\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.ArraySet = class extends C33.DefendedBase {\n    constructor() {\n      super(), this._set = /* @__PURE__ */ new Set(), this._arr = [], this._needToRebuildArray = false;\n    }\n    Release() {\n      this.Clear();\n    }\n    Clear() {\n      this._set.clear(), C33.clearArray(this._arr), this._needToRebuildArray = false;\n    }\n    Add(e) {\n      this._set.has(e) || (this._set.add(e), this._needToRebuildArray || this._arr.push(e));\n    }\n    Has(e) {\n      return this._set.has(e);\n    }\n    Delete(e) {\n      this._set.delete(e) && (this._needToRebuildArray = true);\n    }\n    GetSize() {\n      return this._set.size;\n    }\n    IsEmpty() {\n      return 0 === this._set.size;\n    }\n    GetArray() {\n      return this._needToRebuildArray && (this._RebuildArray(), this._needToRebuildArray = false), this._arr;\n    }\n    _RebuildArray() {\n      const e = this._arr;\n      C33.clearArray(e);\n      for (const r of this._set) e.push(r);\n    }\n  };\n}\n{\n  const C33 = self.C3, EASE_MAP = /* @__PURE__ */ new Map(), PREDEFINED_EASE_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_EDITOR_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_RUNTIME_MAP = /* @__PURE__ */ new Map(), CUSTOM_EASE_DATA_RUNTIME_MAP = /* @__PURE__ */ new Map(), PRIVATE_EASE_MAP = /* @__PURE__ */ new Map(), BUILT_IN_TRANSITION_MAP = /* @__PURE__ */ new Map(), ALIAS_MAP = /* @__PURE__ */ new Map();\n  ALIAS_MAP.set(\"linear\", \"noease\"), ALIAS_MAP.set(\"default\", \"noease\");\n  const EASE_TRANSLATION_KEYS = [\"default\", \"noease\", \"easeinquad\", \"easeoutquad\", \"easeinoutquad\", \"easeincubic\", \"easeoutcubic\", \"easeinoutcubic\", \"easeinquart\", \"easeoutquart\", \"easeinoutquart\", \"easeinquint\", \"easeoutquint\", \"easeinoutquint\", \"easeinsine\", \"easeoutsine\", \"easeinoutsine\", \"easeinexpo\", \"easeoutexpo\", \"easeinoutexpo\", \"easeincirc\", \"easeoutcirc\", \"easeinoutcirc\", \"easeinelastic\", \"easeoutelastic\", \"easeinoutelastic\", \"easeinback\", \"easeoutback\", \"easeinoutback\", \"easeinbounce\", \"easeoutbounce\", \"easeinoutbounce\"], SHORT_EASE_TRANSLATION_KEYS = [\"default\", \"noease\", \"quad\", \"cubic\", \"quart\", \"quint\", \"sine\", \"expo\", \"circ\", \"elastic\", \"back\", \"bounce\"], EASE_API2INTERNAL_NAMES = /* @__PURE__ */ new Map([[\"linear\", \"noease\"], [\"in-sine\", \"easeinsine\"], [\"out-sine\", \"easeoutsine\"], [\"in-out-sine\", \"easeinoutsine\"], [\"in-elastic\", \"easeinelastic\"], [\"out-elastic\", \"easeoutelastic\"], [\"in-out-elastic\", \"easeinoutelastic\"], [\"in-back\", \"easeinback\"], [\"out-back\", \"easeoutback\"], [\"in-out-back\", \"easeinoutback\"], [\"in-bounce\", \"easeinbounce\"], [\"out-bounce\", \"easeoutbounce\"], [\"in-out-bounce\", \"easeinoutbounce\"], [\"in-cubic\", \"easeincubic\"], [\"out-cubic\", \"easeoutcubic\"], [\"in-out-cubic\", \"easeinoutcubic\"], [\"in-quadratic\", \"easeinquad\"], [\"out-quadratic\", \"easeoutquad\"], [\"in-out-quadratic\", \"easeinoutquad\"], [\"in-quartic\", \"easeinquart\"], [\"out-quartic\", \"easeoutquart\"], [\"in-out-quartic\", \"easeinoutquart\"], [\"in-quintic\", \"easeinquint\"], [\"out-quintic\", \"easeoutquint\"], [\"in-out-quintic\", \"easeinoutquint\"], [\"in-circular\", \"easeincirc\"], [\"out-circular\", \"easeoutcirc\"], [\"in-out-circular\", \"easeinoutcirc\"], [\"in-exponential\", \"easeinexpo\"], [\"out-exponential\", \"easeoutexpo\"], [\"in-out-exponential\", \"easeinoutexpo\"]]);\n  self.Ease = class e {\n    constructor() {\n    }\n    static InheritEase() {\n      return \"default\";\n    }\n    static DefaultEase() {\n      return \"noease\";\n    }\n    static ToInternal(e2) {\n      return EASE_API2INTERNAL_NAMES.get(e2);\n    }\n    static GetEditorEaseNames(a2, ...s) {\n      let t, i;\n      this._CreateEaseMap(), a2 ? (CUSTOM_EASE_EDITOR_MAP.has(a2) || CUSTOM_EASE_EDITOR_MAP.set(a2, /* @__PURE__ */ new Map()), t = CUSTOM_EASE_EDITOR_MAP.get(a2), i = [...t.keys()].filter((s2) => !e.GetEditorEaseData(s2, a2) || e.GetEditorEaseData(s2, a2).transition.IsForAnyPurpose())) : (t = CUSTOM_EASE_RUNTIME_MAP, i = [...t.keys()]);\n      const x = i.sort();\n      return [...PREDEFINED_EASE_MAP.keys()].concat(x).filter((e2) => !s.includes(e2));\n    }\n    static GetRuntimeEaseNames() {\n      this._CreateEaseMap();\n      const e2 = [...CUSTOM_EASE_RUNTIME_MAP.keys()];\n      return e2.sort(), [...PREDEFINED_EASE_MAP.keys()].concat(e2);\n    }\n    static GetCustomRuntimeEaseNames() {\n      this._CreateEaseMap();\n      const e2 = [...CUSTOM_EASE_RUNTIME_MAP.keys()];\n      return e2.sort(), e2;\n    }\n    static IsPredefinedTranslatedName(e2) {\n      for (const a2 of EASE_TRANSLATION_KEYS) {\n        if (self.lang(`ui.bars.timeline.eases.${a2}`) === e2) return true;\n      }\n      for (const a2 of SHORT_EASE_TRANSLATION_KEYS) {\n        if (self.lang(`ui.bars.timeline.short-eases.${a2}`) === e2) return true;\n      }\n    }\n    static IsNamePredefined(e2) {\n      return this._CreateEaseMap(), [...PREDEFINED_EASE_MAP.keys()].includes(e2);\n    }\n    static _GetEase(a2) {\n      const s = ALIAS_MAP.get(a2);\n      return s ? EASE_MAP.get(s) : e.IsNamePredefined(a2) ? EASE_MAP.get(a2) : PRIVATE_EASE_MAP.has(a2) ? PRIVATE_EASE_MAP.get(a2) : void 0;\n    }\n    static GetBuiltInTransition(e2) {\n      return this._CreateEaseMap(), BUILT_IN_TRANSITION_MAP.get(e2);\n    }\n    static GetEditorEase(a2, s) {\n      this._CreateEaseMap();\n      const t = e._GetEase(a2);\n      if (t) return t;\n      if (!s) throw new Error(\"missing ease function\");\n      return CUSTOM_EASE_EDITOR_MAP.get(s).get(a2);\n    }\n    static GetEditorEaseData(e2, a2) {\n      this._CreateEaseMap();\n      const s = CUSTOM_EASE_DATA_EDITOR_MAP.get(a2);\n      if (s) return s.get(e2);\n    }\n    static HasEditorEase(a2, s) {\n      this._CreateEaseMap();\n      return !!e._GetEase(a2) || !!CUSTOM_EASE_EDITOR_MAP.get(s).get(a2);\n    }\n    static GetRuntimeEase(a2) {\n      this._CreateEaseMap();\n      const s = e._GetEase(a2);\n      return s || CUSTOM_EASE_RUNTIME_MAP.get(a2);\n    }\n    static GetRuntimeEaseData(e2) {\n      return this._CreateEaseMap(), CUSTOM_EASE_DATA_RUNTIME_MAP.get(e2);\n    }\n    static GetEaseFromIndex(e2) {\n      this._CreateEaseMap();\n      return this.GetRuntimeEaseNames()[e2];\n    }\n    static GetIndexForEase(e2, a2) {\n      this._CreateEaseMap();\n      return this.GetEditorEaseNames(a2).indexOf(e2);\n    }\n    static GetIndexForEaseAtRuntime(e2) {\n      return this.GetIndexForEase(e2);\n    }\n    static _CreateEaseMap() {\n      0 === EASE_MAP.size && (this._AddPredifinedEase(\"default\", () => {\n      }), this._AddPredifinedEase(\"noease\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.336, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.336, \"eay\": 0, \"se\": false, \"ee\": true }], true), this._AddPredifinedEase(\"easeinsine\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.485, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.038, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutsine\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.038, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.485, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutsine\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.336, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.336, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinelastic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.018, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.116, \"y\": 2e-3, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.266, \"y\": -5e-3, \"sax\": 0.024, \"say\": 0, \"eax\": -0.021, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.416, \"y\": 0.016, \"sax\": 0.024, \"say\": 0, \"eax\": -0.026, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.566, \"y\": -0.045, \"sax\": 0.061, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.716, \"y\": 0.132, \"sax\": 0.072, \"say\": -4e-3, \"eax\": -0.045, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.866, \"y\": -0.373, \"sax\": 0.06, \"say\": 0, \"eax\": -0.049, \"eay\": -2e-3, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.038, \"eay\": -0.263, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutelastic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.038, \"say\": 0.263, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.136, \"y\": 1.373, \"sax\": 0.049, \"say\": 2e-3, \"eax\": -0.06, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.286, \"y\": 0.868, \"sax\": 0.045, \"say\": 0, \"eax\": -0.072, \"eay\": 4e-3, \"se\": true, \"ee\": true }, { \"x\": 0.436, \"y\": 1.045, \"sax\": 0.025, \"say\": 0, \"eax\": -0.061, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.586, \"y\": 0.984, \"sax\": 0.026, \"say\": 0, \"eax\": -0.024, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.736, \"y\": 1.005, \"sax\": 0.021, \"say\": 0, \"eax\": -0.024, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.886, \"y\": 0.998, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.018, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutelastic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.025, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.067, \"y\": 1e-3, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.18, \"y\": -5e-3, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.292, \"y\": 0.025, \"sax\": 0.053, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.405, \"y\": -0.118, \"sax\": 0.069, \"say\": 0, \"eax\": -0.027, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.597, \"y\": 1.118, \"sax\": 0.027, \"say\": 0, \"eax\": -0.069, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.71, \"y\": 0.975, \"sax\": 0.025, \"say\": 0, \"eax\": -0.053, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.822, \"y\": 1.005, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.935, \"y\": 0.999, \"sax\": 0.025, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinback\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.35, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.34, \"eay\": -1.579, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutback\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.34, \"say\": 1.579, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.35, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutback\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.035, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.242, \"y\": -0.1, \"sax\": 0.258, \"say\": 0, \"eax\": -0.025, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 0.76, \"y\": 1.1, \"sax\": 0.025, \"say\": 0, \"eax\": -0.26, \"eay\": 0, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.035, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinbounce\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.033, \"say\": 0.025, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.092, \"y\": 0, \"sax\": 0.026, \"say\": 0.078, \"eax\": -0.033, \"eay\": 0.025, \"se\": true, \"ee\": true }, { \"x\": 0.274, \"y\": 0, \"sax\": 0.097, \"say\": 0.319, \"eax\": -0.026, \"eay\": 0.078, \"se\": true, \"ee\": true }, { \"x\": 0.637, \"y\": 0, \"sax\": 0.105, \"say\": 0.625, \"eax\": -0.097, \"eay\": 0.319, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.125, \"eay\": -4e-3, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutbounce\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.125, \"say\": 4e-3, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.365, \"y\": 1, \"sax\": 0.097, \"say\": -0.319, \"eax\": -0.105, \"eay\": -0.625, \"se\": true, \"ee\": true }, { \"x\": 0.728, \"y\": 1, \"sax\": 0.026, \"say\": -0.078, \"eax\": -0.097, \"eay\": -0.319, \"se\": true, \"ee\": true }, { \"x\": 0.91, \"y\": 1, \"sax\": 0.033, \"say\": -0.025, \"eax\": -0.026, \"eay\": -0.078, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.033, \"eay\": -0.025, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutbounce\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.01, \"say\": 6e-3, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.046, \"y\": 0, \"sax\": 0.021, \"say\": 0.038, \"eax\": -0.01, \"eay\": 6e-3, \"se\": true, \"ee\": true }, { \"x\": 0.137, \"y\": 0, \"sax\": 0.059, \"say\": 0.158, \"eax\": -0.021, \"eay\": 0.038, \"se\": true, \"ee\": true }, { \"x\": 0.319, \"y\": 0, \"sax\": 0.117, \"say\": 0.744, \"eax\": -0.059, \"eay\": 0.158, \"se\": true, \"ee\": true }, { \"x\": 0.683, \"y\": 1, \"sax\": 0.059, \"say\": -0.158, \"eax\": -0.117, \"eay\": -0.744, \"se\": true, \"ee\": true }, { \"x\": 0.865, \"y\": 1, \"sax\": 0.021, \"say\": -0.038, \"eax\": -0.059, \"eay\": -0.158, \"se\": true, \"ee\": true }, { \"x\": 0.956, \"y\": 1, \"sax\": 0.01, \"say\": -6e-3, \"eax\": -0.021, \"eay\": -0.038, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.01, \"eay\": -6e-3, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeincubic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.75, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.138, \"eay\": -0.321, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutcubic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.138, \"say\": 0.321, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.75, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutcubic\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.285, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.5, \"y\": 0.5, \"sax\": 0.081, \"say\": 0.272, \"eax\": -0.081, \"eay\": -0.272, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.285, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinquad\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.4, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.178, \"eay\": -0.392, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutquad\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.178, \"say\": 0.392, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.4, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutquad\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.25, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.5, \"y\": 0.5, \"sax\": 0.03, \"say\": 0.065, \"eax\": -0.03, \"eay\": -0.065, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.25, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinquart\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.25, \"say\": 1, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.5, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutquart\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.5, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.25, \"eay\": -1, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutquart\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.765, \"say\": 0.03, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.765, \"eay\": -0.03, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinquint\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.6, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.2, \"eay\": -1, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutquint\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.2, \"say\": 1, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.6, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutquint\", [{ \"eax\": 0, \"eay\": 0, \"ee\": false, \"sax\": 0.84, \"say\": 0, \"se\": true, \"x\": 0, \"y\": 0 }, { \"eax\": -0.84, \"eay\": 0, \"ee\": true, \"sax\": 0, \"say\": 0, \"se\": false, \"x\": 1, \"y\": 1 }]), this._AddPredifinedEase(\"easeincirc\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.25, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.024, \"eay\": -0.808, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutcirc\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.024, \"say\": 0.808, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.25, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutcirc\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.125, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 0.5, \"y\": 0.5, \"sax\": 0.02, \"say\": 0.428, \"eax\": -0.02, \"eay\": -0.428, \"se\": true, \"ee\": true }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.125, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinexpo\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.66, \"say\": 0, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.14, \"eay\": -1, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeoutexpo\", [{ \"x\": 0, \"y\": 0, \"sax\": 0.14, \"say\": 1, \"eax\": 0, \"eay\": 0, \"se\": true, \"ee\": false }, { \"x\": 1, \"y\": 1, \"sax\": 0, \"say\": 0, \"eax\": -0.66, \"eay\": 0, \"se\": false, \"ee\": true }]), this._AddPredifinedEase(\"easeinoutexpo\", [{ \"eax\": 0, \"eay\": 0, \"ee\": false, \"sax\": 0.345, \"say\": 0, \"se\": true, \"x\": 0, \"y\": 0 }, { \"eax\": -0.06, \"eay\": -0.5, \"ee\": true, \"sax\": 0.06, \"say\": 0.5, \"se\": true, \"x\": 0.5, \"y\": 0.5 }, { \"eax\": -0.335, \"eay\": 0, \"ee\": true, \"sax\": 0, \"say\": 0, \"se\": false, \"x\": 1, \"y\": 1 }]), this._AddPrivateCustomEase(\"cubicbezier\", this.EaseCubicBezier), this._AddPrivateCustomEase(\"spline\", this.EaseSpline));\n    }\n    static _AddPredifinedEase(a2, s, t = false) {\n      if (\"function\" == typeof s) e._AddEase(a2, s, \"predefined\");\n      else {\n        if (!C33.IsArray(s)) throw new Error(\"unexpected arguments\");\n        if (self.BuiltInTransition) {\n          const i = C33.New(self.BuiltInTransition, a2, t);\n          i.SetFromJson(s), e._AddEase(a2, (e2, a3, s2, t2) => i.Interpolate(e2, a3, s2, t2), \"predefined\"), BUILT_IN_TRANSITION_MAP.set(a2, i);\n        } else {\n          const i = C33.New(C33.Transition, [a2, s.map((e2) => [e2[\"x\"], e2[\"y\"], e2[\"sax\"], e2[\"say\"], e2[\"eax\"], e2[\"eay\"], e2[\"se\"], e2[\"ee\"]])], false);\n          i.MakeLinear(t), e._AddEase(a2, (e2, a3, s2, t2) => i.Interpolate(e2, a3, s2, t2), \"predefined\");\n        }\n      }\n    }\n    static _AddPrivateCustomEase(a2, s) {\n      e._AddEase(a2, s, \"private\");\n    }\n    static AddCustomEase(a2, s, t, i) {\n      this._CreateEaseMap(), e._AddEase(a2, s, \"custom\", t, i);\n    }\n    static RemoveCustomEase(e2, a2) {\n      if (this.IsNamePredefined(e2)) return;\n      if ([...PRIVATE_EASE_MAP.keys()].includes(e2)) return;\n      const s = CUSTOM_EASE_EDITOR_MAP.get(a2);\n      s && s.delete(e2);\n      const t = CUSTOM_EASE_DATA_EDITOR_MAP.get(a2);\n      t && t.delete(e2);\n    }\n    static _AddEase(e2, a2, s, t, i) {\n      switch (s) {\n        case \"predefined\":\n          EASE_MAP.set(e2, a2), PREDEFINED_EASE_MAP.set(e2, a2);\n          break;\n        case \"custom\":\n          if (t) {\n            CUSTOM_EASE_EDITOR_MAP.has(t) || CUSTOM_EASE_EDITOR_MAP.set(t, /* @__PURE__ */ new Map()), CUSTOM_EASE_DATA_EDITOR_MAP.has(t) || CUSTOM_EASE_DATA_EDITOR_MAP.set(t, /* @__PURE__ */ new Map());\n            CUSTOM_EASE_EDITOR_MAP.get(t).set(e2, a2);\n            CUSTOM_EASE_DATA_EDITOR_MAP.get(t).set(e2, i);\n          } else CUSTOM_EASE_RUNTIME_MAP.set(e2, a2), CUSTOM_EASE_DATA_RUNTIME_MAP.set(e2, i);\n          break;\n        case \"private\":\n          EASE_MAP.set(e2, a2), PRIVATE_EASE_MAP.set(e2, a2);\n          break;\n        default:\n          throw new Error(\"unexpected ease mode\");\n      }\n    }\n    static NoEase(e2, a2, s, t) {\n      return 0 === t ? a2 : s * e2 / t + a2;\n    }\n    static EaseCubicBezier(e2, a2, s, t, i) {\n      return a2 + 3 * e2 * (s - a2) + 3 * e2 ** 2 * (a2 + t - 2 * s) + e2 ** 3 * (i - a2 + 3 * s - 3 * t);\n    }\n    static EaseSpline(e2, s, t, i, x, y, n, E, _, r) {\n      if (i === x && y === n) return e2;\n      const u = get_t_for_x(e2, s, i, y, E, r), d = a(t, x, n, _), A = b(t, x, n, _), o = c(t, x, n, _);\n      return calc_bezier(u, d, A, o);\n    }\n    static GetBezierSamples(e2, s, t, i) {\n      const x = [], y = a(e2, s, t, i), n = b(e2, s, t, i), E = c(e2, s, t, i);\n      for (let e3 = 0; e3 < SAMPLE_COUNT; ++e3) {\n        const a2 = calc_bezier(e3 * SAMPLE_STEP, y, n, E);\n        x.push(a2);\n      }\n      return x;\n    }\n  };\n  const SAMPLE_COUNT = 11, SAMPLE_STEP = 1 / (SAMPLE_COUNT - 1), NEWTON_RAPHSON_ITERATIONS = 4, NEWTON_RAPHSON_MIN_SLOPE = 0.01, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, a = (e, a2, s, t) => t - 3 * s + 3 * a2 - e, b = (e, a2, s, t) => 3 * s - 6 * a2 + 3 * e, c = (e, a2, s, t) => 3 * (a2 - e), calc_bezier = (e, a2, s, t) => ((a2 * e + s) * e + t) * e, get_slope = (e, a2, s, t) => 3 * a2 * e * e + 2 * s * e + t, get_t_for_x = (e, s, t, i, x, y) => {\n    if (1 == e) return 1;\n    let n = 0, E = 1, _ = y[E], r = SAMPLE_COUNT - 1;\n    y[SAMPLE_COUNT - 1];\n    for (; E != r && _ <= e; ) E++, _ = y[E], n += SAMPLE_STEP;\n    E--, _ = y[E];\n    let u = n + (e - _) / (y[E + 1] - _) * SAMPLE_STEP;\n    const d = a(s, t, i, x), A = b(s, t, i, x), o = c(s, t, i, x), M = get_slope(u, d, A, o);\n    if (0 === M) return u;\n    if (M >= 0.01) {\n      for (let a2 = 0; a2 < 4; ++a2) {\n        u -= (calc_bezier(u, d, A, o) - e) / get_slope(u, d, A, o);\n      }\n      return u;\n    }\n    {\n      let a2, s2, t2 = n, i2 = n + SAMPLE_STEP, x2 = 0;\n      do {\n        u = t2 + (i2 - t2) / 2;\n        let y2 = calc_bezier(u, d, A, o) - e;\n        y2 > 0 ? i2 = u : t2 = u, a2 = Math.abs(y2) > 1e-7, s2 = ++x2 < 10;\n      } while (a2 && s2);\n      return u;\n    }\n  };\n}\n{\n  let RequireStringOrNumber = function(t) {\n    C33.IsString(t);\n  };\n  RequireStringOrNumber2 = RequireStringOrNumber;\n  const C33 = self.C3;\n  C33.ProbabilityTable = class {\n    constructor(t) {\n      this._items = [], this._name = t || \"\", this._totalWeight = 0;\n    }\n    Release() {\n      this.Clear(), this._items = null;\n    }\n    GetName() {\n      return this._name;\n    }\n    Clear() {\n      C33.clear2DArray(this._items), this._totalWeight = 0;\n    }\n    GetTotalWeight() {\n      return this._totalWeight;\n    }\n    Sample(t = Math.random() * this.GetTotalWeight()) {\n      let e = 0;\n      for (const [i, s] of this._items) if (e += i, t < e) return s;\n      return 0;\n    }\n    HasItems() {\n      return !!this._items.length;\n    }\n    AddItem(t, e) {\n      RequireStringOrNumber(e), this._totalWeight += t, this._items.push([t, e]);\n    }\n    RemoveItem(t, e) {\n      RequireStringOrNumber(e);\n      const i = 0 === t;\n      for (let s = 0; s < this._items.length; s++) {\n        const r = this._items[s], h = i || r[0] === t, n = r[1] === e;\n        if (h && n) {\n          this._items.splice(s, 1), this._totalWeight -= r[0];\n          break;\n        }\n      }\n    }\n    asJSON() {\n      return JSON.stringify(this._items);\n    }\n    static fromJSON(t, e) {\n      const i = new C33.ProbabilityTable(e), s = JSON.parse(t);\n      for (const t2 of s) {\n        const e2 = t2[0], s2 = t2[1];\n        i.AddItem(e2, s2);\n      }\n      return i;\n    }\n  };\n}\nvar RequireStringOrNumber2;\n{\n  const C33 = self.C3;\n  let nextId = 0;\n  C33.ScreenReaderText = class {\n    constructor(t, e) {\n      this._runtime = t, this._text = e, this._id = nextId++, this._runtime.PostComponentMessageToDOM(\"runtime\", \"screen-reader-text\", { \"type\": \"create\", \"id\": this._id, \"text\": this._text });\n    }\n    Release() {\n      this._runtime.PostComponentMessageToDOM(\"runtime\", \"screen-reader-text\", { \"type\": \"release\", \"id\": this._id }), this._runtime = null, this._text = \"\", this._id = -1;\n    }\n    SetText(t) {\n      this._text !== t && (this._text = t, this._runtime.PostComponentMessageToDOM(\"runtime\", \"screen-reader-text\", { \"type\": \"update\", \"id\": this._id, \"text\": this._text }));\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Event = class {\n    constructor(t, e) {\n      this.type = t, this.cancelable = !!e, this.defaultPrevented = false, this.propagationStopped = false, this.isAsync = false;\n    }\n    preventDefault() {\n      if (!this.cancelable) throw new Error(`event '${this.type}' is not cancelable`);\n      this.defaultPrevented = true;\n    }\n    stopPropagation() {\n      if (!this.cancelable) throw new Error(`event '${this.type}' cannot be stopped`);\n      if (this.isAsync) throw new Error(`cannot stop async event '${this.type}' propagation`);\n      this.propagationStopped = true;\n    }\n  };\n}\n{\n  const C33 = self.C3, assert = self.assert;\n  C33.Event.Handler = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._type = e, this._captureListeners = [], this._captureListenersSet = /* @__PURE__ */ new Set(), this._listeners = [], this._listenersSet = /* @__PURE__ */ new Set(), this._fireDepth = 0, this._queueModifyListeners = [];\n    }\n    Release() {\n      this._fireDepth > 0 || (C33.clearArray(this._captureListeners), this._captureListenersSet.clear(), C33.clearArray(this._listeners), this._listenersSet.clear(), C33.clearArray(this._queueModifyListeners), C33.Release(this));\n    }\n    _AddListener(e, t) {\n      if (this._IsFiring()) this._queueModifyListeners.push({ op: \"add\", func: e, capture: t });\n      else if (t) {\n        if (this._captureListenersSet.has(e)) return;\n        this._captureListeners.push(e), this._captureListenersSet.add(e);\n      } else {\n        if (this._listenersSet.has(e)) return;\n        this._listeners.push(e), this._listenersSet.add(e);\n      }\n    }\n    _RemoveListener(e, t) {\n      this._IsFiring() ? this._queueModifyListeners.push({ op: \"remove\", func: e, capture: t }) : t ? this._captureListenersSet.has(e) && (this._captureListenersSet.delete(e), C33.arrayFindRemove(this._captureListeners, e)) : this._listenersSet.has(e) && (this._listenersSet.delete(e), C33.arrayFindRemove(this._listeners, e));\n    }\n    _IsEmpty() {\n      return !this._captureListeners.length && !this._listeners.length;\n    }\n    _IsFiring() {\n      return this._fireDepth > 0;\n    }\n    _ProcessQueuedListeners() {\n      const e = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();\n      for (const s of this._queueModifyListeners) if (\"add\" === s.op) this._AddListener(s.func, s.capture), s.capture ? t.delete(s.func) : e.delete(s.func);\n      else {\n        if (\"remove\" !== s.op) throw new Error(\"invalid op\");\n        s.capture ? (this._captureListenersSet.delete(s.func), t.add(s.func)) : (this._listenersSet.delete(s.func), e.add(s.func));\n      }\n      C33.arrayRemoveAllInSet(this._listeners, e), C33.arrayRemoveAllInSet(this._captureListeners, t), C33.clearArray(this._queueModifyListeners);\n    }\n    _FireCancellable(e) {\n      this._IncreaseFireDepth();\n      let t = false;\n      for (let s = 0, r = this._captureListeners.length; s < r; ++s) if (this._captureListeners[s](e), e.propagationStopped) {\n        t = true;\n        break;\n      }\n      if (!t) for (let t2 = 0, s = this._listeners.length; t2 < s && (this._listeners[t2](e), !e.propagationStopped); ++t2) ;\n      return this._DecreaseFireDepth(), !e.defaultPrevented;\n    }\n    _FireNonCancellable(e) {\n      this._IncreaseFireDepth();\n      for (let t = 0, s = this._captureListeners.length; t < s; ++t) this._captureListeners[t](e);\n      for (let t = 0, s = this._listeners.length; t < s; ++t) this._listeners[t](e);\n      return this._DecreaseFireDepth(), true;\n    }\n    _IncreaseFireDepth() {\n      this._fireDepth++;\n    }\n    _DecreaseFireDepth() {\n      this._fireDepth--, 0 === this._fireDepth && this._queueModifyListeners.length > 0 && this._ProcessQueuedListeners();\n    }\n    SetDelayRemoveEventsEnabled(e) {\n      e ? this._IncreaseFireDepth() : this._DecreaseFireDepth();\n    }\n    _FireAsync(e) {\n      let t = [];\n      for (let s = 0, r = this._captureListeners.length; s < r; ++s) {\n        let r2 = this._captureListeners[s];\n        t.push(C33.Asyncify(() => r2(e)));\n      }\n      for (let s = 0, r = this._listeners.length; s < r; ++s) {\n        let r2 = this._listeners[s];\n        t.push(C33.Asyncify(() => r2(e)));\n      }\n      return Promise.all(t).then(() => !e.defaultPrevented);\n    }\n    _FireAndWait_AsyncOptional(e) {\n      const t = [];\n      this._IncreaseFireDepth();\n      for (let s = 0, r = this._captureListeners.length; s < r; ++s) {\n        const r2 = this._captureListeners[s](e);\n        r2 instanceof Promise && t.push(r2);\n      }\n      for (let s = 0, r = this._listeners.length; s < r; ++s) {\n        const r2 = this._listeners[s](e);\n        r2 instanceof Promise && t.push(r2);\n      }\n      return this._DecreaseFireDepth(), t.length ? Promise.all(t).then(() => !e.defaultPrevented) : !e.defaultPrevented;\n    }\n    async _FireAndWaitAsync(e) {\n      return await this._FireAndWait_AsyncOptional(e);\n    }\n    async _FireAndWaitAsyncSequential(e) {\n      this._IncreaseFireDepth();\n      for (let t = 0, s = this._captureListeners.length; t < s; ++t) {\n        const s2 = this._captureListeners[t](e);\n        s2 instanceof Promise && await s2;\n      }\n      for (let t = 0, s = this._listeners.length; t < s; ++t) {\n        const s2 = this._listeners[t](e);\n        s2 instanceof Promise && await s2;\n      }\n      return this._DecreaseFireDepth(), !e.defaultPrevented;\n    }\n    *_FireAsGenerator(e) {\n      this._IncreaseFireDepth();\n      for (let t = 0, s = this._captureListeners.length; t < s; ++t) {\n        const s2 = this._captureListeners[t](e);\n        C33.IsIterator(s2) && (yield* s2);\n      }\n      for (let t = 0, s = this._listeners.length; t < s; ++t) {\n        const s2 = this._listeners[t](e);\n        C33.IsIterator(s2) && (yield* s2);\n      }\n      this._DecreaseFireDepth();\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Event.Dispatcher = class extends C33.DefendedBase {\n    constructor() {\n      super(), this._eventHandlers = /* @__PURE__ */ new Map(), this._dispatcherWasReleased = false;\n    }\n    Release() {\n      if (this._dispatcherWasReleased) throw new Error(\"already released\");\n      this.ClearEvents(), this._dispatcherWasReleased = true, C33.Release(this);\n    }\n    WasReleased() {\n      return this._dispatcherWasReleased;\n    }\n    ClearEvents() {\n      if (this._eventHandlers) {\n        for (let e of this._eventHandlers.values()) e.Release();\n        this._eventHandlers.clear();\n      }\n    }\n    _GetHandlerByType(e, t) {\n      let n = this._eventHandlers.get(e);\n      return n || (t ? (n = C33.New(C33.Event.Handler, e), this._eventHandlers.set(e, n), n) : null);\n    }\n    HasAnyHandlerFor(e) {\n      return this._eventHandlers.has(e);\n    }\n    addEventListener(e, t, n) {\n      this._GetHandlerByType(e, true)._AddListener(t, !!n);\n    }\n    removeEventListener(e, t, n) {\n      let s = this._GetHandlerByType(e, false);\n      s && (s._RemoveListener(t, !!n), s._IsEmpty() && this._eventHandlers.delete(e));\n    }\n    dispatchEvent(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      return !t || (e.cancelable ? t._FireCancellable(e) : t._FireNonCancellable(e));\n    }\n    dispatchEventAsync(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      return t ? (e.isAsync = true, t._FireAsync(e)) : Promise.resolve(true);\n    }\n    async dispatchEventAndClearAsync(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      if (!t) return true;\n      this._eventHandlers.delete(e.type), e.isAsync = true;\n      const n = await t._FireAsync(e);\n      return t.Release(), n;\n    }\n    async dispatchEventAndWaitAsync(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      return !t || await t._FireAndWaitAsync(e);\n    }\n    dispatchEventAndWait_AsyncOptional(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      return !t || t._FireAndWait_AsyncOptional(e);\n    }\n    async dispatchEventAndWaitAsyncSequential(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      return !t || await t._FireAndWaitAsyncSequential(e);\n    }\n    dispatchGeneratorEvent(e) {\n      const t = this._GetHandlerByType(e.type, false);\n      if (!t) return null;\n      if (e.cancelable) throw new Error(\"not supported\");\n      return t._FireAsGenerator(e);\n    }\n    SetDelayRemoveEventsEnabled(e) {\n      for (const t of this._eventHandlers.values()) t.SetDelayRemoveEventsEnabled(e);\n    }\n  };\n}\n{\n  let SetNewCallback = function(e) {\n    callbackId = SUPPORTS_RIC && 0 === highThroughputMode ? requestIdleCallback(DoAsyncifiedWork, { timeout: 35 }) : setTimeout(DoAsyncifiedWork, highThroughputMode > 0 ? 1 : e);\n  }, DoAsyncifiedWork = function(e) {\n    if (callbackId = -1, !workQueue.length) return;\n    let o = performance.now(), i = o, t = 0, n = 0;\n    do {\n      DoNextAsyncifiedJob(workQueue.shift()), i = performance.now(), ++t, n = (i - o) / t * 1.1;\n    } while (workQueue.length && (SUPPORTS_RIC && 0 === highThroughputMode && void 0 !== e ? n < e[\"timeRemaining\"]() : i - o + n < 12));\n    if (-1 === callbackId && workQueue.length) {\n      let e2 = i - o;\n      SetNewCallback(Math.max(16 - e2, 4));\n    }\n  }, DoNextAsyncifiedJob = function(e) {\n    let o;\n    try {\n      o = e.func();\n    } catch (o2) {\n      return void e.reject(o2);\n    }\n    e.resolve(o);\n  };\n  SetNewCallback2 = SetNewCallback, DoAsyncifiedWork2 = DoAsyncifiedWork, DoNextAsyncifiedJob2 = DoNextAsyncifiedJob;\n  const C33 = self.C3, SETTIMEOUT_WORK_DURATION = 12, SETTIMEOUT_INTERVAL = 16, IDLECALLBACK_TIMEOUT = 35, SUPPORTS_RIC = \"undefined\" != typeof requestIdleCallback;\n  let workQueue = [], callbackId = -1, highThroughputMode = 0;\n  let asyncifyDisabled = C33.QueryString.Has(\"disable-asyncify\");\n  asyncifyDisabled && console.warn(\"[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.\"), C33.Asyncify = function(e) {\n    let o = null;\n    return C33.isDebug && (o = C33.GetCallStack()), new Promise((i, t) => {\n      workQueue.push({ func: e, resolve: i, reject: t, stack: o }), asyncifyDisabled ? DoNextAsyncifiedJob(workQueue.pop()) : -1 === callbackId && SetNewCallback(16);\n    });\n  }, C33.Asyncify.SetHighThroughputMode = function(e) {\n    if (e) ++highThroughputMode;\n    else if (--highThroughputMode, highThroughputMode < 0) throw new Error(\"already turned off high throughput mode\");\n  };\n}\nvar SetNewCallback2;\nvar DoAsyncifiedWork2;\nvar DoNextAsyncifiedJob2;\n{\n  let ClearTimeCache = function() {\n    cachedNowTime = -1;\n  }, CheckActiveIdleTimeouts = function() {\n    timerId = -1, nextDeadline = -1;\n    let e = Date.now();\n    for (let t of activeIdleTimeouts) if (t._CheckTimeout(e)) {\n      let e2 = t._GetDeadline();\n      (-1 === nextDeadline || e2 < nextDeadline) && (nextDeadline = e2);\n    } else activeIdleTimeouts.delete(t);\n    if (-1 !== nextDeadline) {\n      let t = Math.max(nextDeadline - e + 100, 1e3);\n      timerId = self.setTimeout(CheckActiveIdleTimeouts, t);\n    }\n  };\n  ClearTimeCache2 = ClearTimeCache, CheckActiveIdleTimeouts2 = CheckActiveIdleTimeouts;\n  const C33 = self.C3, IDLE_CHECK_MIN_INTERVAL = 1e3, IDLE_CHECK_TIMER_OVERSHOOT = 100;\n  let cachedNowTime = -1;\n  C33.FastGetDateNow = function() {\n    return -1 === cachedNowTime && (cachedNowTime = Date.now(), self.setTimeout(ClearTimeCache, 16)), cachedNowTime;\n  };\n  let timerId = -1, nextDeadline = -1, activeIdleTimeouts = /* @__PURE__ */ new Set();\n  C33.IdleTimeout = class {\n    constructor(e, t) {\n      this._callback = e, this._timeout = 1e3 * t, this._deadline = 0, this._isActive = false;\n    }\n    Reset() {\n      let e = C33.FastGetDateNow();\n      this._deadline = e + this._timeout, this._isActive || (activeIdleTimeouts.add(this), this._isActive = true), -1 === timerId ? (nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + 100)) : this._deadline < nextDeadline && nextDeadline > e + 1e3 && (self.clearTimeout(timerId), nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + 100));\n    }\n    _CheckTimeout(e) {\n      return !(e >= this._deadline) || (this._callback() ? (this._deadline = e + this._timeout, true) : (this._isActive = false, false));\n    }\n    _GetDeadline() {\n      return this._deadline;\n    }\n    Cancel() {\n      this._isActive && (activeIdleTimeouts.delete(this), this._isActive = false, 0 === activeIdleTimeouts.size && -1 !== timerId && (self.clearTimeout(timerId), timerId = -1, nextDeadline = -1));\n    }\n    Release() {\n      this.Cancel(), this._callback = null;\n    }\n  };\n}\nvar ClearTimeCache2;\nvar CheckActiveIdleTimeouts2;\n{\n  const C33 = self.C3;\n  C33.Disposable = class s {\n    constructor(s2) {\n      this._disposed = false, this._disposeAction = s2;\n    }\n    Dispose() {\n      this._disposed || (this._disposed = true, this._disposeAction && (this._disposeAction(), this._disposeAction = null));\n    }\n    IsDisposed() {\n      return this._disposed;\n    }\n    Release() {\n      this.Dispose();\n    }\n    static Release(e) {\n      return new s(() => e.Release());\n    }\n    static From(s2, e, i, o, t) {\n      if (\"string\" != typeof e && !Array.isArray(e)) throw new TypeError(\"expected string or array\");\n      if (null == o) o = false;\n      else if (\"boolean\" != typeof o && \"object\" != typeof o) throw new TypeError(\"invalid event listener options\");\n      if (t && (i = i.bind(t)), Array.isArray(e) || e.includes(\" \")) {\n        \"string\" == typeof e && (e = e.split(\" \"));\n        const t2 = new C33.CompositeDisposable();\n        for (const r of e) s2.addEventListener(r, i, o), t2.Add(C33.New(C33.Disposable, () => s2.removeEventListener(r, i, o)));\n        return t2;\n      }\n      return s2.addEventListener(e, i, o), C33.New(C33.Disposable, () => s2.removeEventListener(e, i, o));\n    }\n  }, C33.StubDisposable = class extends C33.Disposable {\n    SetAction(s) {\n      this._disposeAction = s;\n    }\n  }, C33.CompositeDisposable = class extends C33.Disposable {\n    constructor(...s) {\n      super(), this._disposables = /* @__PURE__ */ new Set();\n      for (let e of s) this.Add(e);\n    }\n    Add(...s) {\n      if (this._disposed) throw new Error(\"already disposed\");\n      for (let e of s) this._disposables.add(e);\n    }\n    Remove(s) {\n      if (this._disposed) throw new Error(\"already disposed\");\n      this._disposables.delete(s);\n    }\n    RemoveAll() {\n      if (this._disposed) throw new Error(\"already disposed\");\n      if (this._disposables) {\n        for (let s of this._disposables) s.Dispose();\n        this._disposables.clear();\n      }\n    }\n    IsDisposed() {\n      return this._disposed;\n    }\n    Dispose() {\n      if (this._disposed) throw new Error(\"already disposed\");\n      this._disposed = true;\n      for (let s of this._disposables) s.Dispose();\n      this._disposables.clear(), this._disposables = null;\n    }\n    Release() {\n      this.Dispose();\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.KahanSum = class extends C33.DefendedBase {\n    constructor() {\n      super(), this._c = 0, this._y = 0, this._t = 0, this._sum = 0;\n    }\n    Add(s) {\n      s = +s, this._y = s - this._c, this._t = this._sum + this._y, this._c = this._t - this._sum - this._y, this._sum = this._t;\n    }\n    Subtract(s) {\n      this._sum -= +s;\n    }\n    Get() {\n      return this._sum;\n    }\n    Reset() {\n      this._c = 0, this._y = 0, this._t = 0, this._sum = 0;\n    }\n    Set(s) {\n      this._c = 0, this._y = 0, this._t = 0, this._sum = +s;\n    }\n    Copy(s) {\n      this._c = s._c, this._y = s._y, this._t = s._t, this._sum = s._sum;\n    }\n    Release() {\n    }\n  };\n}\n{\n  const C33 = self.C3, js_cols = {}, RED = true, BLACK = false;\n  js_cols.RBnode = function(t) {\n    this.tree = t, this.right = this.tree.sentinel, this.left = this.tree.sentinel, this.parent = null, this.color = false, this.key = null;\n  }, js_cols.RedBlackSet = function(t) {\n    this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = false, this.root = this.sentinel, this.root.parent = this.sentinel, this.compare = t || this.default_compare;\n  }, js_cols.RedBlackSet.prototype.default_compare = function(t, e) {\n    return t < e ? -1 : e < t ? 1 : 0;\n  }, js_cols.RedBlackSet.prototype.clone = function() {\n    var t = new js_cols.RedBlackSet(this.compare);\n    return t.insertAll(this), t;\n  }, js_cols.RedBlackSet.prototype.clear = function() {\n    this.size = 0, this.sentinel = new js_cols.RBnode(this), this.sentinel.color = false, this.root = this.sentinel, this.root.parent = this.sentinel;\n  }, js_cols.RedBlackSet.prototype.leftRotate = function(t) {\n    var e = t.right;\n    t.right = e.left, e.left != this.sentinel && (e.left.parent = t), e.parent = t.parent, t.parent == this.sentinel ? this.root = e : t == t.parent.left ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;\n  }, js_cols.RedBlackSet.prototype.rightRotate = function(t) {\n    var e = t.left;\n    t.left = e.right, e.right != this.sentinel && (e.right.parent = t), e.parent = t.parent, t.parent == this.sentinel ? this.root = e : t == t.parent.right ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;\n  }, js_cols.RedBlackSet.prototype.insert = function(t) {\n    if (this.contains(t)) {\n      this.get_(t).key = t;\n    } else {\n      var e = new js_cols.RBnode(this);\n      e.key = t;\n      for (var s = this.sentinel, r = this.root; r != this.sentinel; ) s = r, r = this.compare(e.key, r.key) < 0 ? r.left : r.right;\n      e.parent = s, s == this.sentinel ? this.root = e : this.compare(e.key, s.key) < 0 ? s.left = e : s.right = e, e.left = this.sentinel, e.right = this.sentinel, e.color = RED, this.insertFixup(e), this.size++;\n    }\n  }, js_cols.RedBlackSet.prototype.insertFixup = function(t) {\n    for (; t != this.sentinel && t != this.root && t.parent.color == RED; ) {\n      var e;\n      if (t.parent == t.parent.parent.left) (e = t.parent.parent.right).color == RED ? (t.parent.color = false, e.color = false, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.right && (t = t.parent, this.leftRotate(t)), t.parent.color = false, t.parent.parent.color = RED, t.parent.parent != this.sentinel && this.rightRotate(t.parent.parent));\n      else (e = t.parent.parent.left).color == RED ? (t.parent.color = false, e.color = false, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.left && (t = t.parent, this.rightRotate(t)), t.parent.color = false, t.parent.parent.color = RED, t.parent.parent != this.sentinel && this.leftRotate(t.parent.parent));\n    }\n    this.root.color = false;\n  }, js_cols.RedBlackSet.prototype.delete_ = function(t) {\n    var e, s;\n    (s = (e = t.left == this.sentinel || t.right == this.sentinel ? t : this.successor_(t)).left != this.sentinel ? e.left : e.right).parent = e.parent, e.parent == this.sentinel ? this.root = s : e == e.parent.left ? e.parent.left = s : e.parent.right = s, e != t && (t.key = e.key), false == e.color && this.deleteFixup(s), this.size--;\n  }, js_cols.RedBlackSet.prototype.deleteFixup = function(t) {\n    for (; t != this.root && false == t.color; ) {\n      var e;\n      if (t == t.parent.left) (e = t.parent.right).color == RED && (e.color = false, t.parent.color = RED, this.leftRotate(t.parent), e = t.parent.right), false == e.left.color && false == e.right.color ? (e.color = RED, t = t.parent) : (false == e.right.color && (e.left.color = false, e.color = RED, this.rightRotate(e), e = t.parent.right), e.color = t.parent.color, t.parent.color = false, e.right.color = false, this.leftRotate(t.parent), t = this.root);\n      else (e = t.parent.left).color == RED && (e.color = false, t.parent.color = RED, this.rightRotate(t.parent), e = t.parent.left), false == e.right.color && false == e.left.color ? (e.color = RED, t = t.parent) : (false == e.left.color && (e.right.color = false, e.color = RED, this.leftRotate(e), e = t.parent.left), e.color = t.parent.color, t.parent.color = false, e.left.color = false, this.rightRotate(t.parent), t = this.root);\n    }\n    t.color = false;\n  }, js_cols.RedBlackSet.prototype.remove = function(t) {\n    var e = this.get_(t);\n    if (e != this.sentinel) {\n      var s = e.key;\n      return this.delete_(e), s;\n    }\n    return null;\n  }, js_cols.RedBlackSet.prototype.removeSwapped = function(t, e) {\n    this.remove(e);\n  }, js_cols.RedBlackSet.prototype.min = function(t) {\n    for (; t.left != this.sentinel; ) t = t.left;\n    return t;\n  }, js_cols.RedBlackSet.prototype.max = function(t) {\n    for (; t.right != this.sentinel; ) t = t.right;\n    return t;\n  }, js_cols.RedBlackSet.prototype.successor_ = function(t) {\n    if (t.right != this.sentinel) return this.min(t.right);\n    for (var e = t.parent; e != this.sentinel && t == e.right; ) t = e, e = e.parent;\n    return e;\n  }, js_cols.RedBlackSet.prototype.predeccessor_ = function(t) {\n    if (t.left != this.sentinel) return this.max(t.left);\n    for (var e = t.parent; e != this.sentinel && t == e.left; ) t = e, e = e.parent;\n    return e;\n  }, js_cols.RedBlackSet.prototype.successor = function(t) {\n    if (this.size > 0) {\n      var e = this.get_(t);\n      if (e == this.sentinel) return null;\n      if (e.right != this.sentinel) return this.min(e.right).key;\n      for (var s = e.parent; s != this.sentinel && e == s.right; ) e = s, s = s.parent;\n      return s != this.sentinel ? s.key : null;\n    }\n    return null;\n  }, js_cols.RedBlackSet.prototype.predecessor = function(t) {\n    if (this.size > 0) {\n      var e = this.get_(t);\n      if (e == this.sentinel) return null;\n      if (e.left != this.sentinel) return this.max(e.left).key;\n      for (var s = e.parent; s != this.sentinel && e == s.left; ) e = s, s = s.parent;\n      return s != this.sentinel ? s.key : null;\n    }\n    return null;\n  }, js_cols.RedBlackSet.prototype.getMin = function() {\n    return this.min(this.root).key;\n  }, js_cols.RedBlackSet.prototype.getMax = function() {\n    return this.max(this.root).key;\n  }, js_cols.RedBlackSet.prototype.get_ = function(t) {\n    for (var e = this.root; e != this.sentinel && 0 != this.compare(e.key, t); ) e = this.compare(t, e.key) < 0 ? e.left : e.right;\n    return e;\n  }, js_cols.RedBlackSet.prototype.contains = function(t) {\n    return null != this.get_(t).key;\n  }, js_cols.RedBlackSet.prototype.getValues = function() {\n    var t = [];\n    return this.forEach(function(e) {\n      t.push(e);\n    }), t;\n  }, js_cols.RedBlackSet.prototype.insertAll = function(t) {\n    if (\"array\" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.insert(t[e]);\n    else if (\"function\" == js_cols.typeOf(t.forEach)) t.forEach(this.insert, this);\n    else if (\"function\" == js_cols.typeOf(t.getValues)) {\n      var s = t.getValues();\n      for (e = 0; e < s.length; e++) this.insert(s[e]);\n    } else if (\"object\" == js_cols.typeOf(t)) for (var r in t) this.insert(t[r]);\n  }, js_cols.RedBlackSet.prototype.removeAll = function(t) {\n    if (\"array\" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.remove(t[e]);\n    else if (\"function\" == js_cols.typeOf(t.forEach)) t.forEach(this.removeSwapped, this);\n    else if (\"function\" == js_cols.typeOf(t.getValues)) {\n      var s = t.getValues();\n      for (e = 0; e < s.length; e++) this.remove(s[e]);\n    } else if (\"object\" == js_cols.typeOf(t)) for (var r in t) this.remove(t[r]);\n  }, js_cols.RedBlackSet.prototype.containsAll = function(t) {\n    if (\"array\" == js_cols.typeOf(t)) {\n      for (var e = 0; e < t.length; e++) if (!this.contains(t[e])) return false;\n      return true;\n    }\n    if (\"function\" == js_cols.typeOf(t.forEach)) return t.every(this.contains, this);\n    if (\"function\" == js_cols.typeOf(t.getValues)) {\n      var s = t.getValues();\n      for (e = 0; e < s.length; e++) if (!this.contains(s[e])) return false;\n      return true;\n    }\n    if (\"object\" == js_cols.typeOf(t)) {\n      for (var r in t) if (!this.contains(t[r])) return false;\n      return true;\n    }\n  }, js_cols.RedBlackSet.prototype.range = function(t, e) {\n    var s = [];\n    return this.traverseFromTo(function(t2) {\n      s.push(t2);\n    }, t, e), s;\n  }, js_cols.RedBlackSet.prototype.traverse = function(t, e) {\n    if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; ) {\n      if (t.call(e, s.key, this)) return;\n      s = this.successor_(s);\n    }\n  }, js_cols.RedBlackSet.prototype.traverseFrom = function(t, e, s) {\n    if (!this.isEmpty()) for (var r = this.get_(e); r != this.sentinel; ) {\n      if (t.call(s, r.key, this)) return;\n      r = this.successor_(r);\n    }\n  }, js_cols.RedBlackSet.prototype.traverseTo = function(t, e, s) {\n    if (!this.isEmpty()) for (var r = this.min(this.root), i = this.get_(e); r != i; ) {\n      if (t.call(s, r.key, this)) return;\n      r = this.successor_(r);\n    }\n  }, js_cols.RedBlackSet.prototype.traverseFromTo = function(t, e, s, r) {\n    if (!this.isEmpty()) for (var i = this.get_(e), o = this.get_(s); i != o; ) {\n      if (t.call(r, i.key, this)) return;\n      i = this.successor_(i);\n    }\n  }, js_cols.RedBlackSet.prototype.traverseBackwards = function(t, e) {\n    if (!this.isEmpty()) for (var s = this.max(this.root); s != this.sentinel; ) {\n      if (t.call(e, s.key, this)) return;\n      s = this.predeccessor_(s);\n    }\n  }, js_cols.RedBlackSet.prototype.forEach = function(t, e) {\n    if (!this.isEmpty()) for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) t.call(e, s.key, s.key, this);\n  }, js_cols.RedBlackSet.prototype.some = function(t, e) {\n    if (this.isEmpty()) return false;\n    for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) if (t.call(e, s.key, s.key, this)) return true;\n    return false;\n  }, js_cols.RedBlackSet.prototype.every = function(t, e) {\n    if (this.isEmpty()) return false;\n    for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) if (!t.call(e, s.key, s.key, this)) return false;\n    return true;\n  }, js_cols.RedBlackSet.prototype.map = function(t, e) {\n    var s = [];\n    if (this.isEmpty()) return s;\n    for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) s.push(t.call(e, r.key, r.key, this));\n    return s;\n  }, js_cols.RedBlackSet.prototype.filter = function(t, e) {\n    var s = [];\n    if (this.isEmpty()) return s;\n    for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) t.call(e, r.key, r.key, this) && s.push(r.key);\n    return s;\n  }, js_cols.RedBlackSet.prototype.getCount = function() {\n    return this.size;\n  }, js_cols.RedBlackSet.prototype.isEmpty = function() {\n    return 0 == this.size;\n  }, js_cols.RedBlackSet.prototype.isSubsetOf = function(t) {\n    var e = js_cols.getCount(t);\n    if (this.getCount() > e) return false;\n    var s = 0;\n    if (this.isEmpty()) return true;\n    for (var r = this.min(this.root); r != this.sentinel; r = this.successor_(r)) js_cols.contains.call(t, t, r.key) && s++;\n    return s == this.getCount();\n  }, js_cols.RedBlackSet.prototype.intersection = function(t) {\n    var e = new js_cols.RedBlackSet(this.compare);\n    if (this.isEmpty()) return e;\n    for (var s = this.min(this.root); s != this.sentinel; s = this.successor_(s)) t.contains.call(t, s.key, s.key, this) && e.insert(s.key);\n    return e;\n  }, C33.RedBlackSet = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._rbSet = new js_cols.RedBlackSet(t), this._enableQueue = false, this._queueInsert = /* @__PURE__ */ new Set(), this._queueRemove = /* @__PURE__ */ new Set();\n    }\n    Add(t) {\n      this._enableQueue ? this._rbSet.contains(t) ? this._queueRemove.delete(t) : this._queueInsert.add(t) : this._rbSet.insert(t);\n    }\n    Remove(t) {\n      this._enableQueue ? this._rbSet.contains(t) ? this._queueRemove.add(t) : this._queueInsert.delete(t) : this._rbSet.remove(t);\n    }\n    Has(t) {\n      return this._enableQueue ? !!this._queueInsert.has(t) || !this._queueRemove.has(t) && this._rbSet.contains(t) : this._rbSet.contains(t);\n    }\n    Clear() {\n      this._rbSet.clear(), this._queueInsert.clear(), this._queueRemove.clear();\n    }\n    toArray() {\n      if (this._enableQueue) throw new Error(\"cannot be used in queueing mode\");\n      return this._rbSet.getValues();\n    }\n    GetSize() {\n      return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size;\n    }\n    IsEmpty() {\n      return 0 === this.GetSize();\n    }\n    Front() {\n      if (this.IsEmpty()) throw new Error(\"empty set\");\n      if (this._enableQueue) throw new Error(\"cannot be used in queueing mode\");\n      const t = this._rbSet;\n      return t.min(t.root).key;\n    }\n    Shift() {\n      if (this.IsEmpty()) throw new Error(\"empty set\");\n      if (this._enableQueue) throw new Error(\"cannot be used in queueing mode\");\n      const t = this.Front();\n      return this.Remove(t), t;\n    }\n    SetQueueingEnabled(t) {\n      if (t = !!t, this._enableQueue !== t && (this._enableQueue = t, !t)) {\n        for (const t2 of this._queueRemove) this._rbSet.remove(t2);\n        this._queueRemove.clear();\n        for (const t2 of this._queueInsert) this._rbSet.insert(t2);\n        this._queueInsert.clear();\n      }\n    }\n    ForEach(t) {\n      this._rbSet.forEach(t);\n    }\n    *values() {\n      if (this.IsEmpty()) return;\n      const t = this._rbSet;\n      for (let e = t.min(t.root); e != t.sentinel; e = t.successor_(e)) yield e.key;\n    }\n    [Symbol.iterator]() {\n      return this.values();\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.PromiseThrottle = class {\n    constructor(e = C33.hardwareConcurrency) {\n      this._maxParallel = e, this._queue = [], this._activeCount = 0;\n    }\n    Add(e) {\n      return new Promise((t, r) => {\n        this._queue.push({ func: e, resolve: t, reject: r }), this._MaybeStartNext();\n      });\n    }\n    _FindInQueue(e) {\n      for (let t = 0, r = this._queue.length; t < r; ++t) if (this._queue[t].func === e) return t;\n      return -1;\n    }\n    RemoveAndResolve(e, t) {\n      const r = this._FindInQueue(e);\n      if (-1 === r) throw new Error(\"cannot find promise to resolve\");\n      this._queue[r].resolve(t), this._queue.splice(r, 1);\n    }\n    RemoveAndReject(e, t) {\n      const r = this._FindInQueue(e);\n      if (-1 === r) throw new Error(\"cannot find promise to reject\");\n      this._queue[r].reject(t), this._queue.splice(r, 1);\n    }\n    async _MaybeStartNext() {\n      if (!this._queue.length) return;\n      if (this._activeCount >= this._maxParallel) return;\n      this._activeCount++;\n      const e = this._queue.shift();\n      try {\n        const t = await e.func();\n        e.resolve(t);\n      } catch (t) {\n        e.reject(t);\n      }\n      this._activeCount--, this._MaybeStartNext();\n    }\n    static async Batch(e, t) {\n      const r = [];\n      let s = false;\n      const i = async (e2) => {\n        let i2;\n        for (; i2 = t.pop(); ) {\n          if (s) return;\n          try {\n            r.push(await i2());\n          } catch (e3) {\n            throw s = true, e3;\n          }\n        }\n      }, n = [];\n      for (; e--; ) n.push(i());\n      return await Promise.all(n), r;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.RateLimiter = class {\n    constructor(t, e, i) {\n      this._callback = t, this._interval = e, this._intervalOnBattery = i || 2 * e, this._timerId = -1, this._lastCallTime = -1 / 0, this._timerCallFunc = () => this._OnTimer(), this._ignoreReset = false, this._canRunImmediate = false, this._callbackArguments = null;\n    }\n    SetCanRunImmediate(t) {\n      this._canRunImmediate = !!t;\n    }\n    _GetInterval() {\n      return void 0 !== C33.Battery && C33.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval;\n    }\n    Call(...t) {\n      if (-1 !== this._timerId) return;\n      this._callbackArguments = t;\n      let e = C33.FastGetDateNow(), i = e - this._lastCallTime, l = this._GetInterval();\n      i >= l && this._canRunImmediate ? (this._lastCallTime = e, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(l - i, 4));\n    }\n    _RunCallback() {\n      this._ignoreReset = true;\n      const t = this._callbackArguments;\n      this._callbackArguments = null, t ? this._callback(...t) : this._callback(), this._ignoreReset = false;\n    }\n    Reset() {\n      this._ignoreReset || (this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = C33.FastGetDateNow());\n    }\n    _OnTimer() {\n      this._timerId = -1, this._lastCallTime = C33.FastGetDateNow(), this._RunCallback();\n    }\n    _CancelTimer() {\n      -1 !== this._timerId && (self.clearTimeout(this._timerId), this._timerId = -1);\n    }\n    Release() {\n      this._CancelTimer(), this._callback = null, this._callbackArguments = null, this._timerCallFunc = null;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.SVGRasterManager = class {\n    constructor() {\n      this._images = /* @__PURE__ */ new Map(), this._allowNpotSurfaces = false, this._getBaseSizeCallback = null, this._rasterAtSizeCallback = null, this._releaseResultCallback = null, this._redrawCallback = null;\n    }\n    SetNpotSurfaceAllowed(e) {\n      this._allowNpotSurfaces = !!e;\n    }\n    IsNpotSurfaceAllowed() {\n      return this._allowNpotSurfaces;\n    }\n    SetGetBaseSizeCallback(e) {\n      this._getBaseSizeCallback = e;\n    }\n    GetBaseSize(e) {\n      if (!this._getBaseSizeCallback) throw new Error(\"no get base size callback set\");\n      return this._getBaseSizeCallback(e);\n    }\n    SetRasterAtSizeCallback(e) {\n      this._rasterAtSizeCallback = e;\n    }\n    RasterAtSize(e, a, t, l, s, r) {\n      if (!this._rasterAtSizeCallback) throw new Error(\"no raster at size callback set\");\n      return this._rasterAtSizeCallback(e, a, t, l, s, r);\n    }\n    SetReleaseResultCallback(e) {\n      this._releaseResultCallback = e;\n    }\n    ReleaseResult(e) {\n      if (!this._releaseResultCallback) throw new Error(\"no release result callback set\");\n      this._releaseResultCallback(e);\n    }\n    SetRedrawCallback(e) {\n      this._redrawCallback = e;\n    }\n    Redraw() {\n      if (!this._redrawCallback) throw new Error(\"no redraw callback set\");\n      this._redrawCallback();\n    }\n    AddImage(e) {\n      let a = this._images.get(e);\n      return a || (a = C33.New(C33.SVGRasterImage, this, e), this._images.set(e, a)), a.IncReference(), a;\n    }\n    _RemoveImage(e) {\n      this._images.delete(e.GetDataSource());\n    }\n    OnTexturesChanged() {\n      for (const e of this._images.values()) e.ReleaseRasterizedResult(), e.ForceRasterAgain();\n    }\n  };\n}\n{\n  const C33 = self.C3, MAX_SURFACE_SIZE = 4096;\n  C33.SVGRasterImage = class {\n    constructor(e, t) {\n      this._manager = e, this._dataSource = t, this._refCount = 0, this._baseWidth = 0, this._baseHeight = 0, this._getBaseSizePromise = this._manager.GetBaseSize(t).then((e2) => {\n        this._manager && (this._baseWidth = e2[0], this._baseHeight = e2[1], this._manager.Redraw());\n      }).catch((e2) => {\n        console.error(\"[SVG] Error loading SVG: \", e2), this._hadError = true, this._manager && this._manager.Redraw();\n      }), this._rasterSurfaceWidth = 0, this._rasterSurfaceHeight = 0, this._rasterImageWidth = 0, this._rasterImageHeight = 0, this._isRasterizing = false, this._rasterizedResult = null, this._forceRaster = false, this._hadError = false;\n    }\n    Release() {\n      if (this._refCount <= 0) throw new Error(\"already released\");\n      this._refCount--, 0 === this._refCount && this._Release();\n    }\n    ReleaseRasterizedResult() {\n      this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null);\n    }\n    _Release() {\n      this.ReleaseRasterizedResult(), this._manager._RemoveImage(this), this._manager = null;\n    }\n    GetDataSource() {\n      return this._dataSource;\n    }\n    IncReference() {\n      this._refCount++;\n    }\n    HasReferences() {\n      return this._refCount > 0;\n    }\n    GetRasterizedResult() {\n      return this._rasterizedResult;\n    }\n    ForceRasterAgain() {\n      this._forceRaster = true;\n    }\n    async StartRasterForSize(e, t, r) {\n      if (0 === t || 0 === r || this._hadError) return;\n      if (this._isRasterizing) return;\n      let s = C33.nextHighestPowerOfTwo(Math.ceil(t)), a = C33.nextHighestPowerOfTwo(Math.ceil(r));\n      const i = Math.max(s, a);\n      if (i > 4096) {\n        const e2 = 4096 / i;\n        t *= e2, r *= e2, s = Math.min(Math.ceil(s * e2), 4096), a = Math.min(Math.ceil(a * e2), 4096);\n      }\n      if (t < s && r < a) {\n        const e2 = t / r;\n        s / a > e2 ? (t = a * e2, r = a) : (t = s, r = s / e2);\n      }\n      if (this._manager.IsNpotSurfaceAllowed() && (s = Math.ceil(t), a = Math.ceil(r)), s <= this._rasterSurfaceWidth && a <= this._rasterSurfaceHeight && !this._forceRaster) return;\n      this._isRasterizing = true, this._rasterSurfaceWidth = s, this._rasterSurfaceHeight = a;\n      const h = await this._manager.RasterAtSize(this._dataSource, e, this._rasterSurfaceWidth, this._rasterSurfaceHeight, t, r);\n      this._manager && (this.ReleaseRasterizedResult(), this._rasterizedResult = h, this._rasterImageWidth = t, this._rasterImageHeight = r, this._isRasterizing = false, this._forceRaster = false, this._manager.Redraw());\n    }\n    WhenBaseSizeReady() {\n      return this._getBaseSizePromise;\n    }\n    GetBaseWidth() {\n      return this._baseWidth;\n    }\n    GetBaseHeight() {\n      return this._baseHeight;\n    }\n    GetRasterWidth() {\n      return this._rasterImageWidth;\n    }\n    GetRasterHeight() {\n      return this._rasterImageHeight;\n    }\n    HadError() {\n      return this._hadError;\n    }\n  };\n}\n{\n  let lookupHtmlEntity = function(t) {\n    return HTML_ENTITY_MAP.get(t);\n  };\n  lookupHtmlEntity2 = lookupHtmlEntity;\n  const C33 = self.C3;\n  C33.UTF8_BOM = \"\\uFEFF\";\n  const NUMERIC_CHARS = new Set(\"0123456789\");\n  C33.IsNumericChar = function(t) {\n    return NUMERIC_CHARS.has(t);\n  };\n  const WHITESPACE_CHARS = new Set(\" \t\\n\\r\\xA0\\x85\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u200B\\u2028\\u2029\\u202F\\u205F\\u3000\");\n  C33.IsWhitespaceChar = function(t) {\n    return WHITESPACE_CHARS.has(t);\n  }, C33.FilterWhitespace = function(t) {\n    return [...t].filter((t2) => !C33.IsWhitespaceChar(t2)).join(\"\");\n  }, C33.IsStringAllWhitespace = function(t) {\n    for (const e of t) if (!C33.IsWhitespaceChar(e)) return false;\n    return true;\n  }, C33.IsCharArrayAllWhitespace = function(t) {\n    for (const e of t) if (!C33.IsWhitespaceChar(e)) return false;\n    return true;\n  }, C33.IsUnprintableChar = function(t) {\n    return 1 === t.length && t.charCodeAt(0) < 32;\n  }, C33.FilterUnprintableChars = function(t) {\n    return [...t].filter((t2) => !C33.IsUnprintableChar(t2)).join(\"\");\n  };\n  let cjkPunctuationRegex = null;\n  try {\n    cjkPunctuationRegex = new RegExp(\"\\\\p{P}(?<=[\\\\u3000-\\\\u303F\\\\uFF00-\\\\uFFEF])\", \"u\");\n  } catch (t) {\n    console.warn(\"Unable to detect CJK punctuation: \", t);\n  }\n  C33.IsCJKPunctuationChar = function(t) {\n    return !C33.IsWhitespaceChar(t) && cjkPunctuationRegex && cjkPunctuationRegex.test(t);\n  };\n  const NUMERIC_STRING_CHARS = new Set(\"0123456789.+-e\");\n  C33.IsStringNumber = function(t) {\n    if (!(t = t.trim()).length) return false;\n    let e = t.charAt(0);\n    if (\"-\" !== e && !NUMERIC_CHARS.has(e)) return false;\n    for (let e2 of t) if (!NUMERIC_STRING_CHARS.has(e2)) return false;\n    return true;\n  }, C33.RemoveTrailingDigits = function(t) {\n    let e = t.length;\n    for (; e > 0; ) {\n      let n = t.charAt(e - 1);\n      if (!C33.IsNumericChar(n)) break;\n      --e;\n    }\n    return t.substr(0, e);\n  }, C33.IncrementNumberAtEndOf = function(t) {\n    let e = C33.RemoveTrailingDigits(t), n = t.substr(e.length);\n    return n = n ? (parseInt(n, 10) + 1).toString() : \"2\", e + n;\n  };\n  const HTML_ENTITY_MAP = /* @__PURE__ */ new Map([[\"&\", \"&amp;\"], [\"<\", \"&lt;\"], [\">\", \"&gt;\"], ['\"', \"&quot;\"], [\"'\", \"&#39;\"]]);\n  const HTML_ENTITY_REGEX = /[&<>\"']/g;\n  C33.EscapeHTML = function(t) {\n    return t.replace(HTML_ENTITY_REGEX, lookupHtmlEntity);\n  }, C33.EscapeJS = function(t) {\n    let e = C33.ReplaceAll(t, \"\\\\\", \"\\\\\\\\\");\n    return e = C33.ReplaceAll(e, '\"', '\\\\\"'), e = C33.ReplaceAll(e, \"\t\", \"\\\\t\"), e = C33.ReplaceAll(e, \"\\r\", \"\"), C33.ReplaceAll(e, \"\\n\", \"\\\\n\");\n  }, C33.EscapeXML = function(t) {\n    let e = C33.ReplaceAll(t, \"&\", \"&amp;\");\n    return e = C33.ReplaceAll(e, \"<\", \"&lt;\"), e = C33.ReplaceAll(e, \">\", \"&gt;\"), C33.ReplaceAll(e, '\"', \"&quot;\");\n  };\n  const ESCAPE_REGEX = /[-[\\]{}()*+?.,\\\\^$|#\\s]/g;\n  C33.EscapeRegex = function(t) {\n    return t.replace(ESCAPE_REGEX, \"\\\\$&\");\n  }, C33.CountCharsInString = function(t, e) {\n    let n = 0;\n    for (const r of t) r === e && ++n;\n    return n;\n  }, C33.StringPosToLineNumber = function(t, e) {\n    let n = 0, r = 0;\n    for (; n < e; ) {\n      if (n = t.indexOf(\"\\n\", n), -1 === n) return r;\n      r++, n++;\n    }\n    return r;\n  }, C33.FindAll = function(t, e, n = false) {\n    if (!e) return [];\n    n || (t = t.toLowerCase(), e = e.toLowerCase());\n    const r = e.length;\n    let o = 0, i = 0, l = [];\n    for (; (i = t.indexOf(e, o)) > -1; ) l.push(i), o = i + r;\n    return l;\n  }, C33.ReplaceAll = function(t, e, n) {\n    return t.replaceAll(e, () => n);\n  }, C33.ReplaceAllCaseInsensitive = function(t, e, n) {\n    return t.replace(new RegExp(C33.EscapeRegex(e), \"gi\"), () => n);\n  }, C33.SetElementContent = function(t, e) {\n    \"string\" == typeof e ? t.textContent = e : e.isPlainText() ? t.textContent = e.toString() : (t.innerHTML = e.toHTML(), e instanceof C33.BBString && e.attachLinkHandlers(t));\n  }, C33.StringLikeEquals = function(t, e) {\n    return t instanceof C33.HtmlString || t instanceof C33.BBString ? t.equals(e) : e instanceof C33.HtmlString || e instanceof C33.BBString ? e.equals(t) : t === e;\n  }, C33.StringSubstitute = function(t, ...e) {\n    let n = t;\n    for (let r = 0, o = e.length; r < o; ++r) {\n      const o2 = `{${r}}`;\n      if (!t.includes(o2)) throw new Error(`missing placeholder '${o2}' in string substitution`);\n      n = n.replace(o2, e[r].toString());\n    }\n    return n;\n  }, C33.StringSubstituteAllowMissing = function(t, ...e) {\n    let n = t, r = -1, o = -1;\n    for (let i = 0, l = e.length; i < l; ++i) {\n      const l2 = `{${i}}`;\n      t.includes(l2) ? (o = i, n = n.replace(l2, e[i].toString())) : -1 === r && (r = i);\n    }\n    if (r >= 0 && o >= 0 && r < o) throw new Error(`missing placeholder '${r}' in string substitution`);\n    return n;\n  }, C33.StringSubstituteMap = function(t, e) {\n    let n = t;\n    for (let [t2, r] of Object.entries(e)) n = n.replaceAll(t2, r.toString());\n    return n;\n  }, C33.SortAZ = function(t, e) {\n    return t > e ? 1 : t < e ? -1 : 0;\n  }, C33.SortAZCaseInsensitive = function(t, e) {\n    let n = t.toLowerCase(), r = e.toLowerCase();\n    return n > r ? 1 : n < r ? -1 : 0;\n  };\n  const intlSegmenter = new self[\"Intl\"][\"Segmenter\"]();\n  C33.SplitGraphemes = function(t) {\n    const e = [];\n    for (const n of intlSegmenter[\"segment\"](t)) e.push(n[\"segment\"]);\n    return e;\n  }, C33.IterateGraphemes = function* (t) {\n    for (const e of intlSegmenter[\"segment\"](t)) yield e[\"segment\"];\n  }, C33.CountGraphemes = function(t) {\n    let e = 0;\n    for (const n of intlSegmenter[\"segment\"](t)) ++e;\n    return e;\n  };\n  const KILOBYTE = 1024, MEGABYTE = 1048576, GIGABYTE = 1073741824, TERABYTE = 1099511627776;\n  C33.FormatDataSize = function(t, e) {\n    let n = \"common.\" + (e ? \"dataRates\" : \"dataSizes\") + \".\";\n    const r = self.langSub;\n    if (t < 1024) return r(n + \"bytes\", t);\n    if (t < 1048576) {\n      let e2 = t / 1024;\n      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r(n + \"kilobytes\", e2);\n    }\n    if (t < GIGABYTE) {\n      let e2 = t / 1048576;\n      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r(n + \"megabytes\", e2);\n    }\n    if (t < TERABYTE) {\n      let e2 = t / GIGABYTE;\n      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r(n + \"gigabytes\", e2);\n    }\n    {\n      let e2 = t / TERABYTE;\n      return e2 = e2 < 10 ? Math.round(10 * e2) / 10 : Math.round(e2), r(n + \"terabytes\", e2);\n    }\n  };\n  const DEFAULT_FORMATTIME_OPTS = { approximate: false, days: true, hours: true, minutes: true, seconds: true };\n  C33.FormatTime = function(t, e) {\n    e = Object.assign({}, DEFAULT_FORMATTIME_OPTS, e), C33.Lang.PushContext(\"common.time\");\n    const n = [], r = self.lang, o = self.langPluralSub;\n    if (e.days) {\n      const e2 = Math.floor(t / 86400);\n      e2 > 0 && (t -= 24 * e2 * 3600, n.push(o(\".days\", null, e2)));\n    }\n    if (e.hours) {\n      const e2 = Math.floor(t / 3600);\n      (e2 > 0 || n.length) && (t -= 3600 * e2, n.push(o(\".hours\", null, e2)));\n    }\n    if (e.minutes) {\n      const r2 = Math.floor(t / 60);\n      (r2 > 0 || n.length || !e.seconds) && (t -= 60 * r2, n.push(o(\".minutes\", null, r2)));\n    }\n    if (e.seconds) {\n      const e2 = Math.floor(t % 60);\n      n.push(o(\".seconds\", null, e2));\n    }\n    const i = (e.approximate ? r(\".approx-prefix\") : \"\") + n.join(r(\".separator\"));\n    return C33.Lang.PopContext(), i;\n  }, C33.ZeroPad = function(t, e) {\n    let n = t < 0 ? \"-\" : \"\", r = (t = Math.abs(t)).toString(), o = e - r.length;\n    for (let t2 = 0; t2 < o; ++t2) n += \"0\";\n    return n + r;\n  }, C33.StringToTitleCase = function(t) {\n    return t.toLowerCase().replace(/\\b\\w/g, (t2) => t2.toUpperCase());\n  }, C33.CompareVersionStrings = function(t, e) {\n    let n = t.split(\".\").map((t2) => t2.trim()), r = e.split(\".\").map((t2) => t2.trim());\n    C33.resizeArray(n, 4, \"0\"), C33.resizeArray(r, 4, \"0\"), n = n.map((t2) => parseInt(t2, 10)), r = r.map((t2) => parseInt(t2, 10));\n    for (let t2 = 0; t2 < 4; ++t2) {\n      const e2 = n[t2] - r[t2];\n      if (0 !== e2) return e2 < 0 ? -1 : 1;\n    }\n    return 0;\n  }, C33.CreateGUID = function() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (t) => {\n      const e = Math.floor(16 * Math.random());\n      return (\"x\" === t ? e : 3 & e | 8).toString(16);\n    });\n  }, C33.StringHammingDistance = function(t, e) {\n    if (t.length !== e.length) throw new Error(\"strings must be same length\");\n    let n = 0;\n    for (let r = 0, o = t.length; r < o; ++r) t.charAt(r) !== e.charAt(r) && ++n;\n    return n;\n  }, C33.StringLevenshteinDistance = function(t, e) {\n    if (0 === t.length) return e.length;\n    if (0 === e.length) return t.length;\n    let n, r, o, i, l, s;\n    for (t.length > e.length && (n = t, t = e, e = n), s = Array(t.length + 1), r = 0; r <= t.length; r++) s[r] = r;\n    for (r = 1; r <= e.length; r++) {\n      for (i = r, o = 1; o <= t.length; o++) l = e[r - 1] === t[o - 1] ? s[o - 1] : Math.min(s[o - 1] + 1, Math.min(i + 1, s[o] + 1)), s[o - 1] = i, i = l;\n      s[t.length] = i;\n    }\n    return s[t.length];\n  };\n}\nvar lookupHtmlEntity2;\n{\n  let bbToHtmlReplacerFunc = function(t, s, i) {\n    const n = BB_CODE_MAP.get(i);\n    if (!n) return \"class\" === i ? s ? \"</span>\" : `<span class=\"bbclass${classIndex++}\">` : t;\n    if (\"string\" == typeof n) {\n      if (\"a\" === n && 0 === linkActions.length || \"abbr\" === n && 0 === tipList.length) return t;\n      if (\"a\" !== n || s) {\n        if (\"abbr\" !== n || s) return \"<\" + s + n + \">\";\n        {\n          const t2 = parseInt(i.substring(3), 10) - 1;\n          if (t2 < 0 || t2 >= tipList.length) throw new Error(\"invalid bbcode tip substitution\");\n          const s2 = tipList[t2];\n          let n2 = \"\";\n          if (\"string\" == typeof s2 ? n2 = s2 : \"function\" == typeof s2 && (n2 = s2()), \"string\" != typeof n2) throw new TypeError(\"invalid bbcode tip\");\n          return `<abbr title=\"${C33.ReplaceAll(n2, '\"', \"&quot;\")}\">`;\n        }\n      }\n      {\n        const t2 = parseInt(i.substring(1), 10) - 1;\n        if (t2 < 0 || t2 >= linkActions.length) throw new Error(\"invalid bbcode link substitution\");\n        const s2 = linkActions[t2];\n        if (\"string\" == typeof s2) return `<a href=\"${linkActions[t2]}\">`;\n        if (\"function\" == typeof s2) return `<a class=\"bblink${t2}\">`;\n        throw new TypeError(\"invalid bbcode link action\");\n      }\n    }\n    if (Array.isArray(n)) {\n      let t2 = n[0], i2 = n[1];\n      return s ? \"</\" + t2 + \">\" : `<${t2} class=\"${i2}\">`;\n    }\n  };\n  bbToHtmlReplacerFunc2 = bbToHtmlReplacerFunc;\n  const C33 = self.C3, assert = self.assert, BB_CODE_MAP = /* @__PURE__ */ new Map([[\"b\", \"strong\"], [\"i\", \"em\"], [\"s\", \"s\"], [\"u\", \"u\"], [\"sub\", \"sub\"], [\"sup\", \"sup\"], [\"small\", \"small\"], [\"mark\", \"mark\"], [\"code\", \"code\"], [\"a1\", \"a\"], [\"a2\", \"a\"], [\"a3\", \"a\"], [\"a4\", \"a\"], [\"a5\", \"a\"], [\"a6\", \"a\"], [\"a7\", \"a\"], [\"a8\", \"a\"], [\"a9\", \"a\"], [\"tip1\", \"abbr\"], [\"tip2\", \"abbr\"], [\"tip3\", \"abbr\"], [\"tip4\", \"abbr\"], [\"tip5\", \"abbr\"], [\"tip6\", \"abbr\"], [\"tip7\", \"abbr\"], [\"tip8\", \"abbr\"], [\"tip9\", \"abbr\"], [\"bad\", [\"span\", \"bbCodeBad\"]], [\"good\", [\"span\", \"bbCodeGood\"]], [\"info\", [\"span\", \"bbCodeInfo\"]], [\"h1\", [\"span\", \"bbCodeH1\"]], [\"h2\", [\"span\", \"bbCodeH2\"]], [\"h3\", [\"span\", \"bbCodeH3\"]], [\"h4\", [\"span\", \"bbCodeH4\"]], [\"item\", [\"span\", \"bbCodeItem\"]]]), SELF_CLOSING_TAGS = /* @__PURE__ */ new Set([\"icon\"]), BBREGEX = /\\[(\\/?)([a-zA-Z0-9]+)\\]/g, CUSTOM_BBREGEX = /\\[(\\/?)([^\\[\\n]*?)\\]/g;\n  let linkActions = null, tipList = null, classIndex = 0;\n  const LINEBREAK_REGEX = /\\n/g;\n  C33.BBString = class {\n    constructor(t, s) {\n      if (this._bbstr = s && s.noEscape ? t : C33.EscapeHTML(t), this._htmlstr = \"\", this._convertLineBreaks = false, this._linkActions = [], this._tipList = [], s) {\n        if (this._convertLineBreaks = !!s.convertLineBreaks, s.links) {\n          if (s.links.length > 9) throw new Error(\"too many links\");\n          this._linkActions = s.links;\n        }\n        if (s.tips) {\n          if (s.tips.length > 9) throw new Error(\"too many tips\");\n          this._tipList = s.tips;\n        }\n      }\n      this._hasAnyBBtags = this._bbstr.includes(\"[\"), this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes(\"\\n\"), this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes(\"&\"), this._hasParsedFragments = false, this._fragments = [];\n    }\n    toString() {\n      return this._bbstr;\n    }\n    valueOf() {\n      return this._bbstr;\n    }\n    isPlainText() {\n      return this._isPlain;\n    }\n    toPlainText() {\n      return this._hasAnyBBtags ? this._bbstr.replace(BBREGEX, \"\") : this._bbstr;\n    }\n    toHTML() {\n      if (this._isPlain) return this._bbstr;\n      if (!this._htmlstr && this._bbstr) {\n        let t = this._bbstr;\n        this._hasAnyBBtags && (classIndex = 0, linkActions = this._linkActions, tipList = this._tipList, t = t.replace(BBREGEX, bbToHtmlReplacerFunc), linkActions = null, tipList = null), this._needsLineBreakConversion && (t = t.replace(LINEBREAK_REGEX, \"<br>\")), this._htmlstr = t;\n      }\n      return this._htmlstr;\n    }\n    attachLinkHandlers(t) {\n      if (this._linkActions.length) for (let s = 0, i = this._linkActions.length; s < i; ++s) {\n        const i2 = this._linkActions[s];\n        if (\"function\" != typeof i2) continue;\n        const n = t.querySelector(\".bblink\" + s);\n        if (!n) throw new Error(\"unable to attach BBString link handler\");\n        n.onclick = i2;\n      }\n    }\n    equals(t) {\n      return t instanceof C33.HtmlString ? this.toHTML() === t.toHTML() : t instanceof C33.BBString ? this._bbstr === t._bbstr : this._bbstr === t;\n    }\n    toFragmentList() {\n      if (this._hasParsedFragments) return this._fragments;\n      const t = [], s = this._bbstr, i = [];\n      CUSTOM_BBREGEX.lastIndex = 0;\n      let n = 0, e = null;\n      for (; null !== (e = CUSTOM_BBREGEX.exec(s)); ) {\n        const r = e.index;\n        if (r > 0 && \"\\\\\" === s.charAt(r - 1)) continue;\n        const a = e[0], o = e[1], l = e[2], b = s.substring(n, r);\n        if (n = r + a.length, b && t.push({ text: b, styles: i.slice(0) }), l) if (o) {\n          const t2 = l.toLowerCase();\n          for (let s2 = i.length - 1; s2 >= 0; --s2) if (i[s2].tag === t2) {\n            i.splice(s2, 1);\n            break;\n          }\n        } else {\n          let s2 = l, n2 = null;\n          const e2 = l.indexOf(\"=\");\n          if (-1 !== e2 ? (s2 = l.substring(0, e2).toLowerCase(), n2 = l.substring(e2 + 1)) : s2 = s2.toLowerCase(), SELF_CLOSING_TAGS.has(s2)) {\n            if (\"icon\" !== s2) throw new Error(`unknown self-closing tag ${s2}`);\n            t.push({ icon: n2, styles: i.slice(0) });\n          } else i.push({ tag: s2, param: n2 });\n        }\n      }\n      n < s.length && t.push({ text: s.substring(n), styles: i.slice(0) });\n      for (const s2 of t) s2.text && (s2.text = this._ProcessBBCodeEscapeSequences(s2.text));\n      return this._fragments = t.map((t2) => t2.icon ? C33.New(C33.IconFragment, { icon: t2.icon, styles: t2.styles }) : C33.New(C33.TextFragment, { chArr: C33.SplitGraphemes(t2.text), styles: t2.styles })), this._hasParsedFragments = true, this._fragments;\n    }\n    _ProcessBBCodeEscapeSequences(t) {\n      return t = C33.ReplaceAll(t, \"\\\\[\", \"[\"), C33.ReplaceAll(t, \"\\\\\\\\\", \"\\\\\");\n    }\n    static StripTags(t) {\n      return C33.New(C33.BBString, t, { noEscape: true }).toPlainText();\n    }\n    static StripAnyTags(t) {\n      return t.replace(CUSTOM_BBREGEX, \"\");\n    }\n  };\n}\nvar bbToHtmlReplacerFunc2;\n{\n  let IsWordBreakWhiteSpace = function(t) {\n    return \"\\xA0\" !== t && \"\\u202F\" !== t && C33.IsWhitespaceChar(t);\n  }, IsOpeningCJKPunctiationChar = function(t) {\n    return CJK_OPEN_PUNCTUATION.has(t);\n  }, IsContinuingCJKPunctuationChar = function(t) {\n    return C33.IsCJKPunctuationChar(t) && !IsOpeningCJKPunctiationChar(t);\n  }, WordBreakTrimEnd = function(t) {\n    for (; t.length > 0 && IsWordBreakWhiteSpace(t.at(-1)); ) t.pop();\n  }, IsNewline = function(t) {\n    return \"\\n\" === t || \"\\r\\n\" === t;\n  };\n  IsWordBreakWhiteSpace2 = IsWordBreakWhiteSpace, IsOpeningCJKPunctiationChar2 = IsOpeningCJKPunctiationChar, IsContinuingCJKPunctuationChar2 = IsContinuingCJKPunctuationChar, WordBreakTrimEnd2 = WordBreakTrimEnd, IsNewline2 = IsNewline;\n  const C33 = self.C3;\n  const CJK_OPEN_PUNCTUATION = new Set(\"\\u3008\\u300A\\u300C\\u300E\\u3010\\u3014\\u3016\\u3018\\u301A\\u301D\");\n  C33.WordWrap = class {\n    constructor() {\n      this._lines = [], this._iconSet = null;\n    }\n    GetLines() {\n      return this._lines;\n    }\n    GetLineCount() {\n      return this._lines.length;\n    }\n    SetIconSet(t) {\n      this._iconSet = t;\n    }\n    _MeasureLine(t, e) {\n      let n = 0, s = 0, i = 0, o = 0, r = 0;\n      for (const h of t) {\n        if (-1 === h.GetWidth()) {\n          const t2 = e(h);\n          h.SetHeight(t2.height), h.SetFontBoundingBoxAscent(t2.fontBoundingBoxAscent || 0), h.SetFontBoundingBoxDescent(t2.fontBoundingBoxDescent || 0), h.SetTopToAlphabeticDistance(t2.topToAlphabeticDistance || 0), h.IsText() ? h.SetWidth(t2.width) : h.IsIcon() && h.CalculateWidthFromHeight(this._iconSet);\n        }\n        n += h.GetWidth(), s = Math.max(s, h.GetHeight()), i = Math.max(i, h.GetFontBoundingBoxAscent()), o = Math.max(o, h.GetFontBoundingBoxDescent()), r = Math.max(r, h.GetTopToAlphabeticDistance());\n      }\n      return { width: n, height: s, fontBoundingBoxAscent: i, fontBoundingBoxDescent: o, topToAlphabeticDistance: r };\n    }\n    _AddLine(t, e, n, s, i, o) {\n      this._lines.push(C33.New(C33.WordWrap.Line, { fragments: t, width: e, height: n, fontBoundingBoxAscent: s, fontBoundingBoxDescent: i, topToAlphabeticDistance: o }));\n    }\n    WordWrap(t, e, n, s, i) {\n      if (\"string\" == typeof t && (t = [C33.New(C33.TextFragment, { chArr: C33.SplitGraphemes(t) })]), C33.clearArray(this._lines), !t.length || 1 === t.length && t[0].IsText() && t[0].IsEmpty() || n < 2) return;\n      if (1 === t.length) {\n        const s2 = t[0];\n        if (s2.IsText() && s2.GetLength() <= 100 && !s2.HasNewLine()) {\n          let { width: t2, height: o2, fontBoundingBoxAscent: r, fontBoundingBoxDescent: h, topToAlphabeticDistance: a } = e(s2);\n          if (t2 += i, s2.SetWidth(t2), s2.SetHeight(o2), s2.SetFontBoundingBoxAscent(r || 0), s2.SetFontBoundingBoxDescent(h || 0), s2.SetTopToAlphabeticDistance(a || 0), t2 <= n) return void this._AddLine([s2], t2, o2, r, h, a);\n        }\n      }\n      let o;\n      o = \"word\" === s ? this._TokeniseByWord(t) : \"cjk\" === s ? this._TokeniseByCJK(t) : this._TokeniseByChar(t), this._WrapText(o, e, n, i);\n    }\n    _TokeniseByWord(t) {\n      const e = [];\n      let n = [], s = false;\n      for (const i of t) {\n        const t2 = i.GetStyles();\n        if (i.IsIcon()) n.length > 0 && e.push(n), e.push([i]), n = [];\n        else for (const o of i.GetCharacterArray()) if (IsNewline(o)) n.length > 0 && e.push(n), e.push([C33.New(C33.TextFragment, { chArr: [\"\\n\"], styles: t2 })]), n = [];\n        else if (0 === n.length) n.push(C33.New(C33.TextFragment, { chArr: [o], styles: t2 })), s = IsWordBreakWhiteSpace(o);\n        else {\n          const i2 = IsWordBreakWhiteSpace(o);\n          if (i2 === s) {\n            const e2 = n.at(-1);\n            e2.GetStyles() === t2 ? e2._AppendChar(o) : n.push(C33.New(C33.TextFragment, { chArr: [o], styles: t2 }));\n          } else e.push(n), n = [C33.New(C33.TextFragment, { chArr: [o], styles: t2 })], s = i2;\n        }\n      }\n      return n.length > 0 && e.push(n), e;\n    }\n    _TokeniseByCJK(t) {\n      const e = [];\n      let n = [], s = false;\n      for (const i of t) {\n        const t2 = i.GetStyles();\n        if (i.IsIcon()) n.length > 0 && e.push(n), e.push([i]), n = [];\n        else for (const o of i.GetCharacterArray()) if (IsNewline(o)) n.length > 0 && e.push(n), e.push([C33.New(C33.TextFragment, { chArr: [\"\\n\"], styles: t2 })]), n = [];\n        else if (0 === n.length) n.push(C33.New(C33.TextFragment, { chArr: [o], styles: t2 })), s = IsOpeningCJKPunctiationChar(o);\n        else if (s || IsContinuingCJKPunctuationChar(o)) {\n          const e2 = n.at(-1);\n          e2.GetStyles() === t2 ? e2._AppendChar(o) : n.push(C33.New(C33.TextFragment, { chArr: [o], styles: t2 })), s = IsOpeningCJKPunctiationChar(o);\n        } else e.push(n), n = [C33.New(C33.TextFragment, { chArr: [o], styles: t2 })], s = IsOpeningCJKPunctiationChar(o);\n      }\n      return n.length > 0 && e.push(n), e;\n    }\n    _TokeniseByChar(t) {\n      const e = [];\n      for (const n of t) if (n.IsText()) {\n        const t2 = n.GetCharacterArray();\n        C33.appendArray(e, t2.map((t3) => [C33.New(C33.TextFragment, { chArr: [t3], styles: n.GetStyles() })]));\n      } else e.push([n]);\n      return e;\n    }\n    _CopyLine(t) {\n      return t.map((t2) => t2._Clone());\n    }\n    _AddWordToLine(t, e) {\n      const n = t.length ? t.at(-1) : null;\n      let s = 0;\n      n && n.IsText() && e[0].IsText() && e[0].GetStyles() === n.GetStyles() && (n._Append(e[0].GetCharacterArray()), s = 1);\n      for (let n2 = e.length; s < n2; ++s) {\n        const n3 = e[s];\n        t.push(n3._Clone());\n      }\n    }\n    _WrapText(t, e, n, s) {\n      let i = [], o = 0, r = 0, h = 0, a = 0, c = 0;\n      for (const s2 of t) {\n        if (1 === s2.length && s2[0].IsText() && 1 === s2[0].GetLength() && IsNewline(s2[0].GetCharacterArray()[0])) {\n          if (0 === r) {\n            const t3 = e(C33.New(C33.TextFragment, { chArr: [\" \"], styles: s2[0].GetStyles() }));\n            r = t3.height, h = t3.fontBoundingBoxAscent || 0, a = t3.fontBoundingBoxDescent || 0, c = t3.topToAlphabeticDistance || 0;\n          }\n          this._AddLine(i, o, r, h, a, c), i = [], o = 0, r = 0, h = 0, a = 0, c = 0;\n          continue;\n        }\n        const t2 = this._CopyLine(i);\n        this._AddWordToLine(t2, s2);\n        const l = this._MeasureLine(t2, e), u = l.width;\n        if (u >= n) if (i.length > 0 && this._AddLine(i, o, r, h, a, c), i = [], s2[0].IsText() && C33.IsCharArrayAllWhitespace(s2[0].GetCharacterArray())) o = 0, r = 0, h = 0, a = 0, c = 0;\n        else {\n          this._AddWordToLine(i, s2);\n          const t3 = this._MeasureLine(i, e);\n          o = t3.width, r = t3.height, h = t3.fontBoundingBoxAscent, a = t3.fontBoundingBoxDescent, c = t3.topToAlphabeticDistance;\n        }\n        else i = t2, o = u, r = l.height, h = l.fontBoundingBoxAscent, a = l.fontBoundingBoxDescent, c = l.topToAlphabeticDistance;\n      }\n      i.length > 0 && this._AddLine(i, o, r, h, a, c), this._TrimLinesTrailingWhitespace(e, s);\n    }\n    _TrimLinesTrailingWhitespace(t, e) {\n      for (const n of this._lines) {\n        const s = n._GetFragmentsArray();\n        if (!s.length) continue;\n        let i = s.at(-1);\n        if (i.IsText()) {\n          const o = i.GetCharacterArray(), r = o.slice(0);\n          if (WordBreakTrimEnd(r), 0 === r.length) n.OffsetWidth(-i.GetWidth()), s.pop();\n          else if (r.length < o.length) {\n            i.SetCharacterArray(r);\n            const e2 = t(i).width, s2 = i.GetWidth() - e2;\n            i.SetWidth(e2), n.OffsetWidth(-s2);\n          }\n          0 !== e && s.length > 0 && (i = s.at(-1), i.OffsetWidth(e), n.OffsetWidth(e));\n        }\n      }\n    }\n    Clear() {\n      C33.clearArray(this._lines);\n    }\n    GetMaxLineWidth() {\n      return this._lines.reduce((t, e) => Math.max(t, e.GetWidth()), 0);\n    }\n    GetTotalLineHeight() {\n      return this._lines.reduce((t, e) => t + e.GetHeight(), 0);\n    }\n  };\n}\nvar IsWordBreakWhiteSpace2;\nvar IsOpeningCJKPunctiationChar2;\nvar IsContinuingCJKPunctuationChar2;\nvar WordBreakTrimEnd2;\nvar IsNewline2;\n{\n  const C33 = self.C3;\n  C33.WordWrap.Line = class {\n    constructor(t) {\n      this._fragments = t.fragments || [], this._width = t.width || -1, this._height = t.height || -1, this._fontBoundingBoxAscent = t.fontBoundingBoxAscent || -1, this._fontBoundingBoxDescent = t.fontBoundingBoxDescent || -1, this._topToAlphabeticDistance = t.topToAlphabeticDistance || -1, this._posX = 0, this._posY = 0;\n    }\n    fragments() {\n      return this._fragments.values();\n    }\n    *fragmentsReverse() {\n      const t = this._fragments;\n      for (let e = t.length - 1; e >= 0; --e) yield t[e];\n    }\n    _GetFragmentsArray() {\n      return this._fragments;\n    }\n    OffsetWidth(t) {\n      this._width += t;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    GetFoundBoundingBoxAscent() {\n      return this._fontBoundingBoxAscent;\n    }\n    GetFontBoundingBoxDescent() {\n      return this._fontBoundingBoxDescent;\n    }\n    GetTopToAlphabeticDistance() {\n      return this._topToAlphabeticDistance;\n    }\n    SetPosX(t) {\n      this._posX = t;\n    }\n    GetPosX() {\n      return this._posX;\n    }\n    SetPosY(t) {\n      this._posY = t;\n    }\n    GetPosY() {\n      return this._posY;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.FragmentBase = class {\n    constructor(t) {\n      this._styles = t.styles || [], this._width = t.width || -1, this._height = t.height || -1, this._fontBoundingBoxAscent = t.fontBoundingBoxAscent || -1, this._fontBoundingBoxDescent = t.fontBoundingBoxDescent || -1, this._topToAlphabeticDistance = t.topToAlphabeticDistance || -1, this._posX = 0, this._posY = 0;\n    }\n    IsText() {\n      return false;\n    }\n    IsIcon() {\n      return false;\n    }\n    GetStyles() {\n      return this._styles;\n    }\n    GetStyleTag(t) {\n      const e = this._styles;\n      for (let s = e.length - 1; s >= 0; --s) {\n        const n = e[s];\n        if (n.tag === t) return n;\n      }\n      return null;\n    }\n    HasStyleTag(t) {\n      return !!this.GetStyleTag(t);\n    }\n    GetStyleMap() {\n      const t = /* @__PURE__ */ new Map();\n      for (const e of this._styles) t.set(e.tag, e.param);\n      return t;\n    }\n    OffsetWidth(t) {\n      this._width += t;\n    }\n    SetWidth(t) {\n      this._width = t;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    SetHeight(t) {\n      this._height = t;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    SetFontBoundingBoxAscent(t) {\n      this._fontBoundingBoxAscent = t;\n    }\n    GetFontBoundingBoxAscent() {\n      return this._fontBoundingBoxAscent;\n    }\n    SetFontBoundingBoxDescent(t) {\n      this._fontBoundingBoxDescent = t;\n    }\n    GetFontBoundingBoxDescent() {\n      return this._fontBoundingBoxDescent;\n    }\n    SetTopToAlphabeticDistance(t) {\n      this._topToAlphabeticDistance = t;\n    }\n    GetTopToAlphabeticDistance() {\n      return this._topToAlphabeticDistance;\n    }\n    SetPosX(t) {\n      this._posX = t;\n    }\n    GetPosX() {\n      return this._posX;\n    }\n    SetPosY(t) {\n      this._posY = t;\n    }\n    GetPosY() {\n      return this._posY;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.TextFragment = class extends C33.FragmentBase {\n    constructor(t) {\n      super(t), this._chArr = t.chArr;\n    }\n    IsText() {\n      return true;\n    }\n    _Append(t) {\n      C33.appendArray(this._chArr, t), this._width = -1, this._height = -1, this._fontBoundingBoxAscent = -1, this._fontBoundingBoxDescent = -1, this._topToAlphabeticDistance = -1;\n    }\n    _AppendChar(t) {\n      this._chArr.push(t);\n    }\n    _Clone() {\n      return C33.New(C33.TextFragment, { chArr: this._chArr.slice(0), styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });\n    }\n    GetCharacterArray() {\n      return this._chArr;\n    }\n    SetCharacterArray(t) {\n      this._chArr = t;\n    }\n    GetLength() {\n      return this._chArr.length;\n    }\n    IsEmpty() {\n      return 0 === this._chArr.length;\n    }\n    HasNewLine() {\n      return this._chArr.includes(\"\\n\");\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.IconFragment = class extends C33.FragmentBase {\n    constructor(t) {\n      super(t), this._icon = t.icon;\n    }\n    IsIcon() {\n      return true;\n    }\n    GetIconParameter() {\n      return this._icon;\n    }\n    _Clone() {\n      return C33.New(C33.IconFragment, { icon: this._icon, styles: this._styles, width: this._width, height: this._height, fontBoundingBoxAscent: this._fontBoundingBoxAscent, fontBoundingBoxDescent: this._fontBoundingBoxDescent, topToAlphabeticDistance: this._topToAlphabeticDistance });\n    }\n    GetTextIcon(t) {\n      if (!t) return null;\n      let e = Number(this._icon);\n      return String(e) === this._icon ? (e = Math.floor(e), t.GetTextIconByIndex(e)) : t.GetTextIconByTag(this._icon);\n    }\n    CalculateWidthFromHeight(t) {\n      const e = this.GetTextIcon(t);\n      this._width = e ? this._height * e.GetWidth() / e.GetHeight() : 0;\n    }\n    GetDrawable(t) {\n      const e = this.GetTextIcon(t);\n      return e ? e.GetDrawable() : null;\n    }\n    GetLength() {\n      return 1;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.TextIconManager = class {\n    constructor(t) {\n      this._iconSets = /* @__PURE__ */ new Map(), this._getIconSetMetaCallback = t.getIconSetMeta, this._getIconSetContentCallback = t.getIconSetContent;\n    }\n    Release() {\n      for (const t of this._iconSets.values()) t.Release();\n      this._iconSets.clear();\n    }\n    GetIconSet(t) {\n      let e = this._iconSets.get(t);\n      if (e) return e;\n      const n = this._getIconSetMetaCallback(t);\n      return e = C33.New(C33.TextIconSet, this, { source: t, iconMeta: n }), this._iconSets.set(t, e), e;\n    }\n    HasIconSet(t) {\n      return this._iconSets.has(t);\n    }\n    DeleteIconSet(t) {\n      const e = this._iconSets.get(t);\n      e && e.Release(), this._iconSets.delete(t);\n    }\n    async _GetIconSetContent(t) {\n      return await this._getIconSetContentCallback(t);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.TextIconSet = class {\n    constructor(t, s) {\n      this._textIconManager = t, this._source = s.source, this._iconsArray = [], this._iconsByTag = /* @__PURE__ */ new Map(), this._hasStartedLoad = false, this._isLoading = false, this._loadPromise = null;\n      const o = s.iconMeta.icons;\n      for (let t2 = 0, s2 = o.length; t2 < s2; ++t2) {\n        const s3 = o[t2], e = C33.New(C33.TextIcon, this, { index: t2, tag: s3.tag, source: s3.source, width: s3.width, height: s3.height });\n        this._iconsArray.push(e), s3.tag && this._iconsByTag.set(s3.tag.toLowerCase(), e);\n      }\n    }\n    Release() {\n      for (const t of this._iconsArray) t.Release();\n      C33.clearArray(this._iconsArray), this._iconsByTag.clear(), this._textIconManager = null, this._source = null;\n    }\n    HasLoaded() {\n      return this._hasStartedLoad;\n    }\n    IsLoading() {\n      return this._isLoading;\n    }\n    LoadContent() {\n      return this._loadPromise || (this._loadPromise = this._DoLoadContent()), this._loadPromise;\n    }\n    async _DoLoadContent() {\n      if (this._hasStartedLoad) return;\n      this._hasStartedLoad = true, this._isLoading = true;\n      const t = await this._textIconManager._GetIconSetContent(this._source);\n      if (!this._textIconManager) return;\n      const s = t.icons;\n      for (let t2 = 0, o = Math.min(s.length, this._iconsArray.length); t2 < o; ++t2) {\n        const o2 = s[t2].drawable;\n        this._iconsArray[t2]._SetDrawable(o2);\n      }\n      this._isLoading = false;\n    }\n    GetTextIconByIndex(t) {\n      return (t = Math.floor(t)) < 0 || t >= this._iconsArray.length ? null : this._iconsArray[t];\n    }\n    GetTextIconByTag(t) {\n      return this._iconsByTag.get(t.toLowerCase()) || null;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.TextIcon = class {\n    constructor(t, e) {\n      this._textIconSet = t, this._source = e.source || null, this._index = e.index, this._tag = e.tag, this._width = e.width, this._height = e.height, this._drawable = null;\n    }\n    Release() {\n      this._width = 0, this._height = 0, this._textIconSet = null;\n    }\n    GetSource() {\n      return this._source;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    _SetDrawable(t) {\n      this._drawable = t;\n    }\n    GetDrawable() {\n      return this._drawable;\n    }\n  };\n}\n{\n  let PlaneFromPoints = function(t, e, r, n) {\n    const a = tempVec3c;\n    vec3.subtract(tempVec3a, r, e), vec3.subtract(tempVec3b, t, e), vec3.cross(a, tempVec3a, tempVec3b), vec3.normalize(a, a), n.set(a[0], a[1], a[2], vec3.dot(t, a));\n  }, IsInFrontOfPlane = function(t, e, r, n, a, c, s) {\n    const o = s.x, i = s.y, l = s.z, f = s.w, P = s.xF, h = s.yF, m = s.zF, p = 1 - P, v = 1 - h, u = 1 - m;\n    if (o * t * P + o * n * p + i * e * h + i * a * v + l * r * m + l * c * u >= f) return true;\n    return o * n * P + o * t * p + i * a * h + i * e * v + l * c * m + l * r * u > f;\n  }, IsPointInFrontOfPlane = function(t, e, r, n) {\n    return n.x * t + n.y * e + n.z * r >= n.w;\n  };\n  PlaneFromPoints2 = PlaneFromPoints, IsInFrontOfPlane2 = IsInFrontOfPlane, IsPointInFrontOfPlane2 = IsPointInFrontOfPlane;\n  const C33 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempVec3a = vec3.create(), tempVec3b = vec3.create(), tempVec3c = vec3.create(), tempVec4 = vec4.create(), tempMat4 = mat4.create(), neartl = vec3.create(), neartr = vec3.create(), nearbl = vec3.create(), nearbr = vec3.create(), fartl = vec3.create(), fartr = vec3.create(), farbl = vec3.create(), farbr = vec3.create(), unitViewport = vec4.fromValues(0, 0, 1, 1);\n  C33.Gfx = { Project(t, e, r, n, a, c, s) {\n    const o = n[0] * t + n[4] * e + n[8] * r + n[12], i = n[1] * t + n[5] * e + n[9] * r + n[13], l = n[2] * t + n[6] * e + n[10] * r + n[14], f = n[3] * t + n[7] * e + n[11] * r + n[15];\n    let P = a[0] * o + a[4] * i + a[8] * l + a[12] * f, h = a[1] * o + a[5] * i + a[9] * l + a[13] * f, m = a[2] * o + a[6] * i + a[10] * l + a[14] * f, p = a[3] * o + a[7] * i + a[11] * l + a[15] * f;\n    return 0 !== p && (p = 1 / p, P *= p, h *= p, m *= p, s[0] = (0.5 * P + 0.5) * c[2] + c[0], s[1] = (0.5 * h + 0.5) * c[3] + c[1], s[2] = 0.5 * (1 + m), true);\n  }, Unproject(t, e, r, n, a, c, s) {\n    const o = tempMat4, i = tempVec4;\n    return mat4.multiply(o, a, n), null !== mat4.invert(o, o) && (i[0] = (t - c[0]) / c[2] * 2 - 1, i[1] = (e - c[1]) / c[3] * 2 - 1, i[2] = 2 * r - 1, i[3] = 1, vec4.transformMat4(i, i, o), 0 !== i[3] && (i[3] = 1 / i[3], s[0] = i[0] * i[3], s[1] = i[1] * i[3], s[2] = i[2] * i[3], true));\n  }, UnprojectScreenToWorldZ(t, e, r, n, a, c, s) {\n    const o = tempVec3a, i = tempVec3b;\n    if (!C33.Gfx.Unproject(t, e, 0, n, a, c, o)) return false;\n    if (!C33.Gfx.Unproject(t, e, 1, n, a, c, i)) return false;\n    const l = tempVec3b;\n    vec3.subtract(l, i, o);\n    const f = tempVec3c;\n    vec3.set(f, 0, 0, 1);\n    const P = -r, h = vec3.dot(f, l);\n    let m = 0;\n    if (0 === h) {\n      if (0 !== vec3.dot(f, o) + P) return false;\n    } else if (m = -(vec3.dot(o, f) + P) / h, m < 0) return false;\n    return vec3.scaleAndAdd(s, o, l, m), true;\n  } };\n  class Plane {\n    constructor() {\n      this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, this.xF = NaN, this.yF = NaN, this.zF = NaN;\n    }\n    set(t, e, r, n) {\n      this.x = t, this.y = e, this.z = r, this.w = n, this.xF = t > 0 ? 1 : 0, this.yF = e > 0 ? 1 : 0, this.zF = r > 0 ? 1 : 0;\n    }\n  }\n  C33.Gfx.ViewFrustum = class {\n    constructor() {\n      this._leftP = new Plane(), this._topP = new Plane(), this._rightP = new Plane(), this._bottomP = new Plane(), this._nearP = new Plane(), this._farP = new Plane();\n    }\n    CalculatePlanes(t, e) {\n      const r = unitViewport;\n      C33.Gfx.Unproject(0, 1, 0, t, e, r, neartl), C33.Gfx.Unproject(1, 1, 0, t, e, r, neartr), C33.Gfx.Unproject(0, 0, 0, t, e, r, nearbl), C33.Gfx.Unproject(1, 0, 0, t, e, r, nearbr), C33.Gfx.Unproject(0, 1, 1, t, e, r, fartl), C33.Gfx.Unproject(1, 1, 1, t, e, r, fartr), C33.Gfx.Unproject(0, 0, 1, t, e, r, farbl), C33.Gfx.Unproject(1, 0, 1, t, e, r, farbr), PlaneFromPoints(nearbl, neartl, fartl, this._leftP), PlaneFromPoints(neartl, neartr, fartr, this._topP), PlaneFromPoints(neartr, nearbr, farbr, this._rightP), PlaneFromPoints(nearbr, nearbl, farbl, this._bottomP), PlaneFromPoints(farbl, fartl, fartr, this._farP), PlaneFromPoints(nearbr, neartr, neartl, this._nearP);\n    }\n    ContainsAABB(t, e, r, n, a, c) {\n      return IsInFrontOfPlane(t, e, r, n, a, c, this._leftP) && IsInFrontOfPlane(t, e, r, n, a, c, this._topP) && IsInFrontOfPlane(t, e, r, n, a, c, this._rightP) && IsInFrontOfPlane(t, e, r, n, a, c, this._bottomP) && IsInFrontOfPlane(t, e, r, n, a, c, this._nearP) && IsInFrontOfPlane(t, e, r, n, a, c, this._farP);\n    }\n    IsBehindNearPlane(t, e, r) {\n      return !IsPointInFrontOfPlane(t, e, r, this._nearP);\n    }\n  };\n}\nvar PlaneFromPoints2;\nvar IsInFrontOfPlane2;\nvar IsPointInFrontOfPlane2;\n{\n  const C33 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempMat4 = mat4.create(), tmpVec3a = vec3.fromValues(0, 0, 0), tmpVec3b = vec3.fromValues(0, 0, 0), tmpVec3c = vec3.fromValues(0, 0, 0), defaultUpVector = vec3.fromValues(0, 1, 0), tmpVec4 = vec4.fromValues(0, 0, 0, 0), tmpQuad = new C33.Quad(), tmpRect = new C33.Rect(), defaultTexCoordsQuad = new C33.Quad(0, 0, 1, 0, 1, 1, 0, 1), DEFAULT_RENDERERBASE_OPTS = { nearZ: 1, farZ: 1e4 }, matWebGLtoWebGPU = mat4.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);\n  C33.Gfx.RendererBase = class {\n    constructor(e) {\n      e = Object.assign({}, DEFAULT_RENDERERBASE_OPTS, e), this._width = 0, this._height = 0, this._fovY = C33.toRadians(45), this._tan_fovY_2 = Math.tan(this._fovY / 2), this._matP = mat4.create(), this._matMV = mat4.create(), this._zAxisScale = false, this._nearZ = e.nearZ, this._farZ = e.farZ, this._allShaderPrograms = [], this._shaderProgramsByName = /* @__PURE__ */ new Map(), this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._stateGroups = /* @__PURE__ */ new Map(), this._currentStateGroup = null, this._blendModeTable = [], this._namedBlendModeMap = /* @__PURE__ */ new Map(), this._baseZ = 0, this._currentZ = 0, this._lineWidth = 1, this._lineWidthStack = [this._lineWidth], this._lineCap = 1, this._lineCapStack = [this._lineCap], this._lineOffset = 0.5, this._lineOffsetStack = [this._lineOffset], this._frameNumber = 0, this._enableMipmaps = true, this._hasMajorPerformanceCaveat = false;\n    }\n    FillIndexBufferData(e) {\n      let t = 0, i = e.length, a = 0;\n      for (; t < i; ) e[t++] = a, e[t++] = a + 1, e[t++] = a + 2, e[t++] = a, e[t++] = a + 2, e[t++] = a + 3, a += 4;\n    }\n    _ClearState() {\n      this._baseZ = 0, this._currentZ = 0, this._spTextureFill = null, this._spPoints = null, this._spTilemapFill = null, this._spTileRandomization = null, this._spColorFill = null, this._spLinearGradientFill = null, this._spPenumbraFill = null, this._spHardEllipseFill = null, this._spHardEllipseOutline = null, this._spSmoothEllipseFill = null, this._spSmoothEllipseOutline = null, this._spSmoothLineFill = null, this._ClearAllShaderPrograms();\n    }\n    InitState() {\n      this._ClearState(), this._currentStateGroup = null;\n    }\n    OnDeviceOrContextLost() {\n      for (const e of this._allShaderPrograms) e.Release();\n      this._ClearState();\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    GetDefaultCameraZ(e) {\n      return this.IsZAxisScaleNormalized() ? 100 : e / (2 * this._GetTanFovYDiv2());\n    }\n    GetZAxisScaleFactor(e) {\n      if (this.IsZAxisScaleNormalized()) {\n        return e / (2 * this._GetTanFovYDiv2()) / this.GetDefaultCameraZ(e);\n      }\n      return 1;\n    }\n    SetNearZ(e) {\n      this._nearZ = e;\n    }\n    GetNearZ() {\n      return this._nearZ;\n    }\n    SetFarZ(e) {\n      this._farZ = e;\n    }\n    GetFarZ() {\n      return this._farZ;\n    }\n    SetFovY(e) {\n      this._fovY = e, this._tan_fovY_2 = Math.tan(this._fovY / 2);\n    }\n    GetFovY() {\n      return this._fovY;\n    }\n    _GetTanFovYDiv2() {\n      return this._tan_fovY_2;\n    }\n    SetZAxisScaleNormalized() {\n      this._zAxisScale = false;\n    }\n    SetZAxisScaleRegular() {\n      this._zAxisScale = true;\n    }\n    IsZAxisScaleNormalized() {\n      return !this._zAxisScale;\n    }\n    IsZAxisScaleRegular() {\n      return this._zAxisScale;\n    }\n    CalculatePerspectiveMatrix(e, t, i = 0.5, a = 0.5) {\n      const s = this.GetNearZ(), r = this.GetFarZ(), l = this.GetFovY();\n      if (0.5 === i && 0.5 === a) this.IsWebGPU() ? mat4.perspectiveZO(e, l, t, s, r) : mat4.perspective(e, l, t, s, r);\n      else {\n        const l2 = 2 * (i = 1 - i) - 2, n = 2 * i, h = 2 * a - 2, o = 2 * a, p = this._GetTanFovYDiv2() * s, _ = p * t;\n        mat4.frustum(e, l2 * _, n * _, h * p, o * p, s, r), this.IsWebGPU() && mat4.mul(e, matWebGLtoWebGPU, e);\n      }\n    }\n    CalculateOrthographicMatrix(e, t, i, a = 1) {\n      const s = self.devicePixelRatio, r = 2 * this.GetDefaultCameraZ(i) * s * this._GetTanFovYDiv2() / i, l = t * r / (2 * s * a), n = i * r / (2 * s * a), h = -l, o = l, p = -n, _ = n;\n      this.IsWebGPU() ? mat4.orthoZO(e, h, o, p, _, this.GetNearZ(), this.GetFarZ()) : mat4.ortho(e, h, o, p, _, this.GetNearZ(), this.GetFarZ());\n    }\n    CalculateLookAtModelView(e, t, i, a, s, r = 1) {\n      let l = 1;\n      this.IsZAxisScaleNormalized() && (l = 200 * this._GetTanFovYDiv2() / s);\n      const n = tmpVec3c;\n      vec3.set(n, l, -l, 1);\n      const h = tmpVec3a, o = tmpVec3b;\n      vec3.multiply(h, t, n), vec3.multiply(o, i, n), mat4.lookAt(e, h, o, a || defaultUpVector), n[2] = r, mat4.scale(e, e, n);\n    }\n    CalculateLookAtModelView2(e, t, i, a, s, r, l, n) {\n      return vec3.set(tmpVec3a, e, t, i), vec3.set(tmpVec3b, a, s, r), this.CalculateLookAtModelView(tempMat4, tmpVec3a, tmpVec3b, defaultUpVector, l, n), tempMat4;\n    }\n    _AddShaderProgram(e) {\n      this._allShaderPrograms.push(e), this._shaderProgramsByName.set(e.GetName(), e);\n    }\n    _RemoveShaderProgram(e) {\n      const t = this._allShaderPrograms.indexOf(e);\n      -1 !== t && this._allShaderPrograms.splice(t, 1), this._shaderProgramsByName.delete(e.GetName());\n    }\n    _ClearAllShaderPrograms() {\n      C33.clearArray(this._allShaderPrograms), this._shaderProgramsByName.clear();\n    }\n    GetShaderProgramByName(e) {\n      return this._shaderProgramsByName.get(e) || null;\n    }\n    GetTextureFillShaderProgram() {\n      return this._spTextureFill;\n    }\n    SetTextureFillMode() {\n      this.SetProgram(this._spTextureFill);\n    }\n    GetPointsRenderingProgram() {\n      return this._spPoints;\n    }\n    SetPointsRenderingProgram() {\n      this.SetProgram(this._spPoints);\n    }\n    SetTilemapFillMode() {\n      this.SetProgram(this._spTilemapFill);\n    }\n    SetTileRandomizationMode() {\n      this.SetProgram(this._spTileRandomization);\n    }\n    SetColorFillMode() {\n      this.SetProgram(this._spColorFill);\n    }\n    SetLinearGradientFillMode() {\n      this.SetProgram(this._spLinearGradientFill);\n    }\n    SetPenumbraFillMode() {\n      this.SetProgram(this._spPenumbraFill);\n    }\n    SetHardEllipseFillMode() {\n      this.SetProgram(this._spHardEllipseFill);\n    }\n    SetHardEllipseOutlineMode() {\n      this.SetProgram(this._spHardEllipseOutline);\n    }\n    SetSmoothEllipseFillMode() {\n      this.SetProgram(this._spSmoothEllipseFill);\n    }\n    SetSmoothEllipseOutlineMode() {\n      this.SetProgram(this._spSmoothEllipseOutline);\n    }\n    SetSmoothLineFillMode() {\n      this.SetProgram(this._spSmoothLineFill);\n    }\n    _SetCurrentStateGroup(e) {\n      this._currentStateGroup = e;\n    }\n    GetCurrentStateGroup() {\n      return this._currentStateGroup;\n    }\n    AcquireStateGroup(e, t, i, a) {\n      const s = C33.Gfx.StateGroup.MakeKey(e, t, i, a);\n      let r = this._stateGroups.get(s);\n      return r || (r = C33.New(C33.Gfx.StateGroup, this, e, t, i, a), this._stateGroups.set(s, r)), r.AddRef(), r;\n    }\n    ReleaseStateGroup(e) {\n      e.DecRef(), 0 === e._GetRefCount() && (this._currentStateGroup === e && (this._currentStateGroup = null), this._stateGroups.delete(e.GetKey()), e.Release());\n    }\n    _InitBlendModeData(e) {\n      C33.clearArray(this._blendModeTable), this._namedBlendModeMap.clear();\n      let t = 0;\n      for (const i of e) {\n        const e2 = i[0], a = i[1], s = i[2];\n        this._blendModeTable.push([a, s]), this._namedBlendModeMap.set(e2, { number: t, srcBlend: a, destBlend: s }), t++;\n      }\n    }\n    _GetBlendByIndex(e) {\n      return this._blendModeTable[e];\n    }\n    GetSrcBlendByIndex(e) {\n      return this._GetBlendByIndex(e)[0];\n    }\n    GetDestBlendByIndex(e) {\n      return this._GetBlendByIndex(e)[1];\n    }\n    GetNamedBlend(e) {\n      const t = this._namedBlendModeMap.get(e);\n      if (void 0 === t) throw new Error(\"invalid blend name\");\n      return t;\n    }\n    NamedBlendToNumber(e) {\n      const t = this._namedBlendModeMap.get(e);\n      if (void 0 === t) throw new Error(\"invalid blend name\");\n      return t.number;\n    }\n    SetBaseZ(e) {\n      this._baseZ = e;\n    }\n    GetBaseZ() {\n      return this._baseZ;\n    }\n    SetCurrentZ(e) {\n      this._currentZ = e, this._currentStateGroup = null;\n    }\n    GetCurrentZ() {\n      return this._currentZ;\n    }\n    Line(e, t, i, a) {\n      const s = C33.angleTo(e, t, i, a), r = Math.sin(s), l = Math.cos(s), n = 0.5 * this._lineWidth, h = r * n, o = l * n, p = this._lineCap;\n      2 === p ? this.LinePreCalc_LineCap2(e, t, 0, i, a, 0, h, o) : 1 === p ? this.LinePreCalc_LineCap1(e, t, 0, i, a, 0, h, o) : this.LinePreCalc_LineCap0(e, t, 0, i, a, 0, h, o);\n    }\n    Line3D(e, t, i, a, s, r) {\n      const l = C33.angleTo(e, t, a, s), n = Math.sin(l), h = Math.cos(l), o = 0.5 * this._lineWidth, p = n * o, _ = h * o, c = this._lineCap;\n      2 === c ? this.LinePreCalc_LineCap2(e, t, i, a, s, r, p, _) : 1 === c ? this.LinePreCalc_LineCap1(e, t, i, a, s, r, p, _) : this.LinePreCalc_LineCap0(e, t, i, a, s, r, p, _);\n    }\n    LinePreCalc_LineCap2(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h - n, p = t + h - l, _ = a + h + n, c = s + h + l, u = 2 * n, d = 2 * l, C = o + l, m = p - n, L = o - l + u, f = p + n + d, g = _ + l, S = c - n, P = _ - l - u, G = c + n - d;\n      this.Quad3D2(C, m, i, g, S, r, P, G, r, L, f, i, defaultTexCoordsQuad);\n    }\n    LinePreCalc_LineCap1(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h - n, p = t + h - l, _ = a + h + n, c = s + h + l, u = o + l, d = p - n, C = o - l, m = p + n, L = _ + l, f = c - n, g = _ - l, S = c + n;\n      this.Quad3D2(u, d, i, L, f, r, g, S, r, C, m, i, defaultTexCoordsQuad);\n    }\n    LinePreCalc_LineCap0(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h, p = t + h, _ = a + h, c = s + h, u = o + l, d = p - n, C = o - l, m = p + n, L = _ + l, f = c - n, g = _ - l, S = c + n;\n      this.Quad3D2(u, d, i, L, f, r, g, S, r, C, m, i, defaultTexCoordsQuad);\n    }\n    TexturedLine(e, t, i, a, s, r) {\n      const l = C33.angleTo(e, t, i, a), n = Math.sin(l), h = Math.cos(l), o = 0.5 * this._lineWidth, p = n * o, _ = h * o, c = this._lineCap;\n      2 === c ? this.TexturedLinePreCalc_LineCap2(e, t, i, a, p, _, s, r) : 1 === c ? this.TexturedLinePreCalc_LineCap1(e, t, i, a, p, _, s, r) : this.TexturedLinePreCalc_LineCap0(e, t, i, a, p, _, s, r);\n    }\n    TexturedLinePreCalc_LineCap2(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h - r, p = t + h - s, _ = i + h + r, c = a + h + s, u = 2 * r, d = 2 * s, C = o + s, m = p - r, L = o - s + u, f = p + r + d, g = _ + s, S = c - r, P = _ - s - u, G = c + r - d;\n      tmpQuad.set(C, m, g, S, P, G, L, f), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);\n    }\n    TexturedLinePreCalc_LineCap1(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h - r, p = t + h - s, _ = i + h + r, c = a + h + s, u = o + s, d = p - r, C = o - s, m = p + r, L = _ + s, f = c - r, g = _ - s, S = c + r;\n      tmpQuad.set(u, d, L, f, g, S, C, m), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);\n    }\n    TexturedLinePreCalc_LineCap0(e, t, i, a, s, r, l, n) {\n      const h = this._lineOffset, o = e + h, p = t + h, _ = i + h, c = a + h, u = o + s, d = p - r, C = o - s, m = p + r, L = _ + s, f = c - r, g = _ - s, S = c + r;\n      tmpQuad.set(u, d, L, f, g, S, C, m), tmpRect.set(l, 0, n, 0), this.Quad3(tmpQuad, tmpRect);\n    }\n    LineRect(e, t, i, a) {\n      const s = 0.5 * this._lineWidth, r = this._lineCap;\n      2 === r ? this._LineRectPreCalc_LineCap2(e, t, i, a, s) : 1 === r ? this._LineRectPreCalc_LineCap1(e, t, i, a, s) : this._LineRectPreCalc_LineCap0(e, t, i, a, s);\n    }\n    _LineRectPreCalc_LineCap2(e, t, i, a, s) {\n      this.LinePreCalc_LineCap2(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap2(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap2(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap2(e, a, 0, e, t, 0, -s, 0);\n    }\n    _LineRectPreCalc_LineCap1(e, t, i, a, s) {\n      this.LinePreCalc_LineCap1(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap1(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap1(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap1(e, a, 0, e, t, 0, -s, 0);\n    }\n    _LineRectPreCalc_LineCap0(e, t, i, a, s) {\n      this.LinePreCalc_LineCap0(e, t, 0, i, t, 0, 0, s), this.LinePreCalc_LineCap0(i, t, 0, i, a, 0, s, 0), this.LinePreCalc_LineCap0(i, a, 0, e, a, 0, 0, -s), this.LinePreCalc_LineCap0(e, a, 0, e, t, 0, -s, 0);\n    }\n    LineRect2(e) {\n      this.LineRect(e.getLeft(), e.getTop(), e.getRight(), e.getBottom());\n    }\n    LineQuad(e) {\n      const t = C33.angleTo(e.getTlx(), e.getTly(), e.getTrx(), e.getTry()), i = Math.sin(t), a = Math.cos(t), s = 0.5 * this._lineWidth, r = i * s, l = a * s, n = this._lineCap;\n      2 === n ? this._LineQuadPreCalc_LineCap2(e, r, l) : 1 === n ? this._LineQuadPreCalc_LineCap1(e, r, l) : this._LineQuadPreCalc_LineCap0(e, r, l);\n    }\n    _LineQuadPreCalc_LineCap2(e, t, i) {\n      this.LinePreCalc_LineCap2(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap2(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap2(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap2(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);\n    }\n    _LineQuadPreCalc_LineCap1(e, t, i) {\n      this.LinePreCalc_LineCap1(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap1(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap1(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap1(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);\n    }\n    _LineQuadPreCalc_LineCap0(e, t, i) {\n      this.LinePreCalc_LineCap0(e.getTlx(), e.getTly(), 0, e.getTrx(), e.getTry(), 0, t, i), this.LinePreCalc_LineCap0(e.getTrx(), e.getTry(), 0, e.getBrx(), e.getBry(), 0, i, -t), this.LinePreCalc_LineCap0(e.getBrx(), e.getBry(), 0, e.getBlx(), e.getBly(), 0, -t, -i), this.LinePreCalc_LineCap0(e.getBlx(), e.getBly(), 0, e.getTlx(), e.getTly(), 0, -i, t);\n    }\n    SetLineWidth(e) {\n      this._lineWidth = e, this._lineWidthStack[this._lineWidthStack.length - 1] = e;\n    }\n    GetLineWidth() {\n      return this._lineWidth;\n    }\n    PushLineWidth(e) {\n      if (this._lineWidthStack.length >= 100) throw new Error(\"pushed too many line widths - check push/pop pairs\");\n      this._lineWidthStack.push(e), this._lineWidth = e;\n    }\n    PopLineWidth() {\n      if (this._lineWidthStack.length <= 1) throw new Error(\"cannot pop last line width - check push/pop pairs\");\n      this._lineWidthStack.pop(), this._lineWidth = this._lineWidthStack.at(-1);\n    }\n    SetLineCapButt() {\n      this._lineCap = 0, this._lineCapStack[this._lineCapStack.length - 1] = 0;\n    }\n    SetLineCapSquare() {\n      this._lineCap = 1, this._lineCapStack[this._lineCapStack.length - 1] = 0;\n    }\n    SetLineCapZag() {\n      this._lineCap = 2, this._lineCapStack[this._lineCapStack.length - 1] = 0;\n    }\n    PushLineCap(e) {\n      if (\"butt\" === e) this.PushLineCapButt();\n      else if (\"square\" === e) this.PushLineCapSquare();\n      else {\n        if (\"zag\" !== e) throw new Error(\"invalid line cap\");\n        this.PushLineCapZag();\n      }\n    }\n    PushLineCapButt() {\n      if (this._lineCapStack.length >= 100) throw new Error(\"pushed too many line caps - check push/pop pairs\");\n      this._lineCapStack.push(0), this._lineCap = 0;\n    }\n    PushLineCapSquare() {\n      if (this._lineCapStack.length >= 100) throw new Error(\"pushed too many line caps - check push/pop pairs\");\n      this._lineCapStack.push(1), this._lineCap = 1;\n    }\n    PushLineCapZag() {\n      if (this._lineCapStack.length >= 100) throw new Error(\"pushed too many line caps - check push/pop pairs\");\n      this._lineCapStack.push(2), this._lineCap = 2;\n    }\n    PopLineCap() {\n      if (this._lineCapStack.length <= 1) throw new Error(\"cannot pop last line cap - check push/pop pairs\");\n      this._lineCapStack.pop(), this._lineCap = this._lineCapStack.at(-1);\n    }\n    SetLineOffset(e) {\n      this._lineOffset = e, this._lineOffsetStack[this._lineOffsetStack.length - 1] = e;\n    }\n    GetLineOffset() {\n      return this._lineOffset;\n    }\n    PushLineOffset(e) {\n      if (this._lineOffsetStack.length >= 100) throw new Error(\"pushed too many line offsets - check push/pop pairs\");\n      this._lineOffsetStack.push(e), this._lineOffset = e;\n    }\n    PopLineOffset() {\n      if (this._lineOffsetStack.length <= 1) throw new Error(\"cannot pop last line offset - check push/pop pairs\");\n      this._lineOffsetStack.pop(), this._lineOffset = this._lineOffsetStack.at(-1);\n    }\n    ConvexPoly(e) {\n      const t = e.length / 2;\n      if (t < 3) throw new Error(\"need at least 3 points\");\n      const i = t - 2, a = i - 1, s = e[0], r = e[1];\n      for (let t2 = 0; t2 < i; t2 += 2) {\n        const i2 = 2 * t2, l = e[i2 + 2], n = e[i2 + 3], h = e[i2 + 4], o = e[i2 + 5];\n        if (t2 === a) this.Quad2(s, r, l, n, h, o, h, o);\n        else {\n          const t3 = e[i2 + 6], a2 = e[i2 + 7];\n          this.Quad2(s, r, l, n, h, o, t3, a2);\n        }\n      }\n    }\n    GetNumVertexComponents() {\n      return 3;\n    }\n    Finish() {\n      this.EndBatch(true), this._frameNumber++;\n    }\n    GetFrameNumber() {\n      return this._frameNumber;\n    }\n    IncrementFrameNumber() {\n      this._frameNumber++;\n    }\n    SetMipmapsEnabled(e) {\n      this._enableMipmaps = !!e;\n    }\n    AreMipmapsEnabled() {\n      return this._enableMipmaps;\n    }\n    SetHasMajorPerformanceCaveat(e) {\n      this._hasMajorPerformanceCaveat = !!e;\n    }\n    HasMajorPerformanceCaveat() {\n      return this._hasMajorPerformanceCaveat;\n    }\n    IsWebGL() {\n      return false;\n    }\n    IsWebGPU() {\n      return false;\n    }\n    GetEstimatedBackBufferMemoryUsage() {\n    }\n    GetEstimatedRenderBufferMemoryUsage() {\n    }\n    GetEstimatedTextureMemoryUsage() {\n    }\n    GetEstimatedTotalMemoryUsage() {\n      return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage();\n    }\n    CreateRendererText() {\n      return C33.New(C33.Gfx.RendererText, this);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Gfx.ShaderProgramBase = class {\n    constructor(e, t) {\n      this._name = t.name, this._renderer = e, this._extendBoxHorizontal = t.extendBoxHorizontal || 0, this._extendBoxVertical = t.extendBoxVertical || 0, this._crossSampling = !!t.crossSampling, this._mustPreDraw = !!t.mustPreDraw, this._preservesOpaqueness = !!t.preservesOpaqueness, this._supports3dDirectRendering = !!t.supports3dDirectRendering, this._animated = !!t.animated, this._blendsBackground = !!t.blendsBackground, this._usesDepth = !!t.usesDepth, this._usesAnySrcRectOrPixelSize = false, this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;\n    }\n    Release() {\n      this._renderer = null;\n    }\n    GetRenderer() {\n      return this._renderer;\n    }\n    GetName() {\n      return this._name;\n    }\n    ExtendsBox() {\n      return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;\n    }\n    GetBoxExtendHorizontal() {\n      return this._extendBoxHorizontal;\n    }\n    GetBoxExtendVertical() {\n      return this._extendBoxVertical;\n    }\n    UsesCrossSampling() {\n      return this._crossSampling;\n    }\n    MustPreDraw() {\n      return this._mustPreDraw;\n    }\n    PreservesOpaqueness() {\n      return this._preservesOpaqueness;\n    }\n    Supports3DDirectRendering() {\n      return this._supports3dDirectRendering;\n    }\n    IsAnimated() {\n      return this._animated;\n    }\n    BlendsBackground() {\n      return this._blendsBackground;\n    }\n    UsesDepth() {\n      return this._usesDepth;\n    }\n    UsesAnySrcRectOrPixelSize() {\n      return this._usesAnySrcRectOrPixelSize;\n    }\n    NeedsPostDrawOrExtendsBox() {\n      return this._needsPostDrawOrExtendBox;\n    }\n    UsesIsSrcTexRotated() {\n      return false;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Gfx.StateGroup = class {\n    constructor(e, r, t, s, o) {\n      this._renderer = e, this._refCount = 0, this._shaderProgram = null, this._shaderProgramName = \"\", this._blendMode = t, this._color = C33.New(C33.Color), this._color.set(s), this._zElevation = o, \"string\" == typeof r ? this._shaderProgramName = r : (this._shaderProgram = r, this._shaderProgramName = this._shaderProgram.GetName());\n    }\n    Release() {\n      if (this._refCount > 0) throw new Error(\"releasing state group still in use\");\n      this._renderer = null, this._shaderProgram = null, this._shaderProgramName = \"\";\n    }\n    Apply() {\n      const e = this._renderer;\n      e.SetProgram(this._shaderProgram), e.SetBlendMode(this._blendMode), e.SetColor(this._color), e.SetCurrentZ(this._zElevation), e._SetCurrentStateGroup(this);\n    }\n    GetKey() {\n      return C33.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation);\n    }\n    AddRef() {\n      ++this._refCount;\n    }\n    DecRef() {\n      --this._refCount;\n    }\n    _GetRefCount() {\n      return this._refCount;\n    }\n    OnContextLost() {\n      this._shaderProgram = null;\n    }\n    OnContextRestored(e) {\n      if (this._shaderProgram = e.GetShaderProgramByName(this._shaderProgramName), !this._shaderProgram) throw new Error(\"failed to restore shader program\");\n    }\n    static MakeKey(e, r, t, s) {\n      return (\"string\" == typeof e ? e : e.GetName()) + \",\" + r + \",\" + t.getR() + \",\" + t.getG() + \",\" + t.getB() + \",\" + t.getA() + \",\" + s;\n    }\n  };\n}\n{\n  let interpolateQuad = function(t, e, s) {\n    const i = s.getTlx(), n = s.getTly(), o = s.getTrx() - i, h = s.getTry() - n;\n    return [i + o * t + (s.getBlx() - i) * e, n + h * t + (s.getBly() - n) * e];\n  };\n  interpolateQuad2 = interpolateQuad;\n  const C33 = self.C3, tempQuadTex = C33.New(C33.Quad);\n  C33.Gfx.MeshPoint = class {\n    constructor(t, e, s) {\n      this._mesh = t, this._col = e, this._row = s, this._x = NaN, this._y = NaN, this._zElevation = NaN, this._u = NaN, this._v = NaN, this._x = 0, this._y = 0, this._zElevation = 0, this._u = 0, this._v = 0;\n    }\n    _Init(t, e, s, i) {\n      this._x = t, this._y = e, this._u = s, this._v = i;\n    }\n    GetX() {\n      return this._x;\n    }\n    SetX(t) {\n      this._x !== t && (this._x = t, this._mesh._SetPointsChanged());\n    }\n    GetY() {\n      return this._y;\n    }\n    SetY(t) {\n      this._y !== t && (this._y = t, this._mesh._SetPointsChanged());\n    }\n    GetZElevation() {\n      return this._zElevation;\n    }\n    SetZElevation(t) {\n      this._zElevation !== t && (this._zElevation = Math.max(t, 0), this._mesh._SetPointsChanged());\n    }\n    GetU() {\n      return this._u;\n    }\n    SetU(t) {\n      this._u = t;\n    }\n    GetV() {\n      return this._v;\n    }\n    SetV(t) {\n      this._v = t;\n    }\n    _Interpolate_TexRect(t, e, s) {\n      [this._x, this._y] = interpolateQuad(t._x, t._y, e), this._zElevation = t._zElevation, this._u = C33.lerp(s.getLeft(), s.getRight(), t._u), this._v = C33.lerp(s.getTop(), s.getBottom(), t._v);\n    }\n    _Interpolate_TexQuad(t, e, s) {\n      [this._x, this._y] = interpolateQuad(t._x, t._y, e), this._zElevation = t._zElevation, [this._u, this._v] = interpolateQuad(t._u, t._v, s);\n    }\n    SaveToJson() {\n      return { \"x\": this.GetX(), \"y\": this.GetY(), \"z\": this.GetZElevation(), \"u\": this.GetU(), \"v\": this.GetV() };\n    }\n    LoadFromJson(t) {\n      this.SetX(t[\"x\"]), this.SetY(t[\"y\"]), t.hasOwnProperty(\"z\") && this.SetZElevation(t[\"z\"]), this.SetU(t[\"u\"]), this.SetV(t[\"v\"]);\n    }\n    GetMesh() {\n      return this._mesh;\n    }\n    GetColumn() {\n      return this._col;\n    }\n    GetRow() {\n      return this._row;\n    }\n  }, C33.Gfx.Mesh = class {\n    constructor(t, e, s) {\n      if (t < 2 || e < 2) throw new Error(\"invalid mesh size\");\n      this._hsize = t, this._vsize = e, this._owner = s || null, this._pts = [], this._minX = 0, this._minY = 0, this._maxX = 1, this._maxY = 1, this._maxZ = 0, this._pointsChanged = false;\n      const i = t - 1, n = e - 1;\n      for (let s2 = 0; s2 < e; ++s2) {\n        const e2 = [];\n        for (let o = 0; o < t; ++o) {\n          const t2 = C33.New(C33.Gfx.MeshPoint, this, o, s2), h = o / i, r = s2 / n;\n          t2._Init(h, r, h, r), e2.push(t2);\n        }\n        this._pts.push(e2);\n      }\n    }\n    Release() {\n      C33.clearArray(this._pts);\n    }\n    GetHSize() {\n      return this._hsize;\n    }\n    GetVSize() {\n      return this._vsize;\n    }\n    GetOwner() {\n      return this._owner;\n    }\n    _GetPoints() {\n      return this._pts;\n    }\n    _SetPointsChanged() {\n      this._pointsChanged = true;\n    }\n    _MaybeComputeBounds() {\n      if (!this._pointsChanged) return;\n      let t = 1 / 0, e = 1 / 0, s = -1 / 0, i = -1 / 0, n = 0;\n      for (const o of this._pts) for (const h of o) {\n        const o2 = h.GetX(), r = h.GetY();\n        t = Math.min(t, o2), e = Math.min(e, r), s = Math.max(s, o2), i = Math.max(i, r), n = Math.max(n, h.GetZElevation());\n      }\n      this._minX = t, this._minY = e, this._maxX = s, this._maxY = i, this._maxZ = n, this._pointsChanged = false;\n    }\n    GetMinX() {\n      return this._MaybeComputeBounds(), this._minX;\n    }\n    GetMinY() {\n      return this._MaybeComputeBounds(), this._minY;\n    }\n    GetMaxX() {\n      return this._MaybeComputeBounds(), this._maxX;\n    }\n    GetMaxY() {\n      return this._MaybeComputeBounds(), this._maxY;\n    }\n    GetMaxZ() {\n      return this._MaybeComputeBounds(), this._maxZ;\n    }\n    HasAnyZElevation() {\n      return this.GetMaxZ() > 0;\n    }\n    GetMeshPointAt(t, e) {\n      return t = Math.floor(t), e = Math.floor(e), t < 0 || t >= this._hsize || e < 0 || e >= this._vsize ? null : this._pts[e][t];\n    }\n    CalculateTransformedMesh(t, e, s) {\n      const i = s instanceof C33.Rect;\n      if (t.GetHSize() !== this.GetHSize() || t.GetVSize() !== this.GetVSize()) throw new Error(\"source mesh wrong size\");\n      const n = t._pts, o = this._pts;\n      for (let t2 = 0, h = o.length; t2 < h; ++t2) {\n        const h2 = n[t2], r = o[t2];\n        for (let t3 = 0, n2 = r.length; t3 < n2; ++t3) {\n          const n3 = h2[t3], o2 = r[t3];\n          i ? o2._Interpolate_TexRect(n3, e, s) : o2._Interpolate_TexQuad(n3, e, s);\n        }\n      }\n    }\n    Draw(t) {\n      const e = this._pts;\n      let s = e[0];\n      for (let i = 1, n = e.length; i < n; ++i) {\n        const n2 = e[i];\n        let o = s[0], h = n2[0];\n        for (let e2 = 1, i2 = n2.length; e2 < i2; ++e2) {\n          const i3 = s[e2], r = n2[e2];\n          tempQuadTex.set(o.GetU(), o.GetV(), i3.GetU(), i3.GetV(), r.GetU(), r.GetV(), h.GetU(), h.GetV()), t.Quad3D2(o.GetX(), o.GetY(), o.GetZElevation(), i3.GetX(), i3.GetY(), i3.GetZElevation(), r.GetX(), r.GetY(), r.GetZElevation(), h.GetX(), h.GetY(), h.GetZElevation(), tempQuadTex), o = i3, h = r;\n        }\n        s = n2;\n      }\n    }\n    Outline(t, e) {\n      e || (e = (t2, e2, s2) => [t2, e2, s2]);\n      const s = this._pts;\n      let i = s[0];\n      for (let n = 1, o = s.length; n < o; ++n) {\n        const h = s[n];\n        let r = i[0], a = h[0];\n        for (let s2 = 1, l = h.length; s2 < l; ++s2) {\n          const _ = i[s2], G = h[s2], [u, c, m] = e(r.GetX(), r.GetY(), r.GetZElevation()), [p, C, f] = e(_.GetX(), _.GetY(), _.GetZElevation()), [x, v, M] = e(G.GetX(), G.GetY(), G.GetZElevation()), [g, y, d] = e(a.GetX(), a.GetY(), a.GetZElevation());\n          t.Line3D(u, c, m, p, C, f), t.Line3D(u, c, m, x, v, M), t.Line3D(u, c, m, g, y, d), s2 === l - 1 && t.Line3D(p, C, f, x, v, M), n === o - 1 && t.Line3D(g, y, d, x, v, M), r = _, a = G;\n        }\n        i = h;\n      }\n    }\n    InsertPolyMeshVertices(t) {\n      const e = 1e-3, s = 0.99999999, i = t.pointsArr(), n = [], o = this.GetHSize() - 1, h = this.GetVSize() - 1, r = 1 / o, a = 1 / h, l = o - 1, _ = h - 1;\n      let G = i[0], u = i[1], c = C33.clamp(Math.floor(G * o), 0, l), m = C33.clamp(Math.floor(u * h), 0, _), p = true, C = 0, f = 0, x = 0;\n      let v = -1;\n      const M = () => {\n        G = C33.clamp(C33.lerp(G, C, x), 0, 1), u = C33.clamp(C33.lerp(u, f, x), 0, 1), n.push(G, u);\n      };\n      for (let t2 = 0, g = i.length; t2 < g; t2 += 2) {\n        G = i[t2], u = i[t2 + 1], n.push(G, u), c = C33.clamp(Math.floor(G * o), 0, l), m = C33.clamp(Math.floor(u * h), 0, _);\n        const y = (t2 + 2) % g;\n        for (C = i[y], f = i[y + 1], v = -1; ; ) {\n          if (n.length > 1e6) throw new Error(\"Too many mesh poly points\");\n          const t3 = c * r, i2 = m * a, o2 = (c + 1) * r, h2 = (m + 1) * a;\n          if (p = C33.isPointInTriangleInclusive(G, u, t3, i2, o2, i2, o2, h2), 0 !== v && (x = C33.rayIntersectExtended(G, u, C, f, t3, i2, o2, h2, -1e-3), x >= 0 && x <= s)) M(), p = !p, v = 0;\n          else if (m > 0 && 2 !== v && (x = C33.rayIntersectExtended(G, u, C, f, t3, i2, o2, i2, e), x >= 0 && x <= s)) M(), m--, p = false, v = 4;\n          else if (c < l && 3 !== v && (x = C33.rayIntersectExtended(G, u, C, f, o2, i2, o2, h2, e), x >= 0 && x <= s)) M(), c++, p = false, v = 1;\n          else if (c > 0 && 1 !== v && (x = C33.rayIntersectExtended(G, u, C, f, t3, i2, t3, h2, e), x >= 0 && x <= s)) M(), c--, p = true, v = 3;\n          else {\n            if (!(m < _ && 4 !== v && (x = C33.rayIntersectExtended(G, u, C, f, t3, h2, o2, h2, e), x >= 0 && x <= s))) break;\n            M(), m++, p = true, v = 2;\n          }\n        }\n      }\n      return C33.New(C33.CollisionPoly, n);\n    }\n    TransformCollisionPoly(t, e) {\n      const s = this._TransformPolyPoints(t);\n      this._SimplifyPoly(s), e.setPoints(s);\n    }\n    _TransformPolyPoints(t) {\n      const e = [], s = t.pointsArr();\n      for (let t2 = 0, i = s.length; t2 < i; t2 += 2) {\n        const i2 = s[t2], n = s[t2 + 1], [o, h] = this.TransformPoint(i2, n);\n        e.push(o, h);\n      }\n      return e;\n    }\n    TransformPoint(t, e) {\n      const s = this.GetHSize() - 1, i = this.GetVSize() - 1, n = 1 / s, o = 1 / i, h = C33.clamp(Math.floor(t * s), 0, s - 1), r = C33.clamp(Math.floor(e * i), 0, i - 1), a = h * n, l = r * o, _ = (h + 1) * n, G = (r + 1) * o, u = this.GetMeshPointAt(h, r), c = this.GetMeshPointAt(h + 1, r + 1), m = C33.isPointInTriangleInclusive(t, e, a, l, _, l, _, G), p = m ? a + n : a, C = m ? l : l + o, f = this.GetMeshPointAt(h + (m ? 1 : 0), r + (m ? 0 : 1)), [x, v, M] = C33.triangleCartesianToBarycentric(t, e, a, l, p, C, _, G);\n      return C33.triangleBarycentricToCartesian3d(x, v, M, u.GetX(), u.GetY(), u.GetZElevation(), f.GetX(), f.GetY(), f.GetZElevation(), c.GetX(), c.GetY(), c.GetZElevation());\n    }\n    _SimplifyPoly(t) {\n      const e = [], s = 1e-7;\n      let i = t[0], n = t[1], o = i - t.at(-2), h = n - t.at(-1);\n      for (let r = 0, a = t.length; r < a; r += 2) {\n        const l = (r + 2) % a, _ = t[l], G = t[l + 1], u = _ - i, c = G - n, m = Math.abs(u) < s && Math.abs(o) < s && Math.sign(c) === Math.sign(h), p = Math.abs(c) < s && Math.abs(h) < s && Math.sign(u) === Math.sign(o);\n        (!m && !p && Math.abs(u / o - c / h) > 1e-3 || 0 == u && 0 === c) && e.push(i, n), i = _, n = G, o = u, h = c;\n      }\n      e.length >= 6 && e.length < t.length && C33.shallowAssignArray(t, e);\n    }\n    SaveToJson() {\n      return { \"cols\": this.GetHSize(), \"rows\": this.GetVSize(), \"points\": this._pts.map((t) => t.map((t2) => t2.SaveToJson())) };\n    }\n    LoadFromJson(t) {\n      const e = this.GetHSize(), s = this.GetVSize();\n      if (t[\"cols\"] !== e || t[\"rows\"] !== s) throw new Error(\"mesh data wrong size\");\n      const i = t[\"points\"];\n      for (let t2 = 0; t2 < s; ++t2) {\n        const s2 = i[t2];\n        for (let i2 = 0; i2 < e; ++i2) {\n          this.GetMeshPointAt(i2, t2).LoadFromJson(s2[i2]);\n        }\n      }\n    }\n  };\n}\nvar interpolateQuad2;\n{\n  let GetFormatSpecifiers = function(e, t) {\n    let i, r, a, s;\n    switch (e) {\n      case \"rgba8\":\n        i = t.RGBA8, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_BYTE;\n        break;\n      case \"rgb8\":\n        i = t.RGB8, r = t.RGB, a = t.RGB, s = t.UNSIGNED_BYTE;\n        break;\n      case \"rgba4\":\n        i = t.RGBA4, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_SHORT_4_4_4_4;\n        break;\n      case \"rgb5_a1\":\n        i = t.RGB5_A1, r = t.RGBA, a = t.RGBA, s = t.UNSIGNED_SHORT_5_5_5_1;\n        break;\n      case \"rgb565\":\n        i = t.RGB565, r = t.RGB, a = t.RGB, s = t.UNSIGNED_SHORT_5_6_5;\n        break;\n      default:\n        throw new Error(\"invalid pixel format\");\n    }\n    return { sizedinternalformat: i, internalformat: r, format: a, type: s };\n  };\n  GetFormatSpecifiers2 = GetFormatSpecifiers;\n  const C33 = self.C3, VALID_PIXEL_FORMATS = /* @__PURE__ */ new Set([\"rgba8\", \"rgb8\", \"rgba4\", \"rgb5_a1\", \"rgb565\"]), VALID_SAMPLINGS = /* @__PURE__ */ new Set([\"nearest\", \"bilinear\", \"trilinear\"]), VALID_MIPMAP_QUALITIES = /* @__PURE__ */ new Set([\"default\", \"low\", \"high\"]), VALID_WRAP_MODES = /* @__PURE__ */ new Set([\"clamp-to-edge\", \"repeat\", \"mirror-repeat\"]);\n  const CREATEFROM_DEFAULT_OPTIONS = { wrapX: \"clamp-to-edge\", wrapY: \"clamp-to-edge\", sampling: \"trilinear\", anisotropy: 0, pixelFormat: \"rgba8\", mipMap: true, mipMapQuality: \"default\", premultiplyAlpha: true, isSvg: false, width: -1, height: -1 }, UPDATE_DEFAULT_OPTIONS = { premultiplyAlpha: true, flipY: false }, allTextures = /* @__PURE__ */ new Set();\n  C33.Gfx.WebGLRendererTexture = class {\n    constructor(e) {\n      this._renderer = e, this._texture = null, this._width = 0, this._height = 0, this._isStatic = true, this._wrapX = \"clamp-to-edge\", this._wrapY = \"clamp-to-edge\", this._sampling = \"trilinear\", this._anisotropy = 0, this._pixelFormat = \"rgba8\", this._isMipMapped = false, this._mipMapQuality = \"default\", this._refCount = 0;\n    }\n    _CreateStatic(e, t) {\n      if (!(\"undefined\" != typeof HTMLImageElement && e instanceof HTMLImageElement || \"undefined\" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || \"undefined\" != typeof ImageBitmap && e instanceof ImageBitmap || \"undefined\" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData || e instanceof ArrayBuffer || null === e)) throw new Error(\"invalid texture source\");\n      if (t = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, t), this._texture) throw new Error(\"already created texture\");\n      if (this._wrapX = t.wrapX, this._wrapY = t.wrapY, this._sampling = t.sampling, this._anisotropy = t.anisotropy, this._pixelFormat = t.pixelFormat, this._isMipMapped = !!t.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = t.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error(\"invalid wrap mode\");\n      if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error(\"invalid sampling\");\n      if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error(\"invalid pixel format\");\n      if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error(\"invalid mipmap quality\");\n      if (this._isStatic = true, e instanceof ArrayBuffer || null === e || t.isSvg) {\n        if (this._width = t.width, this._height = t.height, e instanceof ArrayBuffer && e.byteLength !== this._width * this._height * 4) throw new Error(\"ArrayBuffer wrong size\");\n      } else this._width = e.width, this._height = e.height;\n      if (this._width <= 0 || this._height <= 0) throw new Error(\"invalid texture data size\");\n      if (t.isSvg) {\n        const t2 = C33.CreateCanvas(this._width, this._height);\n        t2.getContext(\"2d\").drawImage(e, 0, 0, this._width, this._height), e = t2;\n      }\n      const i = C33.isPOT(this._width) && C33.isPOT(this._height), r = this._renderer.GetMaxTextureSize();\n      if (this._width > r || this._height > r) throw new Error(\"texture data exceeds maximum texture size\");\n      const a = this._renderer.GetContext(), s = this._renderer.GetWebGLVersionNumber();\n      this._texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this._texture), a.pixelStorei(a[\"UNPACK_PREMULTIPLY_ALPHA_WEBGL\"], t.premultiplyAlpha), a.pixelStorei(a[\"UNPACK_FLIP_Y_WEBGL\"], false);\n      const h = GetFormatSpecifiers(this._pixelFormat, a);\n      if (this._renderer.SupportsNPOTTextures() || i || !this._IsTiled()) if (s >= 2) {\n        let t2;\n        t2 = this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, a.texStorage2D(a.TEXTURE_2D, t2, h.sizedinternalformat, this._width, this._height), e instanceof ArrayBuffer ? a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this._width, this._height, h.format, h.type, new Uint8Array(e)) : null !== e && a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, h.format, h.type, e);\n      } else e instanceof ArrayBuffer ? a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, this._width, this._height, 0, h.format, h.type, new Uint8Array(e)) : null === e ? a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, this._width, this._height, 0, h.format, h.type, null) : a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, h.format, h.type, e);\n      else {\n        if (null === e) throw new Error(\"cannot pass null data when creating a NPOT tiled texture without NPOT support\");\n        if (e instanceof ArrayBuffer && (e = new ImageData(new Uint8ClampedArray(e), this._width, this._height)), e instanceof ImageData) {\n          const t3 = C33.CreateCanvas(this._width, this._height);\n          t3.getContext(\"2d\").putImageData(e, 0, 0), e = t3;\n        }\n        const t2 = C33.CreateCanvas(C33.nextHighestPowerOfTwo(this._width), C33.nextHighestPowerOfTwo(this._height)), i2 = t2.getContext(\"2d\");\n        i2.imageSmoothingEnabled = \"nearest\" !== this._sampling, i2.drawImage(e, 0, 0, this._width, this._height, 0, 0, t2.width, t2.height), a.texImage2D(a.TEXTURE_2D, 0, h.internalformat, h.format, h.type, t2);\n      }\n      null !== e && this._SetTextureParameters(a), a.bindTexture(a.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);\n    }\n    _CreateDynamic(e, t, i) {\n      if (i = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, i), this._texture) throw new Error(\"already created texture\");\n      if (this._wrapX = i.wrapX, this._wrapY = i.wrapY, this._sampling = i.sampling, this._pixelFormat = i.pixelFormat, this._isMipMapped = !!i.mipMap && this._renderer.AreMipmapsEnabled(), this._mipMapQuality = i.mipMapQuality, !VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY)) throw new Error(\"invalid wrap mode\");\n      if (!VALID_SAMPLINGS.has(this._sampling)) throw new Error(\"invalid sampling\");\n      if (!VALID_PIXEL_FORMATS.has(this._pixelFormat)) throw new Error(\"invalid pixel format\");\n      if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality)) throw new Error(\"invalid mipmap quality\");\n      this._isStatic = false, this._width = Math.floor(e), this._height = Math.floor(t);\n      const r = C33.isPOT(this._width) && C33.isPOT(this._height), a = this._renderer.GetMaxTextureSize();\n      if (this._width <= 0 || this._height <= 0) throw new Error(\"invalid texture size\");\n      if (this._width > a || this._height > a) throw new Error(\"texture exceeds maximum texture size\");\n      if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !r) throw new Error(\"non-power-of-two tiled textures not supported\");\n      const s = this._renderer.GetContext(), h = this._renderer.GetWebGLVersionNumber();\n      this._texture = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s[\"UNPACK_PREMULTIPLY_ALPHA_WEBGL\"], i.premultiplyAlpha), s.pixelStorei(s[\"UNPACK_FLIP_Y_WEBGL\"], false);\n      const n = GetFormatSpecifiers(this._pixelFormat, s), _ = h >= 2 ? n.sizedinternalformat : n.internalformat;\n      s.texImage2D(s.TEXTURE_2D, 0, _, this._width, this._height, 0, n.format, n.type, null), this._SetTextureParameters(s), s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture(), this._refCount = 1, allTextures.add(this);\n    }\n    _GetMipMapHint(e) {\n      if (\"default\" === this._mipMapQuality) return this._isStatic ? e.NICEST : e.FASTEST;\n      if (\"low\" === this._mipMapQuality) return e.FASTEST;\n      if (\"high\" === this._mipMapQuality) return e.NICEST;\n      throw new Error(\"invalid mipmap quality\");\n    }\n    _IsTiled() {\n      return \"clamp-to-edge\" !== this._wrapX || \"clamp-to-edge\" !== this._wrapY;\n    }\n    _GetTextureWrapMode(e, t) {\n      if (\"clamp-to-edge\" === t) return e.CLAMP_TO_EDGE;\n      if (\"repeat\" === t) return e.REPEAT;\n      if (\"mirror-repeat\" === t) return e.MIRRORED_REPEAT;\n      throw new Error(\"invalid wrap mode\");\n    }\n    _SetTextureParameters(e) {\n      const t = C33.isPOT(this._width) && C33.isPOT(this._height);\n      if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, this._GetTextureWrapMode(e, this._wrapX)), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, this._GetTextureWrapMode(e, this._wrapY)), \"nearest\" === this._sampling) e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), this._isMipMapped = false;\n      else if (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), (t || this._renderer.SupportsNPOTTextures()) && this._isMipMapped) {\n        e.hint(e.GENERATE_MIPMAP_HINT, this._GetMipMapHint(e)), e.generateMipmap(e.TEXTURE_2D);\n        const t2 = \"trilinear\" === this._sampling && !this._renderer.HasMajorPerformanceCaveat();\n        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t2 ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR_MIPMAP_NEAREST);\n      } else e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), this._isMipMapped = false;\n      const i = this._renderer._GetAnisotropicExtension();\n      i && this._anisotropy > 0 && \"nearest\" !== this._sampling && e.texParameterf(e.TEXTURE_2D, i[\"TEXTURE_MAX_ANISOTROPY_EXT\"], Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()));\n    }\n    _Update(e, t) {\n      if (!(\"undefined\" != typeof HTMLImageElement && e instanceof HTMLImageElement || \"undefined\" != typeof HTMLVideoElement && e instanceof HTMLVideoElement || \"undefined\" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || \"undefined\" != typeof ImageBitmap && e instanceof ImageBitmap || \"undefined\" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData)) throw new Error(\"invalid texture source\");\n      if (!this._texture || this._refCount <= 0) throw new Error(\"texture not created\");\n      if (this._isStatic) throw new Error(\"cannot update static texture\");\n      t = Object.assign({}, UPDATE_DEFAULT_OPTIONS, t);\n      const i = e.width || e.videoWidth, r = e.height || e.videoHeight, a = this._renderer.GetWebGLVersionNumber(), s = this._renderer.GetContext();\n      s.bindTexture(s.TEXTURE_2D, this._texture), s.pixelStorei(s[\"UNPACK_PREMULTIPLY_ALPHA_WEBGL\"], t.premultiplyAlpha), s.pixelStorei(s[\"UNPACK_FLIP_Y_WEBGL\"], !!t.flipY);\n      const h = GetFormatSpecifiers(this._pixelFormat, s), n = a >= 2 ? h.sizedinternalformat : h.internalformat;\n      try {\n        if (this._width === i && this._height === r) {\n          const t2 = C33.isPOT(this._width) && C33.isPOT(this._height);\n          s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, h.format, h.type, e), (t2 || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D));\n        } else {\n          this._width = i, this._height = r;\n          const t2 = C33.isPOT(this._width) && C33.isPOT(this._height);\n          if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !t2) throw new Error(\"non-power-of-two tiled textures not supported\");\n          s.texImage2D(s.TEXTURE_2D, 0, n, h.format, h.type, e), (t2 || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (s.hint(s.GENERATE_MIPMAP_HINT, this._GetMipMapHint(s)), s.generateMipmap(s.TEXTURE_2D));\n        }\n      } catch (e2) {\n        console.error(\"Error updating WebGL texture: \", e2);\n      }\n      s.bindTexture(s.TEXTURE_2D, null), this._renderer._ResetLastTexture();\n    }\n    _Delete() {\n      if (this._refCount > 0) throw new Error(\"texture still has references\");\n      if (!this._texture) throw new Error(\"already deleted texture\");\n      allTextures.delete(this);\n      this._renderer.GetContext().deleteTexture(this._texture), this._texture = null;\n    }\n    IsValid() {\n      return !!this._texture;\n    }\n    _GetTexture() {\n      return this._texture;\n    }\n    GetRenderer() {\n      return this._renderer;\n    }\n    AddReference() {\n      this._refCount++;\n    }\n    SubtractReference() {\n      if (this._refCount <= 0) throw new Error(\"no more references\");\n      this._refCount--;\n    }\n    GetReferenceCount() {\n      return this._refCount;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    IsStatic() {\n      return this._isStatic;\n    }\n    GetEstimatedMemoryUsage() {\n      let e = this._width * this._height;\n      switch (this._pixelFormat) {\n        case \"rgba8\":\n          e *= 4;\n          break;\n        case \"rgb8\":\n          e *= 3;\n          break;\n        case \"rgba4\":\n        case \"rgb5_a1\":\n        case \"rgb565\":\n          e *= 2;\n      }\n      return this._isMipMapped && (e += Math.floor(e / 3)), e;\n    }\n    static OnContextLost() {\n      allTextures.clear();\n    }\n    static allTextures() {\n      return allTextures.values();\n    }\n  };\n}\nvar GetFormatSpecifiers2;\n{\n  const C33 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, VALID_SAMPLINGS = /* @__PURE__ */ new Set([\"nearest\", \"bilinear\", \"trilinear\"]), DEFAULT_RENDERTARGET_OPTIONS = { sampling: \"trilinear\", alpha: true, depth: false, isSampled: true, isDefaultSize: true, multisampling: 0 }, allRenderTargets = /* @__PURE__ */ new Set();\n  C33.Gfx.WebGLRenderTarget = class {\n    constructor(e) {\n      this._renderer = e, this._frameBuffer = null, this._frameBufferNoDepth = null, this._texture = null, this._renderBuffer = null, this._width = 0, this._height = 0, this._isDefaultSize = true, this._sampling = \"trilinear\", this._alpha = true, this._depth = false, this._isSampled = true, this._multisampling = 0, this._projectionMatrix = mat4.create(), this._lastFov = 0, this._lastNearZ = 0, this._lastFarZ = 0;\n    }\n    _Create(e, t, r) {\n      r = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, r);\n      const i = this._renderer.GetWebGLVersionNumber();\n      if (this._texture || this._renderBuffer) throw new Error(\"already created render target\");\n      if (this._sampling = r.sampling, this._alpha = !!r.alpha, this._depth = !!r.depth, this._isSampled = !!r.isSampled, this._isDefaultSize = !!r.isDefaultSize, this._multisampling = r.multisampling, !VALID_SAMPLINGS.has(this._sampling)) throw new Error(\"invalid sampling\");\n      if (this._multisampling > 0 && (i < 2 || this._isSampled)) throw new Error(\"invalid use of multisampling\");\n      if (i < 2 && (this._isSampled = true), this._width = e, this._height = t, this._width <= 0 || this._height <= 0) throw new Error(\"invalid render target size\");\n      this._CalculateProjection();\n      const s = this._renderer.GetContext();\n      if (this._frameBuffer = s.createFramebuffer(), this._depth && (this._frameBufferNoDepth = s.createFramebuffer()), this._isSampled) {\n        this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, { sampling: this._sampling, pixelFormat: this._alpha ? \"rgba8\" : \"rgb8\", mipMap: false });\n        const e2 = this._texture._GetTexture();\n        s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e2, 0), this._depth && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBufferNoDepth), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e2, 0));\n      } else {\n        this._renderBuffer = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, this._renderBuffer);\n        const e2 = this._alpha ? s.RGBA8 : s.RGB8;\n        if (this._multisampling > 0) {\n          const t2 = s.getInternalformatParameter(s.RENDERBUFFER, e2, s.SAMPLES);\n          if (t2 && t2[0]) {\n            const e3 = t2[0];\n            this._multisampling > e3 && (this._multisampling = e3);\n          } else this._multisampling = 0;\n        }\n        0 === this._multisampling ? s.renderbufferStorage(s.RENDERBUFFER, e2, this._width, this._height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, this._multisampling, e2, this._width, this._height), s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._renderBuffer), this._depth && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBufferNoDepth), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._renderBuffer)), s.bindRenderbuffer(s.RENDERBUFFER, null);\n      }\n      const h = this._renderer._GetDepthBuffer();\n      this._depth && h && (s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), this._renderer._CanSampleDepth() ? s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, h, 0) : s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, h)), s.bindFramebuffer(s.FRAMEBUFFER, null), allRenderTargets.add(this);\n    }\n    _Resize(e, t) {\n      if (this._width === e && this._height === t) return;\n      this._width = e, this._height = t, this._CalculateProjection();\n      const r = this._renderer.GetContext();\n      r.bindFramebuffer(r.FRAMEBUFFER, this._frameBuffer), this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (r.bindRenderbuffer(r.RENDERBUFFER, this._renderBuffer), r.renderbufferStorage(r.RENDERBUFFER, this._alpha ? r.RGBA8 : r.RGB8, this._width, this._height), r.bindRenderbuffer(r.RENDERBUFFER, null));\n      const i = this._renderer._GetDepthBuffer();\n      this._depth && i && (this._renderer._CanSampleDepth() ? r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, i, 0) : r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, i)), r.bindFramebuffer(r.FRAMEBUFFER, null);\n    }\n    _Delete() {\n      if (!this._texture && !this._renderBuffer) throw new Error(\"already deleted render target\");\n      allRenderTargets.delete(this);\n      const e = this._renderer.GetContext();\n      this._texture ? (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0)), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null), this._depth && (e.bindFramebuffer(e.FRAMEBUFFER, this._frameBufferNoDepth), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, null)), e.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null), e.bindFramebuffer(e.FRAMEBUFFER, null), this._renderer.GetWebGLVersionNumber() >= 2 && (e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null)), e.deleteFramebuffer(this._frameBuffer), this._depth && e.deleteFramebuffer(this._frameBufferNoDepth);\n      const t = this._renderer.GetBatchState();\n      t.currentFramebuffer = null, t.currentFramebufferNoDepth = null, this._frameBuffer = null;\n    }\n    _CalculateProjection() {\n      this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height), this._lastFov = this._renderer.GetFovY(), this._lastNearZ = this._renderer.GetNearZ(), this._lastFarZ = this._renderer.GetFarZ();\n    }\n    _GetFramebuffer() {\n      return this._frameBuffer;\n    }\n    _GetFramebufferNoDepth() {\n      return this._frameBufferNoDepth;\n    }\n    GetRenderer() {\n      return this._renderer;\n    }\n    GetTexture() {\n      return this._texture;\n    }\n    GetProjectionMatrix() {\n      return this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection(), this._projectionMatrix;\n    }\n    IsLinearSampling() {\n      return \"nearest\" !== this._sampling;\n    }\n    HasAlpha() {\n      return this._alpha;\n    }\n    IsSampled() {\n      return this._isSampled;\n    }\n    HasDepthBuffer() {\n      return this._depth;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    IsDefaultSize() {\n      return this._isDefaultSize;\n    }\n    GetMultisampling() {\n      return this._multisampling;\n    }\n    GetOptions() {\n      const e = { sampling: this._sampling, alpha: this._alpha, isSampled: this._isSampled };\n      return this._isDefaultSize || (e.width = this._width, e.height = this._height), e;\n    }\n    IsCompatibleWithOptions(e) {\n      return \"nearest\" !== (e = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, e)).sampling === this.IsLinearSampling() && (!!e.alpha === this.HasAlpha() && (!!e.depth === this.HasDepthBuffer() && (!(this._renderer.GetWebGLVersionNumber() >= 2 && !!e.isSampled !== this.IsSampled()) && (\"number\" == typeof e.width || \"number\" == typeof e.height ? !this.IsDefaultSize() && this.GetWidth() === Math.floor(e.width) && this.GetHeight() === Math.floor(e.height) : this.IsDefaultSize()))));\n    }\n    _GetWebGLTexture() {\n      return this._texture ? this._texture._GetTexture() : null;\n    }\n    GetEstimatedMemoryUsage() {\n      return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3);\n    }\n    static async DebugReadPixelsToBlob(e, t) {\n      const r = await e.ReadBackRenderTargetToImageData(t, true);\n      return await C33.ImageDataToBlob(r);\n    }\n    static OnContextLost() {\n      allRenderTargets.clear();\n    }\n    static allRenderTargets() {\n      return allRenderTargets.values();\n    }\n    static ResizeAll(e, t) {\n      for (const r of allRenderTargets) r.IsDefaultSize() && r._Resize(e, t);\n    }\n  };\n}\n{\n  const C33 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, mat4 = glMatrix.mat4, RESERVED_UNIFORM_NAMES = /* @__PURE__ */ new Set([\"aPos\", \"aTex\", \"aPoints\", \"matP\", \"matMV\", \"samplerFront\", \"samplerBack\", \"samplerDepth\", \"destStart\", \"destEnd\", \"srcStart\", \"srcEnd\", \"srcOriginStart\", \"srcOriginEnd\", \"pixelSize\", \"seconds\", \"devicePixelRatio\", \"layerScale\", \"layerAngle\", \"layoutStart\", \"layoutEnd\", \"color\", \"color2_\", \"pointTexStart\", \"pointTexEnd\", \"zElevation\", \"tileSize\", \"tileSpacing\", \"outlineThickness\", \"zNear\", \"zFar\"]);\n  C33.Gfx.WebGLShaderProgram = class extends C33.Gfx.ShaderProgramBase {\n    static async Compile(e, t) {\n      const i = e.GetContext(), r = t.src, o = t.vertexSrc, n = t.name, a = i.createShader(i.FRAGMENT_SHADER);\n      i.shaderSource(a, r), i.compileShader(a);\n      const l = i.createShader(i.VERTEX_SHADER);\n      i.shaderSource(l, o), i.compileShader(l);\n      const s = i.createProgram();\n      i.attachShader(s, a), i.attachShader(s, l), i.bindAttribLocation(s, 0, \"aPos\"), i.bindAttribLocation(s, 1, \"aTex\"), i.bindAttribLocation(s, 2, \"aPoints\"), i.linkProgram(s);\n      const h = e._GetParallelShaderCompileExtension();\n      if (h ? await e._WaitForObjectReady(() => i.getProgramParameter(s, h[\"COMPLETION_STATUS_KHR\"])) : await C33.Wait(5), !i.getShaderParameter(a, i.COMPILE_STATUS)) {\n        const e2 = i.getShaderInfoLog(a);\n        throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error(\"Error compiling fragment shader: \" + e2);\n      }\n      if (!i.getShaderParameter(l, i.COMPILE_STATUS)) {\n        const e2 = i.getShaderInfoLog(l);\n        throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error(\"Error compiling vertex shader: \" + e2);\n      }\n      if (!i.getProgramParameter(s, i.LINK_STATUS)) {\n        const e2 = i.getProgramInfoLog(s);\n        throw i.deleteShader(a), i.deleteShader(l), i.deleteProgram(s), new Error(\"Error linking shader program: \" + e2);\n      }\n      const c = C33.FilterUnprintableChars(i.getProgramInfoLog(s) || \"\").trim();\n      return c && !C33.IsStringAllWhitespace(c) && console.info(`[WebGL] Shader program '${n}' compilation log: `, c), i.deleteShader(a), i.deleteShader(l), s;\n    }\n    static async Create(e, t) {\n      const i = await C33.Gfx.WebGLShaderProgram.Compile(e, t);\n      return new C33.Gfx.WebGLShaderProgram(e, i, t);\n    }\n    constructor(e, t, i) {\n      super(e, i);\n      const r = e.GetContext(), o = e.GetBatchState();\n      e.EndBatch(), r.useProgram(t), this._gl = r, this._shaderProgram = t, this._isDeviceTransform = \"<default-device-transform>\" === i.name;\n      const n = r.getAttribLocation(t, \"aPos\"), a = r.getAttribLocation(t, \"aTex\");\n      this._locAPoints = r.getAttribLocation(t, \"aPoints\"), -1 !== n && (r.bindBuffer(r.ARRAY_BUFFER, e._vertexBuffer), r.vertexAttribPointer(n, e.GetNumVertexComponents(), r.FLOAT, false, 0, 0), r.enableVertexAttribArray(n)), -1 !== a && (r.bindBuffer(r.ARRAY_BUFFER, e._texcoordBuffer), r.vertexAttribPointer(a, 2, r.FLOAT, false, 0, 0), r.enableVertexAttribArray(a)), -1 !== this._locAPoints && (r.bindBuffer(r.ARRAY_BUFFER, e._pointBuffer), r.vertexAttribPointer(this._locAPoints, 4, r.FLOAT, false, 0, 0), r.enableVertexAttribArray(this._locAPoints)), r.bindBuffer(r.ARRAY_BUFFER, null), this._uMatP = new C33.Gfx.WebGLShaderUniform(this, \"matP\", \"mat4\"), this._uMatMV = new C33.Gfx.WebGLShaderUniform(this, \"matMV\", \"mat4\"), this._uColor = new C33.Gfx.WebGLShaderUniform(this, \"color\", \"vec4\"), this._uSamplerFront = new C33.Gfx.WebGLShaderUniform(this, \"samplerFront\", \"sampler\"), this._uPointTexStart = new C33.Gfx.WebGLShaderUniform(this, \"pointTexStart\", \"vec2\"), this._uPointTexEnd = new C33.Gfx.WebGLShaderUniform(this, \"pointTexEnd\", \"vec2\"), this._uZElevation = new C33.Gfx.WebGLShaderUniform(this, \"zElevation\", \"float\"), this._uTileSize = new C33.Gfx.WebGLShaderUniform(this, \"tileSize\", \"vec2\"), this._uTileSpacing = new C33.Gfx.WebGLShaderUniform(this, \"tileSpacing\", \"vec2\"), this._uColor2 = new C33.Gfx.WebGLShaderUniform(this, \"color2_\", \"vec4\"), this._uOutlineThickness = new C33.Gfx.WebGLShaderUniform(this, \"outlineThickness\", \"float\"), this._uSamplerBack = new C33.Gfx.WebGLShaderUniform(this, \"samplerBack\", \"sampler\"), this._uSamplerDepth = new C33.Gfx.WebGLShaderUniform(this, \"samplerDepth\", \"sampler\"), this._uDestStart = new C33.Gfx.WebGLShaderUniform(this, \"destStart\", \"vec2\"), this._uDestEnd = new C33.Gfx.WebGLShaderUniform(this, \"destEnd\", \"vec2\"), this._uSrcStart = new C33.Gfx.WebGLShaderUniform(this, \"srcStart\", \"vec2\"), this._uSrcEnd = new C33.Gfx.WebGLShaderUniform(this, \"srcEnd\", \"vec2\"), this._uSrcOriginStart = new C33.Gfx.WebGLShaderUniform(this, \"srcOriginStart\", \"vec2\"), this._uSrcOriginEnd = new C33.Gfx.WebGLShaderUniform(this, \"srcOriginEnd\", \"vec2\"), this._uPixelSize = new C33.Gfx.WebGLShaderUniform(this, \"pixelSize\", \"vec2\"), this._uSeconds = new C33.Gfx.WebGLShaderUniform(this, \"seconds\", \"float\"), this._uDevicePixelRatio = new C33.Gfx.WebGLShaderUniform(this, \"devicePixelRatio\", \"float\"), this._uLayerScale = new C33.Gfx.WebGLShaderUniform(this, \"layerScale\", \"float\"), this._uLayerAngle = new C33.Gfx.WebGLShaderUniform(this, \"layerAngle\", \"float\"), this._uLayoutStart = new C33.Gfx.WebGLShaderUniform(this, \"layoutStart\", \"vec2\"), this._uLayoutEnd = new C33.Gfx.WebGLShaderUniform(this, \"layoutEnd\", \"vec2\"), this._uZNear = new C33.Gfx.WebGLShaderUniform(this, \"zNear\", \"float\"), this._uZFar = new C33.Gfx.WebGLShaderUniform(this, \"zFar\", \"float\"), this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());\n      const l = i.parameters || [];\n      this._uCustomParameters = [], this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed(), this._hasCurrentMatP = false, this._hasCurrentMatMV = false, this._uColor.Init4f(1, 1, 1, 1), this._uColor2.Init4f(1, 1, 1, 1), this._uSamplerFront.Init1i(0), this._uSamplerBack.Init1i(1), this._uSamplerDepth.Init1i(2), this._uPointTexStart.Init2f(0, 0), this._uPointTexEnd.Init2f(1, 1), this._uZElevation.Init1f(0), this._uTileSize.Init2f(0, 0), this._uTileSpacing.Init2f(0, 0), this._uDestStart.Init2f(0, 0), this._uDestEnd.Init2f(1, 1), this._uSrcStart.Init2f(0, 0), this._uSrcEnd.Init2f(0, 0), this._uSrcOriginStart.Init2f(0, 0), this._uSrcOriginEnd.Init2f(0, 0), this._uPixelSize.Init2f(0, 0), this._uDevicePixelRatio.Init1f(1), this._uZNear.Init1f(e.GetNearZ()), this._uZFar.Init1f(e.GetFarZ()), this._uLayerScale.Init1f(1), this._uLayerAngle.Init1f(0), this._uSeconds.Init1f(0), this._uLayoutStart.Init2f(0, 0), this._uLayoutEnd.Init2f(0, 0), this._uOutlineThickness.Init1f(1);\n      for (const e2 of l) {\n        const t2 = e2[0], i2 = e2[2], r2 = new C33.Gfx.WebGLShaderUniform(this, t2, i2);\n        \"color\" === i2 ? r2.Init3f(0, 0, 0) : r2.Init1f(0), this._uCustomParameters.push(r2);\n      }\n      this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(o.currentMatP) : (this.UpdateMatP(o.currentMatP, true), this.UpdateMatMV(o.currentMV, true));\n      const s = o.currentShader;\n      r.useProgram(s ? s._shaderProgram : null);\n    }\n    Release() {\n      this._gl.deleteProgram(this._shaderProgram), this._shaderProgram = null, this._renderer._RemoveShaderProgram(this), this._gl = null, super.Release();\n    }\n    GetWebGLContext() {\n      return this._gl;\n    }\n    GetShaderProgram() {\n      return this._shaderProgram;\n    }\n    GetParameterCount() {\n      return this._uCustomParameters.length;\n    }\n    GetParameterType(e) {\n      return e < 0 || e >= this._uCustomParameters.length ? null : this._uCustomParameters[e].GetType();\n    }\n    AreCustomParametersAlreadySetInBatch(e) {\n      for (let t = 0, i = e.length; t < i; ++t) if (!this._uCustomParameters[t].IsSetToCustomInBatch(e[t])) return false;\n      return true;\n    }\n    SetCustomParametersInBatch(e) {\n      for (let t = 0, i = e.length; t < i; ++t) this._uCustomParameters[t].SetBatchValueCustom(e[t]);\n    }\n    AreOptionalUniformsAlreadySetInBatch(e, t, i, r, o, n, a, l, s, h) {\n      return !this._uSamplerBack.IsUsed() && (!(this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(o, n)) && (!(this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(e.getLeft(), e.getTop())) && (!(this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(e.getRight(), e.getBottom())) && (!(this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(a)) && (!(this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(l)) && (!(this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(s)) && (!(this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(t.getLeft(), t.getTop())) && (!(this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(t.getRight(), t.getBottom())) && (!(this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(i.getLeft(), i.getTop())) && (!(this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(i.getRight(), i.getBottom())) && (!(this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(r.getLeft(), r.getTop())) && (!(this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(r.getTop(), r.getBottom())) && !(this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(h))))))))))))));\n    }\n    SetOptionalUniformsInBatch(e, t, i, r, o, n, a, l, s, h) {\n      this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(o, n), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(e.getLeft(), e.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(e.getRight(), e.getBottom()), this._uDevicePixelRatio.IsUsed() && this._uDevicePixelRatio.SetBatch1(a), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(l), this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(s), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(t.getLeft(), t.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(t.getRight(), t.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(i.getLeft(), i.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(i.getRight(), i.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(r.getLeft(), r.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(r.getTop(), r.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(h));\n    }\n    UpdateMatP(e, t) {\n      this._hasCurrentMatP && !t || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(e), this._hasCurrentMatP = true);\n    }\n    SetMatPStale() {\n      this._hasCurrentMatP = false;\n    }\n    UpdateMatMV(e, t) {\n      this._hasCurrentMatMV && !t || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(e), this._hasCurrentMatMV = true);\n    }\n    SetMatMVStale() {\n      this._hasCurrentMatMV = false;\n    }\n    _UpdateDeviceTransformUniforms(e) {\n      if (!this._isDeviceTransform) throw new Error(\"not device transform shader\");\n      this._uMatP.UpdateMatrix4fv(e);\n      const t = this._renderer, i = t.GetWidth() / 2, r = t.GetHeight() / 2, o = t.CalculateLookAtModelView2(i, r, t.GetDefaultCameraZ(t.GetHeight()), i, r, 0, t.GetHeight());\n      this._uMatMV.UpdateMatrix4fv(o);\n    }\n    UpdateColor(e) {\n      this._uColor.IsUsed() && this._uColor.Update4f(e[0], e[1], e[2], e[3]);\n    }\n    static GetReservedUniformNames() {\n      return RESERVED_UNIFORM_NAMES;\n    }\n    static _GetConservativeDepthShaderPrefix(e) {\n      return e ? \"\\n#extension GL_EXT_conservative_depth : enable\\nlayout (depth_greater) out highp float gl_FragDepth;\\n\t\" : \"\";\n    }\n    static GetDefaultVertexShaderSource(e) {\n      const t = e ? \"highp\" : \"mediump\";\n      return [\"attribute highp vec3 aPos;\", `attribute ${t} vec2 aTex;`, `varying ${t} vec2 vTex;`, \"uniform highp mat4 matP;\", \"uniform highp mat4 matMV;\", \"void main(void) {\", \"\tgl_Position = matP * matMV * vec4(aPos, 1.0);\", \"\tvTex = aTex;\", \"}\"].join(\"\\n\");\n    }\n    static GetDefaultVertexShaderSource_WebGL2(e) {\n      const t = e ? \"highp\" : \"mediump\";\n      return [\"#version 300 es\", \"in highp vec3 aPos;\", `in ${t} vec2 aTex;`, `out ${t} vec2 vTex;`, \"uniform highp mat4 matP;\", \"uniform highp mat4 matMV;\", \"void main(void) {\", \"\tgl_Position = matP * matMV * vec4(aPos, 1.0);\", \"\tvTex = aTex;\", \"}\"].join(\"\\n\");\n    }\n    static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth() {\n      return [\"varying mediump vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"void main(void) {\", \"\tgl_FragColor = texture2D(samplerFront, vTex) * color;\", \"}\"].join(\"\\n\");\n    }\n    static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT() {\n      return [\"#extension GL_EXT_frag_depth : enable\", \"varying mediump vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"void main(void) {\", \"\tgl_FragColor = texture2D(samplerFront, vTex) * color;\", \"\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetTextureFillFragmentShaderSource_WebGL2(e) {\n      return [\"#version 300 es\", C33.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), \"in mediump vec2 vTex;\", \"out lowp vec4 outColor;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"void main(void) {\", \"\toutColor = texture(samplerFront, vTex) * color;\", \"\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetTilemapFragmentShaderSource_WebGL1_NoFragDepth() {\n      return [\"varying highp vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"uniform highp vec2 srcStart;\", \"uniform highp vec2 pixelSize;\", \"uniform highp vec2 tileSize;\", \"uniform highp vec2 tileSpacing;\", \"void main(void) {\", \"\thighp vec2 tile = floor(vTex);\", \"\thighp vec2 tex = fract(vTex);\", \"\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\", \"\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\", \"\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\", \"\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\", \"}\"].join(\"\\n\");\n    }\n    static GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT() {\n      return [\"#extension GL_EXT_frag_depth : enable\", \"varying highp vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"uniform highp vec2 srcStart;\", \"uniform highp vec2 pixelSize;\", \"uniform highp vec2 tileSize;\", \"uniform highp vec2 tileSpacing;\", \"void main(void) {\", \"\thighp vec2 tile = floor(vTex);\", \"\thighp vec2 tex = fract(vTex);\", \"\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\", \"\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\", \"\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\", \"\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\", \"\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetTilemapFragmentShaderSource_WebGL2(e) {\n      return [\"#version 300 es\", C33.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), \"in highp vec2 vTex;\", \"out lowp vec4 outColor;\", \"uniform lowp vec4 color;\", \"uniform lowp sampler2D samplerFront;\", \"uniform highp vec2 srcStart;\", \"uniform highp vec2 pixelSize;\", \"uniform highp vec2 tileSize;\", \"uniform highp vec2 tileSpacing;\", \"void main(void) {\", \"\thighp vec2 tile = floor(vTex);\", \"\thighp vec2 tex = fract(vTex);\", \"\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\", \"\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\", \"\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\", \"\toutColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\", \"\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetTileRandomizationFragmentShaderSource(e, t, i, r) {\n      let o = \"\";\n      return e >= 2 ? o = \"#version 300 es\\n\" + C33.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(r) : (t && (o = \"#extension GL_EXT_frag_depth : enable\\n\"), i && (o += \"#extension GL_EXT_shader_texture_lod : enable\\n\", o += \"#extension GL_OES_standard_derivatives : enable\\n\")), o + `\nprecision highp float;\n${e >= 2 ? \"in\" : \"varying\"} vec2 vTex;\n${e >= 2 ? \"out lowp vec4 outColor;\" : \"\"}\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform vec2 pixelSize;\n\nuniform vec2 tileSize;\nuniform vec2 tileSpacing;\nuniform float outlineThickness;\n\nconst float PI = 3.1415926;\n\nlowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)\n{\n\treturn (a + b + (a - b) * cos(x * PI)) / 2.0;\n}\n\nvec3 randVec3(vec2 seed)\n{\n\treturn vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));\n}\n\nlowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)\n{\n\tvec2 posRandom = tileSize;\n\tfloat angleRandom = outlineThickness;\n\t\n\tvec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;\n\t\n\tfloat angle = angleRandom * rand.z * PI;\n\tfloat sin_a = sin(angle);\n\tfloat cos_a = cos(angle);\n\tfloat aspect = pixelSize.x / pixelSize.y;\n\n\tvec2 mid = tile + vec2(0.5, 0.5);\n\tvec2 dp = uv - mid;\n\tdp.x /= aspect;\n\tvec2 r = vec2(dp.x * cos_a - dp.y * sin_a,\n\t\t\t\t  dp.y * cos_a + dp.x * sin_a);\n\tr.x *= aspect;\n\n\tvec2 p = mid + r + (posRandom * rand.xy / 2.0);\n\t\n\t${e >= 2 ? \"return textureGrad(samplerFront, p, ddx, ddy);\" : \"\"}\n\t${e < 2 && i ? \"return texture2DGradEXT(samplerFront, p, ddx, ddy);\" : \"\"}\n\t${e < 2 && !i ? \"return texture2D(samplerFront, p);\" : \"\"}\n}\n\nvoid main(void) {\n\t\n\t${e < 2 ? \"lowp vec4 outColor;\" : \"\"}\n\t\n\tfloat blendMarginX = tileSpacing.x;\n\tfloat blendMarginY = tileSpacing.y;\n\t\n\tvec2 tile = floor(vTex);\n\tvec2 tex = fract(vTex);\n\tvec2 ddx = ${e >= 2 || i ? \"dFdx(vTex)\" : \"vec2(0.0, 0.0)\"};\n\tvec2 ddy = ${e >= 2 || i ? \"dFdy(vTex)\" : \"vec2(0.0, 0.0)\"};\n\t\n\tvec4 curTile = sampleTile(tile, vTex, ddx, ddy);\n\t\n\tbool inLeftMargin = (tex.x < blendMarginX);\n\tbool inRightMargin = (tex.x > 1.0 - blendMarginX);\n\tbool inTopMargin = (tex.y < blendMarginY);\n\tbool inBottomMargin = (tex.y > 1.0 - blendMarginY);\n\t\n\tif (inLeftMargin)\n\t{\n\t\tlowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);\n\t\tfloat leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;\n\t\tlowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tlowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);\n\t\t\t\n\t\t\toutColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tlowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);\n\t\t\t\n\t\t\toutColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutColor = leftMixedTile;\n\t\t}\n\t}\n\telse if (inRightMargin)\n\t{\n\t\tlowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);\n\t\tfloat rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);\n\t\tlowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);\n\t\t\n\t\tif (inTopMargin)\n\t\t{\n\t\t\tlowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);\n\t\t\t\n\t\t\toutColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t\t}\n\t\telse if (inBottomMargin)\n\t\t{\n\t\t\tlowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);\n\t\t\tlowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);\n\t\t\t\n\t\t\toutColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutColor = rightMixedTile;\n\t\t}\n\t}\n\telse if (inTopMargin)\n\t{\n\t\tlowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);\n\t\toutColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);\n\t}\n\telse if (inBottomMargin)\n\t{\n\t\tlowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);\n\t\toutColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));\n\t}\n\telse\n\t{\n\t\toutColor = curTile;\n\t}\n\t\n\toutColor *= color;\n\t${e < 2 ? \"gl_FragColor = outColor;\" : \"\"}\n\t${e >= 2 ? \"gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\" : \"\"}\n\t${e < 2 && t ? \"gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\" : \"\"}\n}\n`;\n    }\n    static GetPointVertexShaderSource_WebGL1() {\n      return [\"attribute vec4 aPoints;\", \"varying float pointOpacity;\", \"uniform float zElevation;\", \"uniform mat4 matP;\", \"uniform mat4 matMV;\", \"void main(void) {\", \"\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\", \"\tgl_PointSize = aPoints.z;\", \"\tpointOpacity = aPoints.w;\", \"}\"].join(\"\\n\");\n    }\n    static GetPointVertexShaderSource_WebGL2() {\n      return [\"#version 300 es\", \"in vec4 aPoints;\", \"out float pointOpacity;\", \"uniform float zElevation;\", \"uniform mat4 matP;\", \"uniform mat4 matMV;\", \"void main(void) {\", \"\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\", \"\tgl_PointSize = aPoints.z;\", \"\tpointOpacity = aPoints.w;\", \"}\"].join(\"\\n\");\n    }\n    static GetPointFragmentShaderSource_WebGL1_NoFragDepth() {\n      return [\"uniform lowp sampler2D samplerFront;\", \"varying lowp float pointOpacity;\", \"uniform mediump vec2 pointTexStart;\", \"uniform mediump vec2 pointTexEnd;\", \"uniform lowp vec4 color;\", \"void main(void) {\", \"\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\", \"\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\", \"}\"].join(\"\\n\");\n    }\n    static GetPointFragmentShaderSource_WebGL1_FragDepthEXT() {\n      return [\"#extension GL_EXT_frag_depth : enable\", \"uniform lowp sampler2D samplerFront;\", \"varying lowp float pointOpacity;\", \"uniform mediump vec2 pointTexStart;\", \"uniform mediump vec2 pointTexEnd;\", \"uniform lowp vec4 color;\", \"void main(void) {\", \"\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\", \"\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\", \"\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetPointFragmentShaderSource_WebGL2(e) {\n      return [\"#version 300 es\", C33.Gfx.WebGLShaderProgram._GetConservativeDepthShaderPrefix(e), \"uniform lowp sampler2D samplerFront;\", \"in lowp float pointOpacity;\", \"uniform mediump vec2 pointTexStart;\", \"uniform mediump vec2 pointTexEnd;\", \"uniform lowp vec4 color;\", \"out lowp vec4 outColor;\", \"void main(void) {\", \"\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\", \"\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\", \"\toutColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\", \"\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\", \"}\"].join(\"\\n\");\n    }\n    static GetColorFillFragmentShaderSource() {\n      return [\"uniform lowp vec4 color;\", \"void main(void) {\", \"\tgl_FragColor = color;\", \"}\"].join(\"\\n\");\n    }\n    static GetLinearGradientFillFragmentShaderSource() {\n      return [\"precision lowp float;\", \"varying mediump vec2 vTex;\", \"uniform vec4 color;\", \"uniform vec4 color2_;\", \"vec3 fromLinear(vec3 linearRGB)\", \"{\", \"\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\", \"\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\", \"\tvec3 lower = linearRGB * vec3(12.92);\", \"\treturn mix(higher, lower, vec3(cutoff));\", \"}\", \"vec3 toLinear(vec3 sRGB)\", \"{\", \"\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\", \"\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\", \"\tvec3 lower = sRGB/vec3(12.92);\", \"\treturn mix(higher, lower, vec3(cutoff));\", \"}\", \"void main(void) {\", \"\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\", \"\tfloat a = mix(color.a, color2_.a, vTex.x);\", \"\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\", \"}\"].join(\"\\n\");\n    }\n    static GetPenumbraFillFragmentShaderSource() {\n      return [\"precision lowp float;\", \"varying highp vec2 vTex;\", \"uniform vec4 color;\", \"void main(void) {\", \"\thighp float grad = vTex.x / (1.0 - vTex.y);\", \"\tgl_FragColor = color * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);\", \"}\"].join(\"\\n\");\n    }\n    static GetSmoothLineFillFragmentShaderSource() {\n      return [\"varying mediump vec2 vTex;\", \"uniform lowp vec4 color;\", \"void main(void) {\", \"\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\", \"\tgl_FragColor = color * f;\", \"}\"].join(\"\\n\");\n    }\n    static GetHardEllipseFillFragmentShaderSource() {\n      return [\"varying highp vec2 vTex;\", \"uniform lowp vec4 color;\", \"void main(void) {\", \"\thighp vec2 diff = vTex - vec2(0.5, 0.5);\", \"\thighp vec2 diffSq = diff * diff;\", \"\thighp float f = step(diffSq.x + diffSq.y, 0.25);\", \"\tgl_FragColor = color * f;\", \"}\"].join(\"\\n\");\n    }\n    static GetHardEllipseOutlineFragmentShaderSource() {\n      return [\"varying highp vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform highp vec2 pixelSize;\", \"uniform highp float outlineThickness;\", \"void main(void) {\", \"\thighp vec2 diff = vTex - vec2(0.5, 0.5);\", \"\thighp vec2 diffSq = diff * diff;\", \"\thighp float distSq = diffSq.x + diffSq.y;\", \"\thighp vec2 norm = normalize(diff);\", \"\thighp vec2 halfNorm = norm * 0.5;\", \"\thighp float innerF = step(distSq, 0.25);\", \"\thighp vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\", \"\thighp vec2 innerEdgeSq = innerEdge * innerEdge;\", \"\thighp float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\", \"\tgl_FragColor = color * innerF * outerF;\", \"}\"].join(\"\\n\");\n    }\n    static GetSmoothEllipseFillFragmentShaderSource() {\n      return [\"varying highp vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform highp vec2 pixelSize;\", \"void main(void) {\", \"\thighp vec2 diff = vTex - vec2(0.5, 0.5);\", \"\thighp vec2 diffSq = diff * diff;\", \"\thighp vec2 norm = normalize(diff);\", \"\thighp vec2 halfNorm = norm * 0.5;\", \"\thighp vec2 halfNormSq = halfNorm * halfNorm;\", \"\thighp vec2 innerEdge = halfNorm - pixelSize * norm;\", \"\thighp vec2 innerEdgeSq = innerEdge * innerEdge;\", \"\thighp float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\", \"\tgl_FragColor = color * f;\", \"}\"].join(\"\\n\");\n    }\n    static GetSmoothEllipseOutlineFragmentShaderSource() {\n      return [\"varying highp vec2 vTex;\", \"uniform lowp vec4 color;\", \"uniform highp vec2 pixelSize;\", \"uniform highp float outlineThickness;\", \"void main(void) {\", \"\thighp vec2 diff = vTex - vec2(0.5, 0.5);\", \"\thighp vec2 diffSq = diff * diff;\", \"\thighp float distSq = diffSq.x + diffSq.y;\", \"\thighp vec2 norm = normalize(diff);\", \"\thighp vec2 halfNorm = norm * 0.5;\", \"\thighp vec2 halfNormSq = halfNorm * halfNorm;\", \"\thighp vec2 pxNorm = pixelSize * norm;\", \"\thighp vec2 innerEdge1 = halfNorm - pxNorm;\", \"\thighp vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\", \"\thighp float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\", \"\thighp vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\", \"\thighp vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\", \"\thighp vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\", \"\thighp vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\", \"\thighp float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\", \"\tgl_FragColor = color * innerF * outerF;\", \"}\"].join(\"\\n\");\n    }\n  };\n}\n{\n  const C33 = self.C3, glMatrix = self.glMatrix, mat4 = glMatrix.mat4, TYPE_SIZES = /* @__PURE__ */ new Map([[\"float\", 1], [\"percent\", 1], [\"sampler\", 1], [\"vec2\", 2], [\"vec3\", 3], [\"color\", 3], [\"vec4\", 4], [\"mat4\", 16]]);\n  C33.Gfx.WebGLShaderUniform = class {\n    constructor(t, s, a) {\n      if (!TYPE_SIZES.has(a)) throw new Error(\"invalid uniform type\");\n      this._owner = t, this._gl = this._owner.GetWebGLContext(), this._name = s, this._type = a, this._isColorType = \"color\" === this._type, this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), s), this._isUsed = !!this._location;\n      const i = TYPE_SIZES.get(a);\n      this._lastValue = new Float32Array(i), this._lastBatchValue = new Float32Array(i);\n    }\n    Release() {\n      this._owner = null, this._gl = null, this._location = null;\n    }\n    IsUsed() {\n      return this._isUsed;\n    }\n    GetType() {\n      return this._type;\n    }\n    IsColorType() {\n      return this._isColorType;\n    }\n    Init1f(t) {\n      this.IsUsed() && (this._lastValue[0] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, t));\n    }\n    Init1i(t) {\n      this.IsUsed() && (this._lastValue[0] = t, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, t));\n    }\n    Init2f(t, s) {\n      this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, t, s));\n    }\n    Init3f(t, s, a) {\n      this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastValue[2] = a, this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, t, s, a));\n    }\n    Init4f(t, s, a, i) {\n      this.IsUsed() && (this._lastValue[0] = t, this._lastValue[1] = s, this._lastValue[2] = a, this._lastValue[3] = i, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, t, s, a, i));\n    }\n    Update1f(t) {\n      t = Math.fround(t);\n      const s = this._lastValue;\n      s[0] !== t && (s[0] = t, this._gl.uniform1f(this._location, t));\n    }\n    Update1i(t) {\n      const s = this._lastValue;\n      s[0] !== t && (s[0] = t, this._gl.uniform1i(this._location, t));\n    }\n    Update2f(t, s) {\n      t = Math.fround(t), s = Math.fround(s);\n      const a = this._lastValue;\n      a[0] === t && a[1] === s || (a[0] = t, a[1] = s, this._gl.uniform2f(this._location, t, s));\n    }\n    Update3f(t, s, a) {\n      t = Math.fround(t), s = Math.fround(s), a = Math.fround(a);\n      const i = this._lastValue;\n      i[0] === t && i[1] === s && i[2] === a || (i[0] = t, i[1] = s, i[2] = a, this._gl.uniform3f(this._location, t, s, a));\n    }\n    Update4f(t, s, a, i) {\n      t = Math.fround(t), s = Math.fround(s), a = Math.fround(a), i = Math.fround(i);\n      const l = this._lastValue;\n      l[0] === t && l[1] === s && l[2] === a && l[3] === i || (l[0] = t, l[1] = s, l[2] = a, l[3] = i, this._gl.uniform4f(this._location, t, s, a, i));\n    }\n    UpdateMatrix4fv(t) {\n      const s = this._lastValue;\n      mat4.exactEquals(s, t) || (C33.typedArraySet16(s, t, 0), this._gl.uniformMatrix4fv(this._location, false, t));\n    }\n    IsSetToCustomInBatch(t) {\n      const s = this._lastBatchValue;\n      return this.IsColorType() ? s[0] === Math.fround(t.getR()) && s[1] === Math.fround(t.getG()) && s[2] === Math.fround(t.getB()) : s[0] === Math.fround(t);\n    }\n    SetBatchValueCustom(t) {\n      const s = this._lastBatchValue;\n      this.IsColorType() ? (s[0] = t.getR(), s[1] = t.getG(), s[2] = t.getB()) : s[0] = t;\n    }\n    IsSetTo1InBatch(t) {\n      return this._lastBatchValue[0] === Math.fround(t);\n    }\n    IsSetTo2InBatch(t, s) {\n      const a = this._lastBatchValue;\n      return a[0] === Math.fround(t) && a[1] === Math.fround(s);\n    }\n    SetBatch1(t) {\n      this._lastBatchValue[0] = t;\n    }\n    SetBatch2(t, s) {\n      const a = this._lastBatchValue;\n      a[0] = t, a[1] = s;\n    }\n  };\n}\n{\n  const C33 = self.C3, glMatrix = self.glMatrix, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, BATCH_NULL = 0, BATCH_QUAD = 1, BATCH_SETTEXTURE = 2, BATCH_SETCOLOR = 3, BATCH_SETBLEND = 4, BATCH_SETVIEWPORT = 5, BATCH_SETPROJECTION = 6, BATCH_SETMODELVIEW = 7, BATCH_SETRENDERTARGET = 8, BATCH_CLEARSURFACE = 9, BATCH_POINTS = 10, BATCH_SETPROGRAM = 11, BATCH_SETPROGRAMPARAMETERS = 12, BATCH_SETPROGRAMCUSTOMPARAMETERS = 13, BATCH_INVALIDATEFRAMEBUFFER = 14, BATCH_SETPOINTTEXCOORDS = 15, BATCH_SETTILEMAPINFO = 16, BATCH_BLITFRAMEBUFFER = 17, BATCH_STARTQUERY = 18, BATCH_ENDQUERY = 19, BATCH_SETELLIPSEPARAMS = 20, BATCH_SETGRADIENTCOLOR = 21, BATCH_CLEARDEPTH = 22, BATCH_SETDEPTHENABLED = 23, BATCH_SETDEPTHSAMPLINGENABLED = 24, BATCH_COPLANAR_STARTSTENCILPASS = 25, BATCH_COPLANAR_STARTCOLORPASS = 26, BATCH_COPLANAR_RESTORE = 27, BATCH_SET_SCISSOR = 28, BATCH_SETTILERANDOMIZATIONINFO = 29;\n  C33.Gfx.BatchState = class {\n    constructor(t) {\n      this.renderer = t, this.currentMV = mat4.create(), this.currentMatP = mat4.create(), this.currentFramebuffer = null, this.currentFramebufferNoDepth = null, this.isDepthSamplingEnabled = false, this.currentColor = vec4.fromValues(1, 1, 1, 1), this.currentShader = null, this.pointTexCoords = new C33.Rect(), this.clearColor = C33.New(C33.Color, 0, 0, 0, 0);\n    }\n  }, C33.Gfx.WebGLBatchJob = class {\n    constructor(t) {\n      const e = new ArrayBuffer(96);\n      this._type = 0, this._batchState = t, this._gl = t.renderer.GetContext(), this._startIndex = 0, this._indexCount = 0, this._texParam = null, this._mat4param = new Float32Array(e, 0, 16), this._colorParam = new Float32Array(e, 64, 4), this._srcOriginRect = new Float32Array(e, 80, 4), this._shaderParams = [];\n    }\n    InitQuad(t, e) {\n      this._type = 1, this._startIndex = t, this._indexCount = e;\n    }\n    DoQuad() {\n      const t = this._gl;\n      t.drawElements(t.TRIANGLES, this._indexCount, t.UNSIGNED_SHORT, this._startIndex);\n    }\n    InitSetTexture(t) {\n      this._type = 2, this._texParam = t;\n    }\n    DoSetTexture() {\n      const t = this._gl, e = this._texParam;\n      t.bindTexture(t.TEXTURE_2D, e ? e._GetTexture() : null);\n    }\n    InitSetColor(t) {\n      this._type = 3, t.writeToTypedArray(this._colorParam, 0);\n    }\n    DoSetColor() {\n      const t = this._colorParam, e = this._batchState;\n      vec4.copy(e.currentColor, t), e.currentShader.UpdateColor(t);\n    }\n    InitSetGradientColor(t) {\n      this._type = 21, t.writeToTypedArray(this._colorParam, 0);\n    }\n    DoSetGradientColor() {\n      const t = this._colorParam, e = this._batchState.currentShader;\n      e._uColor2.IsUsed() && e._uColor2.Update4f(t[0], t[1], t[2], t[3]);\n    }\n    InitSetBlend(t, e) {\n      this._type = 4, this._startIndex = t, this._indexCount = e;\n    }\n    DoSetBlend() {\n      this._gl.blendFunc(this._startIndex, this._indexCount);\n    }\n    InitSetViewport(t, e, r, a) {\n      this._type = 5;\n      const s = this._colorParam;\n      s[0] = t, s[1] = e, s[2] = r, s[3] = a;\n    }\n    DoSetViewport() {\n      const t = this._colorParam;\n      this._gl.viewport(t[0], t[1], t[2], t[3]);\n    }\n    InitSetProjection(t) {\n      this._type = 6, mat4.copy(this._mat4param, t);\n    }\n    DoSetProjection() {\n      const t = this._batchState, e = t.renderer._allShaderPrograms, r = t.currentShader, a = this._mat4param;\n      for (let t2 = 0, s = e.length; t2 < s; ++t2) {\n        const s2 = e[t2];\n        s2 === r ? s2.UpdateMatP(a, true) : s2.SetMatPStale();\n      }\n      mat4.copy(t.currentMatP, a);\n    }\n    InitSetModelView(t) {\n      this._type = 7, mat4.copy(this._mat4param, t);\n    }\n    DoSetModelView() {\n      const t = this._batchState, e = t.renderer._allShaderPrograms, r = t.currentShader, a = this._mat4param;\n      for (let t2 = 0, s = e.length; t2 < s; ++t2) {\n        const s2 = e[t2];\n        s2 === r ? s2.UpdateMatMV(a, true) : s2.SetMatMVStale();\n      }\n      mat4.copy(t.currentMV, a);\n    }\n    InitSetRenderTarget(t) {\n      this._type = 8, this._texParam = t;\n    }\n    DoSetRenderTarget() {\n      const t = this._gl, e = this._texParam, r = this._batchState;\n      e ? (r.currentFramebuffer = e._GetFramebuffer(), r.currentFramebufferNoDepth = e._GetFramebufferNoDepth(), r.isDepthSamplingEnabled && r.currentFramebufferNoDepth ? t.bindFramebuffer(t.FRAMEBUFFER, r.currentFramebufferNoDepth) : t.bindFramebuffer(t.FRAMEBUFFER, r.currentFramebuffer)) : (r.currentFramebuffer = null, r.currentFramebufferNoDepth = null, t.bindFramebuffer(t.FRAMEBUFFER, null));\n    }\n    InitClearSurface(t) {\n      this._type = 9, t.writeToTypedArray(this._mat4param, 0);\n    }\n    InitClearSurface2(t, e, r, a) {\n      this._type = 9;\n      const s = this._mat4param;\n      s[0] = t, s[1] = e, s[2] = r, s[3] = a;\n    }\n    DoClearSurface() {\n      const t = this._gl, e = this._mat4param, r = this._batchState.clearColor, a = e[0], s = e[1], i = e[2], n = e[3];\n      r.equalsRgba(a, s, i, n) || (t.clearColor(a, s, i, n), r.setRgba(a, s, i, n)), t.clear(t.COLOR_BUFFER_BIT);\n    }\n    InitSetPointTexCoords(t) {\n      this._type = 15, t.writeToTypedArray(this._mat4param, 0);\n    }\n    DoSetPointTextureCoords() {\n      const t = this._mat4param;\n      this._batchState.pointTexCoords.set(t[0], t[1], t[2], t[3]);\n    }\n    InitPoints(t, e) {\n      this._type = 10, this._startIndex = t, this._indexCount = 1, this._mat4param[0] = e;\n    }\n    DoPoints() {\n      const t = this._gl, e = this._batchState, r = e.renderer._spPoints;\n      t.useProgram(r._shaderProgram), r.UpdateMatP(e.currentMatP, false), r.UpdateMatMV(e.currentMV, false);\n      const a = e.pointTexCoords;\n      r._uPointTexStart.IsUsed() && r._uPointTexStart.Update2f(a.getLeft(), a.getTop()), r._uPointTexEnd.IsUsed() && r._uPointTexEnd.Update2f(a.getRight(), a.getBottom());\n      const s = this._mat4param[0];\n      if (r._uZElevation.IsUsed() && r._uZElevation.Update1f(s), r._uColor.IsUsed()) {\n        const t2 = e.currentColor;\n        r._uColor.Update4f(t2[0], t2[1], t2[2], t2[3]);\n      }\n      t.drawArrays(t.POINTS, this._startIndex / 4, this._indexCount), t.useProgram(e.currentShader._shaderProgram);\n    }\n    InitSetProgram(t) {\n      this._type = 11, this._texParam = t;\n    }\n    DoSetProgram() {\n      const t = this._gl, e = this._batchState, r = this._texParam;\n      if (e.currentShader = r, t.useProgram(r._shaderProgram), r.UpdateMatP(e.currentMatP, false), r.UpdateMatMV(e.currentMV, false), r._uColor.IsUsed()) {\n        const t2 = e.currentColor;\n        r._uColor.Update4f(t2[0], t2[1], t2[2], t2[3]);\n      }\n    }\n    InitSetProgramParameters() {\n      this._type = 12;\n    }\n    DoSetProgramParameters() {\n      const t = this._batchState.currentShader, e = this._gl, r = this._mat4param, a = this._colorParam, s = this._srcOriginRect;\n      if (t._uSamplerBack.IsUsed()) {\n        const t2 = this._batchState.renderer, r2 = this._texParam;\n        t2._lastTexture1 !== r2 && (e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, r2 ? r2._GetTexture() : null), t2._lastTexture1 = r2, e.activeTexture(e.TEXTURE0));\n      }\n      t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(r[0], r[1]), t._uDestStart.IsUsed() && t._uDestStart.Update2f(r[2], r[3]), t._uDestEnd.IsUsed() && t._uDestEnd.Update2f(r[4], r[5]), t._uDevicePixelRatio.IsUsed() && t._uDevicePixelRatio.Update1f(this._indexCount), t._uLayerScale.IsUsed() && t._uLayerScale.Update1f(r[6]), t._uLayerAngle.IsUsed() && t._uLayerAngle.Update1f(r[7]), t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(r[12], r[13]), t._uSrcEnd.IsUsed() && t._uSrcEnd.Update2f(r[14], r[15]), t._uSrcOriginStart.IsUsed() && t._uSrcOriginStart.Update2f(s[0], s[1]), t._uSrcOriginEnd.IsUsed() && t._uSrcOriginEnd.Update2f(s[2], s[3]), t._uLayoutStart.IsUsed() && t._uLayoutStart.Update2f(a[0], a[1]), t._uLayoutEnd.IsUsed() && t._uLayoutEnd.Update2f(a[2], a[3]), t._uSeconds.IsUsed() && t._uSeconds.Update1f(this._startIndex);\n    }\n    InitSetProgramCustomParameters() {\n      this._type = 13;\n    }\n    DoSetProgramCustomParameters() {\n      const t = this._batchState.currentShader._uCustomParameters, e = this._shaderParams;\n      for (let r = 0, a = t.length; r < a; ++r) {\n        const a2 = t[r], s = e[r];\n        a2.IsColorType() ? a2.Update3f(s.getR(), s.getG(), s.getB()) : a2.Update1f(s);\n      }\n    }\n    InitInvalidateFramebuffer(t) {\n      this._type = 14, this._texParam = t;\n    }\n    DoInvalidateFramebuffer() {\n      const t = this._gl, e = this._texParam, r = this._batchState.currentFramebuffer;\n      e !== r && t.bindFramebuffer(t.FRAMEBUFFER, e), t.invalidateFramebuffer(t.FRAMEBUFFER, [t.COLOR_ATTACHMENT0]), e !== r && t.bindFramebuffer(t.FRAMEBUFFER, r);\n    }\n    InitBlitFramebuffer(t, e, r) {\n      this._type = 17;\n      const a = this._mat4param, s = this._batchState.renderer;\n      a[0] = t.GetWidth(), a[1] = t.GetHeight(), a[2] = e ? e.GetWidth() : s.GetWidth(), a[3] = e ? e.GetHeight() : s.GetHeight(), a[4] = t.IsLinearSampling() ? 1 : 0, a[5] = \"stretch\" === r;\n      const i = this._shaderParams;\n      C33.clearArray(i), i.push(t._GetFramebuffer()), i.push(e ? e._GetFramebuffer() : null);\n    }\n    DoBlitFramebuffer() {\n      const t = this._mat4param, e = this._shaderParams, r = this._gl, a = t[0], s = t[1], i = t[2], n = t[3], o = 0 !== t[4], _ = 0 !== t[5], h = e[0], u = e[1];\n      if (r.bindFramebuffer(r.READ_FRAMEBUFFER, h), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, u), _) r.blitFramebuffer(0, 0, a, s, 0, 0, i, n, r.COLOR_BUFFER_BIT, o ? r.LINEAR : r.NEAREST);\n      else {\n        const t2 = Math.min(a, i), e2 = Math.min(s, n), o2 = Math.max(s - n, 0), _2 = Math.max(n - s, 0);\n        r.blitFramebuffer(0, o2, t2, e2 + o2, 0, _2, t2, e2 + _2, r.COLOR_BUFFER_BIT, r.NEAREST);\n      }\n    }\n    InitStartQuery(t) {\n      this._type = 18, this._texParam = t;\n    }\n    DoStartQuery() {\n      this._texParam.BeginTimeElapsed(), this._texParam = null;\n    }\n    InitEndQuery(t) {\n      this._type = 19, this._texParam = t;\n    }\n    DoEndQuery() {\n      this._texParam.EndTimeElapsed(), this._texParam = null;\n    }\n    InitSetEllipseParams(t, e, r) {\n      this._type = 20;\n      const a = this._mat4param;\n      a[0] = t, a[1] = e, a[2] = r;\n    }\n    DoSetEllipseParams() {\n      const t = this._batchState.currentShader, e = this._mat4param;\n      t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[0], e[1]), t._uOutlineThickness.IsUsed() && t._uOutlineThickness.Update1f(e[2]);\n    }\n    InitSetTilemapInfo(t, e, r, a, s, i, n) {\n      this._type = 16;\n      const o = this._mat4param;\n      t.writeToTypedArray(o, 0), o[4] = 1 / e, o[5] = 1 / r, o[6] = a / e, o[7] = s / r, o[8] = i / e, o[9] = n / r;\n    }\n    DoSetTilemapInfo() {\n      const t = this._batchState.currentShader, e = this._mat4param;\n      t._uSrcStart.IsUsed() && t._uSrcStart.Update2f(e[0], e[1]), t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[4], e[5]), t._uTileSize.IsUsed() && t._uTileSize.Update2f(e[6], e[7]), t._uTileSpacing.IsUsed() && t._uTileSpacing.Update2f(e[8], e[9]);\n    }\n    InitSetTileRandomizationInfo(t, e, r, a, s, i, n) {\n      this._type = 29;\n      const o = this._mat4param;\n      o[0] = 1 / t, o[1] = 1 / e, o[2] = r, o[3] = a, o[4] = s, o[5] = i, o[6] = n;\n    }\n    DoSetTileRandomizationInfo() {\n      const t = this._batchState.currentShader, e = this._mat4param;\n      t._uPixelSize.IsUsed() && t._uPixelSize.Update2f(e[0], e[1]), t._uTileSize.IsUsed() && t._uTileSize.Update2f(e[2], e[3]), t._uOutlineThickness.IsUsed() && t._uOutlineThickness.Update1f(e[4]), t._uTileSpacing.IsUsed() && t._uTileSpacing.Update2f(e[5], e[6]);\n    }\n    InitClearDepth(t) {\n      this._type = 22, this._startIndex = t ? 1 : 0;\n    }\n    DoClearDepth() {\n      const t = this._gl, e = 0 !== this._startIndex;\n      e || t.depthMask(true), t.clear(t.DEPTH_BUFFER_BIT), e || t.depthMask(false);\n    }\n    InitSetDepthEnabled(t) {\n      this._type = 23, this._startIndex = t ? 1 : 0;\n    }\n    DoSetDepthEnabled() {\n      const t = this._gl;\n      0 === this._startIndex ? (t.disable(t.DEPTH_TEST), t.depthMask(false)) : (t.enable(t.DEPTH_TEST), t.depthMask(true));\n    }\n    InitSetDepthSamplingEnabled(t) {\n      this._type = 24, this._startIndex = t ? 1 : 0;\n    }\n    DoSetDepthSamplingEnabled() {\n      const t = this._gl, e = this._batchState, r = e.renderer, a = 0 !== this._startIndex;\n      e.isDepthSamplingEnabled = a, t.activeTexture(t.TEXTURE2), a ? (e.currentFramebufferNoDepth && t.bindFramebuffer(t.FRAMEBUFFER, e.currentFramebufferNoDepth), t.bindTexture(t.TEXTURE_2D, r._GetDepthBuffer())) : (t.bindTexture(t.TEXTURE_2D, null), e.currentFramebufferNoDepth && t.bindFramebuffer(t.FRAMEBUFFER, e.currentFramebuffer)), t.activeTexture(t.TEXTURE0);\n    }\n    InitCoplanarStartStencilPass() {\n      this._type = 25;\n    }\n    DoCoplanarStartStencilPass() {\n      const t = this._gl;\n      t.clear(t.STENCIL_BUFFER_BIT), t.enable(t.STENCIL_TEST), t.stencilFunc(t.ALWAYS, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.REPLACE), t.colorMask(false, false, false, false);\n    }\n    InitCoplanarStartColorPass() {\n      this._type = 26;\n    }\n    DoCoplanarStartColorPass() {\n      const t = this._gl;\n      t.colorMask(true, true, true, true), t.stencilFunc(t.EQUAL, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.KEEP);\n    }\n    InitCoplanarRestore() {\n      this._type = 27;\n    }\n    DoCoplanarRestore() {\n      const t = this._gl;\n      t.disable(t.STENCIL_TEST);\n    }\n    InitSetScissor(t, e, r, a, s) {\n      this._type = 28, this._startIndex = t ? 1 : 0;\n      const i = this._mat4param;\n      i[0] = e, i[1] = r, i[2] = a, i[3] = s;\n    }\n    DoSetScissor() {\n      const t = this._gl, e = this._mat4param;\n      1 === this._startIndex ? (t.enable(t.SCISSOR_TEST), t.scissor(e[0], e[1], e[2], e[3])) : t.disable(t.SCISSOR_TEST);\n    }\n    Run() {\n      switch (this._type) {\n        case 1:\n          return void this.DoQuad();\n        case 2:\n          return void this.DoSetTexture();\n        case 3:\n          return void this.DoSetColor();\n        case 4:\n          return void this.DoSetBlend();\n        case 5:\n          return void this.DoSetViewport();\n        case 6:\n          return void this.DoSetProjection();\n        case 7:\n          return void this.DoSetModelView();\n        case 8:\n          return void this.DoSetRenderTarget();\n        case 9:\n          return void this.DoClearSurface();\n        case 10:\n          return void this.DoPoints();\n        case 11:\n          return void this.DoSetProgram();\n        case 12:\n          return void this.DoSetProgramParameters();\n        case 13:\n          return void this.DoSetProgramCustomParameters();\n        case 14:\n          return void this.DoInvalidateFramebuffer();\n        case 15:\n          return void this.DoSetPointTextureCoords();\n        case 16:\n          return void this.DoSetTilemapInfo();\n        case 17:\n          return void this.DoBlitFramebuffer();\n        case 18:\n          return void this.DoStartQuery();\n        case 19:\n          return void this.DoEndQuery();\n        case 20:\n          return void this.DoSetEllipseParams();\n        case 21:\n          return void this.DoSetGradientColor();\n        case 22:\n          return void this.DoClearDepth();\n        case 23:\n          return void this.DoSetDepthEnabled();\n        case 24:\n          return void this.DoSetDepthSamplingEnabled();\n        case 25:\n          return void this.DoCoplanarStartStencilPass();\n        case 26:\n          return void this.DoCoplanarStartColorPass();\n        case 27:\n          return void this.DoCoplanarRestore();\n        case 28:\n          return void this.DoSetScissor();\n        case 29:\n          return void this.DoSetTileRandomizationInfo();\n      }\n    }\n  };\n}\n{\n  let fillOrStrokeRect = function(t, e, i, s, a, n) {\n    e ? t.strokeRect(i, s, a, n) : t.fillRect(i, s, a, n);\n  }, ptToPx = function(t) {\n    return t * (4 / 3);\n  }, getOffsetParam = function(t, e) {\n    t = t.trim();\n    const i = parseFloat(t);\n    return isFinite(i) ? t.endsWith(\"%\") ? e * i / 100 : i : 0;\n  };\n  fillOrStrokeRect2 = fillOrStrokeRect, ptToPx2 = ptToPx, getOffsetParam2 = getOffsetParam;\n  const C33 = self.C3, MAX_TEXTURE_SIZE = 4096, EXTRA_LINE_HEIGHT = 4, GENERIC_FONT_FAMILIES = /* @__PURE__ */ new Set([\"serif\", \"sans-serif\", \"monospace\", \"cursive\", \"fantasy\", \"system-ui\", \"ui-serif\", \"ui-sans-serif\", \"ui-monospace\", \"ui-rounded\", \"math\", \"emoji\", \"fangsong\"]), DEFAULT_OPTS = { timeout: 60 }, tempColor = new C33.Color(0, 0, 0, 1), VALID_HORIZ_ALIGNMENTS = /* @__PURE__ */ new Set([\"left\", \"center\", \"right\"]), VALID_VERT_ALIGNMENTS = /* @__PURE__ */ new Set([\"top\", \"center\", \"bottom\"]), VALID_WORD_WRAP_MODES = /* @__PURE__ */ new Set([\"word\", \"cjk\", \"character\"]), VALID_TEXT_DIRECTIONS = /* @__PURE__ */ new Set([\"ltr\", \"rtl\"]), allRendererTexts = /* @__PURE__ */ new Set();\n  C33.FontManager && C33.FontManager.addEventListener(\"fontload\", (t) => {\n    const e = t.font.GetName();\n    for (const t2 of allRendererTexts) (t2.IsBBCodeEnabled() || C33.equalsNoCase(t2.GetFontName(), e)) && t2._SetWordWrapChanged();\n  });\n  let didCheckFoundBoundingBoxSupport = false, supportsFontBoundingBoxMeasurements = false;\n  C33.Gfx.RendererText = class {\n    constructor(t, e) {\n      e = Object.assign({}, DEFAULT_OPTS, e), this._renderer = t, this._fontName = \"Arial\", this._fontSize = 16, this._fontSizeScale = 1, this._lineHeight = 0, this._isBold = false, this._isItalic = false, this._colorStr = \"black\", this._isBBcodeEnabled = false, this._iconSet = null, this._iconSmoothing = true, this.onloadfont = null, this._alreadyLoadedFonts = /* @__PURE__ */ new Set(), this._horizontalAlign = \"left\", this._verticalAlign = \"top\", this._text = \"\", this._bbString = null, this._wrappedText = C33.New(C33.WordWrap), this._wrapMode = \"word\", this._textDirection = \"ltr\", this._wordWrapChanged = false, this._textLayoutChanged = false, this._drawChanged = false, this._drawMaxCharCount = -1, this._drawCharCount = 0, this._cssWidth = 0, this._cssHeight = 0, this._width = 0, this._height = 0, this._zoom = 1, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._lastCanvasWidth = -1, this._lastCanvasHeight = -1, this._lastTextCanvasFont = \"\", this._lastMeasureCanvasFont = \"\", this._lastTextCanvasFillStyle = \"\", this._lastTextCanvasOpacity = 1, this._lastTextCanvasLineWidth = 1, this._measureTextCallback = (t2) => this._MeasureText(t2), this._texture = null, this._rcTex = new C33.Rect(), this._scaleFactor = 1, this._textureTimeout = new C33.IdleTimeout(() => {\n        this.ReleaseTexture(), this._SetTextCanvasSize(8, 8);\n      }, e.timeout), this.ontextureupdate = null, this._wasReleased = false, allRendererTexts.add(this);\n    }\n    Release() {\n      this.onloadfont = null, this._alreadyLoadedFonts.clear(), this._iconSet = null, this._bbString = null, this._textCanvas = null, this._textContext = null, this._measureContext = null, this._measureContextTop = null, this._measureTextCallback = null, this._textureTimeout.Release(), this.ontextureupdate = null, this.ReleaseTexture(), this._wrappedText.Clear(), this._wrappedText = null, this._renderer = null, this._wasReleased = true, allRendererTexts.delete(this);\n    }\n    _SetDrawChanged() {\n      this._drawChanged = true;\n    }\n    _SetTextLayoutChanged() {\n      this._SetDrawChanged(), this._textLayoutChanged = true;\n    }\n    _SetWordWrapChanged() {\n      this._SetTextLayoutChanged(), this._wordWrapChanged = true;\n    }\n    SetBBCodeEnabled(t) {\n      if (t = !!t, this._isBBcodeEnabled === t) return;\n      this._isBBcodeEnabled = t;\n      const e = this._isBBcodeEnabled ? \"alphabetic\" : \"top\";\n      this._textContext && (this._textContext.textBaseline = e), this._measureContext && (this._measureContext.textBaseline = e), this._SetWordWrapChanged();\n    }\n    IsBBCodeEnabled() {\n      return this._isBBcodeEnabled;\n    }\n    SetIconSet(t) {\n      this._iconSet !== t && (this._iconSet = t, this._wrappedText.SetIconSet(t), this._iconSet && this._iconSet.IsLoading() && this._iconSet.LoadContent().then(() => this._SetDrawChanged()), this._SetWordWrapChanged());\n    }\n    SetIconSmoothing(t) {\n      t = !!t, this._iconSmoothing !== t && (this._iconSmoothing = t, this._SetDrawChanged());\n    }\n    SetFontName(t) {\n      t || (t = \"serif\"), this._fontName !== t && (this._fontName = t, this._SetWordWrapChanged());\n    }\n    GetFontName() {\n      return this._fontName;\n    }\n    SetFontSize(t) {\n      t < 0.1 && (t = 0.1), this._fontSize !== t && (this._fontSize = t, this._SetWordWrapChanged());\n    }\n    GetFontSize() {\n      return this._fontSize;\n    }\n    SetFontSizeScale(t) {\n      this._fontSizeScale !== t && (this._fontSizeScale = t, this._SetWordWrapChanged());\n    }\n    SetLineHeight(t) {\n      this._lineHeight !== t && (this._lineHeight = t, this._SetTextLayoutChanged());\n    }\n    GetLineHeight() {\n      return this._lineHeight;\n    }\n    SetBold(t) {\n      t = !!t, this._isBold !== t && (this._isBold = t, this._SetWordWrapChanged());\n    }\n    IsBold() {\n      return this._isBold;\n    }\n    SetItalic(t) {\n      t = !!t, this._isItalic !== t && (this._isItalic = t, this._SetWordWrapChanged());\n    }\n    IsItalic() {\n      return this._isItalic;\n    }\n    SetDrawMaxCharacterCount(t) {\n      t = Math.floor(t), this._drawMaxCharCount !== t && (this._drawMaxCharCount = t, this._SetDrawChanged());\n    }\n    GetDrawMaxCharacterCount() {\n      return this._drawMaxCharCount;\n    }\n    _GetFontString(t, e) {\n      let i = [];\n      (this._isBold || e.HasStyleTag(\"b\")) && i.push(\"bold\"), (this._isItalic || e.HasStyleTag(\"i\")) && i.push(\"italic\");\n      const s = e.GetStyleTag(\"size\"), a = (s ? parseFloat(s.param) : this._fontSize) * this._fontSizeScale;\n      t ? i.push(a + \"pt\") : i.push(a * this.GetDrawScale() + \"pt\");\n      let n = this._fontName;\n      const h = e.GetStyleTag(\"font\");\n      return h && h.param && (n = h.param, this.onloadfont && !this._alreadyLoadedFonts.has(n) && (this.onloadfont(n), this._alreadyLoadedFonts.add(n))), n && (GENERIC_FONT_FAMILIES.has(n) ? i.push(n) : i.push('\"' + n + '\"')), i.join(\" \");\n    }\n    SetColor(t) {\n      t instanceof C33.Color && (t = t.getCssRgb()), this._colorStr !== t && (this._colorStr = t, this._SetDrawChanged());\n    }\n    SetColorRgb(t, e, i) {\n      tempColor.setRgb(t, e, i), this.SetColor(tempColor);\n    }\n    SetHorizontalAlignment(t) {\n      if (!VALID_HORIZ_ALIGNMENTS.has(t)) throw new Error(\"invalid horizontal alignment\");\n      this._horizontalAlign !== t && (this._horizontalAlign = t, this._SetTextLayoutChanged());\n    }\n    GetHorizontalAlignment() {\n      return this._horizontalAlign;\n    }\n    SetVerticalAlignment(t) {\n      if (!VALID_VERT_ALIGNMENTS.has(t)) throw new Error(\"invalid vertical alignment\");\n      this._verticalAlign !== t && (this._verticalAlign = t, this._SetTextLayoutChanged());\n    }\n    GetVerticalAlignment() {\n      return this._verticalAlign;\n    }\n    SetWordWrapMode(t) {\n      if (!VALID_WORD_WRAP_MODES.has(t)) throw new Error(\"invalid word wrap mode\");\n      this._wrapMode !== t && (this._wrapMode = t, this._SetWordWrapChanged());\n    }\n    GetWordWrapMode() {\n      return this._wrapMode;\n    }\n    SetTextDirection(t) {\n      if (!VALID_TEXT_DIRECTIONS.has(t)) throw new Error(\"invalid text direction\");\n      this._textDirection !== t && (this._textDirection = t, this._textContext && (this._textContext.direction = this._textDirection), this._measureContext && (this._measureContext.direction = this._textDirection), this._SetWordWrapChanged());\n    }\n    GetTextDirection() {\n      return this._textDirection;\n    }\n    SetText(t) {\n      this._text !== t && (this._text = t, this._SetWordWrapChanged());\n    }\n    GetText() {\n      return this._text;\n    }\n    GetDrawScale() {\n      return this._scaleFactor * this._zoom * self.devicePixelRatio;\n    }\n    SetSize(t, e, i) {\n      if (void 0 === i && (i = 1), t <= 0 || t <= 0) return;\n      if (this._cssWidth === t && this._cssHeight === e && this._zoom === i) return;\n      const s = this._cssWidth;\n      this._cssWidth = t, this._cssHeight = e, this._zoom = i;\n      const a = self.devicePixelRatio;\n      this._width = this._cssWidth * this._zoom * a, this._height = this._cssHeight * this._zoom * a;\n      const n = Math.max(this._width, this._height), h = Math.min(this._renderer.GetMaxTextureSize(), 4096);\n      let o = 1;\n      n > h && (o = h / n, this._width = Math.min(this._width * o, h), this._height = Math.min(this._height * o, h)), this._scaleFactor = o, this._cssWidth !== s ? this._SetWordWrapChanged() : this._SetTextLayoutChanged();\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    GetZoom() {\n      return this._zoom;\n    }\n    GetTextWidth() {\n      return this._UpdateTextMeasurements(), this._wrappedText.GetMaxLineWidth();\n    }\n    GetTextHeight() {\n      return this._UpdateTextMeasurements(), this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + 4) - this._lineHeight;\n    }\n    GetLengthInGraphemes() {\n      this._UpdateTextMeasurements();\n      let t = 0;\n      for (const e of this._wrappedText.GetLines()) for (const i of e.fragments()) t += i.GetLength();\n      return t;\n    }\n    GetTexture() {\n      return this._textureTimeout.Reset(), this._MaybeUpdate(), this._texture;\n    }\n    HitTestFragment(t, e) {\n      this._UpdateTextMeasurements();\n      const i = this.GetDrawScale(), s = this._wrappedText.GetLines();\n      for (const a of s) {\n        const s2 = a.GetFontBoundingBoxDescent() * i;\n        if (e >= a.GetPosY() - a.GetHeight() * i + s2 && e < a.GetPosY() + s2) {\n          for (const e2 of a.fragments()) if (t >= e2.GetPosX() && t < e2.GetPosX() + e2.GetWidth() * i) return e2;\n        }\n      }\n      return null;\n    }\n    *fragmentsWithTag(t) {\n      this._UpdateTextMeasurements();\n      const e = this._wrappedText.GetLines();\n      for (const i of e) for (const e2 of i.fragments()) {\n        const i2 = e2.GetStyleTag(\"tag\");\n        i2 && C33.equalsNoCase(i2.param, t) && (yield e2);\n      }\n    }\n    FindFragmentWithTag(t, e) {\n      for (const i of this.fragmentsWithTag(t)) {\n        if (0 === e) return i;\n        --e;\n      }\n      return null;\n    }\n    CountFragmentsWithTag(t) {\n      let e = 0;\n      for (const i of this.fragmentsWithTag(t)) ++e;\n      return e;\n    }\n    _MaybeUpdate() {\n      (!this._texture || this._drawChanged || this._textLayoutChanged || this._wordWrapChanged) && (this._wasReleased || this._width <= 0 || this._height <= 0 || (this._drawChanged = false, this._DoUpdate()));\n    }\n    _DoUpdate() {\n      this._wasReleased || (this._UpdateTextMeasurements(), this._SetTextCanvasSize(Math.max(C33.nextHighestPowerOfTwo(Math.ceil(this._width)), 128), Math.max(C33.nextHighestPowerOfTwo(Math.ceil(this._height)), 64)), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset());\n    }\n    _SetTextCanvasSize(t, e) {\n      this._textCanvas || (this._textCanvas = C33.CreateCanvas(16, 16));\n      let i = false;\n      this._lastCanvasWidth === t && this._lastCanvasHeight === e || (this._lastCanvasWidth = t, this._lastCanvasHeight = e, this._textCanvas.width = t, this._textCanvas.height = e, i = true), this._textContext || (this._textContext = this._textCanvas.getContext(\"2d\"), i = true), i ? (this._textContext.textBaseline = this._isBBcodeEnabled ? \"alphabetic\" : \"top\", this._textContext.direction = this._textDirection, this._textContext.font = this._lastTextCanvasFont, this._textContext.fillStyle = this._lastTextCanvasFillStyle, this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, t, e);\n    }\n    _MaybeCreateMeasureContext() {\n      this._measureContext || (this._measureContext = C33.CreateCanvas(16, 16).getContext(\"2d\"), this._measureContextTop = C33.CreateCanvas(16, 16).getContext(\"2d\"), this._measureContext.textBaseline = this._isBBcodeEnabled ? \"alphabetic\" : \"top\", this._measureContextTop.textBaseline = \"top\", this._measureContext.direction = this._textDirection, this._measureContextTop.direction = this._textDirection);\n    }\n    _SetMeasureFontString(t) {\n      this._lastMeasureCanvasFont !== t && (this._lastMeasureCanvasFont = t, this._measureContext.font = t, this._measureContextTop.font = t);\n    }\n    _SupportsFontBoundingBoxMeasurements() {\n      if (!didCheckFoundBoundingBoxSupport) {\n        didCheckFoundBoundingBoxSupport = true, this._MaybeCreateMeasureContext();\n        const t = this._measureContext.measureText(\"test\");\n        supportsFontBoundingBoxMeasurements = \"number\" == typeof t[\"fontBoundingBoxAscent\"] && \"number\" == typeof t[\"fontBoundingBoxDescent\"];\n      }\n      return supportsFontBoundingBoxMeasurements;\n    }\n    _UpdateTextMeasurements() {\n      this._UpdateWordWrap(), this._UpdateTextLayout();\n    }\n    _UpdateWordWrap() {\n      this._wordWrapChanged && (this._MaybeCreateMeasureContext(), !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C33.BBString(this._text, { noEscape: true })), this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._wordWrapChanged = false);\n    }\n    _UpdateTextLayout() {\n      this._textLayoutChanged && (this._LayoutText(), this._textLayoutChanged = false);\n    }\n    _MeasureText(t) {\n      const e = t.IsText() ? t.GetCharacterArray().join(\"\") : \" \";\n      this._SetMeasureFontString(this._GetFontString(true, t));\n      const i = t.GetStyleTag(\"size\"), s = (i ? parseFloat(i.param) : this._fontSize) * this._fontSizeScale, a = this._measureContext.measureText(e);\n      let n = 0;\n      if (this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements()) {\n        const t2 = this._measureContextTop.measureText(e);\n        n = a[\"fontBoundingBoxAscent\"] - t2[\"fontBoundingBoxAscent\"];\n      }\n      return { width: a.width, height: ptToPx(s), fontBoundingBoxAscent: a[\"fontBoundingBoxAscent\"] || 0, fontBoundingBoxDescent: a[\"fontBoundingBoxDescent\"] || 0, topToAlphabeticDistance: n };\n    }\n    _SetDrawFontString(t) {\n      this._lastTextCanvasFont !== t && (this._lastTextCanvasFont = t, this._textContext.font = t);\n    }\n    _SetDrawCanvasColor(t) {\n      this._lastTextCanvasFillStyle !== t && (this._lastTextCanvasFillStyle = t, this._textContext.fillStyle = t, this._textContext.strokeStyle = t);\n    }\n    _SetDrawCanvasOpacity(t) {\n      this._lastTextCanvasOpacity !== t && (this._lastTextCanvasOpacity = t, this._textContext.globalAlpha = t);\n    }\n    _SetDrawCanvasLineWith(t) {\n      this._lastTextCanvasLineWidth !== t && (this._lastTextCanvasLineWidth = t, this._textContext.lineWidth = t);\n    }\n    _LayoutText() {\n      const t = this.GetDrawScale(), e = (4 + this._lineHeight) * t;\n      let i = 0;\n      const s = this._wrappedText.GetLines();\n      if (0 === s.length) return;\n      for (const t2 of s) {\n        t2.SetPosX(NaN), t2.SetPosY(NaN);\n        for (const e2 of t2.fragments()) e2.SetPosX(NaN), e2.SetPosY(NaN);\n      }\n      const a = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements();\n      let n = s[0].GetHeight() * t;\n      if (\"center\" === this._verticalAlign) {\n        const h = s.reduce((i2, s2) => i2 + s2.GetHeight() * t + e, 0) - e;\n        i = Math.max(this._height / 2 - h / 2, 0), a && (n = s[0].GetTopToAlphabeticDistance() * t);\n      } else if (\"bottom\" === this._verticalAlign) {\n        const n2 = s.reduce((i2, s2) => i2 + s2.GetHeight() * t + e, 0) - this._lineHeight * t, h = a ? s.at(-1).GetFontBoundingBoxDescent() * t : 0;\n        i = this._height - n2 - h - 2;\n      }\n      for (let a2 = 0, h = s.length; a2 < h; ++a2) {\n        const h2 = s[a2], o = h2.GetHeight() * t, r = i;\n        if (this._isBBcodeEnabled) {\n          if (i += 0 === a2 ? n : o, a2 > 0 && i > this._height - 4 * t) break;\n        } else if (a2 > 0 && i >= this._height - o) break;\n        r >= 0 && this._LayoutTextLine(h2, i, t), this._isBBcodeEnabled || (i += o), i += e;\n      }\n    }\n    _LayoutTextLine(t, e, i) {\n      let s = 0;\n      \"center\" === this._horizontalAlign ? s = Math.floor((this._width - t.GetWidth() * i) / 2) : \"right\" === this._horizontalAlign && (s = this._width - t.GetWidth() * i), t.SetPosX(s), t.SetPosY(e);\n      for (const a of \"ltr\" === this._textDirection ? t.fragments() : t.fragmentsReverse()) this._LayoutFragment(a, s, e, i), s += a.GetWidth() * i;\n    }\n    _LayoutFragment(t, e, i, s) {\n      const a = t.GetStyleTag(\"offsetx\");\n      e += a ? getOffsetParam(a.param, t.GetHeight()) * s : 0;\n      const n = t.GetStyleTag(\"offsety\");\n      if (i += n ? getOffsetParam(n.param, t.GetHeight()) * s : 0, t.IsIcon()) {\n        const e2 = t.GetStyleTag(\"iconoffsety\");\n        i += e2 ? getOffsetParam(e2.param, t.GetHeight()) * s : 0.2 * t.GetHeight() * s;\n      }\n      t.SetPosX(e), t.SetPosY(i);\n    }\n    _DrawTextToCanvas() {\n      this._textContext.imageSmoothingEnabled = this._iconSmoothing, this._textContext.imageSmoothingQuality = \"high\", this._drawCharCount = 0;\n      const t = this.GetDrawScale(), e = this._wrappedText.GetLines();\n      for (const i of e) this._DrawTextLine(i, t);\n    }\n    _DrawTextLine(t, e) {\n      const i = t.GetPosX(), s = t.GetPosY();\n      if (Number.isFinite(i) && Number.isFinite(s)) for (const i2 of \"ltr\" === this._textDirection ? t.fragments() : t.fragmentsReverse()) this._DrawFragment(i2, e, t.GetHeight());\n    }\n    _DrawFragment(t, e, i) {\n      const s = this._textContext, a = t.GetPosX(), n = t.GetPosY();\n      if (!Number.isFinite(a) || !Number.isFinite(n)) return;\n      const h = i / 16;\n      let o = t.GetWidth() * e;\n      const r = t.GetHeight() * e, _ = t.GetHeight() / 16, l = (4 + this._lineHeight) * e;\n      let d = t.IsText() ? t.GetCharacterArray() : null;\n      if (-1 !== this._drawMaxCharCount) {\n        if (this._drawCharCount >= this._drawMaxCharCount) return;\n        t.IsText() && this._drawCharCount + d.length > this._drawMaxCharCount && (d = d.slice(0, this._drawMaxCharCount - this._drawCharCount), o = this._MeasureText(t).width * e), this._drawCharCount += t.GetLength();\n      }\n      const x = t.GetStyleTag(\"background\"), u = t.HasStyleTag(\"u\"), C = t.HasStyleTag(\"s\");\n      if (t.IsText() && C33.IsCharArrayAllWhitespace(d) && !x && !u && !C || t.HasStyleTag(\"hide\")) return;\n      const c = t.GetStyleTag(\"color\"), g = t.GetStyleTag(\"opacity\");\n      this._SetDrawCanvasOpacity(g ? parseFloat(g.param) / 100 : 1), x && (this._SetDrawCanvasColor(x.param), s.fillRect(a, n - r, o, r + l));\n      const S = t.GetStyleTag(\"linethickness\"), T = S ? parseFloat(S.param) : 1, p = t.HasStyleTag(\"stroke\");\n      if (p && this._SetDrawCanvasLineWith(0.5 * _ * T * this.GetDrawScale()), t.IsText()) {\n        const e2 = d.join(\"\");\n        if (this._SetDrawFontString(this._GetFontString(false, t)), !p) {\n          this._SetDrawCanvasLineWith(0.5 * _ * T * this.GetDrawScale());\n          const i2 = t.GetStyleTag(\"outlineback\");\n          i2 && (this._SetDrawCanvasColor(i2.param), this._FillOrStrokeText(true, e2, a, n, o));\n        }\n        if (this._SetDrawCanvasColor(c ? c.param : this._colorStr), this._FillOrStrokeText(p, e2, a, n, o), !p) {\n          this._SetDrawCanvasLineWith(0.5 * _ * T * this.GetDrawScale());\n          const i2 = t.GetStyleTag(\"outline\");\n          i2 && (this._SetDrawCanvasColor(i2.param), this._FillOrStrokeText(true, e2, a, n, o));\n        }\n      } else if (t.IsIcon() && t.GetWidth() > 0) {\n        const e2 = t.GetDrawable(this._iconSet);\n        e2 && s.drawImage(e2, a, n - r, o, r);\n      }\n      if (this._SetDrawCanvasColor(c ? c.param : this._colorStr), u && fillOrStrokeRect(s, p, a, n + e * h, o, e * h * T), C) {\n        const t2 = e * _, i2 = n - r / 4 + t2 / 2;\n        s.fillRect(a, i2 - t2 * T / 2, o, t2 * T);\n      }\n    }\n    _FillOrStrokeText(t, e, i, s, a) {\n      \"rtl\" === this._textDirection && (i += a), t ? \"Gecko\" === C33.Platform.BrowserEngine ? this._textContext.strokeText(e, i, s, a) : this._textContext.strokeText(e, i, s) : \"Gecko\" === C33.Platform.BrowserEngine ? this._textContext.fillText(e, i, s, a) : this._textContext.fillText(e, i, s);\n    }\n    _UpdateTexture() {\n      this._renderer.IsContextLost() || (this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textCanvas.width, this._textCanvas.height, { mipMap: true, mipMapQuality: \"high\" })), this._renderer.UpdateTexture(this._textCanvas, this._texture), this._rcTex.set(0, 0, this._width / this._texture.GetWidth(), this._height / this._texture.GetHeight()), this.ontextureupdate && this.ontextureupdate());\n    }\n    GetTexRect() {\n      return this._rcTex;\n    }\n    ReleaseTexture() {\n      this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture), this._texture = null);\n    }\n    static OnContextLost() {\n      for (const t of allRendererTexts) t.ReleaseTexture();\n    }\n    static GetAll() {\n      return allRendererTexts.values();\n    }\n  };\n}\nvar fillOrStrokeRect2;\nvar ptToPx2;\nvar getOffsetParam2;\n{\n  const C33 = self.C3;\n  class WebGLRealTimeElapsedQuery {\n    constructor(e) {\n      this._gl = e.GetContext(), this._version = e.GetWebGLVersionNumber(), this._timerExt = e._GetDisjointTimerQueryExtension(), this._query = null, this._isActive = false, this._hasResult = false, this._result = 0, 1 === this._version ? this._query = this._timerExt[\"createQueryEXT\"]() : this._query = this._gl[\"createQuery\"]();\n    }\n    Release() {\n      this._DeleteQueryObject(), this._gl = null, this._timerExt = null, this._hasResult = false;\n    }\n    _DeleteQueryObject() {\n      this._query && (1 === this._version ? this._timerExt[\"deleteQueryEXT\"](this._query) : this._gl[\"deleteQuery\"](this._query), this._query = null);\n    }\n    BeginTimeElapsed() {\n      if (this._isActive) throw new Error(\"query already active\");\n      1 === this._version ? this._timerExt[\"beginQueryEXT\"](this._timerExt[\"TIME_ELAPSED_EXT\"], this._query) : this._gl[\"beginQuery\"](this._timerExt[\"TIME_ELAPSED_EXT\"], this._query), this._isActive = true;\n    }\n    EndTimeElapsed() {\n      if (!this._isActive) throw new Error(\"query not active\");\n      1 === this._version ? this._timerExt[\"endQueryEXT\"](this._timerExt[\"TIME_ELAPSED_EXT\"]) : this._gl[\"endQuery\"](this._timerExt[\"TIME_ELAPSED_EXT\"]), this._isActive = false;\n    }\n    CheckForResult() {\n      if (!this._query || this._hasResult || this._isActive) return;\n      let e = false;\n      e = 1 === this._version ? this._timerExt[\"getQueryObjectEXT\"](this._query, this._timerExt[\"QUERY_RESULT_AVAILABLE_EXT\"]) : this._gl[\"getQueryParameter\"](this._query, this._gl[\"QUERY_RESULT_AVAILABLE\"]);\n      const t = this._gl.getParameter(this._timerExt[\"GPU_DISJOINT_EXT\"]);\n      e && !t && (1 === this._version ? this._result = this._timerExt[\"getQueryObjectEXT\"](this._query, this._timerExt[\"QUERY_RESULT_EXT\"]) : this._result = this._gl[\"getQueryParameter\"](this._query, this._gl[\"QUERY_RESULT\"]), this._result /= 1e9, this._hasResult = true), (e || t) && this._DeleteQueryObject();\n    }\n    HasResult() {\n      return this._hasResult;\n    }\n    GetResult() {\n      if (!this._hasResult) throw new Error(\"no result available\");\n      return this._result;\n    }\n  }\n  C33.Gfx.WebGLTimeElapsedQuery = class {\n    constructor(e) {\n      this._renderer = e, this._frameNumber = e.GetFrameNumber(), this._isActive = false, this._parentQuery = null, this._isNested = false, this._realQuery = null, this._queries = [];\n    }\n    Release() {\n      for (const e of this._queries) e instanceof WebGLRealTimeElapsedQuery && e.Release();\n      C33.clearArray(this._queries), this._parentQuery = null, this._realQuery = null, this._renderer = null;\n    }\n    BeginTimeElapsed() {\n      if (this._isActive) throw new Error(\"query already active\");\n      const e = this._renderer._GetTimeQueryStack();\n      e.length > 0 ? (this._isNested = true, this._parentQuery = e.at(-1), this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = false, this._parentQuery = null), this._isActive = true, e.push(this), this._StartReal();\n    }\n    EndTimeElapsed() {\n      if (!this._isActive) throw new Error(\"query not active\");\n      if (this._renderer._GetTimeQueryStack().pop() !== this) throw new Error(\"can only end most nested query\");\n      this._isActive = false, this._EndReal(), this._parentQuery && (this._parentQuery._StartReal(), this._parentQuery = null);\n    }\n    _StartReal() {\n      this._realQuery = C33.New(WebGLRealTimeElapsedQuery, this._renderer), this._queries.push(this._realQuery), this._realQuery.BeginTimeElapsed();\n    }\n    _EndReal() {\n      this._realQuery.EndTimeElapsed(), this._realQuery = null;\n    }\n    CheckForResult() {\n      for (const e of this._queries) e.CheckForResult();\n    }\n    IsNested() {\n      return this._isNested;\n    }\n    HasResult() {\n      return this._queries.every((e) => e.HasResult());\n    }\n    GetResult() {\n      return this._queries.reduce((e, t) => e + t.GetResult(), 0);\n    }\n    GetFrameNumber() {\n      return this._frameNumber;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Gfx.WebGLQueryResultBuffer = class {\n    constructor(e, r = 1e3) {\n      this._renderer = e, this._maxQueries = r, this._buffer = [], this._renderer._AddQueryResultBuffer(this);\n    }\n    Release() {\n      this.Clear(), this._renderer._RemoveQueryResultBuffer(this), this._renderer = null;\n    }\n    Clear() {\n      for (const e of this._buffer) e.Release();\n      C33.clearArray(this._buffer);\n    }\n    AddTimeElapsedQuery() {\n      const e = new C33.Gfx.WebGLTimeElapsedQuery(this._renderer);\n      if (this._buffer.push(e), this._buffer.length > this._maxQueries) {\n        this._buffer.shift().Release();\n      }\n      return e;\n    }\n    CheckForResults(e) {\n      for (const r of this._buffer) {\n        if (r.GetFrameNumber() >= e) return;\n        if (r.IsNested()) return;\n        r.CheckForResult();\n      }\n    }\n    GetFrameRangeResultSum(e, r) {\n      if (r <= e) return NaN;\n      let t = 0;\n      for (const s of this._buffer) {\n        if (s.GetFrameNumber() >= r) break;\n        if (!(s.GetFrameNumber() < e)) {\n          if (!s.HasResult()) return NaN;\n          t += s.GetResult();\n        }\n      }\n      return t;\n    }\n    DeleteAllBeforeFrameNumber(e) {\n      for (let r = 0, t = this._buffer.length; r < t; ++r) {\n        const t2 = this._buffer[r];\n        if (!(t2.GetFrameNumber() < e)) return void (r > 0 && this._buffer.splice(0, r));\n        t2.Release();\n      }\n    }\n  };\n}\n{\n  let CheckPendingPolls = function() {\n    pollRafId = -1;\n    for (const t of pendingPolls) t.checkFunc() && (t.resolve(), pendingPolls.delete(t));\n    pendingPolls.size > 0 && (pollRafId = self.requestAnimationFrame(CheckPendingPolls));\n  };\n  CheckPendingPolls2 = CheckPendingPolls;\n  const C33 = self.C3, assert = self.assert, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, DEFAULT_WEBGLRENDERER_OPTS = { powerPreference: \"default\", enableGpuProfiling: true, alpha: false, depth: false, canSampleDepth: false, maxWebGLVersion: 2, failIfMajorPerformanceCaveat: false }, VALID_POWER_PREFERENCES = /* @__PURE__ */ new Set([\"default\", \"low-power\", \"high-performance\"]), MAX_VERTICES = 8e3, MAX_INDICES = 12e3, MAX_POINTS = 8e3, LAST_POINT = 7996, PARTIAL_TEXTURE_UPLOAD_CHUNK_SIZE = 262144, defaultTexCoordsQuad = new C33.Quad(0, 0, 1, 0, 1, 1, 0, 1), tmpProjection = mat4.create(), tmpModelView = mat4.create(), tmpQuad = new C33.Quad(), tmpRect = new C33.Rect();\n  let loseContextExtension = null;\n  C33.isDebug && (self.debug_lose_webgl_context = function() {\n    loseContextExtension ? loseContextExtension.loseContext() : console.warn(\"WEBGL_lose_context not supported\");\n  }, self.debug_restore_webgl_context = function() {\n    loseContextExtension ? loseContextExtension.restoreContext() : console.warn(\"WEBGL_lose_context not supported\");\n  });\n  const pendingPolls = /* @__PURE__ */ new Set();\n  let pollRafId = -1;\n  C33.Gfx.WebGLRenderer = class extends C33.Gfx.RendererBase {\n    constructor(t, e) {\n      if (super(e), e = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, e), !VALID_POWER_PREFERENCES.has(e.powerPreference)) throw new Error(\"invalid power preference\");\n      const r = { \"alpha\": !!e.alpha, \"depth\": false, \"antialias\": false, \"powerPreference\": e.powerPreference, \"failIfMajorPerformanceCaveat\": !!e.failIfMajorPerformanceCaveat };\n      let i = null, s = 0;\n      if (e.maxWebGLVersion >= 2 && (i = t.getContext(\"webgl2\", r), s = 2), i || (i = t.getContext(\"webgl\", r), s = 1), !i) throw new Error(\"renderer-unavailable (could not get WebGL context)\");\n      this._gl = i, this._attribs = i.getContextAttributes(), this._versionString = i.getParameter(i.VERSION), this._version = s, this._viewport = vec4.create(), this._didChangeTransform = false, this._bbProjectionMatrix = mat4.create(), this._usesDepthBuffer = !!e.depth, this._canSampleDepth = !(!e.depth || !e.canSampleDepth), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._depthBuffer = null, this._isAutoSizeDepthBuffer = true, this._depthBufferWidth = 0, this._depthBufferHeight = 0, this._vertexBuffer = null, this._texcoordBuffer = null, this._indexBuffer = null, this._pointBuffer = null, this._vertexData = new Float32Array(8e3 * this.GetNumVertexComponents()), this._indexData = new Uint16Array(12e3), this._texcoordData = new Float32Array(16e3), this._pointData = new Float32Array(32e3), this._vertexPtr = 0, this._texPtr = 0, this._pointPtr = 0, this._lastVertexPtr = 0, this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._batch = [], this._batchPtr = 0, this._topOfBatch = 0, this._currentRenderTarget = null, this._lastPointZ = 0, this._batchState = C33.New(C33.Gfx.BatchState, this), this._lastColor = C33.New(C33.Color, 1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._lastSrcBlend = 0, this._lastDestBlend = 0, this._lastPointTexCoords = new C33.Rect(), this._lastScissorRect = C33.New(C33.Rect, 0, 0, -1, -1), this._coplanarMode = 0, this._maxTextureSize = -1, this._minPointSize = 0, this._maxPointSize = 0, this._unmaskedVendor = \"(unavailable)\", this._unmaskedRenderer = \"(unavailable)\", this._extensions = [], this._isInitialisingAfterContextRestored = false, this._parallelShaderCompileExt = null, this._anisotropicExt = null, this._conservativeDepthExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._isGpuProfilingEnabled = !!e.enableGpuProfiling, this._timerExt = null, this._allQueryResultBuffers = /* @__PURE__ */ new Set(), this._timeQueryStack = [], this.FillIndexBufferData(this._indexData);\n    }\n    IsWebGL() {\n      return true;\n    }\n    async InitState() {\n      super.InitState();\n      const t = this._gl, e = this.GetNumVertexComponents();\n      this._lastColor.setRgba(1, 1, 1, 1), this._lastTexture0 = null, this._lastTexture1 = null, this._vertexPtr = 0, this._pointPtr = 0, this._lastVertexPtr = 8e3 * e - 4 * e, C33.clearArray(this._batch), this._batchPtr = 0, this._topOfBatch = 0, this._lastProgram = null, this._currentRenderTarget = null, this._lastPointTexCoords.set(0, 0, 1, 1), this._lastPointZ = 0;\n      const r = this._batchState;\n      r.currentShader = null, r.currentFramebuffer = null, r.currentFramebufferNoDepth = null, vec4.set(r.currentColor, 1, 1, 1, 1), r.clearColor.setRgba(0, 0, 0, 0), r.pointTexCoords.set(0, 0, 1, 1), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.BLEND), t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), this._lastSrcBlend = t.ONE, this._lastDestBlend = t.ONE_MINUS_SRC_ALPHA, this._InitBlendModes(t), t.disable(t.CULL_FACE), t.disable(t.STENCIL_TEST), t.disable(t.DITHER), this._usesDepthBuffer ? (t.enable(t.DEPTH_TEST), t.depthMask(true), t.depthFunc(t.LEQUAL)) : (t.disable(t.DEPTH_TEST), t.depthMask(false)), this._isDepthEnabled = this._usesDepthBuffer, this._isDepthSamplingEnabled = false, this._pointBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferData(t.ARRAY_BUFFER, this._pointData.byteLength, t.DYNAMIC_DRAW), this._vertexBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this._vertexData.byteLength, t.DYNAMIC_DRAW), this._texcoordBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferData(t.ARRAY_BUFFER, this._texcoordData.byteLength, t.DYNAMIC_DRAW), this._indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indexData, t.STATIC_DRAW), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, null), this._maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE);\n      const i = t.getParameter(t.ALIASED_POINT_SIZE_RANGE);\n      this._minPointSize = i[0], this._maxPointSize = i[1], this._maxPointSize > 2048 && (this._maxPointSize = 2048), this._extensions = t.getSupportedExtensions();\n      const s = t.getExtension(\"WEBGL_debug_renderer_info\");\n      if (s && (this._unmaskedVendor = t.getParameter(s[\"UNMASKED_VENDOR_WEBGL\"]), this._unmaskedRenderer = t.getParameter(s[\"UNMASKED_RENDERER_WEBGL\"])), this._parallelShaderCompileExt = t.getExtension(\"KHR_parallel_shader_compile\"), this._version >= 2 && (\"Chromium\" !== C33.Platform.BrowserEngine || C33.Platform.BrowserVersionNumber >= 135) && (this._conservativeDepthExt = t.getExtension(\"EXT_conservative_depth\")), C33.isDebug && (loseContextExtension = t.getExtension(\"WEBGL_lose_context\")), this._isGpuProfilingEnabled && (1 === this.GetWebGLVersionNumber() ? this._timerExt = t.getExtension(\"EXT_disjoint_timer_query\") : this._timerExt = t.getExtension(\"EXT_disjoint_timer_query_webgl2\") || t.getExtension(\"EXT_disjoint_timer_query\")), this._anisotropicExt = t.getExtension(\"EXT_texture_filter_anisotropic\"), this._anisotropicExt ? this._maxAnisotropy = t.getParameter(this._anisotropicExt[\"MAX_TEXTURE_MAX_ANISOTROPY_EXT\"]) : this._maxAnisotropy = 0, this.GetWebGLVersionNumber() < 2 && this._usesDepthBuffer && this._canSampleDepth && (this._depthTextureExt = t.getExtension(\"WEBGL_depth_texture\"), !this._depthTextureExt)) throw new Error(\"no depth texture support\");\n      this.GetWebGLVersionNumber() < 2 && (this._fragDepthExt = t.getExtension(\"EXT_frag_depth\"), this._stdDerivativesExt = t.getExtension(\"OES_standard_derivatives\"), this._textureLodExt = t.getExtension(\"EXT_shader_texture_lod\"));\n      const a = C33.Gfx.WebGLShaderProgram, h = a.GetDefaultVertexShaderSource(false);\n      let n = a.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth(), o = h, l = a.GetPointFragmentShaderSource_WebGL1_NoFragDepth(), _ = a.GetPointVertexShaderSource_WebGL1(), u = a.GetTilemapFragmentShaderSource_WebGL1_NoFragDepth(), d = a.GetDefaultVertexShaderSource(true), c = false;\n      this._usesDepthBuffer && (this.GetWebGLVersionNumber() < 2 ? this._fragDepthExt && (n = a.GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT(), l = a.GetPointFragmentShaderSource_WebGL1_FragDepthEXT(), u = a.GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT(), c = true) : (o = a.GetDefaultVertexShaderSource_WebGL2(), n = a.GetTextureFillFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), l = a.GetPointFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), _ = a.GetPointVertexShaderSource_WebGL2(), u = a.GetTilemapFragmentShaderSource_WebGL2(this._SupportsConservativeDepth()), d = a.GetDefaultVertexShaderSource_WebGL2(true)));\n      const f = a.GetTileRandomizationFragmentShaderSource(this.GetWebGLVersionNumber(), c, this._stdDerivativesExt && this._textureLodExt, this._SupportsConservativeDepth()), p = this.GetWebGLVersionNumber() >= 2 ? a.GetDefaultVertexShaderSource_WebGL2() : h, x = [[n, o, \"<default>\"], [n, o, \"<default-device-transform>\"], [l, _, \"<point>\"], [a.GetColorFillFragmentShaderSource(), h, \"<fill>\"], [a.GetLinearGradientFillFragmentShaderSource(), h, \"<lineargradient>\"], [a.GetPenumbraFillFragmentShaderSource(), h, \"<penumbra>\"], [a.GetHardEllipseFillFragmentShaderSource(), h, \"<hardellipse>\"], [a.GetHardEllipseOutlineFragmentShaderSource(), h, \"<hardellipseoutline>\"], [a.GetSmoothEllipseFillFragmentShaderSource(), h, \"<smoothellipse>\"], [a.GetSmoothEllipseOutlineFragmentShaderSource(), h, \"<smoothellipseoutline>\"], [a.GetSmoothLineFillFragmentShaderSource(), h, \"<smoothline>\"], [u, d, \"<tilemap>\"], [f, p, \"<tilerandomization>\"]], E = await Promise.all(x.map((t2) => this.CreateShaderProgram({ src: t2[0], vertexSrc: t2[1], name: t2[2] })));\n      this._spTextureFill = E[0], this._spDeviceTransformTextureFill = E[1], this._spPoints = E[2], this._spColorFill = E[3], this._spLinearGradientFill = E[4], this._spPenumbraFill = E[5], this._spHardEllipseFill = E[6], this._spHardEllipseOutline = E[7], this._spSmoothEllipseFill = E[8], this._spSmoothEllipseOutline = E[9], this._spSmoothLineFill = E[10], this._spTilemapFill = E[11], this._spTileRandomization = E[12], this.SetTextureFillMode();\n    }\n    async CreateShaderProgram(t) {\n      const e = await C33.Gfx.WebGLShaderProgram.Create(this, t);\n      return this._AddShaderProgram(e), e;\n    }\n    ResetLastProgram() {\n      this._lastProgram = null;\n    }\n    SetSize(t, e, r) {\n      if (this._width === t && this._height === e && !r) return;\n      this.EndBatch();\n      const i = this._gl, s = this._batchState;\n      this._width = t, this._height = e, this._SetViewport(0, 0, t, e), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, t / e), this.SetProjectionMatrix(this._bbProjectionMatrix), this._spDeviceTransformTextureFill && (i.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), this._lastProgram = this._spDeviceTransformTextureFill, this._batchState.currentShader = this._spDeviceTransformTextureFill), i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE0), this._lastTexture0 = null, this._lastTexture1 = null, this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height), this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height), i.bindFramebuffer(i.FRAMEBUFFER, null), this._currentRenderTarget = null, s.currentFramebuffer = null, s.currentFramebufferNoDepth = null;\n    }\n    _SetDepthBufferSize(t, e) {\n      const r = this._gl;\n      this._depthBuffer && this._depthBufferWidth === t && this._depthBufferHeight === e || (this._canSampleDepth ? (this._depthBuffer && r.deleteTexture(this._depthBuffer), this._depthBuffer = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this._depthBuffer), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), this.GetWebGLVersionNumber() >= 2 ? r.texImage2D(r.TEXTURE_2D, 0, r.DEPTH24_STENCIL8, t, e, 0, r.DEPTH_STENCIL, r.UNSIGNED_INT_24_8, null) : this._depthTextureExt && r.texImage2D(r.TEXTURE_2D, 0, r.DEPTH_STENCIL, t, e, 0, r.DEPTH_STENCIL, this._depthTextureExt[\"UNSIGNED_INT_24_8_WEBGL\"], null), r.bindTexture(r.TEXTURE_2D, null)) : (this._depthBuffer && r.deleteRenderbuffer(this._depthBuffer), this._depthBuffer = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, this._depthBuffer), r.renderbufferStorage(r.RENDERBUFFER, this._version >= 2 ? r.DEPTH24_STENCIL8 : r.DEPTH_STENCIL, t, e), r.bindRenderbuffer(r.RENDERBUFFER, null)), this._depthBufferWidth = t, this._depthBufferHeight = e);\n    }\n    SetFixedSizeDepthBuffer(t, e) {\n      this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = false, this._SetDepthBufferSize(t, e));\n    }\n    SetAutoSizeDepthBuffer() {\n      this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = true, this._SetDepthBufferSize(this._width, this._height));\n    }\n    _SetViewport(t, e, r, i) {\n      const s = this._viewport;\n      if (s[0] === t && s[1] === e && s[2] === r && s[3] === i) return;\n      this.PushBatch().InitSetViewport(t, e, r, i), vec4.set(s, t, e, r, i), this._topOfBatch = 0;\n    }\n    SetFovY(t) {\n      super.SetFovY(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);\n    }\n    SetNearZ(t) {\n      super.SetNearZ(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);\n    }\n    SetFarZ(t) {\n      super.SetFarZ(t), this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height);\n    }\n    SetProjectionMatrix(t) {\n      if (mat4.exactEquals(this._matP, t)) return;\n      this.PushBatch().InitSetProjection(t), mat4.copy(this._matP, t), this._topOfBatch = 0, this._didChangeTransform = true;\n    }\n    SetDefaultRenderTargetProjectionState() {\n      let t, e, r;\n      const i = this._currentRenderTarget;\n      null === i ? (t = this._bbProjectionMatrix, e = this.GetWidth(), r = this.GetHeight()) : (t = i.GetProjectionMatrix(), e = i.GetWidth(), r = i.GetHeight()), this.SetProjectionMatrix(t), this._SetViewport(0, 0, e, r);\n    }\n    SetModelViewMatrix(t) {\n      if (mat4.exactEquals(this._matMV, t)) return;\n      this.PushBatch().InitSetModelView(t), mat4.copy(this._matMV, t), this._topOfBatch = 0, this._didChangeTransform = true;\n    }\n    ResetDidChangeTransformFlag() {\n      this._didChangeTransform = false;\n    }\n    DidChangeTransform() {\n      return this._didChangeTransform;\n    }\n    GetBatchState() {\n      return this._batchState;\n    }\n    PushBatch() {\n      const t = this._batch;\n      return this._batchPtr === t.length && t.push(new C33.Gfx.WebGLBatchJob(this._batchState)), t[this._batchPtr++];\n    }\n    EndBatch() {\n      0 !== this._batchPtr && (this.IsContextLost() || (this._WriteBuffers(), this._ExecuteBatch(), this._batchPtr = 0, this._vertexPtr = 0, this._texPtr = 0, this._pointPtr = 0, this._topOfBatch = 0));\n    }\n    _WriteBuffers() {\n      const t = this._gl;\n      this._pointPtr > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this._pointBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr))), this._vertexPtr > 0 && (t.bindBuffer(t.ARRAY_BUFFER, this._vertexBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)), t.bindBuffer(t.ARRAY_BUFFER, this._texcoordBuffer), t.bufferSubData(t.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)));\n    }\n    _ExecuteBatch() {\n      const t = this._batch;\n      for (let e = 0, r = this._batchPtr; e < r; ++e) t[e].Run();\n    }\n    GetOpacity() {\n      return this._lastColor.getA();\n    }\n    SetColorRgba(t, e, r, i) {\n      const s = this._lastColor;\n      if (s.equalsRgba(t, e, r, i)) return;\n      s.setRgba(t, e, r, i);\n      this.PushBatch().InitSetColor(s), this._topOfBatch = 0, this._currentStateGroup = null;\n    }\n    SetOpacity(t) {\n      const e = this._lastColor;\n      if (e.getA() === t) return;\n      e.setA(t);\n      this.PushBatch().InitSetColor(e), this._topOfBatch = 0, this._currentStateGroup = null;\n    }\n    SetColor(t) {\n      const e = this._lastColor;\n      if (e.equals(t)) return;\n      e.set(t);\n      this.PushBatch().InitSetColor(e), this._topOfBatch = 0, this._currentStateGroup = null;\n    }\n    ResetColor() {\n      this.SetColorRgba(1, 1, 1, 1);\n    }\n    GetColor() {\n      return this._lastColor;\n    }\n    SetTexture(t) {\n      if (t === this._lastTexture0) return;\n      this.PushBatch().InitSetTexture(t), this._lastTexture0 = t, this._topOfBatch = 0;\n    }\n    _ResetLastTexture() {\n      this._lastTexture0 = null;\n    }\n    SetBlendMode(t) {\n      const e = this._GetBlendByIndex(t);\n      this._SetBlend(e[0], e[1]);\n    }\n    SetNamedBlendMode(t) {\n      const e = this.GetNamedBlend(t);\n      this._SetBlend(e.srcBlend, e.destBlend);\n    }\n    _SetBlend(t, e) {\n      if (t === this._lastSrcBlend && e === this._lastDestBlend) return;\n      this.PushBatch().InitSetBlend(t, e), this._lastSrcBlend = t, this._lastDestBlend = e, this._topOfBatch = 0, this._currentStateGroup = null;\n    }\n    IsPremultipliedAlphaBlend() {\n      return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA;\n    }\n    SetAlphaBlend() {\n      this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);\n    }\n    SetNoPremultiplyAlphaBlend() {\n      this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);\n    }\n    SetCopyBlend() {\n      this._SetBlend(this._gl.ONE, this._gl.ZERO);\n    }\n    Rect(t) {\n      this.Rect2(t.getLeft(), t.getTop(), t.getRight(), t.getBottom());\n    }\n    Rect2(t, e, r, i) {\n      this.Quad2(t, e, r, e, r, i, t, i);\n    }\n    _ExtendQuadBatch() {\n      let t = this._vertexPtr;\n      if (t >= this._lastVertexPtr && (this.EndBatch(), t = 0), 1 === this._topOfBatch) this._batch[this._batchPtr - 1]._indexCount += 6;\n      else {\n        this.PushBatch().InitQuad(t, 6), this._topOfBatch = 1;\n      }\n    }\n    _WriteQuadToVertexBuffer(t) {\n      t.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ), this._vertexPtr += 12;\n    }\n    Quad(t) {\n      this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(t), defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    Quad2(t, e, r, i, s, a, h, n) {\n      this._ExtendQuadBatch();\n      const o = this._vertexData;\n      let l = this._vertexPtr;\n      const _ = this._baseZ + this._currentZ;\n      o[l++] = t, o[l++] = e, o[l++] = _, o[l++] = r, o[l++] = i, o[l++] = _, o[l++] = s, o[l++] = a, o[l++] = _, o[l++] = h, o[l++] = n, o[l++] = _, this._vertexPtr = l, defaultTexCoordsQuad.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    Quad3(t, e) {\n      this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(t), e.writeAsQuadToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    Quad4(t, e) {\n      this._ExtendQuadBatch(), this._WriteQuadToVertexBuffer(t), e.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    Quad3D(t, e, r, i, s, a, h, n, o, l, _, u, d) {\n      this._ExtendQuadBatch();\n      const c = this._vertexData;\n      let f = this._vertexPtr;\n      const p = this._baseZ + this._currentZ;\n      c[f++] = t, c[f++] = e, c[f++] = p + r, c[f++] = i, c[f++] = s, c[f++] = p + a, c[f++] = h, c[f++] = n, c[f++] = p + o, c[f++] = l, c[f++] = _, c[f++] = p + u, this._vertexPtr = f, d.writeAsQuadToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    Quad3D2(t, e, r, i, s, a, h, n, o, l, _, u, d) {\n      this._ExtendQuadBatch();\n      const c = this._vertexData;\n      let f = this._vertexPtr;\n      const p = this._baseZ + this._currentZ;\n      c[f++] = t, c[f++] = e, c[f++] = p + r, c[f++] = i, c[f++] = s, c[f++] = p + a, c[f++] = h, c[f++] = n, c[f++] = p + o, c[f++] = l, c[f++] = _, c[f++] = p + u, this._vertexPtr = f, d.writeToTypedArray(this._texcoordData, this._texPtr), this._texPtr += 8;\n    }\n    DrawMesh(t, e, r) {\n      const i = this._vertexData, s = this._texcoordData;\n      if (r.length % 3 != 0) throw new Error(\"invalid index buffer length\");\n      for (let a = 0, h = r.length; a < h; ) {\n        const h2 = r[a++], n = r[a++], o = r[a++], l = 3 * h2, _ = 3 * n, u = 3 * o, d = 2 * h2, c = 2 * n, f = 2 * o;\n        this._ExtendQuadBatch();\n        let p = this._vertexPtr, x = this._texPtr;\n        i[p++] = t[l + 0], i[p++] = t[l + 1], i[p++] = t[l + 2], i[p++] = t[_ + 0], i[p++] = t[_ + 1], i[p++] = t[_ + 2], i[p++] = t[u + 0], i[p++] = t[u + 1], i[p++] = t[u + 2], i[p++] = t[u + 0], i[p++] = t[u + 1], i[p++] = t[u + 2], s[x++] = e[d + 0], s[x++] = e[d + 1], s[x++] = e[c + 0], s[x++] = e[c + 1], s[x++] = e[f + 0], s[x++] = e[f + 1], s[x++] = e[f + 0], s[x++] = e[f + 1], this._vertexPtr = p, this._texPtr = x;\n      }\n    }\n    FullscreenQuad(t, e) {\n      this.SetCurrentZ(0), mat4.copy(tmpProjection, this._matP), mat4.copy(tmpModelView, this._matMV), this.SetDefaultRenderTargetProjectionState();\n      const [r, i] = this.GetRenderTargetSize(this._currentRenderTarget), s = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ(i), 0, 0, 0, i);\n      if (this.SetModelViewMatrix(s), \"crop\" === t && this._currentRenderTarget && e) {\n        const t2 = this._width / 2, r2 = this._height / 2, i2 = e.GetWidth(), s2 = e.GetHeight(), a = this._currentRenderTarget.GetWidth(), h = this._currentRenderTarget.GetHeight(), n = Math.min(a, i2), o = Math.min(h, s2), l = Math.max(s2 - h, 0), _ = Math.max(h - s2, 0);\n        tmpRect.set(-t2, r2 - _, -t2 + n, r2 - o - _), tmpQuad.setFromRect(tmpRect), tmpRect.set(0, l, n, o + l), tmpRect.divide(i2, s2), this.Quad3(tmpQuad, tmpRect);\n      } else {\n        const t2 = r / 2, e2 = i / 2;\n        this.Rect2(-t2, e2, t2, -e2);\n      }\n      this.SetProjectionMatrix(tmpProjection), this.SetModelViewMatrix(tmpModelView);\n    }\n    StartRenderingPoints(t) {\n      if (this._lastPointTexCoords.equals(t)) return;\n      this._lastPointTexCoords.copy(t);\n      this.PushBatch().InitSetPointTexCoords(t), this._topOfBatch = 0;\n    }\n    FinishRenderingPoints() {\n    }\n    Point(t, e, r, i) {\n      this._pointPtr >= 7996 && this.EndBatch();\n      let s = this._pointPtr;\n      const a = this._baseZ + this._currentZ;\n      if (2 === this._topOfBatch && this._lastPointZ === a) this._batch[this._batchPtr - 1]._indexCount++;\n      else {\n        this.PushBatch().InitPoints(s, a), this._topOfBatch = 2, this._lastPointZ = a;\n      }\n      const h = this._pointData;\n      h[s++] = t, h[s++] = e, h[s++] = r, h[s++] = i, this._pointPtr = s;\n    }\n    SetProgram(t) {\n      if (this._lastProgram === t) return;\n      this.PushBatch().InitSetProgram(t), this._lastProgram = t, this._topOfBatch = 0, this._currentStateGroup = null;\n    }\n    GetProgram() {\n      return this._lastProgram;\n    }\n    SetDeviceTransformTextureFillMode() {\n      this.SetProgram(this._spDeviceTransformTextureFill);\n    }\n    SetGradientColor(t) {\n      this.PushBatch().InitSetGradientColor(t), this._topOfBatch = 0;\n    }\n    SetEllipseParams(t, e, r = 1) {\n      this.PushBatch().InitSetEllipseParams(t, e, r), this._topOfBatch = 0;\n    }\n    SetTilemapInfo(t, e, r, i, s, a, h) {\n      if (this._lastProgram !== this._spTilemapFill) throw new Error(\"must set tilemap fill mode first\");\n      this.PushBatch().InitSetTilemapInfo(t, e, r, i, s, a, h), this._topOfBatch = 0;\n    }\n    SetTileRandomizationInfo(t, e, r, i, s, a, h) {\n      if (this._lastProgram !== this._spTileRandomization) throw new Error(\"must set tile randomization mode first\");\n      this.PushBatch().InitSetTileRandomizationInfo(t, e, r, i, s, a, h), this._topOfBatch = 0;\n    }\n    SetProgramParameters(t, e, r, i, s, a, h, n, o, l, _) {\n      const u = this._lastProgram;\n      if (_ %= 10800, !u._hasAnyOptionalUniforms || u.AreOptionalUniformsAlreadySetInBatch(e, r, i, s, a, h, n, o, l, _)) return;\n      const d = this.PushBatch();\n      d.InitSetProgramParameters(), u.SetOptionalUniformsInBatch(e, r, i, s, a, h, n, o, l, _);\n      const c = d._mat4param;\n      c[0] = a, c[1] = h, e.writeToTypedArray(c, 2), c[6] = o, c[7] = l, r.writeToTypedArray(c, 12);\n      const f = d._colorParam;\n      s.writeToTypedArray(f, 0);\n      const p = f[1];\n      f[1] = f[3], f[3] = p, i.writeToTypedArray(d._srcOriginRect, 0), d._startIndex = _, d._indexCount = n, u._uSamplerBack.IsUsed() ? d._texParam = t ? t.GetTexture() : null : d._texParam = null, this._topOfBatch = 0;\n    }\n    SetProgramCustomParameters(t) {\n      const e = this._lastProgram;\n      if (0 === t.length || e.AreCustomParametersAlreadySetInBatch(t)) return;\n      const r = this.PushBatch();\n      r.InitSetProgramCustomParameters(), e.SetCustomParametersInBatch(t), C33.shallowAssignArray(r._shaderParams, t), this._topOfBatch = 0;\n    }\n    ClearRgba(t, e, r, i) {\n      this.PushBatch().InitClearSurface2(t, e, r, i), this._topOfBatch = 0;\n    }\n    Clear(t) {\n      this.PushBatch().InitClearSurface(t), this._topOfBatch = 0;\n    }\n    Start() {\n    }\n    Finish() {\n      super.Finish(), this._gl.flush();\n    }\n    ClearDepth() {\n      if (!this._usesDepthBuffer || !this._currentRenderTarget || !this._currentRenderTarget.HasDepthBuffer()) return;\n      this.PushBatch().InitClearDepth(this._isDepthEnabled), this._topOfBatch = 0;\n    }\n    SetDepthEnabled(t) {\n      if (t = !!t, this._isDepthEnabled === t) return;\n      if (!this._usesDepthBuffer) return;\n      this._isDepthEnabled = t;\n      this.PushBatch().InitSetDepthEnabled(t), this._topOfBatch = 0;\n    }\n    IsDepthEnabled() {\n      return this._isDepthEnabled;\n    }\n    _GetDepthBuffer() {\n      return this._depthBuffer;\n    }\n    _CanSampleDepth() {\n      return this._canSampleDepth;\n    }\n    SetDepthSamplingEnabled(t) {\n      if (t = !!t, !this._canSampleDepth) return;\n      if (this._isDepthSamplingEnabled === t) return;\n      if (t && this.IsDepthEnabled()) throw new Error(\"depth still enabled\");\n      this._isDepthSamplingEnabled = t;\n      this.PushBatch().InitSetDepthSamplingEnabled(t), this._topOfBatch = 0;\n    }\n    SetScissorRect(t, e, r, i, s = 0) {\n      if (t = Math.floor(t), e = Math.floor(e), r = Math.floor(r), i = Math.floor(i), this._lastScissorRect.equalsWH(t, e, r, i)) return;\n      this._lastScissorRect.setWH(t, e, r, i);\n      e = (s || this.GetRenderTargetSize(this.GetRenderTarget())[1]) - e - i;\n      this.PushBatch().InitSetScissor(true, t, e, r, i), this._topOfBatch = 0;\n    }\n    RemoveScissorRect() {\n      if (-1 === this._lastScissorRect.getRight()) return;\n      this._lastScissorRect.set(0, 0, -1, -1);\n      this.PushBatch().InitSetScissor(false, 0, 0, 0, 0), this._topOfBatch = 0;\n    }\n    CheckForQueryResults() {\n      for (const t of this._allQueryResultBuffers) t.CheckForResults(this._frameNumber);\n    }\n    IsContextLost() {\n      return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored;\n    }\n    OnContextLost() {\n      super.OnDeviceOrContextLost(), C33.Gfx.WebGLRendererTexture.OnContextLost(), C33.Gfx.WebGLRenderTarget.OnContextLost(), C33.Gfx.RendererText.OnContextLost();\n      for (const t of this._allQueryResultBuffers) t.Clear();\n      this._extensions = [], this._timerExt = null, this._parallelShaderCompileExt = null, this._conservativeDepthExt = null, this._anisotropicExt = null, this._depthTextureExt = null, this._fragDepthExt = null, this._stdDerivativesExt = null, this._textureLodExt = null, this._maxAnisotropy = 0, this._unmaskedVendor = \"(unavailable)\", this._unmaskedRenderer = \"(unavailable)\", this._lastProgram = null, this._spDeviceTransformTextureFill = null, this._depthBuffer = null;\n      for (const t of this._stateGroups.values()) t.OnContextLost();\n    }\n    async OnContextRestored() {\n      this._isInitialisingAfterContextRestored = true, await this.InitState(), this._isInitialisingAfterContextRestored = false;\n      for (const t of this._stateGroups.values()) t.OnContextRestored(this);\n      this.SetSize(this._width, this._height, true);\n    }\n    CreateStaticTexture(t, e) {\n      if (this.IsContextLost()) throw new Error(\"context lost\");\n      this.EndBatch();\n      const r = C33.New(C33.Gfx.WebGLRendererTexture, this);\n      return r._CreateStatic(t, e), r;\n    }\n    async CreateStaticTextureAsync(t, e) {\n      if (this.IsContextLost()) throw new Error(\"context lost\");\n      if (e = Object.assign({}, e), C33.Supports.ImageBitmapOptions) {\n        let r = await createImageBitmap(t, { \"premultiplyAlpha\": \"premultiply\" });\n        const i = e.wrapX && \"clamp-to-edge\" !== e.wrapX || e.wrapY && \"clamp-to-edge\" !== e.wrapY, s = C33.isPOT(r.width) && C33.isPOT(r.height);\n        return this.SupportsNPOTTextures() || s || !i ? e.premultiplyAlpha = false : C33.Supports.ImageBitmapOptionsResize ? (r = await createImageBitmap(t, { \"premultiplyAlpha\": \"premultiply\", \"resizeWidth\": C33.nextHighestPowerOfTwo(r.width), \"resizeHeight\": C33.nextHighestPowerOfTwo(r.height) }), e.premultiplyAlpha = false) : r = await createImageBitmap(t, { \"premultiplyAlpha\": \"none\" }), await C33.Asyncify(() => this.CreateStaticTexture(r, e));\n      }\n      if (t instanceof Blob) {\n        if (\"undefined\" == typeof Image) throw new Error(\"texture upload variant not supported in worker\");\n        const e2 = await C33.BlobToImage(t);\n        t = e2;\n      }\n      return await C33.Asyncify(() => this.CreateStaticTexture(t, e));\n    }\n    CreateDynamicTexture(t, e, r) {\n      this.EndBatch();\n      const i = C33.New(C33.Gfx.WebGLRendererTexture, this);\n      return i._CreateDynamic(t, e, r), i;\n    }\n    UpdateTexture(t, e, r) {\n      this.EndBatch(), e._Update(t, r);\n    }\n    DeleteTexture(t) {\n      t && (t.SubtractReference(), t.GetReferenceCount() > 0 || (this.EndBatch(), t === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), t === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t._Delete()));\n    }\n    CreateRenderTarget(t) {\n      let e = this._width, r = this._height, i = true;\n      if (t && (\"number\" == typeof t.width && (e = Math.floor(t.width), i = false), \"number\" == typeof t.height && (r = Math.floor(t.height), i = false)), e <= 0 || r <= 0) throw new Error(\"invalid size\");\n      this.EndBatch();\n      const s = C33.New(C33.Gfx.WebGLRenderTarget, this);\n      return s._Create(e, r, Object.assign({ isDefaultSize: i }, t)), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, s;\n    }\n    SetRenderTarget(t, e = true) {\n      if (t === this._currentRenderTarget) return;\n      t && t.IsDefaultSize() && t._Resize(this._width, this._height);\n      this.PushBatch().InitSetRenderTarget(t), this._currentRenderTarget = t, this._topOfBatch = 0, e && this.SetDefaultRenderTargetProjectionState();\n    }\n    GetRenderTarget() {\n      return this._currentRenderTarget;\n    }\n    GetRenderTargetSize(t) {\n      return t ? [t.GetWidth(), t.GetHeight()] : [this._width, this._height];\n    }\n    CopyRenderTarget(t, e = \"stretch\") {\n      if (this._version < 2 || this._currentRenderTarget && this._currentRenderTarget.GetMultisampling() > 0) this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(t, e);\n      else {\n        this.PushBatch().InitBlitFramebuffer(t, this._currentRenderTarget, e), this._topOfBatch = 0;\n      }\n    }\n    DrawRenderTarget(t, e = \"stretch\") {\n      const r = t.GetTexture();\n      if (!r) throw new Error(\"not a texture-backed render target\");\n      this.SetTexture(r), this.FullscreenQuad(e, r);\n    }\n    InvalidateRenderTarget(t) {\n      if (this._version < 2) return;\n      this.PushBatch().InitInvalidateFramebuffer(t._GetFramebuffer()), this._topOfBatch = 0;\n    }\n    DeleteRenderTarget(t) {\n      this.SetRenderTarget(null), this.EndBatch();\n      const e = t.GetTexture();\n      e === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), e === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), t._Delete();\n    }\n    async ReadBackRenderTargetToImageData(t, e, r) {\n      this.EndBatch();\n      const i = this._currentRenderTarget;\n      let s, a, h;\n      t ? (s = t.GetWidth(), a = t.GetHeight(), h = t._GetFramebuffer()) : (s = this.GetWidth(), a = this.GetHeight(), h = null);\n      let n = 0, o = 0, l = s, _ = a;\n      if (r) {\n        n = C33.clamp(Math.floor(r.getLeft()), 0, s - 1), o = C33.clamp(Math.floor(r.getTop()), 0, a - 1);\n        let t2 = r.width();\n        t2 = 0 === t2 ? s - n : C33.clamp(Math.floor(t2), 0, s - n);\n        let e2 = r.height();\n        e2 = 0 === e2 ? a - o : C33.clamp(Math.floor(e2), 0, a - o), l = t2, _ = e2, o = a - (o + _);\n      }\n      const u = this._gl;\n      u.bindFramebuffer(u.FRAMEBUFFER, h);\n      const d = () => {\n        u.bindFramebuffer(u.FRAMEBUFFER, null), this._currentRenderTarget = null, this._batchState.currentFramebuffer = null, this._batchState.currentFramebufferNoDepth = null, this.SetRenderTarget(i);\n      };\n      let c;\n      if (!e && this.GetWebGLVersionNumber() >= 2) {\n        u.bindFramebuffer(u.READ_FRAMEBUFFER, h);\n        const t2 = u.createBuffer(), e2 = l * _ * 4, r2 = u[\"PIXEL_PACK_BUFFER\"];\n        u.bindBuffer(r2, t2), u.bufferData(r2, e2, u[\"STREAM_READ\"]), u.readPixels(n, o, l, _, u.RGBA, u.UNSIGNED_BYTE, 0), u.bindFramebuffer(u.READ_FRAMEBUFFER, null), u.bindBuffer(r2, null), d();\n        const i2 = u[\"fenceSync\"](u[\"SYNC_GPU_COMMANDS_COMPLETE\"], 0);\n        await this._WaitForObjectReady(() => u[\"getSyncParameter\"](i2, u[\"SYNC_STATUS\"]) === u[\"SIGNALED\"]), u[\"deleteSync\"](i2), c = new ImageData(l, _), u.bindBuffer(r2, t2), u[\"getBufferSubData\"](r2, 0, new Uint8Array(c.data.buffer), 0, e2), u.bindBuffer(r2, null), u.deleteBuffer(t2);\n      } else c = new ImageData(l, _), u.readPixels(n, o, l, _, u.RGBA, u.UNSIGNED_BYTE, new Uint8Array(c.data.buffer)), d();\n      return c;\n    }\n    CoplanarStartStencilPass() {\n      this.SetDepthEnabled(true);\n      this.PushBatch().InitCoplanarStartStencilPass(), this._topOfBatch = 0, this._coplanarMode = 1;\n    }\n    CoplanarStartColorPass() {\n      this.SetDepthEnabled(false);\n      this.PushBatch().InitCoplanarStartColorPass(), this._topOfBatch = 0, this._coplanarMode = 2;\n    }\n    IsCoplanarColorPass() {\n      return 2 === this._coplanarMode;\n    }\n    CoplanarRestoreStandardRendering() {\n      this.SetDepthEnabled(true);\n      this.PushBatch().InitCoplanarRestore(), this._topOfBatch = 0, this._coplanarMode = 0;\n    }\n    StartQuery(t) {\n      if (!this.SupportsGPUProfiling()) return;\n      this.PushBatch().InitStartQuery(t), this._topOfBatch = 0;\n    }\n    EndQuery(t) {\n      if (!this.SupportsGPUProfiling()) return;\n      this.PushBatch().InitEndQuery(t), this._topOfBatch = 0;\n    }\n    _WaitForObjectReady(t) {\n      const e = new Promise((e2) => pendingPolls.add({ resolve: e2, checkFunc: t }));\n      return -1 === pollRafId && (pollRafId = self.requestAnimationFrame(CheckPendingPolls)), e;\n    }\n    GetEstimatedBackBufferMemoryUsage() {\n      return this._width * this._height * (this._attribs[\"alpha\"] ? 4 : 3);\n    }\n    GetEstimatedRenderBufferMemoryUsage() {\n      let t = 0;\n      for (const e of C33.Gfx.WebGLRenderTarget.allRenderTargets()) e.GetTexture() || (t += e.GetEstimatedMemoryUsage());\n      return t;\n    }\n    GetEstimatedTextureMemoryUsage() {\n      let t = 0;\n      for (const e of C33.Gfx.WebGLRendererTexture.allTextures()) t += e.GetEstimatedMemoryUsage();\n      return t;\n    }\n    GetWebGLVersionString() {\n      return this._versionString;\n    }\n    GetWebGLVersionNumber() {\n      return this._version;\n    }\n    GetDisplayName() {\n      return \"webgl\" + this.GetWebGLVersionNumber();\n    }\n    SupportsNPOTTextures() {\n      return this.GetWebGLVersionNumber() >= 2;\n    }\n    GetMaxTextureSize() {\n      return this._maxTextureSize;\n    }\n    GetMinPointSize() {\n      return this._minPointSize;\n    }\n    GetMaxPointSize() {\n      return this._maxPointSize;\n    }\n    GetUnmaskedVendor() {\n      return this._unmaskedVendor;\n    }\n    GetUnmaskedRenderer() {\n      return this._unmaskedRenderer;\n    }\n    GetWebGLExtensionsAnalyticsString() {\n      if (this.GetWebGLVersionNumber() >= 2) return \"webgl2\";\n      {\n        const t = [];\n        return this._fragDepthExt && t.push(\"EXT_frag_depth\"), this._stdDerivativesExt && t.push(\"OES_standard_derivatives\"), this._textureLodExt && t.push(\"EXT_shader_texture_lod\"), t.length > 0 ? \"webgl1:\" + t.join(\",\") : \"webgl1:none\";\n      }\n    }\n    GetExtensions() {\n      return this._extensions;\n    }\n    SupportsGPUProfiling() {\n      return !!this._timerExt;\n    }\n    _GetDisjointTimerQueryExtension() {\n      return this._timerExt;\n    }\n    _GetParallelShaderCompileExtension() {\n      return this._parallelShaderCompileExt;\n    }\n    _SupportsConservativeDepth() {\n      return !!this._conservativeDepthExt;\n    }\n    _GetAnisotropicExtension() {\n      return this._anisotropicExt;\n    }\n    _GetMaxAnisotropy() {\n      return this._maxAnisotropy;\n    }\n    _AddQueryResultBuffer(t) {\n      this._allQueryResultBuffers.add(t);\n    }\n    _RemoveQueryResultBuffer(t) {\n      this._allQueryResultBuffers.delete(t);\n    }\n    _GetTimeQueryStack() {\n      return this._timeQueryStack;\n    }\n    GetContext() {\n      return this._gl;\n    }\n    _InitBlendModes(t) {\n      this._InitBlendModeData([[\"normal\", t.ONE, t.ONE_MINUS_SRC_ALPHA], [\"additive\", t.ONE, t.ONE], [\"xor\", t.ONE, t.ONE_MINUS_SRC_ALPHA], [\"copy\", t.ONE, t.ZERO], [\"destination-over\", t.ONE_MINUS_DST_ALPHA, t.ONE], [\"source-in\", t.DST_ALPHA, t.ZERO], [\"destination-in\", t.ZERO, t.SRC_ALPHA], [\"source-out\", t.ONE_MINUS_DST_ALPHA, t.ZERO], [\"destination-out\", t.ZERO, t.ONE_MINUS_SRC_ALPHA], [\"source-atop\", t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], [\"destination-atop\", t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA]]);\n    }\n    CreateWebGLText() {\n      return this.CreateRendererText();\n    }\n  };\n}\nvar CheckPendingPolls2;\n{\n  const C33 = self.C3, DEFAULT_CTOR_OPTS = { getDrawSize: null, getRenderTarget: null, releaseRenderTarget: null, getTime: null, redraw: null };\n  C33.Gfx.EffectChainManager = class {\n    constructor(e) {\n      e = Object.assign({}, DEFAULT_CTOR_OPTS, e), this._cbGetDrawSize = e.getDrawSize, this._cbGetRenderTarget = e.getRenderTarget, this._cbReleaseRenderTarget = e.releaseRenderTarget, this._cbGetTime = e.getTime, this._cbRedraw = e.redraw, this._webgpuBackTexture = null, this._allEffectChains = /* @__PURE__ */ new Set();\n    }\n    _AddEffectChain(e) {\n      this._allEffectChains.add(e);\n    }\n    _RemoveEffectChain(e) {\n      this._allEffectChains.delete(e);\n    }\n    OnContextLost() {\n      this._webgpuBackTexture = null;\n      for (const e of this._allEffectChains) e.OnContextLost();\n    }\n    GetDrawSize(e) {\n      return this._cbGetDrawSize ? this._cbGetDrawSize(e) : [e.GetWidth(), e.GetHeight()];\n    }\n    GetRenderTarget(e) {\n      return this._cbGetRenderTarget(e);\n    }\n    ReleaseRenderTarget(e, t) {\n      this._cbReleaseRenderTarget(e, t);\n    }\n    GetTime() {\n      return this._cbGetTime();\n    }\n    Redraw(e) {\n      this._cbRedraw(e);\n    }\n    _GetWebGPUBackTexture(e, t, r) {\n      return t = Math.floor(t), r = Math.floor(r), !this._webgpuBackTexture || this._webgpuBackTexture.GetWidth() === t && this._webgpuBackTexture.GetHeight() === r || (e.DeleteTexture(this._webgpuBackTexture), this._webgpuBackTexture = null), null === this._webgpuBackTexture && (this._webgpuBackTexture = e.CreateStaticTexture(null, { width: t, height: r, sampling: \"nearest\", mipMap: false })), this._webgpuBackTexture;\n    }\n  };\n}\n{\n  const C33 = self.C3, assert = self.assert, glMatrix = self.glMatrix, mat4 = glMatrix.mat4, tempRect = C33.New(C33.Rect), tempRect2 = C33.New(C33.Rect), tempRect3 = C33.New(C33.Rect), tempRect4 = C33.New(C33.Rect), tempMat4a = mat4.create(), tempMat4b = mat4.create(), DEFAULT_CTOR_OPTS = { drawContent: null, getSourceTextureInfo: null, getShaderParameters: null, invalidateRenderTargets: false }, DEFAULT_BUILDSTEPS_OPTS = { indexMap: null, forcePreDraw: false, forcePostDraw: false, is3D: false, isSourceTextureRotated: false, isRotatedOrNegativeSizeInstance: false, useFullSurface: false };\n  C33.Gfx.EffectChain = class {\n    constructor(e, t) {\n      t = Object.assign({}, DEFAULT_CTOR_OPTS, t), this._manager = e, this._cbDrawContent = t.drawContent, this._cbGetSourceTextureInfo = t.getSourceTextureInfo, this._cbGetShaderParameters = t.getShaderParameters, this._cbDrawContentHook = null, this._shaderProgramList = [], this._shaderProgramIndices = [], this._steps = [], this._needsRebuild = false, this._blendMode = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._didChangeTransform = false, this._depthEnabledAtStart = false, this._coplanarColorPassAtStart = false, this._canUseFastPath = false, this._useFullSurface = false, this._isSourceTextureRotated = false, this._numTempSurfacesRequired = 0, this._renderTargets = [null, null, null], this._invalidateRenderTargets = !!t.invalidateRenderTargets, this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._drawWidth = 0, this._drawHeight = 0, this._contentObject = null, this._contextObject = null, this._layoutRect = C33.New(C33.Rect), this._drawSurfaceRect = C33.New(C33.Rect), this._rcTexOriginal = C33.New(C33.Rect), this._rcTexBounce = C33.New(C33.Rect), this._rcTexDest = C33.New(C33.Rect), this._devicePixelRatio = 1, this._layerScale = 1, this._layerAngle = 0, this._time = 0, this._destRenderTarget = null, this._backTex = null, this._compositOffX = 0, this._compositOffY = 0, this._compositRtWidth = 0, this._compositRtHeight = 0, this._updateOwnProjection = false, this._projectionMatrix = mat4.create(), this._modelViewMatrix = mat4.create(), this._manager._AddEffectChain(this);\n    }\n    Release() {\n      this._manager._RemoveEffectChain(this), C33.clearArray(this._steps), C33.clearArray(this._shaderProgramList), C33.clearArray(this._shaderProgramIndices), this._contentObject = null, this._contextObject = null, this._cbDrawContent = null, this._cbGetSourceTextureInfo = null, this._cbGetShaderParameters = null;\n    }\n    OnContextLost() {\n      this._needsRebuild = true, C33.clearArray(this._steps), C33.clearArray(this._shaderProgramList), C33.clearArray(this._shaderProgramIndices);\n    }\n    NeedsRebuild() {\n      return this._needsRebuild;\n    }\n    BuildSteps(e, t) {\n      if (t = Object.assign({}, DEFAULT_BUILDSTEPS_OPTS, t), C33.clearArray(this._steps), this._boxExtendHorizontal = 0, this._boxExtendVertical = 0, this._isAnyShaderAnimated = false, this._isAnyShaderDepthSampling = false, this._isAnyShaderBackgroundBlending = false, this._isAnyShaderCrossSampling = false, this._isAnyIsSrcTexRotated = false, this._useCopyTextureBackgroundSampling = false, this._numTempSurfacesRequired = 0, this._isSourceTextureRotated = !!t.isSourceTextureRotated, this._useFullSurface = !!t.useFullSurface, this._needsRebuild = false, C33.shallowAssignArray(this._shaderProgramList, e), 0 === e.length) return;\n      if (t.indexMap) {\n        if (t.indexMap.length !== e.length) throw new Error(\"incorrect indexMap length\");\n        C33.shallowAssignArray(this._shaderProgramIndices, t.indexMap);\n      } else {\n        C33.clearArray(this._shaderProgramIndices);\n        for (let t2 = 0, r2 = e.length; t2 < r2; ++t2) this._shaderProgramIndices.push(t2);\n      }\n      for (const t2 of e) this._boxExtendHorizontal += t2.GetBoxExtendHorizontal(), this._boxExtendVertical += t2.GetBoxExtendVertical(), t2.IsAnimated() && (this._isAnyShaderAnimated = true), t2.UsesDepth() && (this._isAnyShaderDepthSampling = true), t2.BlendsBackground() && (this._isAnyShaderBackgroundBlending = true), t2.UsesCrossSampling() && (this._isAnyShaderCrossSampling = true), t2.UsesIsSrcTexRotated() && (this._isAnyIsSrcTexRotated = true);\n      this._useCopyTextureBackgroundSampling = this._ShouldUseCopyTextureBackgroundSampling(e[0].GetRenderer());\n      const r = this._ShouldPreDraw(e[0], t), s = this._ShouldPostDraw(e.at(-1), t);\n      if (1 === e.length && !r && !s) return void (this._canUseFastPath = true);\n      this._canUseFastPath = false;\n      let i = 0;\n      r && (this._numTempSurfacesRequired = 1, this._steps.push(C33.New(C33.Gfx.EffectChain.Step.PreDraw, this, -1, 1)), i = 1);\n      for (let t2 = 0, a = e.length; t2 < a; ++t2) if (0 !== t2 || r) {\n        let e2 = 1 === i ? 2 : 1;\n        t2 !== a - 1 || s || (e2 = 0), this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, e2), this._steps.push(C33.New(C33.Gfx.EffectChain.Step.Bounce, this, i, e2, t2)), i = e2;\n      } else this._numTempSurfacesRequired = 1, this._steps.push(C33.New(C33.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, t2)), i = 1;\n      s && this._steps.push(C33.New(C33.Gfx.EffectChain.Step.PostDraw, this, i, 0));\n    }\n    _ShouldPreDraw(e, t) {\n      return !!(t.forcePreDraw || e.MustPreDraw() || t.is3D && !e.Supports3DDirectRendering() || e.UsesDepth() && !this._useFullSurface || 0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical) || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() && (t.isRotatedOrNegativeSizeInstance || t.isSourceTextureRotated) || e.UsesAnySrcRectOrPixelSize() && t.isSourceTextureRotated : e.BlendsBackground() && !this._useCopyTextureBackgroundSampling && t.isRotatedOrNegativeSizeInstance);\n    }\n    _ShouldPostDraw(e, t) {\n      return !!t.forcePostDraw || (e.GetRenderer().IsWebGL() ? e.BlendsBackground() || e.UsesCrossSampling() : (e.BlendsBackground() || e.UsesCrossSampling()) && this._UseRenderTargetBackgroundSampling());\n    }\n    _ShouldUseCopyTextureBackgroundSampling(e) {\n      return e.IsWebGPU() && this._isAnyShaderBackgroundBlending && !this._isAnyShaderCrossSampling;\n    }\n    Render(e, t, r) {\n      e.IsWebGPU() && null === t && (t = e.GetBackbufferRenderTarget()), this._destRenderTarget = t, this._contentObject = r.contentObject || null, this._contextObject = r.contextObject || null, this._blendMode = r.blendMode || 0, this._devicePixelRatio = r.devicePixelRatio || 1, this._layerScale = r.layerScale || 1, this._layerAngle = r.layerAngle || 0, this._time = \"number\" == typeof r.time ? r.time : this._manager.GetTime(), this._didChangeTransform = false, e.ResetDidChangeTransformFlag(), this._isAnyShaderAnimated && this._Redraw();\n      let s = false;\n      if (this._UseCopyTextureBackgroundSampling() && (this._CalculateDrawSizeAndRectangles(e, r), s = true, this._backTex = this._manager._GetWebGPUBackTexture(e, this._drawWidth, this._drawHeight), tempRect.copy(this._drawSurfaceRect), tempRect.roundOuter(), e.IsWebGPU() && e._MaybeDoPendingClearRenderPass(this._destRenderTarget), e.CopyTextureToTexture(this._destRenderTarget.GetTexture(), this._backTex, tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height())), this._canUseFastPath) this._Render_FastPath(e, r);\n      else if (s || this._CalculateDrawSizeAndRectangles(e, r), 0 !== this._rcTexOriginal.width() || 0 !== this._rcTexOriginal.height()) {\n        e.SetAlphaBlend(), e.ResetColor(), e.SetBaseZ(0), e.SetCurrentZ(0), this._cbDrawContentHook = r.drawContentHook || null, this._compositOffX = r.compositOffX || 0, this._compositOffY = r.compositOffY || 0, this._compositRtWidth = r.compositRtWidth || 0, this._compositRtHeight = r.compositRtHeight || 0, this._updateOwnProjection = !!r.updateOwnProjection, this._OnBeforeStartEffectChain(e), this._renderTargets[0] = t, this._renderTargets[1] = this._numTempSurfacesRequired >= 1 ? this._GetRenderTarget() : null, this._renderTargets[2] = 2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;\n        for (const t2 of this._steps) {\n          const r2 = this._GetRenderTargetForId(t2.GetSrcTargetId()), s2 = this._GetRenderTargetForId(t2.GetDestTargetId());\n          e.IsWebGPU() ? t2.Run_WebGPU(e, r2, s2) : t2.Run_WebGL(e, r2, s2);\n        }\n        e.SetTexture(null), this._renderTargets[1] && this._ReleaseRenderTarget(this._renderTargets[1]), this._renderTargets[2] && this._ReleaseRenderTarget(this._renderTargets[2]), this._renderTargets.fill(null), this._OnAfterEndEffectChain(e), this._destRenderTarget = null, this._backTex = null, this._contentObject = null, this._contextObject = null, this._cbDrawContentHook = null;\n      }\n    }\n    _CalculateDrawSizeAndRectangles(e, t) {\n      const [r, s] = this._manager.GetDrawSize(e);\n      this._SetDrawSize(e, r, s), this._CalculateRectangles(t);\n    }\n    _SetDrawSize(e, t, r) {\n      if (t <= 0 || r <= 0) throw new Error(\"invalid draw size\");\n      this._drawWidth === t && this._drawHeight === r || this._CalculateDeviceTransformMatrices(e, t, r, 0, 0, this._projectionMatrix, this._modelViewMatrix), this._drawWidth = t, this._drawHeight = r;\n    }\n    _CalculateDeviceTransformMatrices(e, t, r, s, i, a, n) {\n      const h = t / 2 + s, c = r / 2 + i;\n      e.CalculatePerspectiveMatrix(a, t / r);\n      const o = e.CalculateLookAtModelView2(h, c, e.GetDefaultCameraZ(r), h, c, 0, r);\n      mat4.copy(n, o);\n    }\n    _CalculateRectangles(e) {\n      this._layoutRect.copy(e.layoutRect), e.drawSurfaceRect ? this._drawSurfaceRect.copy(e.drawSurfaceRect) : this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight), this._rcTexOriginal.copy(this._drawSurfaceRect), this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);\n      const t = this._layerScale * this._devicePixelRatio;\n      this._drawSurfaceRect.inflate(this._boxExtendHorizontal * t, this._boxExtendVertical * t), this._rcTexDest.copy(this._drawSurfaceRect), this._rcTexDest.divide(this._drawWidth, this._drawHeight), this._drawSurfaceRect.clampBoth(0, 0, this._drawWidth, this._drawHeight), this._rcTexBounce.copy(this._drawSurfaceRect), this._rcTexBounce.divide(this._drawWidth, this._drawHeight);\n    }\n    _OnBeforeStartEffectChain(e) {\n      if (this._depthEnabledAtStart = e.IsDepthEnabled(), this._coplanarColorPassAtStart = e.IsCoplanarColorPass(), this._useFullSurface) e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true);\n      else {\n        if (tempRect.copy(this._drawSurfaceRect), e.IsWebGL()) {\n          const e2 = this._layerScale * this._devicePixelRatio;\n          tempRect.inflate(Math.max(this._boxExtendHorizontal, 1) * e2, Math.max(this._boxExtendVertical, 1) * e2), tempRect.roundOuter(), tempRect.clamp(0, 0, this._drawWidth, this._drawHeight);\n        } else tempRect.roundOuter();\n        e.SetScissorRect(tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height(), this._drawHeight);\n      }\n    }\n    _OnAfterEffectChainDrawContent(e) {\n      e.ResetColor(), this._useFullSurface || (this._coplanarColorPassAtStart && e.CoplanarRestoreStandardRendering(), e.SetDepthEnabled(false), this._isAnyShaderDepthSampling && e.SetDepthSamplingEnabled(true)), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(true);\n    }\n    _OnAfterEndEffectChain(e) {\n      e.SetDepthSamplingEnabled(false), this._coplanarColorPassAtStart && e.CoplanarStartColorPass(), e.SetDepthEnabled(this._depthEnabledAtStart), this._useFullSurface || e.RemoveScissorRect(), e.IsWebGPU() && e.SetNormalizedCoordsProgramVariant(false), this._didChangeTransform = e.DidChangeTransform();\n    }\n    _ClampRcTexDest() {\n      this._rcTexDest.clamp(0, 0, 1, 1);\n    }\n    _GetRenderTargetForId(e) {\n      return e < 0 ? null : this._renderTargets[e];\n    }\n    _GetRenderTarget() {\n      return this._manager.GetRenderTarget(this);\n    }\n    _GetDestRenderTarget() {\n      return this._destRenderTarget;\n    }\n    _ReleaseRenderTarget(e) {\n      this._manager.ReleaseRenderTarget(e, this);\n    }\n    _GetShaderProgramAt(e) {\n      return this._shaderProgramList[e];\n    }\n    _DrawContent(e) {\n      this._cbDrawContentHook ? this._cbDrawContentHook(this, e, () => this._cbDrawContent(e, this)) : this._cbDrawContent(e, this), this._canUseFastPath || this._OnAfterEffectChainDrawContent(e);\n    }\n    _IsRenderTargetSameSizeAndOffset(e) {\n      if (this._useFullSurface) return true;\n      if (0 !== this._compositOffX || 0 !== this._compositOffY || 0 !== this._compositRtWidth || 0 !== this._compositRtHeight) return false;\n      const [t, r] = e.GetRenderTargetSize(e.GetRenderTarget());\n      return t === this._drawWidth && r === this._drawHeight;\n    }\n    _SetDeviceTransform(e, t) {\n      let r = this._projectionMatrix, s = this._modelViewMatrix;\n      if (t && !this._IsRenderTargetSameSizeAndOffset(e)) {\n        let t2, i;\n        r = tempMat4a, s = tempMat4b, 0 !== this._compositRtWidth && 0 !== this._compositRtHeight ? [t2, i] = [this._compositRtWidth, this._compositRtHeight] : [t2, i] = e.GetRenderTargetSize(e.GetRenderTarget()), this._CalculateDeviceTransformMatrices(e, t2, i, this._compositOffX, this._compositOffY, r, s), this._useFullSurface || e.RemoveScissorRect();\n      }\n      e.SetProjectionMatrix(r), e.SetModelViewMatrix(s);\n    }\n    _Redraw() {\n      this._manager.Redraw(this);\n    }\n    _GetShaderParameters(e, t) {\n      return this._cbGetShaderParameters(this._shaderProgramIndices[e], t);\n    }\n    _SetProgramParameters(e, t) {\n      let r = this._rcTexDest, s = this._rcTexBounce, i = this._rcTexOriginal;\n      e.IsWebGL() && (tempRect2.copy(r), tempRect2.flipAround(1), r = tempRect2, tempRect3.copy(s), tempRect3.flipAround(1), s = tempRect3, tempRect4.copy(i), tempRect4.flipAround(1), i = tempRect4), this._DoSetProgramParameters(e, t, s, i, r, 1 / this._drawWidth, 1 / this._drawHeight);\n    }\n    _SetFirstBounceProgramParameters(e, t) {\n      let r = this._rcTexBounce, s = this._rcTexOriginal, i = 1 / this._drawWidth, a = 1 / this._drawHeight;\n      if (this._cbGetSourceTextureInfo) {\n        let { srcTexRect: e2, srcWidth: t2, srcHeight: n2 } = this._cbGetSourceTextureInfo(this._contentObject);\n        e2 || (tempRect.set(0, 0, 0, 0), e2 = tempRect), t2 || (t2 = this._drawWidth), n2 || (n2 = this._drawHeight), r = e2, s = e2, i = 1 / t2, a = 1 / n2;\n      } else e.IsWebGL() && (tempRect3.copy(r), tempRect3.flipAround(1), r = tempRect3, tempRect4.copy(s), tempRect4.flipAround(1), s = tempRect4);\n      let n = this._rcTexDest;\n      e.IsWebGL() && (n = tempRect2, n.copy(this._rcTexDest), n.flipAround(1)), this._DoSetProgramParameters(e, t, r, s, n, i, a), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);\n    }\n    _GetBackTex(e) {\n      return this._isAnyShaderBackgroundBlending ? e.IsWebGPU() ? this._UseCopyTextureBackgroundSampling() ? this._backTex : this._destRenderTarget.GetTexture() : this._destRenderTarget : null;\n    }\n    _DoSetProgramParameters(e, t, r, s, i, a, n) {\n      e.SetProgramParameters(this._GetBackTex(e), i, r, s, this._layoutRect, a, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(t, e));\n    }\n    _Render_FastPath(e, t) {\n      const r = this._shaderProgramList[0], s = e.IsDepthEnabled(), i = r.UsesDepth();\n      i && (e.SetDepthEnabled(false), e.SetDepthSamplingEnabled(true), this._rcTexDest.set(0, 0, 1, 1), this._rcTexOriginal.set(0, 0, 1, 1)), e.SetProgram(r), e.SetBlendMode(this._blendMode), e.SetRenderTarget(this._destRenderTarget);\n      let a = 0, n = 1;\n      if (this._rcTexOriginal.set(0, 0, 1, 1), r.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {\n        const { srcTexRect: e2, srcWidth: t2, srcHeight: r2 } = this._cbGetSourceTextureInfo(this._contentObject);\n        e2 && this._rcTexOriginal.copy(e2), a = Number.isFinite(t2) ? 1 / t2 : 0, n = Number.isFinite(r2) ? 1 / r2 : 0;\n      } else {\n        const [t2, r2] = this._manager.GetDrawSize(e);\n        a = 1 / t2, n = 1 / r2;\n      }\n      t.layoutRect ? this._layoutRect.copy(t.layoutRect) : this._layoutRect.set(0, 0, 0, 0), e.SetProgramParameters(this._GetBackTex(e), this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, a, n, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time), e.SetProgramCustomParameters(this._GetShaderParameters(0, e)), e.IsWebGPU() && this._isAnyIsSrcTexRotated && e.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated), e.SetBaseZ(0), this._DrawContent(e), i && (e.SetDepthSamplingEnabled(false), e.SetDepthEnabled(s));\n    }\n    _UseCopyTextureBackgroundSampling() {\n      return this._useCopyTextureBackgroundSampling;\n    }\n    _UseRenderTargetBackgroundSampling() {\n      return !this._useCopyTextureBackgroundSampling;\n    }\n    IsAnyShaderBackgroundBlending() {\n      return this._isAnyShaderBackgroundBlending;\n    }\n    CanSkipCalculatingDrawSurfaceRect() {\n      return !!this._canUseFastPath && !this._UseCopyTextureBackgroundSampling();\n    }\n    UseFullSurface() {\n      return this._useFullSurface;\n    }\n    GetContentObject() {\n      return this._contentObject;\n    }\n    GetContextObject() {\n      return this._contextObject;\n    }\n    _GetBlendMode() {\n      return this._blendMode;\n    }\n    _UpdateOwnProjection() {\n      return this._updateOwnProjection;\n    }\n    DidChangeTransform() {\n      return this._didChangeTransform;\n    }\n    _GetDrawSurfaceRect() {\n      return this._drawSurfaceRect;\n    }\n    _GetRcTexBounce() {\n      return this._rcTexBounce;\n    }\n    _ShouldInvalidateRenderTargets() {\n      return this._invalidateRenderTargets;\n    }\n    async DebugLogRenderTargetContents(e, t, r) {\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Gfx.EffectChain.Step = class {\n    constructor(t, e, r, s = -1) {\n      this._effectChain = t, this._srcTargetId = e, this._destTargetId = r, this._index = s;\n    }\n    GetEffectChain() {\n      return this._effectChain;\n    }\n    GetSrcTargetId() {\n      return this._srcTargetId;\n    }\n    GetDestTargetId() {\n      return this._destTargetId;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetShaderProgram() {\n      return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex());\n    }\n    Run_WebGL(t, e, r) {\n    }\n    Run_WebGPU(t, e, r) {\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Gfx.EffectChain.Step.PreDraw = class extends C33.Gfx.EffectChain.Step {\n    constructor(e, t, n, a) {\n      super(e, t, n, a);\n    }\n    Run_WebGL(e, t, n) {\n      const a = this.GetEffectChain();\n      e.SetAlphaBlend(), e.SetTextureFillMode(), e.SetRenderTarget(n, a._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), a._DrawContent(e), a._ClampRcTexDest();\n    }\n    Run_WebGPU(e, t, n) {\n      const a = this.GetEffectChain();\n      e.SetAlphaBlend(), e.SetTextureFillMode(), e.SetRenderTarget(n, false), e.ClearRgba(0, 0, 0, 0), a._DrawContent(e), a._ClampRcTexDest();\n    }\n  };\n}\n{\n  const C33 = self.C3, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad);\n  C33.Gfx.EffectChain.Step.PostDraw = class extends C33.Gfx.EffectChain.Step {\n    constructor(e, t, r, a) {\n      super(e, t, r, a);\n    }\n    Run_WebGL(e, t, r) {\n      const a = this.GetEffectChain();\n      e.SetTextureFillMode(), e.SetRenderTarget(r), a._SetDeviceTransform(e, true), e.SetBlendMode(a._GetBlendMode()), e.SetTexture(t.GetTexture()), tempQuad.setFromRect(a._GetDrawSurfaceRect()), tempRect.copy(a._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t);\n    }\n    Run_WebGPU(e, t, r) {\n      const a = this.GetEffectChain();\n      e.SetTextureFillMode(), e.SetRenderTarget(r, false), a._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a._SetDeviceTransform(e, true), tempQuad.setFromRect(a._GetDrawSurfaceRect())), e.SetBackTexture(null), e.SetBlendMode(a._GetBlendMode()), e.SetTexture(t.GetTexture()), a.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a._GetRcTexBounce());\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Gfx.EffectChain.Step.FirstBounce = class extends C33.Gfx.EffectChain.Step {\n    constructor(e, t, r, a) {\n      super(e, t, r, a);\n    }\n    Run_WebGL(e, t, r) {\n      const a = this.GetEffectChain();\n      e.SetRenderTarget(r, a._UpdateOwnProjection()), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a._SetFirstBounceProgramParameters(e, this.GetIndex()), a._DrawContent(e), a._ClampRcTexDest();\n    }\n    Run_WebGPU(e, t, r) {\n      const a = this.GetEffectChain();\n      e.SetRenderTarget(r, false), e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), e.SetProgram(this.GetShaderProgram()), a._SetFirstBounceProgramParameters(e, this.GetIndex()), a._DrawContent(e), a._ClampRcTexDest();\n    }\n  };\n}\n{\n  const C33 = self.C3, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad);\n  C33.Gfx.EffectChain.Step.Bounce = class extends C33.Gfx.EffectChain.Step {\n    constructor(e, t, r, a) {\n      super(e, t, r, a);\n    }\n    Run_WebGL(e, t, r) {\n      const a = this.GetEffectChain();\n      e.SetRenderTarget(r);\n      const d = 0 === this.GetDestTargetId();\n      d ? e.SetBlendMode(a._GetBlendMode()) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend()), e.SetProgram(this.GetShaderProgram()), a._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t.GetTexture()), a._SetDeviceTransform(e, d), tempQuad.setFromRect(a._GetDrawSurfaceRect()), tempRect.copy(a._GetRcTexBounce()), tempRect.flipAround(1), e.Quad3(tempQuad, tempRect), a._ShouldInvalidateRenderTargets() && e.InvalidateRenderTarget(t);\n    }\n    Run_WebGPU(e, t, r) {\n      const a = this.GetEffectChain();\n      e.SetRenderTarget(r, false);\n      0 === this.GetDestTargetId() ? (e.SetBlendMode(a._GetBlendMode()), e.SetBackTexture(null), a._IsRenderTargetSameSizeAndOffset(e) ? tempQuad.setFromRect(a._GetRcTexBounce()) : (e.SetNormalizedCoordsProgramVariant(false), a._SetDeviceTransform(e, true), tempQuad.setFromRect(a._GetDrawSurfaceRect()))) : (e.ClearRgba(0, 0, 0, 0), e.SetCopyBlend(), tempQuad.setFromRect(a._GetRcTexBounce())), e.SetProgram(this.GetShaderProgram()), a._SetProgramParameters(e, this.GetIndex()), e.SetTexture(t.GetTexture()), a.UseFullSurface() ? e.FullscreenQuad() : e.Quad3(tempQuad, a._GetRcTexBounce());\n    }\n  };\n}\n{\n  let SortZOrderList = function(e, t) {\n    const r = e[0] - t[0];\n    if (0 !== r) return r;\n    return e[1] - t[1];\n  };\n  SortZOrderList2 = SortZOrderList;\n  const C33 = self.C3, C3X = self.C3X;\n  let runtime = null;\n  const keysDownByKey = /* @__PURE__ */ new Set();\n  const tempZOrderList = [], tempInstances = [];\n  let didWarnInAlertPolyfill = false, didWarnFpsDeprecated = false, didWarnCreateWorkerDeprecated = false;\n  const VALID_FRAMERATE_MODES = /* @__PURE__ */ new Set([\"vsync\", \"unlimited-tick\", \"unlimited-frame\"]);\n  self.IRuntime = class {\n    constructor(e) {\n      runtime = e, Object.defineProperties(this, { assets: { value: runtime.GetAssetManager().GetIAssetManager(), writable: false }, collisions: { value: runtime.GetCollisionEngine().GetICollisionEngine(), writable: false }, objects: { value: {}, writable: false }, globalVars: { value: {}, writable: false }, projectName: { value: runtime.GetProjectName(), writable: false }, projectVersion: { value: runtime.GetProjectVersion(), writable: false }, projectId: { value: runtime.GetAppId(), writable: false }, projectUniqueId: { value: runtime.GetProjectUniqueId(), writable: false }, exportDate: { value: new Date(runtime.GetExportTimestamp()), writable: false }, storage: { value: new self.IStorage(runtime), writable: false }, isInWorker: { value: runtime.IsInWorker(), writable: false }, viewportWidth: { value: runtime.GetOriginalViewportWidth(), writable: false }, viewportHeight: { value: runtime.GetOriginalViewportHeight(), writable: false }, sampling: { value: runtime.GetSampling(), writable: false }, isPixelRoundingEnabled: { value: runtime.IsPixelRoundingEnabled(), writable: false }, platformInfo: { value: new self.IPlatformInfo(e), writable: false }, sdk: { value: new self.ISDKUtils(e), writable: false } }), runtime.UserScriptDispatcher().addEventListener(\"keydown\", (e2) => {\n        keysDownByKey.has(e2[\"key\"]) ? e2.stopPropagation() : keysDownByKey.add(e2[\"key\"]);\n      }), runtime.UserScriptDispatcher().addEventListener(\"keyup\", (e2) => keysDownByKey.delete(e2[\"key\"])), runtime.Dispatcher().addEventListener(\"window-blur\", () => keysDownByKey.clear()), runtime.IsInWorker() && (self[\"alert\"] = (e2) => (didWarnInAlertPolyfill || (didWarnInAlertPolyfill = true, console.warn(\"[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.\")), this.alert(e2)));\n    }\n    _InitObjects(e) {\n      Object.defineProperties(this.objects, e);\n    }\n    _InitGlobalVars(e) {\n      Object.defineProperties(this.globalVars, e);\n    }\n    addEventListener(e, t) {\n      runtime.UserScriptDispatcher().addEventListener(e, t);\n    }\n    removeEventListener(e, t) {\n      runtime.UserScriptDispatcher().removeEventListener(e, t);\n    }\n    callFunction(e, ...t) {\n      C3X.RequireString(e);\n      const r = runtime.GetEventSheetManager(), n = r.GetFunctionBlockByName(e);\n      if (!n) throw new Error(`cannot find function name '${e}'`);\n      if (!n.IsEnabled()) return n.GetDefaultReturnValue();\n      if (t.length < n.GetFunctionParameterCount()) throw new Error(`not enough function parameters passed for '${e}' (${t.length} passed, ${n.GetFunctionParameterCount()} expected)`);\n      const i = n.GetEventBlock();\n      let o = i.GetSolModifiersIncludingParents();\n      const a = r.GetCurrentEvent();\n      if (a) {\n        o = o.slice(0);\n        const e2 = new Set(o);\n        for (const t2 of a.GetSolModifiersIncludingParents()) e2.has(t2) || (o.push(t2), e2.add(t2));\n        for (const t2 of r.GetDynamicSolModifiersSet()) e2.has(t2) || (o.push(t2), e2.add(t2));\n      }\n      return i.RunAsExpressionFunctionCall(o, n.IsCopyPicked(), n.GetReturnType(), n.GetDefaultReturnValue(), ...t);\n    }\n    setReturnValue(e) {\n      const t = runtime.GetEventStack().GetCurrentExpFuncStackFrame();\n      if (!t) throw new Error(\"not in a function which returns a value\");\n      switch (t.GetFunctionReturnType()) {\n        case 1:\n          \"number\" == typeof e && t.SetFunctionReturnValue(e);\n          break;\n        case 2:\n          \"string\" == typeof e && t.SetFunctionReturnValue(e);\n          break;\n        case 3:\n          \"number\" != typeof e && \"string\" != typeof e || t.SetFunctionReturnValue(e);\n      }\n    }\n    signal(e) {\n      C3X.RequireString(e), runtime.GetEventSheetManager().Signal(e);\n    }\n    waitForSignal(e) {\n      return C3X.RequireString(e), runtime.GetEventSheetManager().WaitForSignal(e);\n    }\n    getViewportSize() {\n      return [runtime.GetOriginalViewportWidth(), runtime.GetOriginalViewportHeight()];\n    }\n    get isSuspended() {\n      return runtime.IsSuspended();\n    }\n    get dt() {\n      return runtime.GetDt();\n    }\n    get dtRaw() {\n      return runtime.GetDtRaw();\n    }\n    get gameTime() {\n      return runtime.GetGameTime();\n    }\n    get tickCount() {\n      return runtime.GetTickCount();\n    }\n    get wallTime() {\n      return runtime.GetWallTime();\n    }\n    get timeScale() {\n      return runtime.GetTimeScale();\n    }\n    set timeScale(e) {\n      C3X.RequireFiniteNumber(e), runtime.SetTimeScale(e);\n    }\n    get fps() {\n      return didWarnFpsDeprecated || (console.warn(\"IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead.\"), didWarnFpsDeprecated = true), runtime.GetFramesPerSecond();\n    }\n    get framesPerSecond() {\n      return runtime.GetFramesPerSecond();\n    }\n    get ticksPerSecond() {\n      return runtime.GetTicksPerSecond();\n    }\n    get cpuUtilisation() {\n      return runtime.GetMainThreadTime();\n    }\n    get gpuUtilisation() {\n      return runtime.GetGPUUtilisation();\n    }\n    get framerateMode() {\n      return runtime.GetFramerateMode();\n    }\n    set framerateMode(e) {\n      if (!VALID_FRAMERATE_MODES.has(e)) throw new Error(\"invalid framerate mode\");\n      runtime._SetFramerateMode(e);\n    }\n    get minDt() {\n      return runtime.GetMinDt();\n    }\n    set minDt(e) {\n      C3X.RequireFiniteNumber(e), runtime.SetMinDt(e);\n    }\n    get maxDt() {\n      return runtime.GetMaxDt();\n    }\n    set maxDt(e) {\n      runtime.SetMaxDt(e);\n    }\n    get loadingProgress() {\n      return runtime.GetAssetManager().GetLoadProgress();\n    }\n    get imageLoadingProgress() {\n      return runtime.GetAssetManager().GetImageLoadProgress();\n    }\n    random() {\n      return runtime.Random();\n    }\n    get layout() {\n      const e = runtime.GetMainRunningLayout();\n      if (!e) throw new Error(\"no layout is running - make sure a layout is loaded before accessing\");\n      return e.GetILayout();\n    }\n    getLayout(e) {\n      const t = runtime.GetLayoutManager();\n      let r = null;\n      if (\"number\" != typeof e && \"string\" != typeof e) throw new TypeError(\"expected string or number\");\n      if (r = t.GetLayout(e), !r) throw new Error(\"invalid layout\");\n      return r.GetILayout();\n    }\n    getAllLayouts() {\n      return runtime.GetLayoutManager().GetAllLayouts().map((e) => e.GetILayout());\n    }\n    goToLayout(e) {\n      const t = runtime.GetLayoutManager();\n      let r = null;\n      if (\"number\" != typeof e && \"string\" != typeof e) throw new TypeError(\"expected string or number\");\n      if (r = t.GetLayout(e), !r) throw new Error(\"invalid layout\");\n      t.IsPendingChangeMainLayout() || t.ChangeMainLayout(r);\n    }\n    get keyboard() {\n      const e = runtime._GetCommonScriptInterfaces().keyboard;\n      if (!e) throw new Error(\"runtime.keyboard used but Keyboard object missing - add it to your project first\");\n      return e;\n    }\n    get mouse() {\n      const e = runtime._GetCommonScriptInterfaces().mouse;\n      if (!e) throw new Error(\"runtime.mouse used but Mouse object missing - add it to your project first\");\n      return e;\n    }\n    get touch() {\n      const e = runtime._GetCommonScriptInterfaces().touch;\n      if (!e) throw new Error(\"runtime.touch used but Touch object missing - add it to your project first\");\n      return e;\n    }\n    get timelineController() {\n      const e = runtime._GetCommonScriptInterfaces().timelineController;\n      if (!e) throw new Error(\"runtime.timelineController used but Timeline Controller object missing - add it to your project first\");\n      return e;\n    }\n    invokeDownload(e, t) {\n      C3X.RequireString(e), C3X.RequireString(t), runtime.InvokeDownload(e, t);\n    }\n    getInstanceByUid(e) {\n      C3X.RequireFiniteNumber(e);\n      const t = runtime.GetInstanceByUID(e);\n      return t ? t.GetInterfaceClass() : null;\n    }\n    sortZOrder(e, t) {\n      C3X.RequireFunction(t);\n      const r = runtime.GetCurrentLayout();\n      for (const t2 of e) {\n        const e2 = runtime._UnwrapIWorldInstance(t2), r2 = e2.GetWorldInfo();\n        tempZOrderList.push([r2.GetLayer().GetIndex(), r2.GetZIndex()]), tempInstances.push(e2);\n      }\n      if (0 === tempZOrderList.length) return;\n      tempZOrderList.sort(SortZOrderList), tempInstances.sort((e2, r2) => t(e2.GetInterfaceClass(), r2.GetInterfaceClass()));\n      let n = false;\n      for (let e2 = 0, t2 = tempZOrderList.length; e2 < t2; ++e2) {\n        const t3 = tempInstances[e2], i = r.GetLayerByIndex(tempZOrderList[e2][0]), o = tempZOrderList[e2][1], a = i._GetInstances();\n        a[o] !== t3 && (a[o] = t3, t3.GetWorldInfo()._SetLayer(i, true), i.SetZIndicesChanged(t3), n = true);\n      }\n      n && runtime.UpdateRender(), C33.clearArray(tempZOrderList), C33.clearArray(tempInstances);\n    }\n    async createWorker(e, t) {\n      didWarnCreateWorkerDeprecated || (console.warn(\"IRuntime.createWorker() is deprecated. All modern browsers now support nested workers so this method is no longer needed.\"), didWarnCreateWorkerDeprecated = true);\n      const r = new MessageChannel(), n = r.port1, i = r.port2;\n      return await runtime.PostComponentMessageToDOMAsync(\"runtime\", \"script-create-worker\", { \"url\": e, \"opts\": t, \"port2\": i }, [i]), n;\n    }\n    alert(e) {\n      return runtime.PostComponentMessageToDOMAsync(\"runtime\", \"alert\", { \"message\": e + (runtime.IsInWorker() ? \" [via Web Worker]\" : \"\") });\n    }\n    getHTMLLayer(e) {\n      return C3X.RequireFiniteNumber(e), runtime._GetHTMLLayerWrapElement(e);\n    }\n    addLoadPromise(e) {\n      runtime.AddLoadPromise(e);\n    }\n    async saveCanvasImage(e, t, r) {\n      C3X.RequireOptionalString(e), C3X.RequireOptionalNumber(t), C3X.RequireOptionalInstanceOf(r, DOMRect), r || (r = new DOMRect(0, 0, 0, 0));\n      const n = runtime.GetCanvasManager();\n      if (!n) return;\n      runtime.UpdateRender();\n      const i = await n.SnapshotCanvas(e || \"image/png\", t, r.x, r.y, r.width, r.height);\n      return await runtime.TriggerAsync(C33.Plugins.System.Cnds.OnCanvasSnapshot, null), i;\n    }\n  };\n}\nvar SortZOrderList2;\n{\n  const C33 = self.C3, C3X = self.C3X;\n  let assetManager = null;\n  self.IAssetManager = class {\n    constructor(e) {\n      assetManager = e, Object.defineProperties(this, { isWebMOpusSupported: { value: true, writable: false } });\n    }\n    loadImageAsset(e) {\n      const t = self.IImageInfo._Unwrap(e);\n      if (!t) throw new Error(\"invalid IImageInfo\");\n      t.LoadAsset(assetManager.GetRuntime());\n    }\n    fetchText(e) {\n      return assetManager.FetchText(e);\n    }\n    fetchJson(e) {\n      return assetManager.FetchJson(e);\n    }\n    fetchBlob(e) {\n      return assetManager.FetchBlob(e);\n    }\n    fetchArrayBuffer(e) {\n      return assetManager.FetchArrayBuffer(e);\n    }\n    getProjectFileUrl(e) {\n      return assetManager.GetProjectFileUrl(e);\n    }\n    getMediaFileUrl(e) {\n      return \"flat\" === assetManager.GetFileStructure() && C33.IsRelativeURL(e) && (e = e.toLowerCase()), assetManager.GetMediaFileUrl(e);\n    }\n    get mediaFolder() {\n      return assetManager.GetMediaSubfolder();\n    }\n    async decodeWebMOpus(e, t) {\n      throw new Error(\"decodeWebMOpus() is no longer supported - use Web Audio's decodeAudioData() directly as all supported platforms now support WebM Opus\");\n    }\n    loadScripts(...e) {\n      return assetManager.LoadScripts(...e);\n    }\n    compileWebAssembly(e) {\n      return assetManager.CompileWebAssembly(e);\n    }\n    loadStyleSheet(e) {\n      return assetManager.LoadStyleSheet(e);\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  let collisionEngine = null;\n  self.ICollisionEngine = class {\n    constructor(n) {\n      collisionEngine = n, Object.defineProperties(this, { runtime: { value: collisionEngine.GetRuntime(), writable: false } });\n    }\n    testOverlap(n, e) {\n      const l = collisionEngine.GetRuntime(), i = l._UnwrapIWorldInstance(n), t = l._UnwrapIWorldInstance(e);\n      return collisionEngine.TestOverlap(i, t);\n    }\n    testOverlapAny(n, e) {\n      const l = collisionEngine.GetRuntime(), i = l._UnwrapIWorldInstance(n);\n      for (const n2 of e) {\n        const e2 = l._UnwrapIWorldInstance(n2);\n        if (collisionEngine.TestOverlap(i, e2)) return n2;\n      }\n      return null;\n    }\n    testOverlapSolid(n) {\n      const e = collisionEngine.GetRuntime()._UnwrapIWorldInstance(n), l = collisionEngine.TestOverlapSolid(e);\n      return l ? l.GetInterfaceClass() : null;\n    }\n    setCollisionCellSize(n, e) {\n      if (C3X.RequireFiniteNumber(n), C3X.RequireFiniteNumber(e), n = Math.floor(n), e = Math.floor(e), n <= 0 || e <= 0) throw new Error(\"invalid cell size\");\n      collisionEngine.SetCollisionCellSize(n, e);\n    }\n    getCollisionCellSize() {\n      return collisionEngine.GetCollisionCellSize();\n    }\n    getCollisionCandidates(n, e) {\n      const l = collisionEngine.GetRuntime();\n      let i;\n      i = Array.isArray(n) ? n.map((n2) => l._UnwrapIObjectClass(n2)) : [l._UnwrapIObjectClass(n)];\n      const t = C33.Rect.FromObject(e), o = [];\n      return collisionEngine.GetObjectClassesCollisionCandidates(null, i, t, o), o.map((n2) => n2.GetInterfaceClass());\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  let runtime = null;\n  const osMap = /* @__PURE__ */ new Map([[\"Windows\", \"windows\"], [\"macOS\", \"macos\"], [\"Linux\", \"linux\"], [\"Chrome OS\", \"chrome-os\"], [\"Android\", \"android\"], [\"iOS\", \"ios\"]]), browserMap = /* @__PURE__ */ new Map([[\"Chrome\", \"chrome\"], [\"Chromium\", \"chromium\"], [\"Edge\", \"edge\"], [\"Opera\", \"opera\"], [\"NW.js\", \"nwjs\"], [\"Firefox\", \"firefox\"], [\"Safari\", \"safari\"]]), browserEngineMap = /* @__PURE__ */ new Map([[\"Chromium\", \"chromium\"], [\"Gecko\", \"gecko\"], [\"WebKit\", \"webkit\"]]);\n  self.IPlatformInfo = class {\n    constructor(e) {\n      runtime = e, Object.defineProperties(this, { isMobile: { value: C33.Platform.IsMobile, writable: false }, os: { value: osMap.get(C33.Platform.OS) || \"unknown\", writable: false }, osVersion: { value: C33.Platform.OSVersion, writable: false }, browser: { value: browserMap.get(C33.Platform.Browser) || \"unknown\", writable: false }, browserVersion: { value: C33.Platform.BrowserVersion, writable: false }, browserEngine: { value: browserEngineMap.get(C33.Platform.BrowserEngine) || \"unknown\", writable: false } });\n    }\n    get exportType() {\n      let e = runtime.GetExportType();\n      return runtime.IsNWjs() ? e = \"nwjs\" : runtime.IsWindowsWebView2() ? e = \"windows-webview2\" : \"cordova\" === e ? e = \"Android\" === C33.Platform.OS ? \"cordova-android\" : \"cordova-ios\" : \"playable-ad-single-file\" !== e && \"playable-ad-zip\" !== e || (e = \"playable-ad\"), e;\n    }\n    get renderer() {\n      return runtime.GetCanvasManager().GetRendererString();\n    }\n    get rendererDetail() {\n      return runtime.GetCanvasManager().GetRendererDetailString();\n    }\n    get canvasClientX() {\n      return runtime.GetCanvasManager().GetCanvasClientX();\n    }\n    get canvasClientY() {\n      return runtime.GetCanvasManager().GetCanvasClientY();\n    }\n    get canvasCssWidth() {\n      return runtime.GetCanvasManager().GetCssWidth();\n    }\n    get canvasCssHeight() {\n      return runtime.GetCanvasManager().GetCssHeight();\n    }\n    get canvasDeviceWidth() {\n      return runtime.GetCanvasManager().GetDeviceWidth();\n    }\n    get canvasDeviceHeight() {\n      return runtime.GetCanvasManager().GetDeviceHeight();\n    }\n    get devicePixelRatio() {\n      return runtime.GetDevicePixelRatio();\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  self.IStorage = class {\n    constructor(e) {\n      this._storage = e._GetProjectStorage();\n    }\n    getItem(e) {\n      return C3X.RequireString(e), this._storage.getItem(e);\n    }\n    setItem(e, t) {\n      return C3X.RequireString(e), this._storage.setItem(e, t);\n    }\n    removeItem(e) {\n      return C3X.RequireString(e), this._storage.removeItem(e);\n    }\n    clear() {\n      return this._storage.clear();\n    }\n    keys() {\n      return this._storage.keys();\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();\n  self.IPlugin = class {\n    #e;\n    constructor() {\n      const e = C33.AddonManager._GetInitObject2(internalApiToken);\n      this.#e = e, Object.defineProperties(this, { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, id: { value: e.GetID(), writable: false }, isSingleGlobal: { value: e.IsSingleGlobal(), writable: false }, isWorldType: { value: e.IsWorldType(), writable: false }, isHTMLElementType: { value: e.IsHTMLElementType(), writable: false }, isRotatable: { value: e.IsRotatable(), writable: false }, hasEffects: { value: e.HasEffects(), writable: false }, is3d: { value: e.Is3D(), writable: false }, supportsHierarchies: { value: e.SupportsSceneGraph(), writable: false }, supportsMesh: { value: e.SupportsMesh(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    static getByConstructor(e) {\n      if (!e) return null;\n      const t = C33.AddonManager.GetPluginByConstructorFunction(e);\n      return t ? t.GetIPlugin() : null;\n    }\n    getSingleGlobalObjectType() {\n      return this.#e.GetSingleGlobalObjectClass().GetIObjectClass();\n    }\n    getSingleGlobalInstance() {\n      return this.#e.GetSingleGlobalInstance().GetInterfaceClass();\n    }\n  };\n}\n{\n  const C33 = globalThis.C3, C3X = globalThis.C3X, internalApiToken = C33._GetInternalAPIToken();\n  globalThis.IObjectClass = class {\n    #e;\n    constructor() {\n      const e = C33.AddonManager._GetInitObject2(internalApiToken);\n      this.#e = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    addEventListener(e, t) {\n      C3X.RequireString(e), C3X.RequireFunction(t), this.#e.UserScriptDispatcher().addEventListener(e, t);\n    }\n    removeEventListener(e, t) {\n      C3X.RequireString(e), C3X.RequireFunction(t), this.#e.UserScriptDispatcher().removeEventListener(e, t);\n    }\n    getAllInstances() {\n      return [...this.instances()];\n    }\n    getFirstInstance() {\n      return C33.first(this.instances());\n    }\n    getPickedInstances() {\n      return [...this.pickedInstances()];\n    }\n    getFirstPickedInstance() {\n      return C33.first(this.pickedInstances());\n    }\n    getPairedInstance(e) {\n      const t = this.#e, n = t.GetRuntime()._UnwrapIInstance(e), i = t.GetPairedInstance(n);\n      return i ? i.GetInterfaceClass() : null;\n    }\n    *instances() {\n      for (const e of this.#e.instancesIncludingPendingCreate()) yield e.GetInterfaceClass();\n    }\n    *pickedInstances() {\n      for (const e of this.#e.GetCurrentSol().GetInstances()) yield e.GetInterfaceClass();\n    }\n  };\n}\n{\n  const C33 = globalThis.C3, C3X = globalThis.C3X, internalApiToken = C33._GetInternalAPIToken();\n  globalThis.IObjectType = class extends globalThis.IObjectClass {\n    #e;\n    constructor() {\n      super();\n      const e = C33.AddonManager._GetInitObject2(internalApiToken);\n      this.#e = e;\n    }\n    setInstanceClass(e) {\n      C3X.RequireFunction(e);\n      const t = this.#e;\n      if (t.GetInstanceCount() > 0) throw new Error(\"setInstanceClass() called too late, because instances have already been created - call in runOnStartup\");\n      t._SetUserScriptInstanceClass(e);\n    }\n    createInstance(e, t, n, a, s) {\n      if (C3X.RequireNumber(t), C3X.RequireNumber(n), \"number\" != typeof e && \"string\" != typeof e) throw new TypeError(\"invalid layer parameter\");\n      const r = this.#e, i = r.GetRuntime(), l = i.GetMainRunningLayout().GetLayer(e);\n      if (!l) throw new Error(\"invalid layer\");\n      const c = i.CreateInstance(r, l, t, n, a, s);\n      a && l.SortAndAddInstancesByZIndex(c);\n      const o = i.GetEventSheetManager();\n      return o.BlockFlushingInstances(true), c._TriggerOnCreatedOnSelfAndRelated(), o.BlockFlushingInstances(false), o.IsInEventEngine() || i.GetLayoutManager().IsEndingLayout() || i.FlushPendingInstances(), c.GetInterfaceClass();\n    }\n    getAllFamilies() {\n      return this.#e.GetFamilies().map((e) => e.GetIObjectClass());\n    }\n    *families() {\n      for (const e of this.#e.GetFamilies()) yield e.GetIObjectClass();\n    }\n    isInFamily(e) {\n      return C3X.RequireInstanceOf(e, globalThis.IFamily), e.hasObjectType(this);\n    }\n  };\n}\n{\n  const C33 = globalThis.C3, C3X = globalThis.C3X, IObjectType = globalThis.IObjectType, internalApiToken = C33._GetInternalAPIToken();\n  globalThis.IFamily = class extends globalThis.IObjectClass {\n    #e;\n    constructor() {\n      super();\n      const e = C33.AddonManager._GetInitObject2(internalApiToken);\n      this.#e = e;\n    }\n    getAllObjectTypes() {\n      return this.#e.GetFamilyMembers().map((e) => e.GetIObjectClass());\n    }\n    *objectTypes() {\n      for (const e of this.#e.GetFamilyMembers()) yield e.GetIObjectClass();\n    }\n    hasObjectType(e) {\n      C3X.RequireInstanceOf(e, IObjectType);\n      const t = this.#e, s = t.GetRuntime()._UnwrapIObjectClass(e);\n      return t.FamilyHasMember(s);\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), VALID_WHERE_STRINGS = [\"above\", \"below\", \"top-sublayer\", \"bottom-sublayer\"];\n  self.ILayout = class {\n    constructor(e) {\n      map.set(this, e);\n      const t = [], r = e.GetEffectList(), i = r.GetAllEffectTypes().length;\n      for (let e2 = 0; e2 < i; ++e2) t.push(new self.IEffectInstance(r, e2));\n      Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, index: { value: e.GetIndex(), writable: false }, effects: { value: t, writable: false } });\n    }\n    addEventListener(e, t) {\n      C3X.RequireString(e), C3X.RequireFunction(t), map.get(this).UserScriptDispatcher().addEventListener(e, t);\n    }\n    removeEventListener(e, t) {\n      C3X.RequireString(e), C3X.RequireFunction(t), map.get(this).UserScriptDispatcher().removeEventListener(e, t);\n    }\n    get width() {\n      return map.get(this).GetWidth();\n    }\n    set width(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetWidth(e);\n    }\n    get height() {\n      return map.get(this).GetHeight();\n    }\n    set height(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetHeight(e);\n    }\n    setSize(e, t) {\n      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t);\n      const r = map.get(this);\n      r.SetWidth(e), r.SetHeight(t);\n    }\n    getSize() {\n      const e = map.get(this);\n      return [e.GetWidth(), e.GetHeight()];\n    }\n    set scale(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetScale(e);\n    }\n    get scale() {\n      return map.get(this).GetScale();\n    }\n    set angle(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetAngle(e);\n    }\n    get angle() {\n      return map.get(this).GetAngle();\n    }\n    set scrollX(e) {\n      C3X.RequireNumber(e), map.get(this).SetScrollX(e);\n    }\n    get scrollX() {\n      return map.get(this).GetScrollX();\n    }\n    set scrollY(e) {\n      C3X.RequireNumber(e), map.get(this).SetScrollY(e);\n    }\n    get scrollY() {\n      return map.get(this).GetScrollY();\n    }\n    scrollTo(e, t) {\n      C3X.RequireNumber(e), C3X.RequireNumber(t);\n      const r = map.get(this);\n      r.SetScrollX(e), r.SetScrollY(t);\n    }\n    getScrollPosition() {\n      const e = map.get(this);\n      return [e.GetScrollX(), e.GetScrollY()];\n    }\n    getLayer(e) {\n      const t = map.get(this);\n      let r = null;\n      if (\"number\" != typeof e && \"string\" != typeof e) throw new TypeError(\"expected string or number\");\n      return r = t.GetLayer(e), r ? r.GetILayer() : null;\n    }\n    getAllLayers() {\n      return map.get(this).GetLayers().map((e) => e.GetILayer());\n    }\n    *allLayers() {\n      for (const e of map.get(this).allLayers()) yield e.GetILayer();\n    }\n    addLayer(e, t, r) {\n      const i = map.get(this), n = self.ILayer;\n      C3X.RequireString(e), C3X.RequireOptionalInstanceOf(t, n);\n      const s = t ? i.GetRuntime()._UnwrapScriptInterface(t) : null, a = VALID_WHERE_STRINGS.indexOf(r);\n      if (a < 0) throw new Error(\"invalid location\");\n      i.AddLayer(e, s, a);\n    }\n    moveLayer(e, t, r) {\n      const i = map.get(this), n = i.GetRuntime(), s = self.ILayer;\n      C3X.RequireInstanceOf(e, s);\n      const a = n._UnwrapScriptInterface(e);\n      if (!a) throw new Error(\"invalid layer\");\n      C3X.RequireOptionalInstanceOf(t, s);\n      const o = t ? n._UnwrapScriptInterface(t) : null, l = VALID_WHERE_STRINGS.indexOf(r);\n      if (l < 0) throw new Error(\"invalid location\");\n      i.MoveLayer(a, o, l);\n    }\n    removeLayer(e) {\n      const t = map.get(this), r = self.ILayer;\n      C3X.RequireInstanceOf(e, r);\n      const i = t.GetRuntime()._UnwrapScriptInterface(e);\n      if (!i) throw new Error(\"invalid layer\");\n      const n = i.GetRuntime();\n      t.RemoveLayer(i), n.GetEventSheetManager().IsInEventEngine() || n.FlushPendingInstances();\n    }\n    removeAllDynamicLayers() {\n      const e = map.get(this), t = e.GetRuntime();\n      e.RemoveAllDynamicLayers(), t.GetEventSheetManager().IsInEventEngine() || t.FlushPendingInstances();\n    }\n    setVanishingPoint(e, t) {\n      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(t), map.get(this).SetVanishingPointXY(e, t);\n    }\n    getVanishingPoint() {\n      return map.get(this)._GetVanishingPoint();\n    }\n    set projection(e) {\n      C3X.RequireString(e);\n      const t = map.get(this);\n      if (\"perspective\" === e) t.SetPerspectiveProjection();\n      else {\n        if (\"orthographic\" !== e) throw new Error(\"invalid projection\");\n        t.SetOrthographicProjection();\n      }\n    }\n    get projection() {\n      return map.get(this).IsOrthographicProjection() ? \"orthographic\" : \"perspective\";\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([[\"normal\", 0], [\"additive\", 1], [\"copy\", 3], [\"destination-over\", 4], [\"source-in\", 5], [\"destination-in\", 6], [\"source-out\", 7], [\"destination-out\", 8], [\"source-atop\", 9], [\"destination-atop\", 10]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), VALID_RENDERING_MODES = /* @__PURE__ */ new Set([\"2d\", \"3d\"]), tempColor = C33.New(C33.Color);\n  self.ILayer = class {\n    constructor(e) {\n      map.set(this, e);\n      const t = [], r = e.GetEffectList(), a = r.GetAllEffectTypes().length;\n      for (let e2 = 0; e2 < a; ++e2) t.push(new self.IEffectInstance(r, e2));\n      Object.defineProperties(this, { name: { value: e.GetName(), writable: false }, layout: { value: e.GetLayout().GetILayout(), writable: false }, effects: { value: t, writable: false } }), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    get parentLayer() {\n      const e = map.get(this).GetParentLayer();\n      return e ? e.GetILayer() : null;\n    }\n    *parentLayers() {\n      for (const e of map.get(this).parentLayers()) yield e.GetILayer();\n    }\n    *subLayers() {\n      for (const e of map.get(this).GetSubLayers()) yield e.GetILayer();\n    }\n    *allSubLayers() {\n      for (const e of map.get(this).GetSubLayers()) for (const t of e.selfAndAllSubLayers()) yield t.GetILayer();\n    }\n    get index() {\n      return map.get(this).GetIndex();\n    }\n    get isVisible() {\n      return map.get(this)._IsVisibleFlagSet();\n    }\n    set isVisible(e) {\n      map.get(this).SetVisible(e);\n    }\n    get isSelfAndParentsVisible() {\n      return map.get(this).IsVisible();\n    }\n    get isInteractive() {\n      return map.get(this).IsInteractive();\n    }\n    set isInteractive(e) {\n      map.get(this).SetInteractive(e);\n    }\n    get isHTMLElementsLayer() {\n      return map.get(this).IsHTMLElementsLayer();\n    }\n    set isHTMLElementsLayer(e) {\n      map.get(this).SetIsHTMLElementsLayer(!!e);\n    }\n    get isSelfAndParentsInteractive() {\n      return map.get(this).IsSelfAndParentsInteractive();\n    }\n    get opacity() {\n      return map.get(this).GetOpacity();\n    }\n    set opacity(e) {\n      e = C33.clamp(+e, 0, 1), isNaN(e) || map.get(this).SetOpacity(e);\n    }\n    set scale(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetOwnScale(e);\n    }\n    get scale() {\n      return map.get(this).GetOwnScale();\n    }\n    set scaleRate(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetScaleRate(e);\n    }\n    get scaleRate() {\n      return map.get(this).GetScaleRate();\n    }\n    set angle(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetAngle(e);\n    }\n    get angle() {\n      return map.get(this).GetOwnAngle();\n    }\n    set parallaxX(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetParallaxX(e);\n    }\n    get parallaxX() {\n      return map.get(this).GetParallaxX();\n    }\n    set parallaxY(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetParallaxY(e);\n    }\n    get parallaxY() {\n      return map.get(this).GetParallaxY();\n    }\n    set zElevation(e) {\n      C3X.RequireFiniteNumber(e), map.get(this).SetZElevation(e);\n    }\n    get zElevation() {\n      return map.get(this).GetZElevation();\n    }\n    set renderingMode(e) {\n      if (!VALID_RENDERING_MODES.has(e)) throw TypeError(\"invalid rendering mode\");\n      map.get(this).SetRenderAs3D(\"3d\" === e);\n    }\n    get renderingMode() {\n      return map.get(this).IsRenderAs3D() ? \"3d\" : \"2d\";\n    }\n    set isTransparent(e) {\n      map.get(this).SetTransparent(e);\n    }\n    get isTransparent() {\n      return map.get(this).IsTransparent();\n    }\n    set isForceOwnTexture(e) {\n      map.get(this).SetForceOwnTexture(e);\n    }\n    get isForceOwnTexture() {\n      return map.get(this).IsForceOwnTexture();\n    }\n    set blendMode(e) {\n      C3X.RequireString(e);\n      const t = BLEND_MODE_TO_INDEX.get(e);\n      if (\"number\" != typeof t) throw new Error(\"invalid blend mode\");\n      map.get(this).SetBlendMode(t);\n    }\n    get blendMode() {\n      return INDEX_TO_BLEND_MODE.get(map.get(this).GetBlendMode());\n    }\n    set backgroundColor(e) {\n      if (C3X.RequireArray(e), e.length < 3) throw new Error(\"expected 3 elements\");\n      tempColor.setRgb(e[0], e[1], e[2]);\n      const t = map.get(this), r = t.GetBackgroundColor();\n      r.equalsIgnoringAlpha(tempColor) || (r.copyRgb(tempColor), t.GetRuntime().UpdateRender());\n    }\n    get backgroundColor() {\n      const e = map.get(this).GetBackgroundColor();\n      return [e.getR(), e.getG(), e.getB()];\n    }\n    set scrollX(e) {\n      C3X.RequireNumber(e);\n      const t = map.get(this);\n      t.SetOwnScrollPositionEnabled(true), t.SetScrollX(e);\n    }\n    get scrollX() {\n      return map.get(this).GetScrollX();\n    }\n    set scrollY(e) {\n      C3X.RequireNumber(e);\n      const t = map.get(this);\n      t.SetOwnScrollPositionEnabled(true), t.SetScrollY(e);\n    }\n    get scrollY() {\n      return map.get(this).GetScrollY();\n    }\n    scrollTo(e, t) {\n      C3X.RequireNumber(e), C3X.RequireNumber(t);\n      const r = map.get(this);\n      r.SetOwnScrollPositionEnabled(true), r.SetScrollX(e), r.SetScrollY(t);\n    }\n    getScrollPosition() {\n      const e = map.get(this);\n      return [e.GetScrollX(), e.GetScrollY()];\n    }\n    restoreScrollPosition() {\n      map.get(this).SetOwnScrollPositionEnabled(false);\n    }\n    getViewport() {\n      return map.get(this).GetViewport().toDOMRect();\n    }\n    cssPxToLayer(e, t, r = 0) {\n      C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r);\n      const a = map.get(this), s = a.GetRuntime();\n      return a.CanvasCssToLayer(e - s.GetCanvasClientX(), t - s.GetCanvasClientY(), r);\n    }\n    layerToCssPx(e, t, r = 0) {\n      C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r);\n      const a = map.get(this), s = a.GetRuntime(), [i, n] = a.LayerToCanvasCss(e, t, r);\n      return [i + s.GetCanvasClientX(), n + s.GetCanvasClientY()];\n    }\n    drawSurfaceToLayer(e, t, r = 0) {\n      return C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r), map.get(this).DrawSurfaceToLayer(e, t, r);\n    }\n    layerToDrawSurface(e, t, r = 0) {\n      return C3X.RequireNumber(e), C3X.RequireNumber(t), C3X.RequireNumber(r), map.get(this).LayerToDrawSurface(e, t, r);\n    }\n    get renderScale() {\n      return map.get(this).GetRenderScale();\n    }\n  };\n}\n{\n  let GetDispatcher = function(e) {\n    let t = dispatchers.get(e);\n    return t || (t = C33.New(C33.Event.Dispatcher), dispatchers.set(e, t), t);\n  };\n  GetDispatcher2 = GetDispatcher;\n  const C33 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();\n  self.IInstance = class {\n    #e;\n    constructor() {\n      const e = C33.AddonManager._GetInitObject2(internalApiToken);\n      this.#e = e;\n      const t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, objectType: { value: e.GetObjectClass().GetIObjectClass(), writable: false }, plugin: { value: e.GetPlugin().GetIPlugin(), writable: false } };\n      e._GetInstVarsScriptDescriptor(t), e._GetBehaviorsScriptDescriptor(t), Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    static _GetInitInst() {\n      return C33.AddonManager._GetInitObject();\n    }\n    _release() {\n      const e = dispatchers.get(this);\n      e && (e.Release(), dispatchers.delete(this));\n    }\n    addEventListener(e, t, i) {\n      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).addEventListener(e, t, i);\n    }\n    removeEventListener(e, t, i) {\n      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).removeEventListener(e, t, i);\n    }\n    dispatchEvent(e) {\n      GetDispatcher(this).dispatchEvent(e);\n    }\n    destroy() {\n      const e = this.#e, t = e.GetRuntime();\n      t.DestroyInstance(e), t.GetEventSheetManager().IsInEventEngine() || t.GetLayoutManager().IsEndingLayout() || t.GetEventSheetManager().IsFlushingBlocked() || t.FlushPendingInstances();\n    }\n    getOtherContainerInstances() {\n      const e = this.#e.GetSiblings();\n      return e ? e.map((e2) => e2.GetInterfaceClass()) : [];\n    }\n    *otherContainerInstances() {\n      const e = this.#e;\n      if (e.IsInContainer()) for (const t of e.siblings()) yield t.GetInterfaceClass();\n    }\n    get uid() {\n      return this.#e.GetUID();\n    }\n    get iid() {\n      return this.#e.GetIID();\n    }\n    get templateName() {\n      return this.#e.GetTemplateName();\n    }\n    set timeScale(e) {\n      C3X.RequireFiniteNumber(e), this.#e.SetTimeScale(e);\n    }\n    get timeScale() {\n      return this.#e.GetActiveTimeScale();\n    }\n    restoreTimeScale() {\n      this.#e.RestoreTimeScale();\n    }\n    get dt() {\n      const e = this.#e;\n      return e.GetRuntime().GetDt(e);\n    }\n    hasTags(...e) {\n      C3X.RequireArray(e);\n      const t = new Set(e), i = this.#e.GetTagsSet();\n      return t.isSubsetOf(i);\n    }\n    setAllTags(e) {\n      C3X.RequireInstanceOf(e, Set), this.#e.SetTagsSet(e);\n    }\n    getAllTags() {\n      return new Set(this.#e.GetTagsSet());\n    }\n    signal(e) {\n      C3X.RequireString(e);\n      const t = this.#e;\n      t.GetRuntime().GetEventSheetManager().InstanceSignal(t, e);\n    }\n    waitForSignal(e) {\n      C3X.RequireString(e);\n      const t = this.#e;\n      return t.GetRuntime().GetEventSheetManager().WaitForInstanceSignal(t, e);\n    }\n  };\n}\nvar GetDispatcher2;\n{\n  const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();\n  self.ISDKInstanceBase = class extends self.IInstance {\n    #e;\n    #t = false;\n    #n = null;\n    #i = false;\n    #r = null;\n    #s;\n    #o;\n    constructor(e) {\n      super(), this.#e = C33.AddonManager._GetInitObject2(internalApiToken), this.#t = false, this.#n = null, this.#i = false, this.#r = null, this.#s = e?.domComponentId, this.#o = e?.wrapperComponentId;\n    }\n    _release() {\n      this._setTicking(false), this._setTicking2(false), super._release();\n    }\n    _getInitProperties() {\n      return C33.AddonManager._GetInitProperties();\n    }\n    _trigger(e) {\n      const t = this.#e;\n      t.GetRuntime().Trigger(e, t);\n    }\n    _triggerAsync(e) {\n      const t = this.#e;\n      return t.GetRuntime().TriggerAsync(e, t);\n    }\n    _addDOMMessageHandler(e, t) {\n      if (C3X.RequireString(e), C3X.RequireFunction(t), !this.#s) throw new Error(\"no DOM component id set\");\n      this.#e.GetRuntime().AddDOMComponentMessageHandler(this.#s, e, t);\n    }\n    _addDOMMessageHandlers(e) {\n      C3X.RequireArray(e);\n      for (const [t, n] of e) this._addDOMMessageHandler(t, n);\n    }\n    _postToDOM(e, t) {\n      if (C3X.RequireString(e), !this.#s) throw new Error(\"no DOM component id set\");\n      this.#e.GetRuntime().PostComponentMessageToDOM(this.#s, e, t);\n    }\n    _postToDOMAsync(e, t) {\n      if (C3X.RequireString(e), !this.#s) throw new Error(\"no DOM component id set\");\n      return this.#e.GetRuntime().PostComponentMessageToDOMAsync(this.#s, e, t);\n    }\n    _postToDOMMaybeSync(e, t) {\n      if (!this.#e.GetRuntime().IsInWorker()) return window[\"c3_runtimeInterface\"][\"_OnMessageFromRuntime\"]({ \"type\": \"event\", \"component\": this.#s, \"handler\": e, \"data\": t, \"responseId\": null });\n      this._postToDOM(e, t);\n    }\n    _setTicking(e) {\n      if (e = !!e, this.#t === e) return;\n      this.#t = e;\n      const t = this.#e.GetRuntime();\n      if (e) {\n        if (!this.#n) if (this.#e.GetRuntime().IsDebug()) {\n          const e2 = globalThis.C3Debugger, t2 = this.plugin;\n          this.#n = () => {\n            const n = performance.now();\n            this._tick(), e2.AddIndividualPluginTickTime(t2, performance.now() - n);\n          };\n        } else this.#n = () => this._tick();\n        t.Dispatcher().addEventListener(\"tick\", this.#n);\n      } else t.Dispatcher().removeEventListener(\"tick\", this.#n);\n    }\n    _isTicking() {\n      return this.#t;\n    }\n    _tick() {\n    }\n    _setTicking2(e) {\n      if (e = !!e, this.#i === e) return;\n      this.#i = e;\n      const t = this.#e.GetRuntime();\n      if (e) {\n        if (!this.#r) if (this.#e.GetRuntime().IsDebug()) {\n          const e2 = globalThis.C3Debugger, t2 = this.plugin;\n          this.#r = () => {\n            const n = performance.now();\n            this._tick2(), e2.AddIndividualPluginTickTime(t2, performance.now() - n);\n          };\n        } else this.#r = () => this._tick2();\n        t.Dispatcher().addEventListener(\"tick2\", this.#r);\n      } else t.Dispatcher().removeEventListener(\"tick2\", this.#r);\n    }\n    _isTicking2() {\n      return this.#i;\n    }\n    _tick2() {\n    }\n    _getDebuggerProperties() {\n      return [];\n    }\n    _saveToJson() {\n      return null;\n    }\n    _loadFromJson(e) {\n    }\n    _isWrapperExtensionAvailable() {\n      if (!this.#o) throw new Error(\"no wrapper component id set\");\n      return this.#e.GetRuntime().HasWrapperComponentId(this.#o);\n    }\n    _addWrapperExtensionMessageHandler(e, t) {\n      if (C3X.RequireString(e), C3X.RequireFunction(t), !this.#o) throw new Error(\"no wrapper component id set\");\n      this.#e.GetRuntime().AddWrapperExtensionMessageHandler(this.#o, e, t);\n    }\n    _addWrapperMessageHandlers(e) {\n      C3X.RequireArray(e);\n      for (const [t, n] of e) this._addWrapperExtensionMessageHandler(t, n);\n    }\n    _sendWrapperExtensionMessage(e, t) {\n      if (!this.#o) throw new Error(\"no wrapper component id set\");\n      this.runtime.sdk.sendWrapperExtensionMessage(this.#o, e, t);\n    }\n    _sendWrapperExtensionMessageAsync(e, t) {\n      if (!this.#o) throw new Error(\"no wrapper component id set\");\n      return this.runtime.sdk.sendWrapperExtensionMessageAsync(this.#o, e, t);\n    }\n  };\n}\n{\n  let MakeIWorldInstanceClass = function(e) {\n    return class t extends e {\n      #e;\n      #t;\n      constructor(e2) {\n        super(e2);\n        const t2 = C33.AddonManager._GetInitObject2(internalApiToken), i = t2.GetWorldInfo();\n        this.#e = t2, this.#t = i, map.set(this, t2);\n        const n = [], r = i.GetInstanceEffectList();\n        if (r) {\n          const e3 = i.GetObjectClass().GetEffectList().GetAllEffectTypes().length;\n          for (let t3 = 0; t3 < e3; ++t3) n.push(new self.IEffectInstance(r, t3));\n        }\n        const s = { effects: { value: n, writable: false } };\n        Object.defineProperties(this, s);\n      }\n      get layout() {\n        return this.#t.GetLayout().GetILayout();\n      }\n      get layer() {\n        return this.#t.GetLayer().GetILayer();\n      }\n      get x() {\n        return this.#t.GetX();\n      }\n      set x(e2) {\n        e2 = +e2;\n        const t2 = this.#t;\n        isNaN(e2) || t2.GetX() === e2 || (t2.SetX(e2), t2.SetBboxChanged());\n      }\n      get y() {\n        return this.#t.GetY();\n      }\n      set y(e2) {\n        e2 = +e2;\n        const t2 = this.#t;\n        isNaN(e2) || t2.GetY() === e2 || (t2.SetY(e2), t2.SetBboxChanged());\n      }\n      setPosition(e2, t2) {\n        e2 = +e2, t2 = +t2;\n        const i = this.#t;\n        isNaN(e2) || isNaN(t2) || i.GetX() === e2 && i.GetY() === t2 || (i.SetXY(e2, t2), i.SetBboxChanged());\n      }\n      getPosition() {\n        const e2 = this.#t;\n        return [e2.GetX(), e2.GetY()];\n      }\n      offsetPosition(e2, t2) {\n        if (e2 = +e2, t2 = +t2, isNaN(e2) || isNaN(t2) || 0 === e2 && 0 === t2) return;\n        const i = this.#t;\n        i.OffsetXY(e2, t2), i.SetBboxChanged();\n      }\n      set originX(e2) {\n        e2 = +e2;\n        const t2 = this.#t;\n        isNaN(e2) || t2.GetOriginX() === e2 || (t2.SetOriginX(e2), t2.SetBboxChanged());\n      }\n      get originX() {\n        return this.#t.GetOriginX();\n      }\n      set originY(e2) {\n        e2 = +e2;\n        const t2 = this.#t;\n        isNaN(e2) || t2.GetOriginY() === e2 || (t2.SetOriginY(e2), t2.SetBboxChanged());\n      }\n      get originY() {\n        return this.#t.GetOriginY();\n      }\n      setOrigin(e2, t2) {\n        e2 = +e2, t2 = +t2;\n        const i = this.#t;\n        isNaN(e2) || isNaN(t2) || i.GetOriginX() === e2 && i.GetOriginY() === t2 || (i.SetOriginX(e2), i.SetOriginY(t2), i.SetBboxChanged());\n      }\n      getOrigin() {\n        const e2 = this.#t;\n        return [e2.GetOriginX(), e2.GetOriginY()];\n      }\n      get zElevation() {\n        return this.#t.GetZElevation();\n      }\n      set zElevation(e2) {\n        e2 = +e2;\n        const t2 = this.#e, i = this.#t;\n        isNaN(e2) || i.GetZElevation() === e2 || (i.SetZElevation(e2), t2.GetRuntime().UpdateRender());\n      }\n      get totalZElevation() {\n        return this.#t.GetTotalZElevation();\n      }\n      get width() {\n        return this.#t.GetWidth();\n      }\n      set width(e2) {\n        e2 = +e2;\n        const t2 = this.#t;\n        isNaN(e2) || t2.GetWidth() === e2 || (t2.SetWidth(e2), t2.SetBboxChanged());\n      }\n      get height() {\n        return this.#t.GetHeight();\n      }\n      set height(e2) {\n        e2 = +e2;\n        const t2 = this.#t;\n        isNaN(e2) || t2.GetHeight() === e2 || (t2.SetHeight(e2), t2.SetBboxChanged());\n      }\n      setSize(e2, t2) {\n        e2 = +e2, t2 = +t2;\n        const i = this.#t;\n        isNaN(e2) || isNaN(t2) || i.GetWidth() === e2 && i.GetHeight() === t2 || (i.SetSize(e2, t2), i.SetBboxChanged());\n      }\n      getSize() {\n        const e2 = this.#t;\n        return [e2.GetWidth(), e2.GetHeight()];\n      }\n      get angle() {\n        return this.#t.GetAngle();\n      }\n      set angle(e2) {\n        e2 = C33.clampAngle(+e2);\n        const t2 = this.#t;\n        isNaN(e2) || t2.GetAngle() === e2 || (t2.SetAngle(e2), t2.SetBboxChanged());\n      }\n      get angleDegrees() {\n        return C33.toDegrees(this.angle);\n      }\n      set angleDegrees(e2) {\n        this.angle = C33.toRadians(e2);\n      }\n      getBoundingBox(e2) {\n        return e2 ? (this.#t.CalculateBbox(tempRect, tempQuad, false), tempRect.toDOMRect()) : this.#t.GetBoundingBox().toDOMRect();\n      }\n      getBoundingQuad(e2) {\n        return e2 ? (this.#t.CalculateBbox(tempRect, tempQuad, false), tempQuad.toDOMQuad()) : this.#t.GetBoundingQuad().toDOMQuad();\n      }\n      isOnScreen() {\n        return this.#t.IsInViewport2();\n      }\n      get isVisible() {\n        return this.#t.IsVisible();\n      }\n      set isVisible(e2) {\n        e2 = !!e2;\n        const t2 = this.#e, i = this.#t;\n        i.IsVisible() !== e2 && (i.SetVisible(e2), t2.GetRuntime().UpdateRender());\n      }\n      get opacity() {\n        return this.#t.GetOpacity();\n      }\n      set opacity(e2) {\n        e2 = C33.clamp(+e2, 0, 1);\n        const t2 = this.#e, i = this.#t;\n        isNaN(e2) || i.GetOpacity() === e2 || (i.SetOpacity(e2), t2.GetRuntime().UpdateRender());\n      }\n      set colorRgb(e2) {\n        if (C3X.RequireArray(e2), e2.length < 3) throw new Error(\"expected 3 elements\");\n        tempColor.setRgb(e2[0], e2[1], e2[2]);\n        const t2 = this.#e, i = this.#t;\n        i.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (i.SetUnpremultipliedColor(tempColor), t2.GetRuntime().UpdateRender());\n      }\n      get colorRgb() {\n        const e2 = this.#t.GetUnpremultipliedColor();\n        return [e2.getR(), e2.getG(), e2.getB()];\n      }\n      set blendMode(e2) {\n        C3X.RequireString(e2);\n        const t2 = BLEND_MODE_TO_INDEX.get(e2);\n        if (\"number\" != typeof t2) throw new Error(\"invalid blend mode\");\n        const i = this.#e;\n        this.#t.SetBlendMode(t2), i.GetRuntime().UpdateRender();\n      }\n      get blendMode() {\n        return INDEX_TO_BLEND_MODE.get(this.#t.GetBlendMode());\n      }\n      moveToTop() {\n        this.#t.ZOrderMoveToTop();\n      }\n      moveToBottom() {\n        this.#t.ZOrderMoveToBottom();\n      }\n      moveToLayer(e2) {\n        C3X.RequireInstanceOf(e2, ILayer);\n        const t2 = this.#e, i = t2.GetRuntime()._UnwrapScriptInterface(e2);\n        if (!i) throw new Error(\"invalid layer\");\n        t2.GetWorldInfo().ZOrderMoveToLayer(i);\n      }\n      moveAdjacentToInstance(e2, i) {\n        C3X.RequireInstanceOf(e2, t), this.#t.ZOrderMoveAdjacentToInstance(map.get(e2), i);\n      }\n      get zIndex() {\n        return this.#t.GetZIndex();\n      }\n      get isCollisionEnabled() {\n        return this.#t.IsCollisionEnabled();\n      }\n      set isCollisionEnabled(e2) {\n        this.#t.SetCollisionEnabled(!!e2);\n      }\n      containsPoint(e2, t2) {\n        return C3X.RequireNumber(e2), C3X.RequireNumber(t2), this.#t.ContainsPoint(+e2, +t2);\n      }\n      testOverlap(e2) {\n        C3X.RequireInstanceOf(e2, t);\n        const i = this.#e, n = map.get(e2);\n        return i.GetRuntime().GetCollisionEngine().TestOverlap(i, n);\n      }\n      testOverlapSolid() {\n        const e2 = this.#e, t2 = e2.GetRuntime().GetCollisionEngine().TestOverlapSolid(e2);\n        return t2 ? t2.GetInterfaceClass() : null;\n      }\n      getParent() {\n        const e2 = this.#e.GetParent();\n        return e2 ? e2.GetInterfaceClass() : null;\n      }\n      getTopParent() {\n        const e2 = this.#e.GetTopParent();\n        return e2 ? e2.GetInterfaceClass() : null;\n      }\n      *parents() {\n        for (const e2 of this.#e.parents()) yield e2.GetInterfaceClass();\n      }\n      getChildCount() {\n        return this.#e.GetChildCount();\n      }\n      getChildAt(e2) {\n        const t2 = this.#e.GetChildAt(e2);\n        return t2 ? t2.GetInterfaceClass() : null;\n      }\n      *children() {\n        for (const e2 of this.#e.children()) yield e2.GetInterfaceClass();\n      }\n      *allChildren() {\n        for (const e2 of this.#e.allChildren()) yield e2.GetInterfaceClass();\n      }\n      addChild(e2, i) {\n        C3X.RequireInstanceOf(e2, t), C3X.RequireOptionalObject(i), i || (i = {});\n        const n = this.#e, r = map.get(e2);\n        n.AddChild(r, i);\n      }\n      removeChild(e2) {\n        C3X.RequireInstanceOf(e2, t);\n        const i = this.#e, n = map.get(e2);\n        i.RemoveChild(n);\n      }\n      removeFromParent() {\n        const e2 = this.#e;\n        if (!e2.HasParent()) return;\n        e2.GetParent().RemoveChild(e2);\n      }\n      getHierarchyOpts() {\n        const e2 = this.#t;\n        return { transformX: e2.GetTransformWithParentX(), transformY: e2.GetTransformWithParentY(), transformWidth: e2.GetTransformWithParentWidth(), transformHeight: e2.GetTransformWithParentHeight(), transformAngle: e2.GetTransformWithParentAngle(), transformZElevation: e2.GetTransformWithParentZElevation(), transformOpacity: e2.GetTransformWithParentOpacity(), transformVisibility: e2.GetTransformWithParentVisibility(), destroyWithParent: e2.GetDestroyWithParent() };\n      }\n      createMesh(e2, t2) {\n        C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t2), this.#t.CreateMesh(e2, t2);\n      }\n      releaseMesh() {\n        const e2 = this.#t;\n        e2.ReleaseMesh(), e2.SetBboxChanged();\n      }\n      setMeshPoint(e2, t2, i) {\n        C3X.RequireFiniteNumber(e2), C3X.RequireFiniteNumber(t2), C3X.RequireObject(i);\n        const n = this.#t;\n        n.SetMeshPoint(e2, t2, i) && n.SetBboxChanged();\n      }\n      getMeshPoint(e2, t2) {\n        let i = NaN, n = NaN, r = NaN, s = NaN, a = NaN;\n        const o = this.#t;\n        if (o.HasMesh()) {\n          const l = o.GetSourceMesh().GetMeshPointAt(e2, t2);\n          null !== l && (i = l.GetX(), n = l.GetY(), r = l.GetZElevation(), s = l.GetU(), a = l.GetV());\n        }\n        return { x: i, y: n, zElevation: r, u: s, v: a };\n      }\n      getMeshSize() {\n        const e2 = this.#t;\n        if (!e2.HasMesh()) return [0, 0];\n        const t2 = e2.GetSourceMesh();\n        return [t2.GetHSize(), t2.GetVSize()];\n      }\n    };\n  };\n  MakeIWorldInstanceClass2 = MakeIWorldInstanceClass;\n  const C33 = self.C3, C3X = self.C3X, IInstance = self.IInstance, ILayer = self.ILayer, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad), map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken(), BLEND_MODE_TO_INDEX = /* @__PURE__ */ new Map([[\"normal\", 0], [\"additive\", 1], [\"copy\", 3], [\"destination-over\", 4], [\"source-in\", 5], [\"destination-in\", 6], [\"source-out\", 7], [\"destination-out\", 8], [\"source-atop\", 9], [\"destination-atop\", 10]]), INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map((e) => [e[1], e[0]])), tempColor = C33.New(C33.Color);\n  self.IWorldInstance = MakeIWorldInstanceClass(self.IInstance), self.IWorldInstanceSDKBase = MakeIWorldInstanceClass(self.ISDKInstanceBase);\n}\nvar MakeIWorldInstanceClass2;\n{\n  const C33 = self.C3, C3X = self.C3X;\n  self.IDOMInstance = class extends self.IWorldInstance {\n    #e;\n    constructor() {\n      super(), this.#e = self.IInstance._GetInitInst();\n    }\n    getElement() {\n      return this.#e.GetSdkInstance()._GetElementInDOMMode();\n    }\n    focus() {\n      this.#e.GetSdkInstance().FocusElement();\n    }\n    blur() {\n      this.#e.GetSdkInstance().BlurElement();\n    }\n    setCssStyle(e, t) {\n      C3X.RequireString(e), this.#e.GetSdkInstance().SetElementCSSStyle(e, t);\n    }\n  };\n}\n{\n  let GetDispatcher = function(e) {\n    let t = dispatchers.get(e);\n    return t || (t = C33.New(C33.Event.Dispatcher), dispatchers.set(e, t), t);\n  };\n  GetDispatcher2 = GetDispatcher;\n  const C33 = self.C3, C3X = self.C3X, dispatchers = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();\n  self.IBehaviorInstance = class {\n    #e;\n    constructor() {\n      const e = C33.AddonManager._GetInitObject2(internalApiToken);\n      this.#e = e;\n      const t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, behaviorType: { value: e.GetBehaviorType().GetIBehaviorType(), writable: false } };\n      Object.defineProperties(this, t), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    static _GetInitInst() {\n      return C33.AddonManager._GetInitObject();\n    }\n    get instance() {\n      return this.#e.GetObjectInstance().GetInterfaceClass();\n    }\n    _release() {\n      const e = dispatchers.get(this);\n      e && (e.Release(), dispatchers.delete(this));\n    }\n    addEventListener(e, t, i) {\n      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).addEventListener(e, t, i);\n    }\n    removeEventListener(e, t, i) {\n      C3X.RequireString(e), C3X.RequireFunction(t), GetDispatcher(this).removeEventListener(e, t, i);\n    }\n    dispatchEvent(e) {\n      GetDispatcher(this).dispatchEvent(e);\n    }\n  };\n}\nvar GetDispatcher2;\n{\n  const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();\n  self.IBehaviorType = class {\n    constructor() {\n      const e = C33.AddonManager._GetInitObject2(internalApiToken), t = { runtime: { value: e.GetRuntime().GetIRuntime(), writable: false }, behavior: { value: e.GetBehavior().GetIBehavior(), writable: false }, name: { value: e.GetName(), writable: false } };\n      Object.defineProperties(this, t);\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();\n  self.IBehavior = class {\n    #t;\n    constructor() {\n      const t = C33.AddonManager._GetInitObject2(internalApiToken);\n      this.#t = t;\n      const e = { runtime: { value: t.GetRuntime().GetIRuntime(), writable: false }, id: { value: t.GetID(), writable: false } };\n      Object.defineProperties(this, e), t.GetRuntime()._MapScriptInterface(this, t);\n    }\n    getAllInstances() {\n      return this.#t.GetInstances().map((t) => t.GetInterfaceClass());\n    }\n    static getByConstructor(t) {\n      if (!t) return null;\n      const e = C33.AddonManager.GetBehaviorByConstructorFunction(t);\n      return e ? e.GetIBehavior() : null;\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, tempColor = C33.New(C33.Color);\n  self.IEffectInstance = class {\n    #e;\n    constructor(e, t) {\n      this.#e = e;\n      const i = { index: { value: t, writable: false } };\n      Object.defineProperties(this, i);\n    }\n    get name() {\n      return this.#e.GetAllEffectTypes()[this.index].GetName();\n    }\n    get isActive() {\n      return this.#e.IsEffectIndexActive(this.index);\n    }\n    set isActive(e) {\n      e = !!e;\n      const t = this.#e;\n      t.IsEffectIndexActive(this.index) !== e && (t.SetEffectIndexActive(this.index, e), t.UpdateActiveEffects(), t.GetRuntime().UpdateRender());\n    }\n    setParameter(e, t) {\n      C3X.RequireFiniteNumber(e), e = Math.floor(+e);\n      const i = this.#e, r = i.GetEffectParameter(this.index, e);\n      if (null === r) throw new RangeError(\"invalid index\");\n      if (r instanceof C33.Color) {\n        if (!Array.isArray(t) || t.length < 3) throw new TypeError(\"expected array with 3 elements\");\n        tempColor.setRgb(t[0], t[1], t[2]), t = tempColor;\n      } else if (\"number\" != typeof t) throw new TypeError(\"expected number\");\n      i.SetEffectParameter(this.index, e, t) && i.IsEffectIndexActive(this.index) && i.GetRuntime().UpdateRender();\n    }\n    getParameter(e) {\n      C3X.RequireFiniteNumber(e), e = Math.floor(+e);\n      const t = this.#e.GetEffectParameter(this.index, e);\n      if (null === t) throw new RangeError(\"invalid index\");\n      return t instanceof C33.Color ? [t.getR(), t.getG(), t.getB()] : t;\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  self.IAnimation = class {\n    #e;\n    constructor(e) {\n      this.#e = e, Object.defineProperties(this, { name: { value: e.GetName(), writable: false } });\n    }\n    get speed() {\n      return this.#e.GetSpeed();\n    }\n    get isLooping() {\n      return this.#e.IsLooping();\n    }\n    get repeatCount() {\n      return this.#e.GetRepeatCount();\n    }\n    get repeatTo() {\n      return this.#e.GetRepeatTo();\n    }\n    get isPingPong() {\n      return this.#e.IsPingPong();\n    }\n    get frameCount() {\n      return this.#e.GetFrameCount();\n    }\n    getFrames() {\n      return this.#e.GetFrames().map((e) => e.GetIAnimationFrame());\n    }\n    *frames() {\n      for (const e of this.#e.GetFrames()) yield e.GetIAnimationFrame();\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  self.IImageInfo = class {\n    #t;\n    constructor(t) {\n      this.#t = t;\n    }\n    static _Unwrap(t) {\n      return t.#t;\n    }\n    get width() {\n      return this.#t.GetWidth();\n    }\n    get height() {\n      return this.#t.GetHeight();\n    }\n    getSize() {\n      const t = this.#t;\n      return [t.GetWidth(), t.GetHeight()];\n    }\n    getTexture(t) {\n      return t.getTextureForImageInfo(this);\n    }\n    getTexRect() {\n      return this.#t.GetTexRect().toDOMRect();\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  self.IAnimationFrame = class extends self.IImageInfo {\n    #t;\n    constructor(t) {\n      super(t.GetImageInfo()), this.#t = t, Object.defineProperties(this, { duration: { value: t.GetDuration(), writable: false }, originX: { value: t.GetOriginX(), writable: false }, originY: { value: t.GetOriginY(), writable: false } });\n    }\n    getOrigin() {\n      const t = this.#t;\n      return [t.GetOriginX(), t.GetOriginY()];\n    }\n    getImagePointCount() {\n      return this.#t.GetImagePointCount();\n    }\n    getImagePointX(t) {\n      return this.getImagePoint(t)[0];\n    }\n    getImagePointY(t) {\n      return this.getImagePoint(t)[1];\n    }\n    getImagePoint(t) {\n      const e = this.#t;\n      let i = null;\n      if (\"number\" == typeof t) i = e.GetImagePointByIndex(Math.floor(t));\n      else {\n        if (\"string\" != typeof t) throw new TypeError(\"expected string or number\");\n        i = e.GetImagePointByName(t);\n      }\n      return i ? [i.GetX(), i.GetY()] : this.getOrigin();\n    }\n    getPolyPointCount() {\n      const t = this.#t.GetCollisionPoly();\n      return t ? t.pointCount() : 0;\n    }\n    getPolyPointX(t) {\n      return this.getPolyPoint(t)[0];\n    }\n    getPolyPointY(t) {\n      return this.getPolyPoint(t)[1];\n    }\n    getPolyPoint(t) {\n      C3X.RequireFiniteNumber(t), t = Math.floor(t);\n      const e = this.#t.GetCollisionPoly();\n      if (!e || t < 0 || t >= e.pointCount()) return [0, 0];\n      const i = e.pointsArr();\n      return [i[2 * t], i[2 * t + 1]];\n    }\n    get tag() {\n      return this.#t.GetTag();\n    }\n  };\n}\n{\n  let GetTimelineState = function(e) {\n    const t = map.get(e);\n    if (t.IsReleased()) throw new Error(\"timeline/tween was released and is no longer valid\");\n    return t;\n  };\n  GetTimelineState2 = GetTimelineState;\n  const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();\n  self.ITimelineStateBase = class {\n    constructor(e) {\n      map.set(this, e), e.GetRuntime()._MapScriptInterface(this, e);\n    }\n    pause() {\n      GetTimelineState(this).Stop();\n    }\n    resume() {\n      GetTimelineState(this).Resume();\n    }\n    stop() {\n      GetTimelineState(this).Reset();\n    }\n    hasTags(e) {\n      return GetTimelineState(this).HasTags(e);\n    }\n    set time(e) {\n      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetTime(e);\n    }\n    get time() {\n      return GetTimelineState(this).GetTime();\n    }\n    set totalTime(e) {\n      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetTotalTime(e);\n    }\n    get totalTime() {\n      return GetTimelineState(this).GetTotalTime();\n    }\n    set isLooping(e) {\n      GetTimelineState(this).SetLoop(!!e);\n    }\n    get isLooping() {\n      return GetTimelineState(this).GetLoop();\n    }\n    set isPingPong(e) {\n      GetTimelineState(this).SetPingPong(!!e);\n    }\n    get isPingPong() {\n      return GetTimelineState(this).GetPingPong();\n    }\n    set playbackRate(e) {\n      C3X.RequireFiniteNumber(e), GetTimelineState(this).SetPlaybackRate(e);\n    }\n    get playbackRate() {\n      return GetTimelineState(this).GetPlaybackRate();\n    }\n    get progress() {\n      const e = GetTimelineState(this);\n      return e.GetTime() / e.GetTotalTime();\n    }\n    get tags() {\n      return GetTimelineState(this).GetTags();\n    }\n    get finished() {\n      return GetTimelineState(this).GetPlayPromise();\n    }\n    get isPlaying() {\n      return GetTimelineState(this).IsPlaying();\n    }\n    get isPaused() {\n      return GetTimelineState(this).IsPaused();\n    }\n    get isReleased() {\n      return map.get(this).IsReleased();\n    }\n  };\n}\nvar GetTimelineState2;\n{\n  let GetTimelineState = function(e) {\n    const t = map.get(e);\n    if (t.IsReleased()) throw new Error(\"timeline was released and is no longer valid\");\n    return t;\n  };\n  GetTimelineState2 = GetTimelineState;\n  const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();\n  let easeToIndexFunc = null;\n  self.ITimelineState = class extends self.ITimelineStateBase {\n    constructor(e) {\n      super(e), map.set(this, e);\n      const t = { name: { value: e.GetName(), writable: false } };\n      Object.defineProperties(this, t);\n    }\n  };\n}\nvar GetTimelineState2;\n{\n  let GetTweenState = function(e) {\n    const t = map.get(e);\n    if (t.IsReleased()) throw new Error(\"tween was released and is no longer valid\");\n    return t;\n  };\n  GetTweenState2 = GetTweenState;\n  const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), behInstMap = /* @__PURE__ */ new WeakMap();\n  let easeToIndexFunc = null;\n  self.ITweenState = class extends self.ITimelineStateBase {\n    constructor(e, t, n) {\n      super(e), easeToIndexFunc || (easeToIndexFunc = n.easeToIndexFunc), map.set(this, e), t && behInstMap.set(this, t);\n    }\n    stop() {\n      const e = GetTweenState(this);\n      behInstMap.get(this).ReleaseTween(e);\n    }\n    setEase(e) {\n      C3X.RequireString(e);\n      const t = self.Ease.GetEaseFromIndex(easeToIndexFunc(e));\n      GetTweenState(this).SetEase(t);\n    }\n    get instance() {\n      const e = GetTweenState(this).GetInstance();\n      return e ? e.GetInterfaceClass() : null;\n    }\n    get isDestroyOnComplete() {\n      return GetTweenState(this).GetDestroyInstanceOnComplete();\n    }\n    set isDestroyOnComplete(e) {\n      GetTweenState(this).SetDestroyInstanceOnComplete(!!e);\n    }\n    get value() {\n      const e = GetTweenState(this);\n      if (\"value\" !== e.GetId()) throw new Error(\"not a value tween\");\n      return e.GetPropertyTrack(\"value\").GetSourceAdapterValue();\n    }\n  };\n}\nvar GetTweenState2;\n{\n  const C33 = self.C3, C3X = self.C3X;\n  self.ISDKPluginBase = class extends self.IPlugin {\n    constructor() {\n      super();\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, internalApiToken = C33._GetInternalAPIToken();\n  self.ISDKDOMPluginBase = class extends self.ISDKPluginBase {\n    #e;\n    #n;\n    #t = 0;\n    #s = /* @__PURE__ */ new Map();\n    constructor(e) {\n      if (super(), this.#e = C33.AddonManager._GetInitObject2(internalApiToken), !e?.domComponentId) throw new Error(\"no DOM component ID specified\");\n      this.#n = e.domComponentId, this._addElementMessageHandler(\"elem-focused\", (e2) => e2._onElemFocused()), this._addElementMessageHandler(\"elem-blurred\", (e2) => {\n        e2 && e2._onElemBlurred();\n      });\n    }\n    _addElement(e) {\n      const n = this.#t++;\n      return this.#s.set(n, e), n;\n    }\n    _removeElement(e) {\n      this.#s.delete(e);\n    }\n    _addElementMessageHandler(e, n) {\n      this.#e.GetRuntime().AddDOMComponentMessageHandler(this.#n, e, (e2) => {\n        const t = this.#s.get(e2[\"elementId\"]);\n        n(t, e2);\n      });\n    }\n    _addElementMessageHandlers(e) {\n      C3X.RequireArray(e);\n      for (const [n, t] of e) this._addElementMessageHandlers(n, t);\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();\n  self.ISDKObjectTypeBase = class extends self.IObjectType {\n    #e;\n    constructor() {\n      super(), this.#e = C33.AddonManager._GetInitObject2(internalApiToken);\n    }\n    _onCreate() {\n    }\n    getImageInfo() {\n      return this.#e.GetImageInfo().GetIImageInfo();\n    }\n    _loadTextures(e) {\n    }\n    _releaseTextures(e) {\n    }\n    _onDynamicTextureLoadComplete() {\n    }\n    _preloadTexturesWithInstances(e) {\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();\n  self.ISDKWorldInstanceBase = class extends self.IWorldInstanceSDKBase {\n    #e;\n    #r = null;\n    #t = null;\n    constructor(e) {\n      super(e), this.#e = C33.AddonManager._GetInitObject2(internalApiToken);\n    }\n    _release() {\n      if (super._release(), this.#r) {\n        const e = this.#e.GetRuntime().Dispatcher();\n        e.removeEventListener(\"renderercontextlost\", this.#r), e.removeEventListener(\"renderercontextrestored\", this.#t), this.#r = null, this.#t = null;\n      }\n    }\n    _handleRendererContextLoss() {\n      if (this.#r) return;\n      this.#r = () => this._onRendererContextLost(), this.#t = () => this._onRendererContextRestored();\n      const e = this.#e.GetRuntime().Dispatcher();\n      e.addEventListener(\"renderercontextlost\", this.#r), e.addEventListener(\"renderercontextrestored\", this.#t);\n    }\n    _onRendererContextLost() {\n    }\n    _onRendererContextRestored() {\n    }\n    _draw(e) {\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, tempRect = C33.New(C33.Rect), map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();\n  self.ISDKDOMInstanceBase = class extends self.ISDKWorldInstanceBase {\n    #e = -1;\n    #t = true;\n    #s = false;\n    #i = false;\n    #n = -0.2;\n    #o = C33.New(C33.Rect, 0, 0, -1, -1);\n    #l = 0;\n    #a = 0;\n    #h = -1;\n    #d = -1;\n    #m = false;\n    constructor(e) {\n      if (!e?.domComponentId) throw new Error(\"no DOM component ID specified\");\n      super(e);\n      const t = C33.AddonManager._GetInitObject2(internalApiToken);\n      map.set(this, t), this.#e = this.plugin._addElement(this);\n      const s = t.GetRuntime().GetCanvasManager();\n      this.#l = s.GetLastWidth(), this.#a = s.GetLastHeight(), this._setTicking(true);\n    }\n    _release() {\n      super._release(), this.plugin._removeElement(this.#e), this._postToDOMElement(\"destroy\"), this.#e = -1, map.delete(this);\n    }\n    _getElementInDOMMode() {\n      if (map.get(this).GetRuntime().IsInWorker()) throw new Error(\"not valid in worker mode\");\n      return this._postToDOMElementMaybeSync(\"get-element\");\n    }\n    _postToDOMElement(e, t) {\n      t || (t = {}), t[\"elementId\"] = this.#e, this._postToDOM(e, t);\n    }\n    _postToDOMElementMaybeSync(e, t) {\n      return t || (t = {}), t[\"elementId\"] = this.#e, this._postToDOMMaybeSync(e, t);\n    }\n    _postToDOMElementAsync(e, t) {\n      return t || (t = {}), t[\"elementId\"] = this.#e, this._postToDOMAsync(e, t);\n    }\n    _createElement(e) {\n      e || (e = {});\n      const t = map.get(this).GetWorldInfo();\n      e[\"elementId\"] = this.#e, e[\"isVisible\"] = t.IsVisible(), e[\"htmlIndex\"] = t.GetLayer().GetHTMLIndex(), e[\"htmlZIndex\"] = t.GetHTMLZIndex(), Object.assign(e, this._getElementState()), this.#t = !!e[\"isVisible\"], this._postToDOMMaybeSync(\"create\", e), this._updatePosition(true);\n    }\n    setElementVisible(e) {\n      e = !!e, this.#t !== e && (this.#t = e, this._postToDOMElement(\"set-visible\", { \"isVisible\": e }));\n    }\n    _tick() {\n      this._updatePosition(false);\n    }\n    _shouldPreserveElement() {\n      const e = map.get(this).GetRuntime().GetCanvasManager().GetFullscreenMode();\n      return \"Android\" === C33.Platform.OS && (\"scale-inner\" === e || \"scale-outer\" === e || \"crop\" === e);\n    }\n    _updatePosition(e) {\n      const t = map.get(this);\n      if (t.IsDestroyed()) return;\n      const s = t.GetWorldInfo(), i = s.GetLayer(), n = s.GetBoundingBox();\n      let [o, l] = i.LayerToCanvasCss(n.getLeft(), n.getTop()), [a, h] = i.LayerToCanvasCss(n.getRight(), n.getBottom());\n      const d = t.GetRuntime().GetCanvasManager(), m = d.GetCssWidth(), r = d.GetCssHeight();\n      if (!s.IsVisible() || !i.IsVisible()) return void this.setElementVisible(false);\n      if (!this._shouldPreserveElement() && (a <= 0 || h <= 0 || o >= m || l >= r)) return void this.setElementVisible(false);\n      tempRect.set(o, l, a, h);\n      const c = d.GetLastWidth(), p = d.GetLastHeight(), u = i.GetHTMLIndex(), M = s.GetHTMLZIndex();\n      if (!e && tempRect.equals(this.#o) && this.#l === c && this.#a === p && this.#h === u && this.#d === M) return void this.setElementVisible(true);\n      this.#o.copy(tempRect), this.#l = c, this.#a = p, this.#h = u, this.#d = M, this.setElementVisible(true);\n      let I = null;\n      this.#i && (I = i.GetDisplayScale() + this.#n), this._postToDOMElement(\"update-position\", { \"left\": Math.round(this.#o.getLeft()), \"top\": Math.round(this.#o.getTop()), \"width\": Math.round(this.#o.width()), \"height\": Math.round(this.#o.height()), \"htmlIndex\": u, \"htmlZIndex\": M, \"fontSize\": I });\n    }\n    focusElement() {\n      this._postToDOMElementMaybeSync(\"focus\", { \"focus\": true });\n    }\n    blurElement() {\n      this._postToDOMElementMaybeSync(\"focus\", { \"focus\": false });\n    }\n    _onElemFocused() {\n      this.#s = true;\n    }\n    _onElemBlurred() {\n      this.#s = false;\n    }\n    isElementFocused() {\n      return this.#s;\n    }\n    setElementCSSStyle(e, t) {\n      this.postToDOMElement(\"set-css-style\", { \"prop\": C33.CSSToCamelCase(e), \"val\": t });\n    }\n    setElementAttribute(e, t) {\n      this.postToDOMElement(\"set-attribute\", { \"name\": e, \"val\": t });\n    }\n    removeElementAttribute(e) {\n      this.postToDOMElement(\"remove-attribute\", { \"name\": e });\n    }\n    _updateElementState() {\n      this.#m || (this.#m = true, Promise.resolve().then(() => {\n        this.#m = false, this._postToDOMElement(\"update-state\", this._getElementState());\n      }));\n    }\n    _getElementState() {\n    }\n    _getElementId() {\n      return this.#e;\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  self.ISDKBehaviorBase = class extends self.IBehavior {\n    constructor() {\n      super();\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  self.ISDKBehaviorTypeBase = class extends globalThis.IBehaviorType {\n    constructor() {\n      super();\n    }\n    _onCreate() {\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), internalApiToken = C33._GetInternalAPIToken();\n  self.ISDKBehaviorInstanceBase = class extends self.IBehaviorInstance {\n    #i = false;\n    #t = false;\n    #e = false;\n    constructor() {\n      super(), map.set(this, C33.AddonManager._GetInitObject2(internalApiToken));\n    }\n    _release() {\n      super._release(), this._setTicking(false), this._setTicking2(false), this._setPostTicking(false), map.delete(this);\n    }\n    _getInitProperties() {\n      return C33.AddonManager._GetInitProperties();\n    }\n    _postCreate() {\n    }\n    _trigger(i) {\n      const t = map.get(this);\n      t.GetRuntime().Trigger(i, t.GetObjectInstance(), t.GetBehaviorType());\n    }\n    _triggerAsync(i) {\n      const t = map.get(this);\n      return t.GetRuntime().TriggerAsync(i, t.GetObjectInstance(), t.GetBehaviorType());\n    }\n    _setTicking(i) {\n      if (i = !!i, this.#i === i) return;\n      this.#i = i;\n      const t = map.get(this).GetRuntime();\n      i ? t._AddBehInstToTick(this) : t._RemoveBehInstToTick(this);\n    }\n    _isTicking() {\n      return this.#i;\n    }\n    _tick() {\n    }\n    _setTicking2(i) {\n      if (i = !!i, this.#t === i) return;\n      this.#t = i;\n      const t = map.get(this).GetRuntime();\n      i ? t._AddBehInstToTick2(this) : t._RemoveBehInstToTick2(this);\n    }\n    _isTicking2() {\n      return this.#t;\n    }\n    _tick2() {\n    }\n    _setPostTicking(i) {\n      if (i = !!i, this.#e === i) return;\n      this.#e = i;\n      const t = map.get(this).GetRuntime();\n      i ? t._AddBehInstToPostTick(this) : t._RemoveBehInstToPostTick(this);\n    }\n    _isPostTicking() {\n      return this.#e;\n    }\n    _postTick() {\n    }\n    _getDebuggerProperties() {\n      return [];\n    }\n    _saveToJson() {\n      return null;\n    }\n    _loadFromJson(i) {\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  let runtime = null;\n  self.ISDKUtils = class {\n    constructor(e) {\n      runtime = e;\n    }\n    addLoadPromise(e) {\n      runtime.AddLoadPromise(e);\n    }\n    sendWrapperExtensionMessage(e, n, t) {\n      C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t), runtime.SendWrapperExtensionMessage(e, n, t);\n    }\n    sendWrapperExtensionMessageAsync(e, n, t) {\n      return C3X.RequireString(e), C3X.RequireString(n), C3X.RequireOptionalArray(t), runtime.SendWrapperExtensionMessageAsync(e, n, t);\n    }\n    createLoopingConditionContext(e) {\n      return C3X.RequireOptionalString(e), new self.ILoopingConditionContext(runtime, e);\n    }\n    set isAutoSuspendEnabled(e) {\n      runtime._SetAutoSuspendEnabled(!!e);\n    }\n    get isAutoSuspendEnabled() {\n      return runtime._IsAutoSuspendEnabled();\n    }\n    setSuspended(e) {\n      runtime.SetSuspended(!!e);\n    }\n    getObjectClassBySid(e) {\n      C3X.RequireNumber(e);\n      const n = runtime.GetObjectClassBySID(e);\n      return n ? n.GetIObjectClass() : null;\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  self.ILoopingConditionContext = class {\n    #e;\n    #t;\n    #o;\n    #n;\n    #s;\n    #r;\n    constructor(e, t) {\n      this.#e = e;\n      const o = e.GetEventSheetManager(), n = e.GetCurrentEvent();\n      this.#t = n, this.#o = n.GetSolModifiers();\n      const s = e.GetEventStack();\n      this.#n = s.GetCurrentStackFrame(), this.#s = s.Push(n);\n      const r = o.GetLoopStack().Push();\n      this.#r = r, t && r.SetName(t), e.SetDebuggingEnabled(false);\n    }\n    retrigger() {\n      const e = this.#e.GetEventSheetManager(), t = this.#o, o = this.#r;\n      e.PushCopySol(t), this.#t.Retrigger(this.#n, this.#s), e.PopSol(t), o.SetIndex(o.GetIndex() + 1);\n    }\n    get isStopped() {\n      return this.#r.IsStopped();\n    }\n    release() {\n      const e = this.#e, t = e.GetEventStack(), o = e.GetEventSheetManager().GetLoopStack();\n      e.SetDebuggingEnabled(true), o.Pop(), t.Pop();\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X;\n  let renderer = null, runtime = null;\n  self.IRenderer = class {\n    constructor(e, r) {\n      runtime = e, renderer = r;\n    }\n    setAlphaBlendMode() {\n      renderer.SetAlphaBlend();\n    }\n    setBlendMode(e) {\n      renderer.SetNamedBlendMode(e);\n    }\n    setColorFillMode() {\n      renderer.SetColorFillMode();\n    }\n    setTextureFillMode() {\n      renderer.SetTextureFillMode();\n    }\n    setSmoothLineFillMode() {\n      renderer.SetSmoothLineFillMode();\n    }\n    setColor(e) {\n      renderer.SetColorRgba(e[0], e[1], e[2], e[3]);\n    }\n    setColorRgba(e, r, n, t) {\n      renderer.SetColorRgba(e, r, n, t);\n    }\n    resetColor() {\n      renderer.ResetColor();\n    }\n    setOpacity(e) {\n      renderer.SetOpacity(e);\n    }\n    setCurrentZ(e) {\n      renderer.SetCurrentZ(e);\n    }\n    getCurrentZ() {\n      renderer.GetCurrentZ();\n    }\n    rect(e) {\n      renderer.Rect2(e.left, e.top, e.right, e.bottom);\n    }\n    rect2(e, r, n, t) {\n      renderer.Rect2(e, r, n, t);\n    }\n    quad(e) {\n      renderer.Quad(C33.Quad.fromDOMQuad(e));\n    }\n    quad2(e, r, n, t, a, d, o, i) {\n      renderer.Quad2(e, r, n, t, a, d, o, i);\n    }\n    quad3(e, r) {\n      renderer.Quad3(C33.Quad.fromDOMQuad(e), C33.Rect.fromDOMRect(r));\n    }\n    quad4(e, r) {\n      renderer.Quad4(C33.Quad.fromDOMQuad(e), C33.Quad.fromDOMQuad(r));\n    }\n    quad3D(e, r, n, t, a, d, o, i, u, l, p, s, c) {\n      renderer.Quad3D(e, r, n, t, a, d, o, i, u, l, p, s, C33.Rect.fromDOMRect(c));\n    }\n    quad3D2(e, r, n, t, a, d, o, i, u, l, p, s, c) {\n      renderer.Quad3D2(e, r, n, t, a, d, o, i, u, l, p, s, C33.Quad.fromDOMQuad(c));\n    }\n    drawMesh(e, r, n) {\n      renderer.DrawMesh(e, r, n);\n    }\n    convexPoly(e) {\n      renderer.ConvexPoly(e);\n    }\n    line(e, r, n, t) {\n      renderer.Line(e, r, n, t);\n    }\n    texturedLine(e, r, n, t, a, d) {\n      renderer.TexturedLine(e, r, n, t, a, d);\n    }\n    lineRect(e, r, n, t) {\n      renderer.LineRect(e, r, n, t);\n    }\n    lineRect2(e) {\n      renderer.LineRect2(C33.Rect.fromDOMRect(e));\n    }\n    lineQuad(e) {\n      renderer.LineQuad(C33.Quad.fromDOMQuad(e));\n    }\n    pushLineWidth(e) {\n      renderer.PushLineWidth(e);\n    }\n    popLineWidth() {\n      renderer.PopLineWidth();\n    }\n    pushLineCap(e) {\n      renderer.PushLineCap(e);\n    }\n    popLineCap() {\n      renderer.PopLineCap();\n    }\n    setTexture(e) {\n      C3X.RequireOptionalInstanceOf(e, self.ITexture);\n      const r = e ? runtime._UnwrapScriptInterface(e) : null;\n      renderer.SetTexture(r);\n    }\n    loadTextureForImageInfo(e, r) {\n      const n = self.IImageInfo._Unwrap(e);\n      if (!n) throw new Error(\"invalid IImageInfo\");\n      return n.LoadStaticTexture(renderer, { wrapX: r?.wrapX ?? \"clamp-to-edge\", wrapY: r?.wrapY ?? \"clamp-to-edge\", sampling: r?.sampling ?? \"trilinear\", mipMap: r?.mipMap ?? true });\n    }\n    releaseTextureForImageInfo(e) {\n      const r = self.IImageInfo._Unwrap(e);\n      if (!r) throw new Error(\"invalid IImageInfo\");\n      r.ReleaseTexture();\n    }\n    getTextureForImageInfo(e) {\n      const r = self.IImageInfo._Unwrap(e);\n      if (!r) throw new Error(\"invalid IImageInfo\");\n      const n = r.GetTexture();\n      return self.ITexture.GetInterface(runtime, n);\n    }\n    createDynamicTexture(e, r, n) {\n      C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(r);\n      const t = renderer.CreateDynamicTexture(e, r, { wrapX: n?.wrapX ?? \"clamp-to-edge\", wrapY: n?.wrapY ?? \"clamp-to-edge\", sampling: n?.sampling ?? \"trilinear\", mipMap: n?.mipMap ?? true });\n      return self.ITexture.GetInterface(runtime, t);\n    }\n    updateTexture(e, r, n) {\n      C3X.RequireInstanceOf(r, self.ITexture);\n      const t = runtime._UnwrapScriptInterface(r);\n      renderer.UpdateTexture(e, t, { premultiplyAlpha: n?.premultiplyAlpha ?? true });\n    }\n    deleteTexture(e) {\n      C3X.RequireInstanceOf(e, self.ITexture);\n      const r = runtime._UnwrapScriptInterface(e);\n      renderer.DeleteTexture(r);\n    }\n    createRendererText() {\n      const e = renderer.CreateRendererText();\n      return new self.IRendererText(runtime, e);\n    }\n    setDeviceTransform() {\n      runtime.GetCanvasManager().SetDeviceTransform(renderer);\n    }\n    setLayerTransform(e) {\n      C3X.RequireInstanceOf(e, globalThis.ILayer);\n      runtime._UnwrapScriptInterface(e)._SetTransform(renderer);\n    }\n  };\n}\n{\n  const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap(), reverseMap = /* @__PURE__ */ new WeakMap();\n  self.ITexture = class {\n    constructor(e, t) {\n      map.set(this, { runtime: e, texture: t }), reverseMap.set(t, this), e._MapScriptInterface(this, t), Object.defineProperties(this, { width: { value: t.GetWidth(), writable: false }, height: { value: t.GetHeight(), writable: false } });\n    }\n    static GetInterface(e, t) {\n      if (!t) return null;\n      const r = reverseMap.get(t);\n      return r || new self.ITexture(e, t);\n    }\n  };\n}\n{\n  let getActual = function(t) {\n    return map.get(t).rendererText;\n  };\n  getActual2 = getActual;\n  const C33 = self.C3, C3X = self.C3X, map = /* @__PURE__ */ new WeakMap();\n  self.IRendererText = class {\n    constructor(t, e) {\n      map.set(this, { runtime: t, rendererText: e }), t._MapScriptInterface(this, e);\n    }\n    release() {\n      getActual(this).Release();\n    }\n    set fontFace(t) {\n      C3X.RequireString(t), getActual(this).SetFontName(t);\n    }\n    get fontFace() {\n      return getActual(this).GetFontName();\n    }\n    set sizePt(t) {\n      C3X.RequireFiniteNumber(t), getActual(this).SetFontSize(t);\n    }\n    get sizePt() {\n      return getActual(this).GetFontSize();\n    }\n    set lineHeight(t) {\n      C3X.RequireFiniteNumber(t), getActual(this).SetLineHeight(t);\n    }\n    get lineHeight() {\n      return getActual(this).GetLineHeight();\n    }\n    set isBold(t) {\n      getActual(this).SetBold(t);\n    }\n    get isBold() {\n      return getActual(this).IsBold();\n    }\n    set isItalic(t) {\n      getActual(this).SetItalic(t);\n    }\n    get isItalic() {\n      return getActual(this).IsItalic();\n    }\n    setColor(t) {\n      C3X.RequireArray(t), this.setColorRgb(t[0], t[1], t[2]);\n    }\n    setColorRgb(t, e, i) {\n      getActual(this).SetColorRgb(t, e, i);\n    }\n    setCssColor(t) {\n      C3X.RequireString(t), getActual(this).SetColor(t);\n    }\n    set horizontalAlign(t) {\n      getActual(this).SetHorizontalAlignment(t);\n    }\n    get horizontalAlign() {\n      return getActual(this).GetHorizontalAlignment();\n    }\n    set verticalAlign(t) {\n      getActual(this).SetVerticalAlignment(t);\n    }\n    get verticalAlign() {\n      return getActual(this).GetVerticalAlignment();\n    }\n    set wordWrapMode(t) {\n      getActual(this).SetWordWrapMode(t);\n    }\n    get wordWrapMode() {\n      return getActual(this).GetWordWrapMode();\n    }\n    set textDirection(t) {\n      getActual(this).SetTextDirection(t);\n    }\n    get textDirection() {\n      return getActual(this).GetTextDirection();\n    }\n    set text(t) {\n      C3X.RequireString(t), getActual(this).SetText(t);\n    }\n    get text() {\n      return getActual(this).GetText();\n    }\n    setSize(t, e, i) {\n      C3X.RequireFiniteNumber(t), C3X.RequireFiniteNumber(e), C3X.RequireFiniteNumber(i), getActual(this).SetSize(t, e, i);\n    }\n    getTexture() {\n      const { runtime: t, rendererText: e } = map.get(this), i = e.GetTexture();\n      return self.ITexture.GetInterface(t, i);\n    }\n    getTexRect() {\n      return getActual(this).GetTexRect().toDOMRect();\n    }\n    setTextureUpdateCallback(t) {\n      C3X.RequireFunction(t), getActual(this).ontextureupdate = t;\n    }\n    releaseTexture() {\n      getActual(this).ReleaseTexture();\n    }\n    get textWidth() {\n      return getActual(this).GetTextWidth();\n    }\n    get textHeight() {\n      return getActual(this).GetTextHeight();\n    }\n  };\n}\nvar getActual2;\n{\n  let GetTypeFromFileExtension = function(e) {\n    if (!e) return \"\";\n    const t = e.split(\".\");\n    if (t.length < 2) return \"\";\n    const i = t.at(-1).toLowerCase();\n    return EXT_TO_TYPE.get(i) || \"\";\n  }, AddScript = function(e) {\n    return new Promise((t, i) => {\n      const s = document.createElement(\"script\");\n      s.onload = t, s.onerror = i, s.async = false, s.type = \"module\", s.src = e, document.head.appendChild(s);\n    });\n  };\n  GetTypeFromFileExtension2 = GetTypeFromFileExtension, AddScript2 = AddScript;\n  const C33 = self.C3, VALID_LOAD_POLICIES = /* @__PURE__ */ new Set([\"local\", \"remote\"]), EXT_TO_TYPE = /* @__PURE__ */ new Map([[\"mp4\", \"video/mp4\"], [\"webm\", \"video/webm\"], [\"m4a\", \"audio/mp4\"], [\"mp3\", \"audio/mpeg\"], [\"js\", \"application/javascript\"], [\"wasm\", \"application/wasm\"], [\"svg\", \"image/svg+xml\"], [\"html\", \"text/html\"]]);\n  C33.AssetManager = class extends C33.DefendedBase {\n    constructor(e, t) {\n      super();\n      const i = t[\"exportType\"];\n      this._runtime = e, this._fileStructure = \"folders\", this._cordovaBlobUrlCache = /* @__PURE__ */ new Map(), this._isCordova = \"cordova\" === i, this._isiOSCordova = !!t[\"isiOSCordova\"], this._isFileProtocol = !!t[\"isFileProtocol\"], this._swClientId = t[\"swClientId\"], this._supportedAudioFormats = t[\"supportedAudioFormats\"] || {}, this._audioFiles = /* @__PURE__ */ new Map(), this._preloadSounds = false, this._scriptSubfolder = t[\"scriptFolder\"], this._mediaSubfolder = \"\", this._fontsSubfolder = \"\", this._iconsSubfolder = \"\", this._fileMap = t[\"fileMap\"] || /* @__PURE__ */ new Map(), this._fileMapBlobUrls = /* @__PURE__ */ new Map();\n      const s = \"html5\" === i || \"scirra-arcade\" === i || \"instant-games\" === i;\n      this._defaultLoadPolicy = s ? \"remote\" : \"local\", this._imageAssetsMap = /* @__PURE__ */ new Map(), this._webFonts = [], this._loadPromises = [], this._hasFinishedInitialLoad = false, this._totalAssetSizeToLoad = 0, this._assetSizeLoaded = 0, this._lastLoadProgress = 0, this._hasHadErrorLoading = false, this._loadingRateLimiter = C33.New(C33.RateLimiter, () => this._FireLoadingProgressEvent(), 50), this._localPromiseThrottle = C33.New(C33.PromiseThrottle, Math.max(C33.hardwareConcurrency, 8)), this._remotePromiseThrottle = C33.New(C33.PromiseThrottle, 20), this._iAssetManager = new self.IAssetManager(this);\n    }\n    Release() {\n      for (const e of this._imageAssetsMap.values()) e.Release();\n      this._imageAssetsMap.clear(), C33.clearArray(this._loadPromises), this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    _SetFileStructure(e) {\n      this._fileStructure = e;\n    }\n    GetFileStructure() {\n      return this._fileStructure;\n    }\n    GetScriptSubfolder() {\n      return this._scriptSubfolder;\n    }\n    _SetMediaSubfolder(e) {\n      this._mediaSubfolder = e;\n    }\n    GetMediaSubfolder() {\n      return this._mediaSubfolder;\n    }\n    _SetFontsSubfolder(e) {\n      this._fontsSubfolder = e;\n    }\n    GetFontsSubfolder() {\n      return this._fontsSubfolder;\n    }\n    _SetIconsSubfolder(e) {\n      this._iconsSubfolder = e;\n    }\n    GetIconsSubfolder() {\n      return this._iconsSubfolder;\n    }\n    IsFileProtocol() {\n      return this._isFileProtocol;\n    }\n    FetchBlob(e, t) {\n      return t = t || this._defaultLoadPolicy, C33.IsRelativeURL(e) ? (\"flat\" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(e) : \"playable-ad-single-file\" === this._runtime.GetExportType() ? self[\"c3_runtimeInterface\"][\"_PlayableAdFetchBlob\"](e) : \"local\" === t ? this._localPromiseThrottle.Add(() => C33.FetchBlob(e)) : this._remotePromiseThrottle.Add(() => C33.FetchBlob(e))) : C33.FetchBlob(e);\n    }\n    FetchArrayBuffer(e) {\n      return C33.IsRelativeURL(e) ? (\"flat\" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(e) : \"playable-ad-single-file\" === this._runtime.GetExportType() ? C33.BlobToArrayBuffer(self[\"c3_runtimeInterface\"][\"_PlayableAdFetchBlob\"](e)) : \"local\" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add(() => C33.FetchArrayBuffer(e)) : this._remotePromiseThrottle.Add(() => C33.FetchArrayBuffer(e))) : C33.FetchArrayBuffer(e);\n    }\n    FetchText(e) {\n      return C33.IsRelativeURL(e) ? (\"flat\" === this._fileStructure && (e = e.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(e) : \"playable-ad-single-file\" === this._runtime.GetExportType() ? C33.BlobToString(self[\"c3_runtimeInterface\"][\"_PlayableAdFetchBlob\"](e)) : \"local\" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add(() => C33.FetchText(e)) : this._remotePromiseThrottle.Add(() => C33.FetchText(e))) : C33.FetchText(e);\n    }\n    async FetchJson(e) {\n      const t = await this.FetchText(e);\n      return JSON.parse(t);\n    }\n    _CordovaFetchLocalFileAs(e, t) {\n      return \"flat\" === this._fileStructure && (e = e.toLowerCase()), this._runtime.PostComponentMessageToDOMAsync(\"runtime\", \"cordova-fetch-local-file\", { \"filename\": e, \"as\": t });\n    }\n    CordovaFetchLocalFileAsText(e) {\n      return this._CordovaFetchLocalFileAs(e, \"text\");\n    }\n    async CordovaFetchLocalFileAsBlob(e) {\n      const t = await this._CordovaFetchLocalFileAs(e, \"buffer\"), i = GetTypeFromFileExtension(e);\n      return new Blob([t], { \"type\": i });\n    }\n    async CordovaFetchLocalFileAsBlobURL(e) {\n      \"flat\" === this._fileStructure && (e = e.toLowerCase());\n      let t = this._cordovaBlobUrlCache.get(e);\n      if (t) return t;\n      const i = await this.CordovaFetchLocalFileAsBlob(e);\n      return t = URL.createObjectURL(i), this._cordovaBlobUrlCache.set(e, t), t;\n    }\n    CordovaFetchLocalFileAsArrayBuffer(e) {\n      return this._CordovaFetchLocalFileAs(e, \"buffer\");\n    }\n    GetMediaFileUrl(e) {\n      \"flat\" === this._fileStructure && (e = e.toLowerCase());\n      let t = this._mediaSubfolder + e;\n      return \"Gecko\" === C33.Platform.BrowserEngine && \"preview\" === this._runtime.GetExportType() && (t = this._GetLocalBlobURLFromFileMap(t)), t;\n    }\n    GetProjectFileUrl(e) {\n      return C33.IsAbsoluteURL(e) ? Promise.resolve(e) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(e) : \"playable-ad-single-file\" === this._runtime.GetExportType() ? URL.createObjectURL(self[\"c3_runtimeInterface\"][\"_PlayableAdFetchBlob\"](e)) : (\"flat\" === this._fileStructure && (e = e.toLowerCase()), Promise.resolve(e));\n    }\n    GetProjectFileIframeUrl(e) {\n      if (C33.IsAbsoluteURL(e) || \"preview\" !== this._runtime.GetExportType() || !this._swClientId || !e) return e;\n      try {\n        const t = new URL(e, location.href);\n        return t.searchParams.set(\"__c3_client_id\", this._swClientId), t.toString();\n      } catch (t) {\n        return console.warn(\"Invalid iframe URL: \" + e), e;\n      }\n    }\n    LoadProjectFileUrl(e) {\n      return this.GetProjectFileUrl(e);\n    }\n    _GetImageAssetKey(e, t) {\n      return (t ? \"true\" : \"false\") + \"|\" + e;\n    }\n    LoadImage(e) {\n      const t = !!e.isTiled;\n      if (e.loadPolicy && !VALID_LOAD_POLICIES.has(e.loadPolicy)) throw new Error(\"invalid load policy\");\n      const i = this._GetImageAssetKey(e.url, t);\n      let s = this._imageAssetsMap.get(i);\n      return s || (s = C33.New(C33.ImageAsset, this, { url: e.url, size: e.size || 0, loadPolicy: e.loadPolicy || this._defaultLoadPolicy, isTiled: t }), this._imageAssetsMap.set(i, s), this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += s.GetSize(), this._loadPromises.push(s.Load().then(() => this._AddLoadedSize(s.GetSize())))), s);\n    }\n    _ReleaseImageAsset(e) {\n      const t = this._GetImageAssetKey(e.GetURL(), e.IsTiled());\n      this._imageAssetsMap.delete(t);\n    }\n    async WaitForAllToLoad() {\n      try {\n        await Promise.all(this._loadPromises), this._lastLoadProgress = 1;\n      } catch (e) {\n        console.error(\"Error loading: \", e), this._hasHadErrorLoading = true, this._FireLoadingProgressEvent();\n      }\n    }\n    SetInitialLoadFinished() {\n      this._hasFinishedInitialLoad = true;\n    }\n    HasHadErrorLoading() {\n      return this._hasHadErrorLoading;\n    }\n    _AddLoadedSize(e) {\n      this._assetSizeLoaded += e, this._loadingRateLimiter.Call();\n    }\n    _FireLoadingProgressEvent() {\n      const e = C33.New(C33.Event, \"loadingprogress\");\n      this._lastLoadProgress = C33.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1), e.progress = this._lastLoadProgress, this._runtime.Dispatcher().dispatchEvent(e), this._runtime.DispatchUserScriptEvent(C33.New(C33.Event, \"loadingprogress\"));\n    }\n    GetLoadProgress() {\n      return this._lastLoadProgress;\n    }\n    GetImageLoadProgress() {\n      return this._runtime.GetSystemPlugin().GetImageLoadingProgress();\n    }\n    _SetWebFonts(e) {\n      C33.shallowAssignArray(this._webFonts, e), this._webFonts.length && this._loadPromises.push(this._LoadWebFonts());\n    }\n    async _LoadWebFonts() {\n      const e = [], t = [];\n      for (const [i, s, o] of this._webFonts) this._totalAssetSizeToLoad += o, e.push(this._LoadWebFont(i, s, t).then(() => this._AddLoadedSize(o)));\n      await Promise.all(e), this._runtime.IsInWorker() && t.length > 0 && await this._runtime.PostComponentMessageToDOMAsync(\"runtime\", \"load-webfonts\", { \"webfonts\": t });\n    }\n    async _LoadWebFont(e, t, i) {\n      try {\n        let s = await this.GetProjectFileUrl(t);\n        \"Gecko\" === C33.Platform.BrowserEngine && (e = `'${e}'`), (\"Gecko\" === C33.Platform.BrowserEngine && \"preview\" === this._runtime.GetExportType() || \"playable-ad-single-file\" === this._runtime.GetExportType()) && (s = this._GetLocalBlobURLFromFileMap(s));\n        const o = new FontFace(e, `url('${s}')`);\n        this._runtime.IsInWorker() ? self.fonts.add(o) : document.fonts.add(o), await o.load(), this._runtime.IsInWorker() && i.push({ name: e, url: s });\n      } catch (t2) {\n        console.warn(`[C3 runtime] Failed to load web font '${e}': `, t2);\n      }\n    }\n    IsAudioFormatSupported(e) {\n      return !!this._supportedAudioFormats[e];\n    }\n    _SetAudioFiles(e, t) {\n      this._preloadSounds = !!t;\n      for (const [t2, i, s] of e) this._audioFiles.set(t2, { fileName: t2, formats: i.map((e2) => ({ type: e2[0], fileExtension: e2[1], fullName: t2 + e2[1], fileSize: e2[2] })), isMusic: s });\n    }\n    GetPreferredAudioFile(e) {\n      \"flat\" === this._fileStructure && (e = e.toLowerCase());\n      const t = this._audioFiles.get(e);\n      if (!t) return null;\n      let i = null;\n      for (const e2 of t.formats) if (i || \"audio/webm; codecs=opus\" !== e2.type || (i = e2), this.IsAudioFormatSupported(e2.type)) return e2;\n      return i;\n    }\n    GetProjectAudioFileUrl(e) {\n      const t = this.GetPreferredAudioFile(e);\n      return t ? { url: this.GetMediaFileUrl(t.fullName), type: t.type } : null;\n    }\n    GetAudioToPreload() {\n      if (this._preloadSounds) {\n        const e = [];\n        for (const t of this._audioFiles.values()) {\n          if (t.isMusic) continue;\n          const i = this.GetPreferredAudioFile(t.fileName);\n          i && e.push({ originalUrl: t.fileName, url: this.GetMediaFileUrl(i.fullName), type: i.type, fileSize: i.fileSize });\n        }\n        return e;\n      }\n      return [];\n    }\n    _GetLocalBlobFromFileMap(e) {\n      return \"preview\" === this._runtime.GetExportType() && (e = new URL(e, location.href).toString()), this._fileMap.get(e) || null;\n    }\n    _GetLocalBlobURLFromFileMap(e) {\n      let t = this._fileMapBlobUrls.get(e);\n      if (t) return t;\n      const i = this._GetLocalBlobFromFileMap(e);\n      return i ? (t = URL.createObjectURL(i), this._fileMapBlobUrls.set(e, t), t) : e;\n    }\n    GetIAssetManager() {\n      return this._iAssetManager;\n    }\n    async LoadScripts(...e) {\n      const t = await Promise.all(e.map((e2) => this.GetProjectFileUrl(e2)));\n      if (this._runtime.IsInWorker()) if (1 === e.length) {\n        const t2 = e[0];\n        await import((C33.IsRelativeURL(t2) ? \"./\" : \"\") + t2);\n      } else {\n        const t2 = e.map((e2) => `import \"${C33.IsRelativeURL(e2) ? \"./\" : \"\"}${e2}\";`).join(\"\\n\"), i = URL.createObjectURL(new Blob([t2], { type: \"application/javascript\" }));\n        await import(i);\n      }\n      else await Promise.all(t.map((e2) => AddScript(e2)));\n    }\n    async CompileWebAssembly(e) {\n      if (WebAssembly.compileStreaming) {\n        const t = await this.GetProjectFileUrl(e);\n        return await WebAssembly.compileStreaming(fetch(t));\n      }\n      {\n        const t = await C33.FetchArrayBuffer(e);\n        return await WebAssembly.compile(t);\n      }\n    }\n    async LoadStyleSheet(e) {\n      const t = await this.GetProjectFileUrl(e);\n      return await this._runtime.PostComponentMessageToDOMAsync(\"runtime\", \"add-stylesheet\", { \"url\": t });\n    }\n  };\n}\nvar GetTypeFromFileExtension2;\nvar AddScript2;\n{\n  const C33 = self.C3;\n  C33.Asset = class extends C33.DefendedBase {\n    constructor(s, i) {\n      super(), this._assetManager = s, this._runtime = s.GetRuntime(), this._url = i.url || \"\", this._size = i.size, this._loadPolicy = i.loadPolicy, this._blob = i.blob || null, this._isLoaded = !!this._blob, this._loadPromise = null;\n    }\n    Release() {\n      this._loadPromise = null, this._assetManager = null, this._runtime = null, this._blob = null;\n    }\n    GetURL() {\n      return this._url;\n    }\n    GetSize() {\n      return this._size;\n    }\n    Load() {\n      return \"local\" === this._loadPolicy || this._blob ? (this._isLoaded = true, Promise.resolve()) : (this._loadPromise || (this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then((s) => (this._isLoaded = true, this._loadPromise = null, this._blob = s, s)).catch((s) => {\n        console.error(\"Error loading resource: \", s), this._loadPromise = null;\n      })), this._loadPromise);\n    }\n    IsLoaded() {\n      return this._isLoaded;\n    }\n    GetBlob() {\n      return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy);\n    }\n  };\n}\n{\n  const C33 = self.C3, promiseThrottle = new C33.PromiseThrottle(), allImageAssets = /* @__PURE__ */ new Set();\n  C33.ImageAsset = class extends C33.Asset {\n    constructor(e, t) {\n      super(e, t), this._texturePromise = null, this._webglTexture = null, this._refCount = 0, this._imageWidth = -1, this._imageHeight = -1, this._isTiled = !!t.isTiled, allImageAssets.add(this);\n    }\n    Release() {\n      if (0 !== this._refCount) throw new Error(\"released image asset which still has texture references\");\n      this._assetManager._ReleaseImageAsset(this), this._texturePromise = null, allImageAssets.delete(this), super.Release();\n    }\n    static OnRendererContextLost() {\n      for (const e of allImageAssets) e._texturePromise = null, e._webglTexture = null, e._refCount = 0;\n    }\n    LoadStaticTexture(e, t) {\n      return t = t || {}, this._refCount++, this._webglTexture ? Promise.resolve(this._webglTexture) : (this._texturePromise || (t.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy(), this._texturePromise = this._DoLoadStaticTexture(e, t)), this._texturePromise);\n    }\n    async _DoLoadStaticTexture(e, t) {\n      try {\n        const s = await this.GetBlob();\n        return 0 === this._refCount ? (this._texturePromise = null, null) : await promiseThrottle.Add(async () => {\n          const r = await e.CreateStaticTextureAsync(s, t);\n          return this._texturePromise = null, 0 === this._refCount ? (e.DeleteTexture(r), null) : (this._webglTexture = r, this._imageWidth = r.GetWidth(), this._imageHeight = r.GetHeight(), this._webglTexture);\n        });\n      } catch (e2) {\n        throw console.error(\"Failed to load texture: \", e2), e2;\n      }\n    }\n    ReleaseTexture() {\n      if (this._refCount <= 0) throw new Error(\"texture released too many times\");\n      if (this._refCount--, 0 === this._refCount && this._webglTexture) {\n        this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture), this._webglTexture = null;\n      }\n    }\n    GetRefCount() {\n      return this._refCount;\n    }\n    GetTexture() {\n      return this._webglTexture;\n    }\n    GetWidth() {\n      return this._imageWidth;\n    }\n    GetHeight() {\n      return this._imageHeight;\n    }\n    IsTiled() {\n      return this._isTiled;\n    }\n    async LoadToDrawable() {\n      const e = await this.GetBlob();\n      return C33.Supports.ImageBitmap ? await createImageBitmap(e) : await C33.BlobToImage(e);\n    }\n  };\n}\n{\n  let SortByInstLastCachedZIndex = function(e, s) {\n    return e.GetWorldInfo()._GetLastCachedZIndex() - s.GetWorldInfo()._GetLastCachedZIndex();\n  };\n  SortByInstLastCachedZIndex2 = SortByInstLastCachedZIndex;\n  const C33 = self.C3, assert = self.assert;\n  C33.RenderCell = class extends C33.DefendedBase {\n    constructor(e, s, n) {\n      super(), this._grid = e, this._x = s, this._y = n, this._instances = [], this._isSorted = true, this._pendingRemoval = /* @__PURE__ */ new Set(), this._isAnyPendingRemoval = false;\n    }\n    Release() {\n      C33.clearArray(this._instances), this._pendingRemoval.clear(), this._grid = null;\n    }\n    Reset() {\n      C33.clearArray(this._instances), this._isSorted = true, this._pendingRemoval.clear(), this._isAnyPendingRemoval = false;\n    }\n    SetChanged() {\n      this._isSorted = false;\n    }\n    IsEmpty() {\n      return !this._instances.length || !(this._instances.length > this._pendingRemoval.size) && (this._FlushPending(), true);\n    }\n    Insert(e) {\n      if (this._pendingRemoval.has(e)) return this._pendingRemoval.delete(e), void (0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = false));\n      this._instances.push(e), this._isSorted = 1 === this._instances.length;\n    }\n    Remove(e) {\n      this._pendingRemoval.add(e), this._isAnyPendingRemoval = true, this._pendingRemoval.size >= 50 && this._FlushPending();\n    }\n    _FlushPending() {\n      this._isAnyPendingRemoval && (this._instances.length !== this._pendingRemoval.size ? (C33.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = false) : this.Reset());\n    }\n    _EnsureSorted() {\n      this._isSorted || (this._instances.sort(SortByInstLastCachedZIndex), this._isSorted = true);\n    }\n    Dump(e) {\n      this._FlushPending(), this._EnsureSorted(), this._instances.length && e.push(this._instances);\n    }\n  };\n}\nvar SortByInstLastCachedZIndex2;\n{\n  const C33 = self.C3;\n  C33.RenderGrid = class extends C33.DefendedBase {\n    constructor(e, t) {\n      super(), this._cellWidth = e, this._cellHeight = t, this._cells = C33.New(C33.PairMap);\n    }\n    Release() {\n      this._cells.Release(), this._cells = null;\n    }\n    GetCell(e, t, l) {\n      let o = this._cells.Get(e, t);\n      return o || (l ? (o = C33.New(C33.RenderCell, this, e, t), this._cells.Set(e, t, o), o) : null);\n    }\n    XToCell(e) {\n      return Math.floor(e / this._cellWidth);\n    }\n    YToCell(e) {\n      return Math.floor(e / this._cellHeight);\n    }\n    Update(e, t, l) {\n      if (t) for (let o = t.getLeft(), s = t.getRight(); o <= s; ++o) for (let s2 = t.getTop(), i = t.getBottom(); s2 <= i; ++s2) {\n        if (l && l.containsPoint(o, s2)) continue;\n        const t2 = this.GetCell(o, s2, false);\n        t2 && (t2.Remove(e), t2.IsEmpty() && this._cells.Delete(o, s2));\n      }\n      if (l) for (let o = l.getLeft(), s = l.getRight(); o <= s; ++o) for (let s2 = l.getTop(), i = l.getBottom(); s2 <= i; ++s2) t && t.containsPoint(o, s2) || this.GetCell(o, s2, true).Insert(e);\n    }\n    QueryRange(e, t) {\n      let l = this.XToCell(e.getLeft());\n      const o = this.YToCell(e.getTop()), s = this.XToCell(e.getRight()), i = this.YToCell(e.getBottom());\n      for (; l <= s; ++l) for (let e2 = o; e2 <= i; ++e2) {\n        const o2 = this.GetCell(l, e2, false);\n        o2 && o2.Dump(t);\n      }\n    }\n    MarkRangeChanged(e) {\n      let t = e.getLeft();\n      const l = e.getTop(), o = e.getRight(), s = e.getBottom();\n      for (; t <= o; ++t) for (let e2 = l; e2 <= s; ++e2) {\n        const l2 = this.GetCell(t, e2, false);\n        l2 && l2.SetChanged();\n      }\n    }\n  };\n}\n{\n  let SortByInstLastCachedZIndex = function(e, t) {\n    return e.GetWorldInfo()._GetLastCachedZIndex() - t.GetWorldInfo()._GetLastCachedZIndex();\n  }, SortByInstZElevation = function(e, t) {\n    return e.GetWorldInfo().GetZElevation() - t.GetWorldInfo().GetZElevation();\n  };\n  SortByInstLastCachedZIndex2 = SortByInstLastCachedZIndex, SortByInstZElevation2 = SortByInstZElevation;\n  const C33 = self.C3, assert = self.assert, tmpRect = new C33.Rect(), tmpQuad = new C33.Quad(), renderCellArr = [], tmpDestRect = new C33.Rect(), tmpSrcRect = new C33.Rect(), glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, mat4 = glMatrix.mat4, tempMat4 = mat4.create(), tempVec3 = vec3.create(), tempVec4 = vec4.create(), camVector = vec3.create(), lookVector = vec3.create(), upVector = vec3.create(), tempVec2 = C33.New(C33.Vector2), tempRect = C33.New(C33.Rect);\n  const tempInstanceList1 = [], tempInstanceList2 = [], tempInstancesByCameraDist = [], DEFAULT_LAYER_OPTIONS = { name: \"\", sid: -1, isDynamic: false, isVisible: true, isInteractive: true, isHTMLElementsLayer: false, backgroundColor: [1, 1, 1, 1], isTransparent: true, parallax: [1, 1], opacity: 1, isForceOwnTexture: false, renderAs3d: false, useCameraDistanceDrawOrder: false, useRenderCells: false, scaleRate: 1, blendMode: 0, zElevation: 0, initialInstancesData: [], effectListData: [], subLayersData: [] };\n  C33.Layer = class extends C33.DefendedBase {\n    constructor(e, t, s) {\n      super(), s = Object.assign({}, DEFAULT_LAYER_OPTIONS, s), this._layout = e, this._runtime = e.GetRuntime(), this._parentLayer = t, this._name = s.name, this._index = -1, this._isHTMLElementsLayer = !!s.isHTMLElementsLayer, this._htmlIndex = -1, this._sid = s.sid, this._isDynamic = !!s.isDynamic, this._isVisible = !!s.isVisible, this._isInteractive = !!s.isInteractive, this._backgroundColor = C33.New(C33.Color), this._backgroundColor.setFromJSON(s.backgroundColor), this._isTransparent = !!s.isTransparent, this._parallaxX = s.parallax[0], this._parallaxY = s.parallax[1], this._color = C33.New(C33.Color, 1, 1, 1, s.opacity), this._premultipliedColor = C33.New(C33.Color), this._isForceOwnTexture = !!s.isForceOwnTexture, this._renderAs3d = !!s.renderAs3d, this._useCameraDistanceDrawOrder = !!s.useCameraDistanceDrawOrder, this._useRenderCells = !!s.useRenderCells, this._scaleRate = s.scaleRate, this._blendMode = s.blendMode, this._curRenderTarget = null, this._scale = 1, this._zElevation = s.zElevation, this._angle = 0, this._scrollX = 0, this._scrollY = 0, this._hasOwnScrollPosition = false, this._viewport = C33.New(C33.Rect), this._viewportZ0 = C33.New(C33.Rect), this._viewport3D = C33.New(C33.Rect), this._isViewportChanged = true, this._projectionMatrix = mat4.create(), this._isProjectionMatrixChanged = true, this._modelViewMatrix = mat4.create(), this._isMVMatrixChanged = true, this._viewFrustum = C33.New(C33.Gfx.ViewFrustum), this._isViewFrustumChanged = true, this._startupInitialInstances = [], this._initialInstancesData = s.initialInstancesData, this._initialInstances = [], this._createdGlobalUids = [], this._initialUIDsToInstanceData = /* @__PURE__ */ new Map(), this._instances = [], this._zIndicesUpToDate = false, this._htmlZIndicesUpToDate = false, this._anyInstanceZElevated = false;\n      const a = this._runtime.GetCanvasManager();\n      this._effectList = C33.New(C33.EffectList, this, s.effectListData), this._effectChain = C33.New(C33.Gfx.EffectChain, a.GetEffectChainManager(), { drawContent: (e2, t2) => {\n        const s2 = t2.GetContentObject(), i = s2.GetRenderTarget();\n        e2.SetColor(s2.GetPremultipliedColor()), e2.DrawRenderTarget(i), e2.InvalidateRenderTarget(i), a.ReleaseAdditionalRenderTarget(i);\n      }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasDefaultColor = true, this._renderGrid = null, this._lastRenderList = [], this._isRenderListUpToDate = false, this._lastRenderCells = C33.New(C33.Rect, 0, 0, -1, -1), this._curRenderCells = C33.New(C33.Rect, 0, 0, -1, -1), this._iLayer = new self.ILayer(this), this._UpdatePremultipliedColor(), this.UsesRenderCells() && (this._renderGrid = C33.New(C33.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight())), this._subLayers = s.subLayersData.map((e2) => C33.Layer.CreateFromExportData(this._layout, this, e2));\n    }\n    _InitInitialInstances() {\n      for (const e of this._initialInstancesData) {\n        const t = this._runtime.GetObjectClassByIndex(e[1]);\n        this._layout._AddInitialObjectClass(t), t.GetDefaultInstanceData() || (t.SetDefaultInstanceData(e), t._SetDefaultLayerIndex(this._index)), this._initialInstances.push(e), this._initialUIDsToInstanceData.set(e[2], e);\n      }\n      C33.shallowAssignArray(this._startupInitialInstances, this._initialInstances), this._initialInstancesData = null;\n    }\n    static CreateFromExportData(e, t, s) {\n      return C33.New(C33.Layer, e, t, { name: s[0], sid: s[2], isVisible: s[3], isInteractive: s[13], isHTMLElementsLayer: s[19], backgroundColor: s[4].map((e2) => e2 / 255), isTransparent: s[5], parallax: [s[6], s[7]], opacity: s[8], isForceOwnTexture: s[9], renderAs3d: s[17], useCameraDistanceDrawOrder: s[18], useRenderCells: s[10], scaleRate: s[11], blendMode: s[12], zElevation: s[16], initialInstancesData: s[14], effectListData: s[15], subLayersData: s[20] });\n    }\n    Release() {\n      for (const e of this._subLayers) e.Release();\n      C33.clearArray(this._subLayers);\n      for (const e of this._instances) this._runtime.DestroyInstance(e);\n      C33.clearArray(this._instances), this._effectList.Release(), this._effectList = null, this._effectChain.Release(), this._effectChain = null, this._iLayer = null, this._parentLayer = null, this._layout = null, this._runtime = null;\n    }\n    WasReleased() {\n      return !this._layout;\n    }\n    GetInitialInstanceData(e) {\n      return this._initialUIDsToInstanceData.get(e);\n    }\n    CreateInitialInstances(e) {\n      const t = this._layout.IsFirstVisit(), s = this._initialInstances;\n      let a = 0;\n      for (let i = 0, r = s.length; i < r; ++i) {\n        const r2 = s[i], n = this._runtime.GetObjectClassByIndex(r2[1]);\n        let l = true;\n        if (!n.HasPersistBehavior() || t) {\n          const t2 = this._runtime.CreateInstanceFromData(r2, this, true);\n          e.push(t2), n.IsGlobal() && (l = false, this._createdGlobalUids.push(t2.GetUID()));\n        }\n        l && (s[a] = s[i], ++a);\n      }\n      C33.truncateArray(s, a), this._runtime.FlushPendingInstances(), this.SetZIndicesChanged();\n    }\n    _AddInstance(e, t) {\n      if (!e.GetPlugin().IsWorldType()) throw new Error(\"instance is not of world type\");\n      const s = e.GetWorldInfo();\n      if (s.GetLayer() !== this) throw new Error(\"instance added to wrong layer\");\n      this._instances.push(e), 0 !== s.GetZElevation() && (this._anyInstanceZElevated = true), t && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged(), this.SetZIndicesChanged(e);\n    }\n    _MaybeAddInstance(e) {\n      this._instances.includes(e) || (this._instances.push(e), 0 !== e.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e));\n    }\n    _PrependInstance(e, t) {\n      const s = e.GetWorldInfo();\n      if (s.GetLayer() !== this) throw new Error(\"instance added to wrong layer\");\n      this._instances.unshift(e), 0 !== s.GetZElevation() && (this._anyInstanceZElevated = true), this.SetZIndicesChanged(e), t && this.UsesRenderCells() && e.GetWorldInfo().SetBboxChanged();\n    }\n    _RemoveInstance(e, t) {\n      const s = this._instances.indexOf(e);\n      s < 0 || (t && this.UsesRenderCells() && e.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(s, 1), this.SetZIndicesChanged(e), this._MaybeResetAnyInstanceZElevatedFlag());\n    }\n    _SetAnyInstanceZElevated() {\n      this._anyInstanceZElevated = true;\n    }\n    _MaybeResetAnyInstanceZElevatedFlag() {\n      0 === this._instances.length && (this._anyInstanceZElevated = false);\n    }\n    _SortInstancesByLastCachedZIndex(e) {\n      if (e) {\n        const e2 = /* @__PURE__ */ new Set();\n        for (const t2 of this._instances) {\n          const s = t2.GetWorldInfo()._GetLastCachedZIndex();\n          s >= 0 && e2.add(s);\n        }\n        let t = -1;\n        for (const s of this._instances) {\n          const a = s.GetWorldInfo();\n          if (!(a._GetLastCachedZIndex() >= 0)) {\n            for (++t; e2.has(t); ) ++t;\n            a._SetZIndex(t);\n          }\n        }\n      }\n      this._instances.sort(SortByInstLastCachedZIndex);\n    }\n    _Start() {\n    }\n    _End() {\n      for (const e of this._instances) e.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(e);\n      this._runtime.FlushPendingInstances(), C33.clearArray(this._instances), this._anyInstanceZElevated = false, this.SetZIndicesChanged();\n    }\n    RecreateInitialObjects(e, t, s, a, i, r) {\n      const n = this._runtime.GetEventSheetManager(), l = this._runtime.GetAllObjectClasses(), o = e.IsFamily(), h = [];\n      for (const c of this._initialInstances) {\n        const d = c[0], _ = d[0], u = d[1];\n        if (!t.containsPoint(_, u)) continue;\n        const G = l[c[1]];\n        if (G !== e) {\n          if (!o) continue;\n          if (!e.FamilyHasMember(G)) continue;\n        }\n        let f = i;\n        if (!f) {\n          const e2 = this._runtime.GetCurrentLayout();\n          this.GetLayout() === e2 ? f = this : (f = e2.GetLayerByName(this.GetName()), f || (f = e2.GetLayerByIndex(this.GetIndex())));\n        }\n        const p = this._runtime.CreateInstanceFromData(c, f, false, void 0, void 0, false, r);\n        f.SortAndAddInstancesByZIndex(p);\n        const I = p.GetWorldInfo();\n        I.OffsetXY(s, a), I.SetBboxChanged(), n.BlockFlushingInstances(true), p._TriggerOnCreatedOnSelfAndRelated(), n.BlockFlushingInstances(false), h.push(p);\n      }\n      return h;\n    }\n    GetInstanceCount() {\n      return this._instances.length;\n    }\n    GetLayout() {\n      return this._layout;\n    }\n    GetName() {\n      return this._name;\n    }\n    _SetIndex(e) {\n      this._index = e;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    _SetHTMLIndex(e) {\n      this._htmlIndex = e;\n    }\n    GetHTMLIndex() {\n      return this._htmlIndex;\n    }\n    IsHTMLElementsLayer() {\n      return this._isHTMLElementsLayer;\n    }\n    SetIsHTMLElementsLayer(e) {\n      e = !!e, this._isHTMLElementsLayer !== e && (this._isHTMLElementsLayer = e, this._layout._ReindexAndUpdateAllLayers(), this._runtime.UpdateRender());\n    }\n    _GetSiblingIndex() {\n      let e = -1;\n      const t = this.GetParentLayer();\n      return e = t ? t.GetSubLayers().indexOf(this) : this.GetLayout()._GetRootLayers().indexOf(this), e;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    IsDynamic() {\n      return this._isDynamic;\n    }\n    HasAnyDynamicParentLayer() {\n      for (const e of this.parentLayers()) if (e.IsDynamic()) return true;\n      return false;\n    }\n    GetDevicePixelRatio() {\n      return this._runtime.GetDevicePixelRatio();\n    }\n    GetEffectList() {\n      return this._effectList;\n    }\n    GetEffectChain() {\n      return this._MaybeRebuildEffectChainSteps(), this._effectChain;\n    }\n    _MaybeRebuildEffectChainSteps() {\n      const e = this.HasDefaultColor();\n      if (!this._needsRebuildEffectChainSteps && e === this._wasDefaultColor && !this._effectChain.NeedsRebuild()) return;\n      const t = this.GetEffectList().GetActiveEffectTypes();\n      this._effectChain.BuildSteps(t.map((e2) => e2.GetShaderProgram()), { indexMap: t.map((e2) => e2.GetIndex()), forcePreDraw: !e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasDefaultColor = e;\n    }\n    UpdateActiveEffects() {\n      this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;\n    }\n    UsesRenderCells() {\n      return this._useRenderCells && !this._useCameraDistanceDrawOrder;\n    }\n    GetRenderGrid() {\n      return this._renderGrid;\n    }\n    SetRenderListStale() {\n      this._isRenderListUpToDate = false;\n    }\n    IsVisible() {\n      for (const e of this.selfAndParentLayers()) if (!e._IsVisibleFlagSet()) return false;\n      return true;\n    }\n    _IsVisibleFlagSet() {\n      return this._isVisible;\n    }\n    SetVisible(e) {\n      e = !!e, this._isVisible !== e && (this._isVisible = e, this._runtime.UpdateRender());\n    }\n    SetInteractive(e) {\n      this._isInteractive = !!e;\n    }\n    IsInteractive() {\n      return this._isInteractive;\n    }\n    IsSelfAndParentsInteractive() {\n      for (const e of this.selfAndParentLayers()) if (!e.IsInteractive()) return false;\n      return true;\n    }\n    SetOwnScrollPositionEnabled(e) {\n      if (e = !!e, this._hasOwnScrollPosition !== e) {\n        if (this._hasOwnScrollPosition = e, e) {\n          const e2 = this.GetLayout();\n          this._scrollX = e2.GetScrollX(), this._scrollY = e2.GetScrollY();\n        }\n        this._SetMVMatrixChanged(), this._runtime.UpdateRender();\n      }\n    }\n    IsOwnScrollPositionEnabled() {\n      return this._hasOwnScrollPosition;\n    }\n    SetScrollX(e) {\n      const t = this.GetLayout(), s = t.GetScrollLeftBound(), a = t.GetScrollRightBound();\n      e > a && (e = a), e < s && (e = s), this._scrollX !== e && (this._scrollX = e, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()));\n    }\n    SetScrollY(e) {\n      const t = this.GetLayout(), s = t.GetScrollTopBound(), a = t.GetScrollBottomBound();\n      e > a && (e = a), e < s && (e = s), this._scrollY !== e && (this._scrollY = e, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()));\n    }\n    GetScrollX() {\n      return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX();\n    }\n    GetScrollY() {\n      return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY();\n    }\n    GetViewport() {\n      return this._MaybeUpdateViewport(), this._viewport;\n    }\n    _GetViewportZ0() {\n      return this._MaybeUpdateViewport(), this._viewportZ0;\n    }\n    GetViewport3D() {\n      return this._MaybeUpdateViewport(), this._viewport3D;\n    }\n    _GetVanishingPoint() {\n      const e = this.GetLayout();\n      return [e.GetVanishingPointX(), e.GetVanishingPointY()];\n    }\n    GetDefaultCameraZ(e) {\n      return this._runtime.GetDefaultCameraZ(e);\n    }\n    GetViewportForZ(e, t) {\n      const s = this._GetViewportZ0();\n      if (0 === e) t.copy(s);\n      else {\n        let a = s.midX(), i = s.midY();\n        const r = this.Get2DScaleFactorToZ(e), n = s.width() / r, l = s.height() / r, [o, h] = this._GetVanishingPoint();\n        if (0.5 !== o || 0.5 !== h) {\n          const t2 = this.Get2DCameraZ(), s2 = this._runtime, r2 = this.GetDefaultCameraZ() / t2;\n          let n2 = (o - 0.5) * s2.GetViewportWidth() / r2, l2 = (h - 0.5) * s2.GetViewportHeight() / r2;\n          const c = this.GetAngle();\n          0 !== c && (tempVec2.set(n2, l2), tempVec2.rotate(c), n2 = tempVec2.getX(), l2 = tempVec2.getY());\n          const d = C33.unlerp(t2, 0, e);\n          a += C33.lerp(n2, 0, d), i += C33.lerp(l2, 0, d);\n        }\n        t.set(a - n / 2, i - l / 2, a + n / 2, i + l / 2);\n      }\n    }\n    GetOpacity() {\n      return this._color.getA();\n    }\n    SetOpacity(e) {\n      e = C33.clamp(e, 0, 1), this._color.getA() !== e && (this._color.setA(e), this._UpdatePremultipliedColor(), this._runtime.UpdateRender());\n    }\n    _UpdatePremultipliedColor() {\n      this._premultipliedColor.copy(this._color), this._premultipliedColor.premultiply();\n    }\n    GetPremultipliedColor() {\n      return this._premultipliedColor;\n    }\n    HasDefaultColor() {\n      return this._color.equalsRgba(1, 1, 1, 1);\n    }\n    GetScaleRate() {\n      return this._scaleRate;\n    }\n    SetScaleRate(e) {\n      this._scaleRate !== e && (this._scaleRate = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    GetParallaxX() {\n      return this._parallaxX;\n    }\n    GetParallaxY() {\n      return this._parallaxY;\n    }\n    SetParallax(e, t) {\n      this._parallaxX === e && this._parallaxY === t || (this._parallaxX = e, this._parallaxY = t, this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    SetParallaxX(e) {\n      this.SetParallax(e, this.GetParallaxY());\n    }\n    SetParallaxY(e) {\n      this.SetParallax(this.GetParallaxX(), e);\n    }\n    SetZElevation(e) {\n      this._zElevation !== e && (this._zElevation = e, this._runtime.UpdateRender());\n    }\n    GetZElevation() {\n      return this._zElevation;\n    }\n    SetAngle(e) {\n      e = C33.clampAngle(e), this._angle !== e && (this._angle = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    GetAngle() {\n      return C33.clampAngle(this._layout.GetAngle() + this._angle);\n    }\n    GetOwnAngle() {\n      return this._angle;\n    }\n    HasInstances() {\n      return this._instances.length > 0;\n    }\n    _GetInstances() {\n      return this._instances;\n    }\n    _GetInstancesInDrawOrder() {\n      return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (C33.shallowAssignArray(tempInstancesByCameraDist, this._GetInstances()), tempInstancesByCameraDist.sort((e, t) => this._SortInstancesByCameraDistance(e, t)), tempInstancesByCameraDist) : this._GetInstances();\n    }\n    _AppendAllInstancesIncludingSubLayersInDrawOrder(e) {\n      C33.appendArray(e, this._GetInstancesInDrawOrder());\n      for (const t of this._subLayers) t.IsVisible() && t.GetOpacity() > 0 && t._AppendAllInstancesIncludingSubLayersInDrawOrder(e);\n    }\n    _SortInstancesByCameraDistance(e, t) {\n      const s = this.GetLayout().Get3DCameraPosition(), a = s[0], i = s[1], r = s[2], n = e.GetWorldInfo(), l = t.GetWorldInfo(), o = n.GetX() - a, h = n.GetY() - i, c = n.GetZElevation() - r, d = l.GetX() - a, _ = l.GetY() - i, u = l.GetZElevation() - r;\n      return d * d + _ * _ + u * u - (o * o + h * h + c * c);\n    }\n    GetBackgroundColor() {\n      return this._backgroundColor;\n    }\n    IsTransparent() {\n      return this._isTransparent;\n    }\n    SetTransparent(e) {\n      e = !!e, this._isTransparent !== e && (this._isTransparent = e, this._runtime.UpdateRender());\n    }\n    IsForceOwnTexture() {\n      return this._isForceOwnTexture;\n    }\n    SetForceOwnTexture(e) {\n      e = !!e, this._isForceOwnTexture !== e && (this._isForceOwnTexture = e, this._runtime.UpdateRender());\n    }\n    SetRenderAs3D(e) {\n      e = !!e, this._renderAs3d !== e && (this._renderAs3d = e, this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    IsRenderAs3D() {\n      return this._renderAs3d;\n    }\n    RendersIn2DMode() {\n      return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d;\n    }\n    RendersIn3DMode() {\n      return !this.RendersIn2DMode();\n    }\n    Has3DCamera() {\n      return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled();\n    }\n    SelfAndAllSubLayersHave3DCamera() {\n      if (!this.Has3DCamera()) return false;\n      for (const e of this._subLayers) if (!e.SelfAndAllSubLayersHave3DCamera()) return false;\n      return true;\n    }\n    SetBlendMode(e) {\n      this._blendMode !== e && (this._blendMode = e, this._runtime.UpdateRender());\n    }\n    GetBlendMode() {\n      return this._blendMode;\n    }\n    IsRootLayer() {\n      return !this._parentLayer;\n    }\n    GetParentLayer() {\n      return this._parentLayer;\n    }\n    _SetParentLayer(e) {\n      this._parentLayer = e;\n    }\n    GetSubLayers() {\n      return this._subLayers;\n    }\n    HasAnySubLayers() {\n      return this._subLayers.length > 0;\n    }\n    _AddSubLayer(e, t = true) {\n      t ? this._subLayers.push(e) : this._subLayers.unshift(e);\n    }\n    _InsertSubLayer(e, t, s) {\n      let a = this._subLayers.indexOf(t);\n      if (-1 === a) throw new Error(\"cannot find layer to insert by\");\n      s && ++a, this._subLayers.splice(a, 0, e);\n    }\n    _RemoveSubLayer(e) {\n      const t = this._subLayers.indexOf(e);\n      if (-1 === t) throw new Error(\"cannot find layer to remove\");\n      this._subLayers.splice(t, 1);\n    }\n    HasAnyVisibleSubLayer() {\n      for (const e of this._subLayers) if (e.ShouldDraw()) return true;\n      return false;\n    }\n    *selfAndAllSubLayers() {\n      for (const e of this._subLayers) yield* e.selfAndAllSubLayers();\n      yield this;\n    }\n    *parentLayers() {\n      let e = this.GetParentLayer();\n      for (; e; ) yield e, e = e.GetParentLayer();\n    }\n    *selfAndParentLayers() {\n      yield this, yield* this.parentLayers();\n    }\n    HasParentLayer(e) {\n      for (const t of this.parentLayers()) if (t === e) return true;\n      return false;\n    }\n    IsTransformCompatibleWith(e) {\n      return this === e || this._parallaxX === e._parallaxX && this._parallaxY === e._parallaxY && this._scale === e._scale && this._scaleRate === e._scaleRate && this._angle === e._angle && this.GetScrollX() === e.GetScrollX() && this.GetScrollY() === e.GetScrollY();\n    }\n    SaveTransform() {\n      return { \"parallaxX\": this.GetParallaxX(), \"parallaxY\": this.GetParallaxY(), \"scale\": this.GetOwnScale(), \"scaleRate\": this.GetScaleRate(), \"angle\": this.GetOwnAngle(), \"hasOwnScroll\": this.IsOwnScrollPositionEnabled(), \"scrollX\": this.GetScrollX(), \"scrollY\": this.GetScrollY() };\n    }\n    RestoreTransform(e) {\n      this.SetParallax(e[\"parallaxX\"], e[\"parallaxY\"]), this.SetOwnScale(e[\"scale\"]), this.SetScaleRate(e[\"scaleRate\"]), this.SetAngle(e[\"angle\"]), this.SetOwnScrollPositionEnabled(e[\"hasOwnScroll\"]), this.SetScrollX(e[\"scrollX\"]), this.SetScrollY(e[\"scrollY\"]), this._MaybeUpdateViewport();\n    }\n    _RemoveAllInstancesInSet(e) {\n      if (0 === e.size) return;\n      C33.arrayRemoveAllInSet(this._instances, e) > 0 && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged());\n    }\n    SetZIndicesChanged(e) {\n      this._zIndicesUpToDate = false, this._isRenderListUpToDate = false, e && !e.GetObjectClass().GetPlugin().IsHTMLElementType() || (this._htmlZIndicesUpToDate = false);\n    }\n    _UpdateZIndices() {\n      if (!this._zIndicesUpToDate) {\n        if (this._instances.sort(SortByInstZElevation), this.UsesRenderCells()) for (let e = 0, t = this._instances.length; e < t; ++e) {\n          const t2 = this._instances[e].GetWorldInfo();\n          t2._SetZIndex(e), this._renderGrid.MarkRangeChanged(t2.GetRenderCellRange());\n        }\n        else for (let e = 0, t = this._instances.length; e < t; ++e) this._instances[e].GetWorldInfo()._SetZIndex(e);\n        this._zIndicesUpToDate = true;\n      }\n    }\n    _UpdateHTMLZIndices() {\n      if (this._htmlZIndicesUpToDate) return;\n      const e = this._layout.GetRootLayersForHTMLLayer(this.GetHTMLIndex()).map((e2) => [...e2.selfAndAllSubLayers()]).flat();\n      let t = 0;\n      for (const s of e) {\n        for (const e2 of s._GetInstances()) e2.GetObjectClass().GetPlugin().IsHTMLElementType() && e2.GetWorldInfo()._SetHTMLZIndex(t++);\n        s._SetHTMLZIndicesUpToDate();\n      }\n    }\n    _SetHTMLZIndicesUpToDate() {\n      this._htmlZIndicesUpToDate = true;\n    }\n    _GetHTMLLayerDOMState() {\n      return { \"isVisible\": this.IsVisible(), \"opacity\": this.GetOpacity(), \"isInteractive\": this.IsInteractive() };\n    }\n    MoveInstanceAdjacent(e, t, s) {\n      const a = e.GetWorldInfo(), i = t.GetWorldInfo();\n      if (a.GetLayer() !== this || i.GetLayer() !== this) throw new Error(\"can't arrange Z order unless both objects on this layer\");\n      const r = a.GetZIndex();\n      let n = i.GetZIndex();\n      return r !== n + (s ? 1 : -1) && (C33.arrayRemove(this._instances, r), r < n && n--, s && n++, n === this._instances.length ? this._instances.push(e) : this._instances.splice(n, 0, e), this.SetZIndicesChanged(e), true);\n    }\n    _MergeSortedZArrays(e, t) {\n      const s = [];\n      let a = 0, i = 0, r = e.length, n = t.length;\n      for (; a < r && i < n; ) {\n        const r2 = e[a], n2 = t[i];\n        r2.GetWorldInfo()._GetLastCachedZIndex() < n2.GetWorldInfo()._GetLastCachedZIndex() ? (s.push(r2), ++a) : (s.push(n2), ++i);\n      }\n      for (; a < r; ++a) s.push(e[a]);\n      for (; i < n; ++i) s.push(t[i]);\n      return s;\n    }\n    _MergeAllSortedZArrays_pass(e) {\n      const t = [], s = e.length;\n      for (let a = 0; a < s - 1; a += 2) {\n        const s2 = e[a], i = e[a + 1];\n        t.push(this._MergeSortedZArrays(s2, i));\n      }\n      return s % 2 == 1 && t.push(e[s - 1]), t;\n    }\n    _MergeAllSortedZArrays(e) {\n      for (; e.length > 1; ) e = this._MergeAllSortedZArrays_pass(e);\n      return e[0];\n    }\n    _GetRenderCellInstancesToDraw() {\n      return this._UpdateZIndices(), C33.clearArray(renderCellArr), this._renderGrid.QueryRange(this.GetViewport(), renderCellArr), renderCellArr.length ? 1 === renderCellArr.length ? renderCellArr[0] : this._MergeAllSortedZArrays(renderCellArr) : [];\n    }\n    ShouldDraw() {\n      return this.IsVisible() && this.GetOpacity() > 0 && this._DrawsAnyContentInSelfOrSubLayers();\n    }\n    _DrawsAnyContentInSelfOrSubLayers() {\n      if (this.HasInstances() || !this.IsTransparent()) return true;\n      for (const e of this._subLayers) if (e._DrawsAnyContentInSelfOrSubLayers()) return true;\n      return false;\n    }\n    UsesOwnTexture() {\n      return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect();\n    }\n    SelfOrAnySubLayerUsesOwnTexture() {\n      if (this.UsesOwnTexture()) return true;\n      for (const e of this._subLayers) if (e.SelfOrAnySubLayerUsesOwnTexture()) return true;\n      return false;\n    }\n    GetRenderTarget() {\n      return this._curRenderTarget;\n    }\n    Get2DScaleFactorToZ(e) {\n      if (this._layout.IsOrthographicProjection()) return 1;\n      {\n        const t = this.Get3DCameraZ();\n        return t / (t - e);\n      }\n    }\n    GetResolutionScaleFactorToZ(e) {\n      const t = this._runtime.GetRenderScale();\n      if (this._layout.IsOrthographicProjection()) return t;\n      {\n        const s = this.Get3DCameraZ();\n        return this.GetDefaultCameraZ() / Math.abs(s - e) * t;\n      }\n    }\n    _SetMVMatrixChanged() {\n      this._isMVMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;\n    }\n    _GetModelViewMatrix(e) {\n      return this._isMVMatrixChanged && (this._CalculateModelViewMatrix(e, this._modelViewMatrix, 0, 0, null), this._isMVMatrixChanged = false), this._modelViewMatrix;\n    }\n    Get2DCameraZ(e) {\n      return this.GetDefaultCameraZ(e) / this.GetNormalScale();\n    }\n    Get3DCameraZ() {\n      return this.Has3DCamera() ? this.GetLayout().Get3DCameraPosition()[2] : this.Get2DCameraZ();\n    }\n    GetCameraPosition() {\n      if (this.Has3DCamera()) {\n        const e = this.GetLayout().Get3DCameraPosition();\n        return [e[0], e[1], e[2]];\n      }\n      return this._Get2DCameraPosition();\n    }\n    _Get2DCameraPosition(e = 0, t = 0, s = 0) {\n      const a = this._runtime, i = this.GetLayout(), r = a.GetParallaxXOrigin(), n = a.GetParallaxYOrigin();\n      let l = (this.GetScrollX() - r) * this._parallaxX + r, o = (this.GetScrollY() - n) * this._parallaxY + n;\n      a.IsPixelRoundingEnabled() && (l = Math.round(l), o = Math.round(o));\n      let h = l + e, c = o + t;\n      const d = i.IsOrthographicProjection() ? this.GetDefaultCameraZ(s) : this.Get2DCameraZ(s), [_, u] = this._GetVanishingPoint();\n      if (0.5 !== _ || 0.5 !== u) {\n        const e2 = this.GetDefaultCameraZ(s) / d;\n        let t2 = (_ - 0.5) * a.GetViewportWidth() / e2, i2 = (u - 0.5) * a.GetViewportHeight() / e2;\n        const r2 = this.GetAngle();\n        0 !== r2 && (tempVec2.set(t2, i2), tempVec2.rotate(r2), t2 = tempVec2.getX(), i2 = tempVec2.getY()), h += t2, c += i2;\n      }\n      return [h, c, d];\n    }\n    _CalculateModelViewMatrix(e, t, s, a, i) {\n      const r = this._runtime, n = this.GetLayout();\n      if (this.Has3DCamera()) {\n        vec3.copy(camVector, n.Get3DCameraPosition()), vec3.copy(lookVector, n.Get3DCameraLookAt()), vec3.copy(upVector, n.Get3DCameraUpVector());\n        const e2 = r.GetParallaxXOrigin(), t2 = r.GetParallaxYOrigin(), s2 = lookVector[0] - camVector[0], a2 = lookVector[1] - camVector[1], i2 = lookVector[2] - camVector[2];\n        camVector[0] = (camVector[0] - e2) * this._parallaxX + e2, camVector[1] = (camVector[1] - t2) * this._parallaxY + t2, camVector[2] *= Math.max(this._parallaxX, this._parallaxY), lookVector[0] = camVector[0] + s2, lookVector[1] = camVector[1] + a2, lookVector[2] = camVector[2] + i2;\n      } else {\n        const [e2, t2, r2] = this._Get2DCameraPosition(s, a, i);\n        vec3.set(camVector, e2, t2, r2), vec3.set(lookVector, e2, t2, r2 - 100);\n        const n2 = this.GetAngle();\n        0 === n2 ? vec3.set(upVector, 0, 1, 0) : vec3.set(upVector, Math.sin(n2), Math.cos(n2), 0);\n      }\n      e.CalculateLookAtModelView(t, camVector, lookVector, upVector, i || r.GetViewportHeight());\n    }\n    _SetProjectionMatrixChanged() {\n      this._isProjectionMatrixChanged = true, this._isViewFrustumChanged = true, this._isViewportChanged = true;\n    }\n    _GetProjectionMatrix(e) {\n      return this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(e), this._isProjectionMatrixChanged = false), this._projectionMatrix;\n    }\n    _CalculateProjectionMatrix(e) {\n      const t = this._runtime.GetCanvasManager(), [s, a] = this._GetVanishingPoint();\n      if (this._layout.IsOrthographicProjection()) e.CalculateOrthographicMatrix(this._projectionMatrix, t.GetDrawWidth(), t.GetDrawHeight());\n      else if (0.5 === s && 0.5 === a) mat4.copy(this._projectionMatrix, t.GetDefaultProjectionMatrix());\n      else {\n        const i = t.GetDrawWidth(), r = t.GetDrawHeight();\n        e.CalculatePerspectiveMatrix(this._projectionMatrix, i / r, s, a);\n      }\n    }\n    _SetTransform(e, t = true, s = 0, a = 0, i = 0) {\n      t && e.SetProjectionMatrix(this._GetProjectionMatrix(e));\n      let r = null;\n      0 === s && 0 === a && 0 === i ? r = this._GetModelViewMatrix(e) : (this._CalculateModelViewMatrix(e, tempMat4, s, a, i), r = tempMat4), e.SetModelViewMatrix(r);\n    }\n    PrepareForDraw(e) {\n      this._SetTransform(e), e.SetBaseZ(this.GetZElevation());\n    }\n    _MaybeStartWebGLProfiling(e) {\n      let t = null;\n      if (e.IsWebGL() && this._runtime.IsGPUProfiling()) {\n        const s = this._runtime.GetCanvasManager().GetLayerTimingsBuffer(this);\n        s && (t = s.AddTimeElapsedQuery(), e.StartQuery(t));\n      }\n      return t;\n    }\n    _MaybeStartWebGPUProfiling(e) {\n      if (e.IsWebGPU() && this._runtime.IsGPUProfiling()) {\n        const t = 2 * (this.GetIndex() + 1);\n        e.StartMeasuringRenderPassTime(t, t + 1);\n      }\n    }\n    Draw(e, t, s) {\n      const a = this._runtime.GetCanvasManager(), i = this.UsesOwnTexture();\n      let r = null;\n      const n = this._MaybeStartWebGLProfiling(e);\n      if (this._MaybeStartWebGPUProfiling(e), i) {\n        const t2 = { sampling: this._runtime.GetSampling(), isSampled: true, canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };\n        \"low\" === a.GetCurrentFullscreenScalingQuality() && (t2.width = a.GetDrawWidth(), t2.height = a.GetDrawHeight()), r = this._runtime.GetAdditionalRenderTarget(t2), this._curRenderTarget = r, e.SetRenderTarget(r), this.IsTransparent() && e.ClearRgba(0, 0, 0, 0);\n      } else this._curRenderTarget = t, e.SetRenderTarget(t);\n      if (this.IsTransparent() || e.Clear(this._backgroundColor), this._layout._DrawLayerList(e, this._curRenderTarget, this._subLayers, i && this.IsTransparent()), this._MaybeStartWebGPUProfiling(e), this._SetTransform(e), e.SetBaseZ(this.GetZElevation()), e.SetDepthEnabled(this.RendersIn3DMode()), this.GetNormalScale() > Number.EPSILON) {\n        this._UpdateZIndices();\n        const t2 = this.UsesRenderCells() && 0 === this.GetZElevation() && !this._anyInstanceZElevated;\n        this.Has3DCamera() ? this._DrawInstances_3DCamera(e) : t2 ? this._DrawInstances_RenderCells(e) : this._DrawInstances(e, this._GetInstancesInDrawOrder());\n      }\n      e.SetBaseZ(0), e.SetCurrentZ(0), i && (e.SetDepthEnabled(false), this._DrawLayerOwnTextureToRenderTarget(e, r, t, s)), n && e.EndQuery(n), this._curRenderTarget = null;\n    }\n    _DrawInstances(e, t) {\n      const s = this.GetViewport(), a = this._curRenderTarget, i = this.GetLayout().IsOrthographicProjection(), r = this.GetLayout().HasVanishingPointOutsideViewport();\n      let n = null;\n      for (let l = 0, o = t.length; l < o; ++l) {\n        const o2 = t[l];\n        if (o2 === n) continue;\n        n = o2;\n        const h = o2.GetWorldInfo();\n        h.IsVisible() && h.IsInViewport(s, r, i) && this._DrawInstanceMaybeWithEffects(o2, h, e, a);\n      }\n    }\n    _DrawInstances_3DCamera(e) {\n      const t = this._curRenderTarget, s = this._GetViewFrustum(), a = tempInstanceList1, i = tempInstanceList2, r = this._GetInstancesInDrawOrder();\n      for (let n = 0, l = r.length; n < l; ) {\n        const o = r[n], h = o.GetWorldInfo();\n        if (!h.IsVisible() || !h.IsInViewport3D(s)) {\n          ++n;\n          continue;\n        }\n        (!o.RendersToOwnZPlane() || h.GetDepth() > 0) && i.push(o);\n        const c = o.GetWorldInfo().GetTotalZElevation();\n        a.push(o);\n        let d = n + 1;\n        for (; d < l; ++d) {\n          const e2 = r[d], t2 = e2.GetWorldInfo();\n          if (t2.IsVisible() && t2.IsInViewport3D(s)) {\n            if (t2.GetTotalZElevation() !== c) break;\n            e2.RendersToOwnZPlane() ? (t2.GetDepth() > 0 && i.push(e2), a.push(e2)) : i.push(e2);\n          }\n        }\n        if (1 !== a.length || a[0].MustMitigateZFighting()) {\n          this._DrawCoplanarInstances_3DCamera(e, a);\n          for (let s2 = 0, a2 = i.length; s2 < a2; ++s2) {\n            const a3 = i[s2], r2 = a3.GetWorldInfo();\n            r2._SetDrawNonBackFacesOnly(true), this._DrawInstanceMaybeWithEffects(a3, r2, e, t), r2._SetDrawNonBackFacesOnly(false);\n          }\n        } else {\n          this._DrawInstanceMaybeWithEffects(o, h, e, t);\n          for (let s2 = 0, a2 = i.length; s2 < a2; ++s2) {\n            const a3 = i[s2];\n            if (a3 === o) continue;\n            const r2 = a3.GetWorldInfo();\n            r2.GetLayer()._DrawInstanceMaybeWithEffects(a3, r2, e, t);\n          }\n        }\n        n = d, C33.clearArray(a), C33.clearArray(i);\n      }\n    }\n    _DrawCoplanarInstances_3DCamera(e, t) {\n      const s = this._curRenderTarget;\n      e.CoplanarStartStencilPass();\n      for (let s2 = 0, a = t.length; s2 < a; ++s2) {\n        const a2 = t[s2], i = a2.GetWorldInfo();\n        i._SetDrawBackFaceOnly(true), this._DrawInstance(a2, i, e);\n      }\n      e.CoplanarStartColorPass();\n      for (let a = 0, i = t.length; a < i; ++a) {\n        const i2 = t[a], r = i2.GetWorldInfo();\n        this._DrawInstanceMaybeWithEffects(i2, r, e, s), r._SetDrawBackFaceOnly(false);\n      }\n      e.CoplanarRestoreStandardRendering();\n    }\n    _DrawInstances_RenderCells(e) {\n      const t = this._renderGrid, s = this._curRenderCells, a = this._lastRenderCells, i = this.GetViewport();\n      let r;\n      s.set(t.XToCell(i.getLeft()), t.YToCell(i.getTop()), t.XToCell(i.getRight()), t.YToCell(i.getBottom())), this._isRenderListUpToDate && s.equals(a) ? r = this._lastRenderList : (r = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = true, a.copy(s)), this._DrawInstances(e, r), r !== this._lastRenderList && C33.shallowAssignArray(this._lastRenderList, r);\n    }\n    _DrawInstanceMaybeWithEffects(e, t, s, a) {\n      t.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(e, t, s, a) : this._DrawInstance(e, t, s);\n    }\n    _DrawInstance(e, t, s) {\n      const a = t.GetRendererStateGroup();\n      s.GetCurrentStateGroup() !== a && a.Apply(), e.Draw(s);\n    }\n    _DrawInstanceWithEffectsAndRestore(e, t, s, a) {\n      this._DrawInstanceWithEffects(e, t, s, a, null) && this._SetTransform(s);\n    }\n    _DrawInstanceWithEffects(e, t, s, a, i) {\n      const r = t.GetInstanceEffectList().GetEffectChain();\n      return r.Render(s, a, { contentObject: e, blendMode: t.GetBlendMode(), devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), time: e.GetInstanceGameTime(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: t.GetBoundingBox(), drawSurfaceRect: r.CanSkipCalculatingDrawSurfaceRect() ? null : this._InstanceBoxToDrawSurface(t), drawContentHook: i && i.drawContentHook, compositOffX: i && i.compositOffX, compositOffY: i && i.compositOffY, compositRtWidth: i && i.compositRtWidth, compositRtHeight: i && i.compositRtHeight, updateOwnProjection: i && i.updateOwnProjection }), s.SetBaseZ(this.GetZElevation()), r.DidChangeTransform();\n    }\n    _DrawLayerOwnTextureToRenderTarget(e, t, s, a) {\n      const i = this._effectList.GetActiveEffectTypes(), r = this._runtime;\n      0 === i.length ? (e.SetRenderTarget(s), e.SetTextureFillMode(), a && 0 === this._blendMode && this.HasDefaultColor() ? e.CopyRenderTarget(t) : (e.SetBlendMode(this._blendMode), e.SetColor(this._premultipliedColor), e.DrawRenderTarget(t)), e.InvalidateRenderTarget(t), r.ReleaseAdditionalRenderTarget(t)) : this.GetEffectChain().Render(e, s, { contentObject: this, blendMode: this.GetBlendMode(), devicePixelRatio: r.GetEffectDevicePixelRatioParam(), layerScale: r.GetEffectLayerScaleParam() * this.GetNormalScale(), layerAngle: this.GetAngle(), layoutRect: this.GetViewport(), drawSurfaceRect: null, invalidateRenderTargets: true });\n    }\n    GetOwnScale() {\n      return this._scale;\n    }\n    SetOwnScale(e) {\n      this._scale !== e && (this._scale = e, this._layout.BoundScrolling(), this._SetMVMatrixChanged(), this._runtime.UpdateRender());\n    }\n    GetRenderScale() {\n      return this.GetNormalScale() * this._runtime.GetRenderScale();\n    }\n    GetDisplayScale() {\n      return this.GetNormalScale() * this._runtime.GetDisplayScale();\n    }\n    GetNormalScale() {\n      return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1;\n    }\n    _MaybeUpdateViewport() {\n      if (!this._isViewportChanged) return;\n      this._isViewportChanged = false;\n      const e = this._runtime.GetParallaxXOrigin(), t = this._runtime.GetParallaxYOrigin(), s = (this.GetScrollX() - e) * this._parallaxX + e, a = (this.GetScrollY() - t) * this._parallaxY + t, i = this.GetNormalScale(), r = this._runtime.GetViewportWidth() / i, n = this._runtime.GetViewportHeight() / i;\n      let l = s - r / 2, o = a - n / 2;\n      this._runtime.IsPixelRoundingEnabled() && (l = Math.round(l), o = Math.round(o));\n      const h = this._viewportZ0;\n      h.set(l, o, l + r, o + n);\n      const c = this.GetAngle();\n      0 !== c && (tmpRect.copy(h), tmpRect.offset(-h.midX(), -h.midY()), tmpQuad.setFromRotatedRect(tmpRect, c), tmpQuad.getBoundingBox(tmpRect), tmpRect.offset(h.midX(), h.midY()), h.copy(tmpRect));\n      const d = this._zElevation;\n      this.GetViewportForZ(d, this._viewport), this.Has3DCamera() ? this.CalculateViewport3D(d, this._viewport3D) : this._viewport3D.copy(this._viewport);\n    }\n    CalculateViewport3D(e, t) {\n      const s = this._runtime.GetCanvasManager(), a = s.GetCssWidth(), i = s.GetCssHeight(), [r, n] = this.CanvasCssToLayer(0, 0, e), [l, o] = this.CanvasCssToLayer(a, 0, e), [h, c] = this.CanvasCssToLayer(a, i, e), [d, _] = this.CanvasCssToLayer(0, i, e);\n      let u = Math.min(r, l, h, d), G = Math.min(n, o, c, _), f = Math.max(r, l, h, d), p = Math.max(n, o, c, _);\n      isFinite(u) || (u = -1 / 0), isFinite(G) || (G = -1 / 0), isFinite(f) || (f = 1 / 0), isFinite(p) || (p = 1 / 0), t.set(u, G, f, p);\n    }\n    CanvasCssToLayer(e, t, s = 0) {\n      return this._CanvasToLayer(e, t, s, this.GetDisplayScale());\n    }\n    DrawSurfaceToLayer(e, t, s = 0) {\n      return this._CanvasToLayer(e, t, s, this.GetRenderScale() * this.GetDevicePixelRatio());\n    }\n    _CanvasToLayer(e, t, s, a) {\n      const i = this._runtime, r = i.GetRenderer(), n = this.GetNormalScale(), l = i.GetViewportWidth() / n, o = i.GetViewportHeight() / n, h = tempVec4;\n      vec4.set(h, 0, 0, l, o), e /= a, t = h[3] - t / a;\n      const c = this._GetProjectionMatrix(r), d = this._GetModelViewMatrix(r), _ = tempVec3;\n      return C33.Gfx.UnprojectScreenToWorldZ(e, t, s, d, c, h, _) ? [_[0], _[1]] : [NaN, NaN];\n    }\n    CanvasCssToLayer_DefaultTransform(e, t) {\n      const s = this._scale, a = this._scaleRate, i = this._parallaxX, r = this._parallaxY, n = this._angle;\n      this._scale = 1, this._scaleRate = 1, this._parallaxX = 1, this._parallaxY = 1, this._angle = 0, this._SetMVMatrixChanged();\n      const l = this.CanvasCssToLayer(e, t);\n      return this._scale = s, this._scaleRate = a, this._parallaxX = i, this._parallaxY = r, this._angle = n, this._SetMVMatrixChanged(), l;\n    }\n    LayerToCanvasCss(e, t, s = 0) {\n      return this._LayerToCanvas(e, t, s, this.GetDisplayScale());\n    }\n    LayerToDrawSurface(e, t, s = 0) {\n      return this._LayerToCanvas(e, t, s, this.GetRenderScale() * this.GetDevicePixelRatio());\n    }\n    _LayerToCanvas(e, t, s, a) {\n      const i = this._runtime, r = i.GetRenderer(), n = this.GetNormalScale(), l = i.GetViewportWidth() / n, o = i.GetViewportHeight() / n, h = tempVec4;\n      vec4.set(h, 0, 0, l, o);\n      const c = this._GetProjectionMatrix(r), d = this._GetModelViewMatrix(r), _ = tempVec3;\n      return C33.Gfx.Project(e, t, s, d, c, h, _) ? [_[0] * a, (h[3] - _[1]) * a] : [NaN, NaN];\n    }\n    _GetLayerToDrawSurfaceScale(e, t) {\n      return e *= this.GetRenderScale() * this.GetDevicePixelRatio(), 0 !== t && (e *= this.Get2DScaleFactorToZ(t)), e;\n    }\n    _InstanceBoxToDrawSurface(e) {\n      const t = e.GetBoundingBox(), s = e.GetTotalZElevation(), a = e.GetDepth(), i = s + a, r = t.getLeft(), n = t.getTop(), l = t.getRight(), o = t.getBottom();\n      if (this.Has3DCamera()) {\n        if (this._IsPointBehindNearPlane(r, n, s) || this._IsPointBehindNearPlane(l, n, s) || this._IsPointBehindNearPlane(l, o, s) || this._IsPointBehindNearPlane(r, o, s)) return null;\n        if (a > 0 && (this._IsPointBehindNearPlane(r, n, i) || this._IsPointBehindNearPlane(l, n, i) || this._IsPointBehindNearPlane(l, o, i) || this._IsPointBehindNearPlane(r, o, i))) return null;\n      } else if (i >= this.Get2DCameraZ()) return null;\n      let [h, c] = this.LayerToDrawSurface(r, n, s), [d, _] = this.LayerToDrawSurface(l, o, s);\n      if (0 !== this.GetAngle() || a > 0 || this.Has3DCamera()) {\n        const [e2, t2] = this.LayerToDrawSurface(l, n, s), [u, G] = this.LayerToDrawSurface(r, o, s);\n        if (a > 0) {\n          const [s2, a2] = this.LayerToDrawSurface(r, n, i), [f, p] = this.LayerToDrawSurface(l, n, i), [I, m] = this.LayerToDrawSurface(l, o, i), [C, y] = this.LayerToDrawSurface(r, o, i);\n          let S = Math.min(h, d, e2, u, s2, f, I, C);\n          d = Math.max(h, d, e2, u, s2, f, I, C), h = S, S = Math.min(c, _, t2, G, a2, p, m, y), _ = Math.max(c, _, t2, G, a2, p, m, y), c = S;\n        } else {\n          let s2 = Math.min(h, d, e2, u);\n          d = Math.max(h, d, e2, u), h = s2, s2 = Math.min(c, _, t2, G), _ = Math.max(c, _, t2, G), c = s2;\n        }\n      }\n      return tmpRect.set(h, c, d, _), tmpRect;\n    }\n    _GetViewFrustum() {\n      return this._isViewFrustumChanged && (this._UpdateViewFrustum(), this._isViewFrustumChanged = false), this._viewFrustum;\n    }\n    _UpdateViewFrustum() {\n      const e = this._runtime.GetRenderer(), t = this._GetProjectionMatrix(e), s = this._GetModelViewMatrix(e);\n      this._viewFrustum.CalculatePlanes(s, t);\n    }\n    _IsPointBehindNearPlane(e, t, s) {\n      return this._GetViewFrustum().IsBehindNearPlane(e, t, s);\n    }\n    _SaveToJson() {\n      return { \"d\": this.IsDynamic(), \"s\": this.GetOwnScale(), \"a\": this.GetOwnAngle(), \"v\": this._IsVisibleFlagSet(), \"i\": this.IsInteractive(), \"html\": this.IsHTMLElementsLayer(), \"bc\": this._backgroundColor.toJSON(), \"t\": this.IsTransparent(), \"sx\": this._scrollX, \"sy\": this._scrollY, \"hosp\": this._hasOwnScrollPosition, \"px\": this.GetParallaxX(), \"py\": this.GetParallaxY(), \"c\": this._color.toJSON(), \"sr\": this.GetScaleRate(), \"fx\": this._effectList.SaveToJson(), \"cg\": this._createdGlobalUids };\n    }\n    _LoadFromJson(e) {\n      this._isDynamic = !!e[\"d\"], this._scale = e[\"s\"], this._angle = e[\"a\"], this._isVisible = !!e[\"v\"], this._isInteractive = !e.hasOwnProperty(\"i\") || e[\"i\"], this._isHTMLElementsLayer = !!e[\"html\"], this._backgroundColor.setFromJSON(e[\"bc\"]), this._isTransparent = !!e[\"t\"], e.hasOwnProperty(\"sx\") && (this._scrollX = e[\"sx\"]), e.hasOwnProperty(\"sy\") && (this._scrollY = e[\"sy\"]), e.hasOwnProperty(\"hosp\") && (this._hasOwnScrollPosition = !!e[\"hosp\"]), this._parallaxX = e[\"px\"], this._parallaxY = e[\"py\"], this._color.setFromJSON(e[\"c\"]), this._UpdatePremultipliedColor(), this._scaleRate = e[\"sr\"], C33.shallowAssignArray(this._createdGlobalUids, e[\"cg\"]), C33.shallowAssignArray(this._initialInstances, this._startupInitialInstances);\n      const t = new Set(this._createdGlobalUids);\n      let s = 0;\n      for (let e2 = 0, a = this._initialInstances.length; e2 < a; ++e2) t.has(this._initialInstances[e2][2]) || (this._initialInstances[s] = this._initialInstances[e2], ++s);\n      C33.truncateArray(this._initialInstances, s), this._effectList.LoadFromJson(e[\"fx\"]), this._needsRebuildEffectChainSteps = true;\n    }\n    _LoadFromJsonAfterInstances() {\n      this._SortInstancesByLastCachedZIndex(false), this.SetZIndicesChanged(), this._SetMVMatrixChanged(), this._SetProjectionMatrixChanged();\n    }\n    GetILayer() {\n      return this._iLayer;\n    }\n    SortAndAddInstancesByZIndex(e, t = false, s = false) {\n      if (this._instances.includes(e)) return t && this._instances.sort((e2, t2) => (e2.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t2.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), void (s && this._instances.forEach((e2, t2) => e2.GetWorldInfo()._SetZIndex(t2)));\n      if (e.HasChildren()) {\n        const t2 = [...e.allChildren()];\n        t2.push(e), t2.sort((e2, t3) => (e2.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t3.GetWorldInfo().GetSceneGraphZIndex() ?? 0));\n        for (const e2 of t2) if (e2.IsInContainer()) for (const s2 of e2.siblings()) {\n          if (t2.includes(s2)) continue;\n          const e3 = [...s2.allChildren()];\n          e3.push(s2), e3.sort((e4, t3) => (e4.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t3.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), e3 && e3.length && t2.splice(t2.length, 0, ...e3);\n        }\n        for (const e2 of t2) e2.GetPlugin().IsWorldType() && this._AddInstance(e2, true);\n        s && this._instances.forEach((e2, t3) => e2.GetWorldInfo()._SetZIndex(t3));\n      } else {\n        if (e.GetPlugin().IsWorldType() && this._AddInstance(e, true), !e.IsInContainer()) return void (s && this._instances.forEach((e2, t2) => e2.GetWorldInfo()._SetZIndex(t2)));\n        for (const t2 of e.siblings()) {\n          const e2 = [...t2.allChildren()];\n          if (e2.push(t2), e2.sort((e3, t3) => (e3.GetWorldInfo().GetSceneGraphZIndex() ?? 0) - (t3.GetWorldInfo().GetSceneGraphZIndex() ?? 0)), e2 && e2.length) for (const t3 of e2) t3.GetPlugin().IsWorldType() && this._AddInstance(t3, true);\n        }\n        s && this._instances.forEach((e2, t2) => e2.GetWorldInfo()._SetZIndex(t2));\n      }\n    }\n  };\n}\nvar SortByInstLastCachedZIndex2;\nvar SortByInstZElevation2;\n{\n  let vec3EqualsXYZ = function(e, t, s, r) {\n    return e[0] === Math.fround(t) && e[1] === Math.fround(s) && e[2] === Math.fround(r);\n  }, MaybePrepareLayerDraw = function(e, t) {\n    lastLayerPreparedForDrawing !== e && (e.PrepareForDraw(t), lastLayerPreparedForDrawing = e);\n  };\n  vec3EqualsXYZ2 = vec3EqualsXYZ, MaybePrepareLayerDraw2 = MaybePrepareLayerDraw;\n  const C33 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, tempDestRect = C33.New(C33.Rect), tempSrcRect = C33.New(C33.Rect), tempLayoutRect = C33.New(C33.Rect), tempColor = C33.New(C33.Color), glMatrix = self.glMatrix, vec3 = glMatrix.vec3, tempRender3dList = [], tempInstanceList1 = [], tempInstanceList2 = [], tempInstanceList3 = [];\n  let lastLayerPreparedForDrawing = null;\n  C33.Layout = class extends C33.DefendedBase {\n    constructor(e, t, s) {\n      super(), this._layoutManager = e, this._runtime = e.GetRuntime(), this._name = s[0], this._originalWidth = s[1], this._originalHeight = s[2], this._width = s[1], this._height = s[2], this._isUnboundedScrolling = !!s[3], this._isOrthographicProjection = !!s[4], this._vanishingPointX = s[5], this._vanishingPointY = s[6], this._eventSheetName = s[7], this._eventSheet = null, this._sid = s[8], this._index = t, this._scrollX = 0, this._scrollY = 0, this._scale = 1, this._angle = 0, this._initialObjectClasses = /* @__PURE__ */ new Set(), this._textureLoadedTypes = /* @__PURE__ */ new Set(), this._textureLoadPendingPromises = /* @__PURE__ */ new Set(), this._createdInstances = [], this._createdPersistedInstances = [], this._createdPersistedInstancesToDataMap = /* @__PURE__ */ new Map(), this._createdPersistedIndexToInstanceMap = /* @__PURE__ */ new Map(), this._initialNonWorld = [], this._is3dCameraEnabled = false, this._cam3dposition = vec3.create(), this._cam3dlook = vec3.create(), this._cam3dup = vec3.create(), this._rootLayers = [], this._allLayersFlat = [], this._layersByName = /* @__PURE__ */ new Map(), this._layersBySid = /* @__PURE__ */ new Map(), this._pendingSetHTMLLayerCount = -1;\n      const r = this._runtime.GetCanvasManager();\n      this._effectList = C33.New(C33.EffectList, this, s[11]), this._effectChain = C33.New(C33.Gfx.EffectChain, r.GetEffectChainManager(), { drawContent: (e2, t2) => {\n        const s2 = t2.GetContentObject().GetRenderTarget();\n        e2.ResetColor(), e2.DrawRenderTarget(s2), e2.InvalidateRenderTarget(s2), r.ReleaseAdditionalRenderTarget(s2);\n      }, getShaderParameters: (e2) => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e2) }), this._needsRebuildEffectChainSteps = true, this._wasFullScreenQualityLow = false, this._curRenderTarget = null, this._persistData = {}, this._persistedIntances = /* @__PURE__ */ new Map(), this._isFirstVisit = true, this._iLayout = new self.ILayout(this), this._userScriptDispatcher = C33.New(C33.Event.Dispatcher);\n      for (const e2 of s[9]) this._rootLayers.push(C33.Layer.CreateFromExportData(this, null, e2));\n      this._ReindexLayers();\n      for (const e2 of this.allLayers()) e2._InitInitialInstances();\n      for (const e2 of s[10]) {\n        const t2 = this._runtime.GetObjectClassByIndex(e2[1]);\n        if (!t2) throw new Error(\"missing nonworld object class\");\n        t2.GetDefaultInstanceData() || t2.SetDefaultInstanceData(e2), this._initialNonWorld.push(e2), this._AddInitialObjectClass(t2);\n      }\n    }\n    Release() {\n      for (const e of this._allLayersFlat) e.Release();\n      C33.clearArray(this._allLayersFlat), this._textureLoadPendingPromises.clear(), this._eventSheet = null, this._layoutManager = null, this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetName() {\n      return this._name;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetEffectList() {\n      return this._effectList;\n    }\n    GetEffectChain() {\n      return this._MaybeRebuildEffectChainSteps(), this._effectChain;\n    }\n    _MaybeRebuildEffectChainSteps() {\n      const e = \"low\" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();\n      if (!this._needsRebuildEffectChainSteps && this._wasFullScreenQualityLow === e && !this._effectChain.NeedsRebuild()) return;\n      const t = this.GetEffectList().GetActiveEffectTypes();\n      this._effectChain.BuildSteps(t.map((e2) => e2.GetShaderProgram()), { indexMap: t.map((e2) => e2.GetIndex()), forcePostDraw: e, useFullSurface: true }), this._needsRebuildEffectChainSteps = false, this._wasFullScreenQualityLow = e;\n    }\n    UpdateActiveEffects() {\n      this.GetEffectList().UpdateActiveEffects(), this._needsRebuildEffectChainSteps = true;\n    }\n    GetMinLayerScale() {\n      let e = this._allLayersFlat[0].GetNormalScale();\n      for (let t = 1, s = this._allLayersFlat.length; t < s; ++t) {\n        const s2 = this._allLayersFlat[t];\n        0 === s2.GetParallaxX() && 0 === s2.GetParallaxY() || (e = Math.min(e, s2.GetNormalScale()));\n      }\n      return e;\n    }\n    _GetScrollBoundMarginHorizontal() {\n      return 0.5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale();\n    }\n    _GetScrollBoundMarginVertical() {\n      return 0.5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale();\n    }\n    GetScrollLeftBound() {\n      return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginHorizontal();\n    }\n    GetScrollRightBound() {\n      return this.IsUnboundedScrolling() ? 1 / 0 : this.GetWidth() - this._GetScrollBoundMarginHorizontal();\n    }\n    GetScrollTopBound() {\n      return this.IsUnboundedScrolling() ? -1 / 0 : this._GetScrollBoundMarginVertical();\n    }\n    GetScrollBottomBound() {\n      return this.IsUnboundedScrolling() ? 1 / 0 : this.GetHeight() - this._GetScrollBoundMarginVertical();\n    }\n    SetScrollX(e) {\n      const t = this.GetScrollLeftBound(), s = this.GetScrollRightBound();\n      e > s && (e = s), e < t && (e = t), this._scrollX !== e && (this._scrollX = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    GetScrollX() {\n      return this._scrollX;\n    }\n    SetScrollY(e) {\n      const t = this.GetScrollTopBound(), s = this.GetScrollBottomBound();\n      e > s && (e = s), e < t && (e = t), this._scrollY !== e && (this._scrollY = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    GetScrollY() {\n      return this._scrollY;\n    }\n    IsUnboundedScrolling() {\n      return this._isUnboundedScrolling;\n    }\n    BoundScrolling() {\n      this.SetScrollX(this.GetScrollX()), this.SetScrollY(this.GetScrollY());\n      for (const e of this._allLayersFlat) e.IsOwnScrollPositionEnabled() && (e.SetScrollX(e.GetScrollX()), e.SetScrollY(e.GetScrollY()));\n    }\n    SetVanishingPointXY(e, t) {\n      this._vanishingPointX === e && this._vanishingPointY === t || (this._vanishingPointX = e, this._vanishingPointY = t, this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender()));\n    }\n    GetVanishingPointX() {\n      return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointX;\n    }\n    GetVanishingPointY() {\n      return this.IsOrthographicProjection() ? 0.5 : this._vanishingPointY;\n    }\n    HasVanishingPointOutsideViewport() {\n      const e = this.GetVanishingPointX(), t = this.GetVanishingPointY();\n      return e < 0 || e > 1 || t < 0 || t > 1;\n    }\n    SetPerspectiveProjection() {\n      this._isOrthographicProjection && (this._isOrthographicProjection = false, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    SetOrthographicProjection() {\n      this._isOrthographicProjection || (this._isOrthographicProjection = true, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    IsOrthographicProjection() {\n      return this._isOrthographicProjection;\n    }\n    IsPerspectiveProjection() {\n      return !this.IsOrthographicProjection();\n    }\n    Set3DCameraEnabled(e) {\n      e = !!e, this._is3dCameraEnabled !== e && (this._is3dCameraEnabled = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    Is3DCameraEnabled() {\n      return this._is3dCameraEnabled;\n    }\n    Set3DCameraOrientation(e, t, s, r, a, n, i, o, l) {\n      vec3EqualsXYZ(this._cam3dposition, e, t, s) && vec3EqualsXYZ(this._cam3dlook, r, a, n) && vec3EqualsXYZ(this._cam3dup, i, o, l) || (vec3.set(this._cam3dposition, e, t, s), vec3.set(this._cam3dlook, r, a, n), vec3.set(this._cam3dup, i, o, l), this.Set3DCameraChanged());\n    }\n    Set3DCameraChanged() {\n      this._SetAllLayersMVChanged(), this._runtime.UpdateRender();\n    }\n    Get3DCameraPosition() {\n      return this._cam3dposition;\n    }\n    Get3DCameraLookAt() {\n      return this._cam3dlook;\n    }\n    Get3DCameraUpVector() {\n      return this._cam3dup;\n    }\n    GetScale() {\n      return this._scale;\n    }\n    SetScale(e) {\n      this._scale !== e && (this._scale = e, this._SetAllLayersMVChanged(), this.BoundScrolling(), this._runtime.UpdateRender());\n    }\n    SetAngle(e) {\n      e = C33.clampAngle(e), this._angle !== e && (this._angle = e, this._SetAllLayersMVChanged(), this._runtime.UpdateRender());\n    }\n    GetAngle() {\n      return this._angle;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    SetWidth(e) {\n      !isFinite(e) || e < 1 || (this._width = e);\n    }\n    GetHeight() {\n      return this._height;\n    }\n    SetHeight(e) {\n      !isFinite(e) || e < 1 || (this._height = e);\n    }\n    GetEventSheet() {\n      return this._eventSheet;\n    }\n    _GetRootLayers() {\n      return this._rootLayers;\n    }\n    *allLayers() {\n      for (const e of this._rootLayers) yield* e.selfAndAllSubLayers();\n    }\n    GetLayers() {\n      return this._allLayersFlat;\n    }\n    GetLayerCount() {\n      return this._allLayersFlat.length;\n    }\n    GetLayer(e) {\n      return \"number\" == typeof e ? this.GetLayerByIndex(e) : this.GetLayerByName(e.toString());\n    }\n    GetLayerByIndex(e) {\n      return e = C33.clamp(Math.floor(e), 0, this._allLayersFlat.length - 1), this._allLayersFlat[e];\n    }\n    GetLayerByName(e) {\n      return this._layersByName.get(e.toLowerCase()) || null;\n    }\n    HasLayerByName(e) {\n      return !!this.GetLayerByName(e);\n    }\n    GetLayerBySID(e) {\n      return this._layersBySid.get(e) || null;\n    }\n    _SetAllLayersProjectionChanged() {\n      for (const e of this._allLayersFlat) e._SetProjectionMatrixChanged();\n    }\n    _SetAllLayersMVChanged() {\n      for (const e of this._allLayersFlat) e._SetMVMatrixChanged();\n    }\n    AddLayer(e, t, s) {\n      if (this.HasLayerByName(e)) throw new Error(`layer name '${e}' already in use`);\n      if (!t && s < 2) throw new Error(\"invalid insert position\");\n      const r = s >= 2 ? t : t.GetParentLayer(), a = C33.New(C33.Layer, this, r, { name: e, sid: Math.floor(1e15 * Math.random()), isDynamic: true });\n      this._InsertLayer(a, t, s), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();\n    }\n    MoveLayer(e, t, s) {\n      if (!t && s < 2) throw new Error(\"invalid insert position\");\n      e === t && s < 2 || (this._RemoveLayer(e), this._InsertLayer(e, t, s), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers());\n    }\n    RemoveLayer(e) {\n      if (this._RemoveLayer(e)) {\n        const t = this._runtime.GetEventSheetManager();\n        t.BlockFlushingInstances(true), e.Release(), t.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();\n      }\n    }\n    RemoveAllDynamicLayers() {\n      const e = /* @__PURE__ */ new Set();\n      for (const t2 of this.allLayers()) t2.IsDynamic() && !t2.HasAnyDynamicParentLayer() && e.add(t2);\n      if (0 === e.size) return;\n      const t = this._runtime.GetEventSheetManager();\n      t.BlockFlushingInstances(true);\n      for (const t2 of e) this._RemoveLayer(t2), t2.Release();\n      t.BlockFlushingInstances(false), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers();\n    }\n    _InsertLayer(e, t, s) {\n      if (s >= 2) if (t) {\n        if (t === e || t.HasParentLayer(e)) throw new Error(`cannot move layer '${e.GetName()}' to sub-layer of itself`);\n        t._AddSubLayer(e, 2 === s), e._SetParentLayer(t);\n      } else 2 === s ? this._rootLayers.push(e) : this._rootLayers.unshift(e), e._SetParentLayer(null);\n      else {\n        const r = t.GetParentLayer();\n        if (r) {\n          if (t.HasParentLayer(e)) throw new Error(`cannot move layer '${e.GetName()}' to sub-layer of itself`);\n          r._InsertSubLayer(e, t, 0 === s), e._SetParentLayer(r);\n        } else {\n          let r2 = this._rootLayers.indexOf(t);\n          if (-1 === r2) throw new Error(\"cannot find layer to insert by\");\n          0 === s && ++r2, this._rootLayers.splice(r2, 0, e), e._SetParentLayer(null);\n        }\n      }\n    }\n    _RemoveLayer(e) {\n      const t = e.GetParentLayer();\n      if (t) return t._RemoveSubLayer(e), true;\n      if (this._rootLayers.length > 1) {\n        const t2 = this._rootLayers.indexOf(e);\n        if (-1 === t2) throw new Error(\"cannot find layer to remove\");\n        return this._rootLayers.splice(t2, 1), true;\n      }\n      return false;\n    }\n    _ReindexLayers() {\n      this._allLayersFlat = [...this.allLayers()], this._layersByName.clear(), this._layersBySid.clear();\n      for (let e = 0, t = this._allLayersFlat.length; e < t; ++e) {\n        const t2 = this._allLayersFlat[e];\n        t2._SetIndex(e), this._layersByName.set(t2.GetName().toLowerCase(), t2), this._layersBySid.set(t2.GetSID(), t2);\n      }\n    }\n    _ReindexHTMLLayers() {\n      let e = 0;\n      for (const t of this._rootLayers) {\n        for (const s of t.selfAndAllSubLayers()) s._SetHTMLIndex(e);\n        t.IsHTMLElementsLayer() && e++;\n      }\n    }\n    GetHTMLLayerCount() {\n      return this._rootLayers.at(-1).GetHTMLIndex() + 1;\n    }\n    async _ReindexAndUpdateAllLayers() {\n      this._ReindexLayers(), this._ReindexHTMLLayers(), this._pendingSetHTMLLayerCount = this.GetHTMLLayerCount();\n    }\n    _GetPendingSetHTMLLayerCount() {\n      return this._pendingSetHTMLLayerCount;\n    }\n    _ResetPendingHTMLLayerCount() {\n      this._pendingSetHTMLLayerCount = -1;\n    }\n    GetRootLayersForHTMLLayer(e) {\n      const t = [];\n      for (const s of this._rootLayers) {\n        const r = s.GetHTMLIndex();\n        if (r === e) t.push(s);\n        else if (r > e) break;\n      }\n      return t;\n    }\n    SaveTransform() {\n      return { \"scrollX\": this.GetScrollX(), \"scrollY\": this.GetScrollY(), \"scale\": this.GetScale(), \"angle\": this.GetAngle(), \"vpX\": this.GetVanishingPointX(), \"vpY\": this.GetVanishingPointY() };\n    }\n    RestoreTransform(e) {\n      this.SetScrollX(e[\"scrollX\"]), this.SetScrollY(e[\"scrollY\"]), this.SetScale(e[\"scale\"]), this.SetAngle(e[\"angle\"]), this.SetVanishingPointXY(e[\"vpX\"], e[\"vpY\"]);\n    }\n    GetLayoutBackgroundColor() {\n      let e = this._rootLayers.filter((e2) => e2.ShouldDraw())[0];\n      for (; e; ) {\n        if (!e.IsTransparent()) return tempColor.copyRgb(e.GetBackgroundColor()), tempColor.setA(1), tempColor;\n        if (e.UsesOwnTexture()) return tempColor.setRgba(0, 0, 0, 0), tempColor;\n        e = e.GetSubLayers().filter((e2) => e2.ShouldDraw())[0];\n      }\n      return tempColor.setRgba(0, 0, 0, 0), tempColor;\n    }\n    IsFirstVisit() {\n      return this._isFirstVisit;\n    }\n    _GetInitialObjectClasses() {\n      return [...this._initialObjectClasses];\n    }\n    _AddInitialObjectClass(e) {\n      if (e.IsInContainer()) for (const t of e.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(t);\n      else this._initialObjectClasses.add(e);\n    }\n    _GetTextureLoadedObjectTypes() {\n      return [...this._textureLoadedTypes];\n    }\n    _Load(e, t) {\n      if (e === this || !t) return Promise.resolve();\n      e && (C33.CopySet(this._textureLoadedTypes, e._textureLoadedTypes), e._textureLoadedTypes.clear());\n      const s = [];\n      for (const e2 of this._initialObjectClasses) this._textureLoadedTypes.has(e2) || (s.push(e2.LoadTextures(t)), this._textureLoadedTypes.add(e2));\n      return Promise.all(s);\n    }\n    async MaybeLoadTexturesFor(e) {\n      if (e.IsFamily()) throw new Error(\"cannot load textures for family\");\n      const t = this._runtime.GetRenderer();\n      if (!t || t.IsContextLost() || this._textureLoadedTypes.has(e)) return;\n      this._textureLoadedTypes.add(e);\n      const s = e.LoadTextures(t);\n      this._AddPendingTextureLoadPromise(s), await s, e.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender();\n    }\n    _AddPendingTextureLoadPromise(e) {\n      this._textureLoadPendingPromises.add(e), e.then(() => this._textureLoadPendingPromises.delete(e)).catch(() => this._textureLoadPendingPromises.delete(e));\n    }\n    WaitForPendingTextureLoadsToComplete() {\n      return Promise.all([...this._textureLoadPendingPromises]);\n    }\n    MaybeUnloadTexturesFor(e) {\n      if (e.IsFamily() || e.GetInstanceCount() > 0) throw new Error(\"cannot unload textures\");\n      const t = this._runtime.GetRenderer();\n      t && this._textureLoadedTypes.has(e) && (this._textureLoadedTypes.delete(e), e.ReleaseTextures(t));\n    }\n    _Unload(e, t) {\n      if (e !== this && t) for (const t2 of this._textureLoadedTypes) t2.IsGlobal() || e._initialObjectClasses.has(t2) || (t2.ReleaseTextures(), this._textureLoadedTypes.delete(t2));\n    }\n    _OnRendererContextLost() {\n      this._textureLoadedTypes.clear();\n    }\n    async _StartRunning(e) {\n      const t = this._runtime, s = this._layoutManager, r = t.GetEventSheetManager();\n      this._eventSheetName && (this._eventSheet = r.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes()), s._SetMainRunningLayout(this), this._width = this._originalWidth, this._height = this._originalHeight, this._scrollX = t.GetOriginalViewportWidth() / 2, this._scrollY = t.GetOriginalViewportHeight() / 2, this.BoundScrolling(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._ReindexHTMLLayers(), await this._runtime.GetCanvasManager().SetHTMLLayerCount(this.GetHTMLLayerCount(), true), this._MoveGlobalObjectsToThisLayout(e), this._runtime.SetUsingCreatePromises(true), this._CreateInitialInstances(), this._isFirstVisit || this._CreatePersistedInstances(), this._CreateAndLinkContainerInstances(this._createdInstances), this._CreateAndLinkContainerInstances(this._createdPersistedInstances), this._CreateInitialNonWorldInstances(), s.ClearPendingChangeLayout(), t.FlushPendingInstances(), this._runtime.SetUsingCreatePromises(false);\n      const a = this._runtime.GetCreatePromises();\n      if (await Promise.all(a), C33.clearArray(a), !t.IsLoadingState()) {\n        for (const e2 of this._createdInstances) e2.SetupInitialSceneGraphConnections();\n        for (const e2 of this._createdPersistedInstances) e2.SetupPersistedSceneGraphConnections(this._createdPersistedInstancesToDataMap, this._createdPersistedIndexToInstanceMap);\n        for (const [e2, t2] of Object.entries(this._persistData)) {\n          const s2 = this._runtime.GetObjectClassBySID(parseInt(e2, 10));\n          s2 && !s2.IsFamily() && s2.HasPersistBehavior() && C33.clearArray(t2);\n        }\n        for (const e2 of this._createdInstances) e2._TriggerOnCreated();\n        for (const e2 of this._createdPersistedInstances) e2._TriggerOnCreated();\n        for (const e2 of this._createdInstances) e2.HasParent() || e2._OnHierarchyReady();\n        for (const e2 of this._createdPersistedInstances) e2.HasParent() || e2._OnHierarchyReady();\n      }\n      C33.clearArray(this._createdInstances), C33.clearArray(this._createdPersistedInstances), this._createdPersistedInstancesToDataMap.clear(), this._createdPersistedIndexToInstanceMap.clear(), await Promise.all([...this._initialObjectClasses].map((e2) => e2.PreloadTexturesWithInstances(this._runtime.GetRenderer()))), e && (t.Dispatcher().dispatchEvent(new C33.Event(\"beforefirstlayoutstart\")), await t.DispatchUserScriptEventAsyncWait(new C33.Event(\"beforeprojectstart\"))), await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event(\"beforeanylayoutstart\")), t.Dispatcher().dispatchEvent(new C33.Event(\"beforelayoutstart\")), await this.DispatchUserScriptEventAsyncWait(new C33.Event(\"beforelayoutstart\")), t.IsLoadingState() || await t.TriggerAsync(C33.Plugins.System.Cnds.OnLayoutStart, null, null), t.Dispatcher().dispatchEvent(new C33.Event(\"afterlayoutstart\")), await this.DispatchUserScriptEventAsyncWait(new C33.Event(\"afterlayoutstart\")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event(\"afteranylayoutstart\")), e && (t.Dispatcher().dispatchEvent(new C33.Event(\"afterfirstlayoutstart\")), await t.DispatchUserScriptEventAsyncWait(new C33.Event(\"afterprojectstart\"))), r._RunQueuedTriggers(s), await this.WaitForPendingTextureLoadsToComplete(), this._isFirstVisit = false;\n    }\n    _MoveGlobalObjectsToThisLayout(e) {\n      for (const e2 of this._runtime.GetAllObjectClasses()) if (!e2.IsFamily() && e2.IsWorldType()) for (const t of e2.GetInstances()) {\n        const e3 = t.GetWorldInfo(), s = e3.GetLayer(), r = C33.clamp(s.GetIndex(), 0, this._allLayersFlat.length - 1), a = this._allLayersFlat[r];\n        e3._SetLayer(a, true), a._MaybeAddInstance(t);\n      }\n      if (!e) for (const e2 of this._allLayersFlat) e2._SortInstancesByLastCachedZIndex(false);\n    }\n    _CreateInitialInstances() {\n      for (const e of this._allLayersFlat) e.CreateInitialInstances(this._createdInstances), e._Start();\n    }\n    _CreatePersistedInstances() {\n      let e = false;\n      for (const [t, s] of Object.entries(this._persistData)) {\n        const r = this._runtime.GetObjectClassBySID(parseInt(t, 10));\n        if (r && !r.IsFamily() && r.HasPersistBehavior()) for (const t2 of s) {\n          let s2 = null;\n          if (r.IsWorldType() && (s2 = t2.hasOwnProperty(\"instJson\") ? this.GetLayerBySID(t2[\"instJson\"][\"w\"][\"l\"]) : this.GetLayerBySID(t2[\"w\"][\"l\"]), !s2)) continue;\n          const a = this._runtime.CreateInstanceFromData(r, s2, false, 0, 0, true);\n          t2.hasOwnProperty(\"instJson\") ? a.LoadFromJson(t2[\"instJson\"]) : a.LoadFromJson(t2), e = true, this._createdPersistedInstances.push(a), t2.hasOwnProperty(\"instJson\") && (this._createdPersistedInstancesToDataMap.set(a, t2), this._createdPersistedIndexToInstanceMap.set(t2[\"index\"], a));\n        }\n      }\n      for (const e2 of this._allLayersFlat) e2._SortInstancesByLastCachedZIndex(true), e2.SetZIndicesChanged();\n      e && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap());\n    }\n    _CreateAndLinkContainerInstances(e) {\n      for (const t of e) {\n        if (!t.IsInContainer()) continue;\n        const s = t.GetWorldInfo(), r = t.GetIID();\n        for (const a of t.GetObjectClass().GetContainer().objectTypes()) {\n          if (a === t.GetObjectClass()) continue;\n          const n = a.GetInstances();\n          if (n.length > r) t._AddSibling(n[r]);\n          else {\n            let r2;\n            r2 = s ? this._runtime.CreateInstanceFromData(a, s.GetLayer(), true, s.GetX(), s.GetY(), true) : this._runtime.CreateInstanceFromData(a, null, true, 0, 0, true), this._runtime.FlushPendingInstances(), a._UpdateIIDs(), t._AddSibling(r2), e.push(r2);\n          }\n        }\n      }\n    }\n    _CreateInitialNonWorldInstances() {\n      for (const e of this._initialNonWorld) {\n        this._runtime.GetObjectClassByIndex(e[1]).IsInContainer() || this._runtime.CreateInstanceFromData(e, null, true);\n      }\n    }\n    _CreateGlobalNonWorlds() {\n      const e = [], t = this._initialNonWorld;\n      let s = 0;\n      for (let r = 0, a = t.length; r < a; ++r) {\n        const a2 = t[r], n = this._runtime.GetObjectClassByIndex(a2[1]);\n        n.IsGlobal() ? n.IsInContainer() && n.GetContainer().HasAnyWorldType() || e.push(this._runtime.CreateInstanceFromData(a2, null, true)) : (t[s] = a2, ++s);\n      }\n      C33.truncateArray(t, s), this._runtime.FlushPendingInstances(), this._CreateAndLinkContainerInstances(e);\n    }\n    RecreateInitialObjects(e, t, s, r, a, n, i) {\n      if (s) return s.RecreateInitialObjects(e, t, a, n, r, i);\n      {\n        const s2 = [];\n        for (const o of this._allLayersFlat) s2.push(o.RecreateInitialObjects(e, t, a, n, r, i));\n        return s2.flat();\n      }\n    }\n    async _StopRunning() {\n      const e = this._layoutManager;\n      this._runtime.IsLoadingState() || (await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event(\"beforeanylayoutend\")), await this.DispatchUserScriptEventAsyncWait(new C33.Event(\"beforelayoutend\")), await this._runtime.TriggerAsync(C33.Plugins.System.Cnds.OnLayoutEnd, null, null), await this.DispatchUserScriptEventAsyncWait(new C33.Event(\"afterlayoutend\")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C33.Event(\"afteranylayoutend\"))), e.SetIsEndingLayout(true), this._runtime.GetEventSheetManager().ClearAllScheduledWaits(), this._isFirstVisit || this._SavePersistData();\n      for (const e2 of this._allLayersFlat) e2._End();\n      for (const e2 of this._runtime.GetAllObjectClasses()) if (!(e2.IsGlobal() || e2.IsWorldType() || e2.GetPlugin().IsSingleGlobal() || e2.IsFamily())) {\n        for (const t of e2.GetInstances()) this._runtime.DestroyInstance(t);\n        this._runtime.FlushPendingInstances();\n      }\n      e.SetIsEndingLayout(false), e.GetMainRunningLayout() === this && e._SetMainRunningLayout(null);\n    }\n    _SaveInstanceToPersist(e, t) {\n      const s = e.GetObjectClass().GetSID().toString();\n      this._persistData.hasOwnProperty(s) || (this._persistData[s] = []);\n      const r = this._persistData[s], a = { \"index\": t, \"instJson\": e.SaveToJson(), \"sceneGraphJson\": { \"children\": [] } };\n      r.push(a), this._persistedIntances.set(e, a);\n    }\n    _SaveSceneGraphInfoToPersist(e) {\n      const t = this._persistedIntances.get(e);\n      for (const s of e.GetChildren()) {\n        const e2 = this._persistedIntances.get(s);\n        e2 && t[\"sceneGraphJson\"][\"children\"].push({ \"index\": e2[\"index\"], \"flags\": C33.SceneGraphInfo._GetFlagsNumber(s.GetWorldInfo()) });\n      }\n    }\n    _SavePersistData() {\n      this._persistedIntances.clear();\n      let e = 0;\n      for (const t of this._allLayersFlat) {\n        t._UpdateZIndices();\n        for (const s of t._GetInstances()) {\n          const t2 = s.GetObjectClass();\n          !t2.IsGlobal() && t2.HasPersistBehavior() && (this._SaveInstanceToPersist(s, e), e++);\n        }\n      }\n      for (const e2 of this._allLayersFlat) for (const t of e2._GetInstances()) {\n        const e3 = t.GetObjectClass();\n        !e3.IsGlobal() && e3.HasPersistBehavior() && this._SaveSceneGraphInfoToPersist(t);\n      }\n      this._persistedIntances.clear();\n    }\n    ResetPersistData() {\n      this._persistData = {}, this._isFirstVisit = true;\n    }\n    GetRenderTarget() {\n      return this._curRenderTarget;\n    }\n    UsesOwnTexture() {\n      const e = this._runtime, t = e.GetRenderer().IsWebGL();\n      return \"low\" === e.GetCanvasManager().GetCurrentFullscreenScalingQuality() || t && e.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect() || t && e.Uses3DFeatures();\n    }\n    _MaybeStartDrawToOwnTexture(e) {\n      const t = this._runtime.GetCanvasManager();\n      if (this.UsesOwnTexture()) {\n        e.SetRenderTarget(null), e.ClearRgba(0, 0, 0, 0);\n        const s = { sampling: this._runtime.GetSampling(), isSampled: e.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect(), canReadPixels: !!e.IsWebGPU() && this._runtime.UsesAnyBackgroundBlending() };\n        \"low\" === t.GetCurrentFullscreenScalingQuality() && (s.width = t.GetDrawWidth(), s.height = t.GetDrawHeight()), this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(s);\n      } else this._curRenderTarget = null;\n    }\n    _MaybeCopyOwnTextureToBackbuffer(e) {\n      this._runtime._NeedsHTMLLayerCompositing(e) && (e.SetDepthEnabled(false), e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(this._curRenderTarget));\n    }\n    _MaybeEndDrawToOwnTexture(e) {\n      this.UsesOwnTexture() && (e.SetDepthEnabled(false), this._DrawLayoutOwnTextureToRenderTarget(e, this._curRenderTarget));\n    }\n    DrawMain(e) {\n      e.SetRenderTarget(this._curRenderTarget), e.Clear(this.GetLayoutBackgroundColor()), this._runtime.Uses3DFeatures() && e.ClearDepth();\n      const t = this.GetRootLayersForHTMLLayer(0);\n      this._DrawLayerList(e, this._curRenderTarget, t, true), e.IsWebGPU() && e.StartMeasuringRenderPassTime(0, 1), this._MaybeEndDrawToOwnTexture(e), this._curRenderTarget = null;\n    }\n    DrawForHTMLLayerIndex(e, t) {\n      let s = null;\n      this._runtime._NeedsHTMLLayerCompositing(e) && (s = this._curRenderTarget), e.SetRenderTarget(s), e.ClearRgba(0, 0, 0, 0), this._runtime.Uses3DFeatures() && e.ClearDepth();\n      const r = this.GetRootLayersForHTMLLayer(t);\n      this._DrawLayerList(e, s, r, true), this._MaybeCopyOwnTextureToBackbuffer(e), e.EndBatch(), this._runtime.GetCanvasManager().BlitMainCanvasToHTMLLayerCanvas(t);\n    }\n    _DrawLayerList(e, t, s, r) {\n      const a = s.filter((e2) => e2.ShouldDraw());\n      for (let s2 = 0, n = a.length; s2 < n; ) {\n        const i = a[s2];\n        if (i.SelfAndAllSubLayersHave3DCamera() && !i.SelfOrAnySubLayerUsesOwnTexture()) {\n          tempRender3dList.push(i);\n          for (let e2 = s2 + 1; e2 < n; ++e2) {\n            const t2 = a[e2];\n            if (!t2.SelfAndAllSubLayersHave3DCamera() || t2.SelfOrAnySubLayerUsesOwnTexture()) break;\n            tempRender3dList.push(a[e2]);\n          }\n          if (tempRender3dList.length >= 2 || 1 === tempRender3dList.length && tempRender3dList[0].HasAnyVisibleSubLayer()) {\n            this._Draw3DLayers(e, t, tempRender3dList), s2 += tempRender3dList.length, C33.clearArray(tempRender3dList);\n            continue;\n          }\n          C33.clearArray(tempRender3dList);\n        }\n        i.Draw(e, t, r && 0 === s2), ++s2;\n      }\n    }\n    _DrawLayoutOwnTextureToRenderTarget(e, t) {\n      const s = this._effectList.GetActiveEffectTypes(), r = this._runtime;\n      0 === s.length ? (e.SetRenderTarget(null), e.SetTextureFillMode(), e.CopyRenderTarget(t), e.InvalidateRenderTarget(t), r.ReleaseAdditionalRenderTarget(t)) : (tempLayoutRect.set(0, 0, r.GetViewportWidth(), r.GetViewportHeight()), this.GetEffectChain().Render(e, null, { contentObject: this, blendMode: 3, devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(), layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(), layerAngle: this.GetAngle(), layoutRect: tempLayoutRect, drawSurfaceRect: null, invalidateRenderTargets: true }));\n    }\n    _Draw3DLayers(e, t, s) {\n      s[0].IsTransparent() || (tempColor.copyRgb(s[0].GetBackgroundColor()), tempColor.setA(1), e.Clear(tempColor));\n      this._runtime.GetCanvasManager();\n      e.SetDepthEnabled(true);\n      const r = tempInstanceList1, a = tempInstanceList2, n = tempInstanceList3;\n      for (const e2 of s) e2._UpdateZIndices(), e2._AppendAllInstancesIncludingSubLayersInDrawOrder(r);\n      const i = s[0], o = i._MaybeStartWebGLProfiling(e);\n      i._MaybeStartWebGPUProfiling(e);\n      for (let s2 = 0, i2 = r.length; s2 < i2; ) {\n        const o2 = r[s2], l = o2.GetWorldInfo(), h = l.GetLayer();\n        if (!l.IsVisible() || !l.IsInViewport3D(h._GetViewFrustum())) {\n          ++s2;\n          continue;\n        }\n        (!o2.RendersToOwnZPlane() || l.GetDepth() > 0) && n.push(o2);\n        const c = o2.GetWorldInfo().GetTotalZElevation();\n        a.push(o2);\n        let d = s2 + 1;\n        for (; d < i2; ++d) {\n          const e2 = r[d], t2 = e2.GetWorldInfo();\n          if (t2.IsVisible() && t2.IsInViewport3D(t2.GetLayer()._GetViewFrustum())) {\n            if (t2.GetTotalZElevation() !== c) break;\n            e2.RendersToOwnZPlane() ? (t2.GetDepth() > 0 && n.push(e2), a.push(e2)) : n.push(e2);\n          }\n        }\n        if (1 !== a.length || a[0].MustMitigateZFighting()) {\n          this._Draw3DLayersCoplanarInstances(e, t, a);\n          for (let s3 = 0, r2 = n.length; s3 < r2; ++s3) {\n            const r3 = n[s3], a2 = r3.GetWorldInfo(), i3 = a2.GetLayer();\n            a2._SetDrawNonBackFacesOnly(true), MaybePrepareLayerDraw(i3, e), i3._DrawInstanceMaybeWithEffects(r3, a2, e, t), a2._SetDrawNonBackFacesOnly(false);\n          }\n        } else {\n          MaybePrepareLayerDraw(h, e), h._DrawInstanceMaybeWithEffects(o2, l, e, t);\n          for (let s3 = 0, r2 = n.length; s3 < r2; ++s3) {\n            const r3 = n[s3];\n            if (r3 === o2) continue;\n            const a2 = r3.GetWorldInfo(), i3 = a2.GetLayer();\n            MaybePrepareLayerDraw(i3, e), i3._DrawInstanceMaybeWithEffects(r3, a2, e, t);\n          }\n        }\n        s2 = d, C33.clearArray(a), C33.clearArray(n);\n      }\n      o && e.EndQuery(o), C33.clearArray(r), lastLayerPreparedForDrawing = null;\n    }\n    _Draw3DLayersCoplanarInstances(e, t, s) {\n      e.CoplanarStartStencilPass();\n      for (let t2 = 0, r = s.length; t2 < r; ++t2) {\n        const r2 = s[t2], a = r2.GetWorldInfo(), n = a.GetLayer();\n        a._SetDrawBackFaceOnly(true), MaybePrepareLayerDraw(n, e), n._DrawInstance(r2, a, e);\n      }\n      e.CoplanarStartColorPass();\n      for (let r = 0, a = s.length; r < a; ++r) {\n        const a2 = s[r], n = a2.GetWorldInfo(), i = n.GetLayer();\n        MaybePrepareLayerDraw(i, e), i._DrawInstanceMaybeWithEffects(a2, n, e, t), n._SetDrawBackFaceOnly(false);\n      }\n      e.CoplanarRestoreStandardRendering();\n    }\n    _SaveToJson() {\n      const e = { \"sx\": this.GetScrollX(), \"sy\": this.GetScrollY(), \"s\": this.GetScale(), \"a\": this.GetAngle(), \"w\": this.GetWidth(), \"h\": this.GetHeight(), \"ortho\": this.IsOrthographicProjection(), \"vpX\": this.GetVanishingPointX(), \"vpY\": this.GetVanishingPointY(), \"fv\": this._isFirstVisit, \"persist\": this._persistData, \"fx\": this._effectList.SaveToJson(), \"layers\": {}, \"dynamicLayers\": [] };\n      for (const t of this._allLayersFlat) if (t.IsDynamic()) {\n        const s = t.GetParentLayer();\n        e[\"dynamicLayers\"].push({ \"sid\": t.GetSID(), \"name\": t.GetName(), \"parentSid\": s ? s.GetSID() : null, \"siblingIndex\": t._GetSiblingIndex(), \"data\": t._SaveToJson() });\n      } else e[\"layers\"][t.GetSID().toString()] = t._SaveToJson();\n      return e;\n    }\n    _LoadFromJson(e) {\n      this._scrollX = e[\"sx\"], this._scrollY = e[\"sy\"], this._scale = e[\"s\"], this._angle = e[\"a\"], this._width = e[\"w\"], this._height = e[\"h\"], this._isOrthographicProjection = !!e[\"ortho\"], e.hasOwnProperty(\"vpX\") && (this._vanishingPointX = e[\"vpX\"]), e.hasOwnProperty(\"vpY\") && (this._vanishingPointY = e[\"vpY\"]), this._isFirstVisit = !!e[\"fv\"], this._persistData = e[\"persist\"], this._effectList.LoadFromJson(e[\"fx\"]), this._needsRebuildEffectChainSteps = true;\n      for (const [t, s] of Object.entries(e[\"layers\"])) {\n        const e2 = parseInt(t, 10), r = this.GetLayerBySID(e2);\n        r && r._LoadFromJson(s);\n      }\n      if (e.hasOwnProperty(\"dynamicLayers\")) {\n        this.RemoveAllDynamicLayers(), this._runtime.FlushPendingInstances();\n        const t = /* @__PURE__ */ new Map(), s = e[\"dynamicLayers\"];\n        for (let e2 = s.length - 1; e2 >= 0; --e2) {\n          const r = s[e2], a = r[\"sid\"], n = r[\"name\"], i = r[\"parentSid\"], o = r[\"siblingIndex\"], l = r[\"data\"];\n          if (this._ReindexLayers(), this.HasLayerByName(n) || this.GetLayerBySID(a)) continue;\n          let h, c;\n          if (null === i) h = null, c = this._rootLayers;\n          else {\n            if (h = this.GetLayerBySID(i), !h) continue;\n            c = h.GetSubLayers();\n          }\n          const d = C33.New(C33.Layer, this, h, { name: n, sid: a, isDynamic: true });\n          c.push(d);\n          let _ = t.get(c);\n          _ || (_ = [], t.set(c, _)), _.push({ layer: d, siblingIndex: o }), d._LoadFromJson(l);\n        }\n        for (const [e2, s2] of t) {\n          s2.sort((e3, t2) => e3.siblingIndex - t2.siblingIndex);\n          for (const t2 of s2) {\n            const s3 = t2.layer, r = t2.siblingIndex;\n            let a = e2.indexOf(s3);\n            e2.splice(a, 1), e2.splice(r, 0, s3);\n          }\n        }\n      }\n      this._ReindexAndUpdateAllLayers(), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged();\n    }\n    GetILayout() {\n      return this._iLayout;\n    }\n    UserScriptDispatcher() {\n      return this._userScriptDispatcher;\n    }\n    DispatchUserScriptEvent(e) {\n      e.layout = this.GetILayout();\n      const t = this._runtime, s = t.IsDebug() && !t.GetEventSheetManager().IsInEventEngine();\n      s && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), s && C3Debugger.AddScriptTime();\n    }\n    DispatchUserScriptEventAsyncWait(e) {\n      return e.layout = this.GetILayout(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);\n    }\n    DispatchRuntimeUserScriptEventAsyncWait(e) {\n      return e.layout = this.GetILayout(), this._runtime.DispatchUserScriptEventAsyncWait(e);\n    }\n    _LogLayerTree() {\n      this._LogLayerList(this._rootLayers);\n    }\n    _LogLayerList(e, t = 0) {\n      const s = e.slice(0);\n      s.reverse();\n      for (const e2 of s) console.log(`${\"\t\".repeat(t)}- ${e2.GetName()}`), this._LogLayerList(e2.GetSubLayers(), t + 1);\n    }\n  };\n}\nvar vec3EqualsXYZ2;\nvar MaybePrepareLayerDraw2;\n{\n  const C33 = self.C3;\n  C33.LayoutManager = class extends C33.DefendedBase {\n    #t;\n    #n = [];\n    #u = /* @__PURE__ */ new Map();\n    #a = /* @__PURE__ */ new Map();\n    #i = null;\n    #e = [];\n    #s = null;\n    #o = 0;\n    #y = null;\n    constructor(t) {\n      super(), this.#t = t;\n    }\n    Release() {\n      this.#t = null, this.#i = null, this.#s = null, this.#y = null, C33.clearArray(this.#n), this.#u.clear(), this.#a.clear(), C33.clearArray(this.#e);\n    }\n    Create(t) {\n      const n = C33.New(C33.Layout, this, this.#n.length, t);\n      this.#n.push(n), this.#u.set(n.GetName().toLowerCase(), n), this.#a.set(n.GetSID(), n);\n    }\n    GetRuntime() {\n      return this.#t;\n    }\n    SetFirstLayout(t) {\n      this.#s = t;\n    }\n    GetFirstLayout() {\n      if (this.#s) return this.#s;\n      if (this.#n.length) return this.#n[0];\n      throw new Error(\"no first layout\");\n    }\n    GetLayoutByName(t) {\n      return this.#u.get(t.toLowerCase()) || null;\n    }\n    GetLayoutBySID(t) {\n      return this.#a.get(t) || null;\n    }\n    GetLayoutByIndex(t) {\n      return t = C33.clamp(Math.floor(t), 0, this.#n.length - 1), this.#n[t];\n    }\n    GetLayout(t) {\n      return \"number\" == typeof t ? this.GetLayoutByIndex(t) : this.GetLayoutByName(t.toString());\n    }\n    GetAllLayouts() {\n      return this.#n;\n    }\n    _SetMainRunningLayout(t) {\n      this.#i = t;\n    }\n    GetMainRunningLayout() {\n      return this.#i;\n    }\n    _AddRunningSubLayout(t) {\n      if (this.#e.includes(t)) throw new Error(\"layout already running\");\n      this.#e.push(t);\n    }\n    _RemoveRunningSubLayout(t) {\n      const n = this.#e.indexOf(t);\n      if (-1 === n) throw new Error(\"layout not running\");\n      this.#e.splice(n, 1);\n    }\n    *runningLayouts() {\n      this.#i && (yield this.#i), this.#e.length && (yield* this.#e);\n    }\n    IsLayoutRunning(t) {\n      return this.#i === t || this.#e.includes(t);\n    }\n    SetIsEndingLayout(t) {\n      if (t) this.#o++;\n      else {\n        if (this.#o <= 0) throw new Error(\"already unset\");\n        this.#o--;\n      }\n    }\n    IsEndingLayout() {\n      return this.#o > 0;\n    }\n    ChangeMainLayout(t) {\n      this.#y = t;\n    }\n    ClearPendingChangeLayout() {\n      this.#y = null;\n    }\n    IsPendingChangeMainLayout() {\n      return !!this.#y;\n    }\n    GetPendingChangeMainLayout() {\n      return this.#y;\n    }\n    SetAllLayerProjectionChanged() {\n      const t = this.GetMainRunningLayout();\n      t && t._SetAllLayersProjectionChanged();\n    }\n    SetAllLayerMVChanged() {\n      const t = this.GetMainRunningLayout();\n      t && t._SetAllLayersMVChanged();\n    }\n  };\n}\n{\n  const C33 = self.C3, NAMES_REGEXP = new RegExp(\"<(.+?)>\", \"g\");\n  C33.TimelineManager = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e, this._timelineDataManager = C33.New(C33.TimelineDataManager), this._pluginInstance = null, this._timelines = [], this._timelinesByName = /* @__PURE__ */ new Map(), this._objectClassToTimelineMap = /* @__PURE__ */ new Map(), this._timelinesCreatedByTemplate = /* @__PURE__ */ new Map(), this._scheduledTimelines = [], this._playingTimelines = [], this._markedForRemovalTimelines = [], this._hasRuntimeListeners = false, this._changingLayout = false, this._isTickingTimelines = false, this._tickFunc = () => this._OnTick(), this._tick2Func = () => this._OnTick2(), this._beforeLayoutChange = () => this._OnBeforeChangeLayout(), this._layoutChange = () => this._OnAfterChangeLayout(), this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance), this._beforeLoad = (e2) => this._OnBeforeLoad(), this._afterLoad = (e2) => this._OnAfterLoad(), this._afterLayoutStart = (e2) => this._OnAfterLayoutStart(), this._destroyedWhileLoadingState = [], this._renderChange = 0;\n    }\n    Release() {\n      this.RemoveRuntimeListeners(), this._tickFunc = null, this._tick2Func = null, this._beforeLayoutChange = null, this._layoutChange = null, this._instanceDestroy = null, this._afterLoad = null;\n      for (const e of this._timelines) e.Stop(), e.Release();\n      C33.clearArray(this._timelines), this._timelines = null, this._timelineDataManager.Release(), this._timelineDataManager = null, C33.clearArray(this._scheduledTimelines), this._scheduledTimelines = null, C33.clearArray(this._playingTimelines), this._playingTimelines = null, C33.clearArray(this._markedForRemovalTimelines), this._markedForRemovalTimelines = null, this._timelinesByName.clear(), this._timelinesByName = null, this._objectClassToTimelineMap.clear(), this._objectClassToTimelineMap = null, this._timelinesCreatedByTemplate.clear(), this._timelinesCreatedByTemplate = null, C33.clearArray(this._destroyedWhileLoadingState), this._destroyedWhileLoadingState = null, this._runtime = null;\n    }\n    AddRuntimeListeners() {\n      const e = this._runtime.Dispatcher();\n      e.addEventListener(\"pretick\", this._tickFunc), e.addEventListener(\"tick2\", this._tick2Func), e.addEventListener(\"beforelayoutchange\", this._beforeLayoutChange), e.addEventListener(\"layoutchange\", this._layoutChange), e.addEventListener(\"instancedestroy\", this._instanceDestroy), e.addEventListener(\"beforeload\", this._beforeLoad), e.addEventListener(\"afterload\", this._afterLoad), e.addEventListener(\"afterlayoutstart\", this._afterLayoutStart);\n    }\n    RemoveRuntimeListeners() {\n      const e = this._runtime.Dispatcher();\n      e.removeEventListener(\"pretick\", this._tickFunc), e.removeEventListener(\"tick2\", this._tick2Func), e.removeEventListener(\"beforelayoutchange\", this._beforeLayoutChange), e.removeEventListener(\"layoutchange\", this._layoutChange), e.removeEventListener(\"instancedestroy\", this._instanceDestroy), e.removeEventListener(\"beforeload\", this._beforeLoad), e.removeEventListener(\"afterload\", this._afterLoad), e.removeEventListener(\"afterlayoutstart\", this._afterLayoutStart);\n    }\n    Create(e) {\n      this._timelineDataManager.Add(e);\n      const i = C33.TimelineState.CreateInitial(e, this);\n      this.Add(i), this.SetTimelineObjectClassesToMap(i), this._timelinesCreatedByTemplate.set(i.GetName(), 0);\n    }\n    CreateFromTemplate(e) {\n      const i = this.GetTimelineDataManager(), t = e.GetTemplateName(), s = i.Get(t), n = C33.TimelineState.CreateFromTemplate(`${t}:${this._timelinesCreatedByTemplate.get(t)}`, s, this);\n      return this._IncreaseTemplateTimelinesCount(t), this.Add(n), n;\n    }\n    _IncreaseTemplateTimelinesCount(e) {\n      this._timelinesCreatedByTemplate.set(e, this._timelinesCreatedByTemplate.get(e) + 1);\n    }\n    _SetCreatedTemplateTimelinesCount() {\n      for (const e of this._timelines) {\n        if (e.IsTemplate()) continue;\n        const i = e.GetTemplateName();\n        this._IncreaseTemplateTimelinesCount(i);\n      }\n    }\n    _ClearCreatedTemplateTimelinesCount() {\n      for (const e of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(e, 0);\n    }\n    Add(e) {\n      this._timelines.push(e), this._timelinesByName.set(e.GetName().toLowerCase(), e);\n    }\n    Remove(e) {\n      e.Removed(), e.IsTemplate() || (C33.arrayFindRemove(this._timelines, e), C33.arrayFindRemove(this._scheduledTimelines, e), C33.arrayFindRemove(this._playingTimelines, e), C33.arrayFindRemove(this._markedForRemovalTimelines, e), this._timelinesByName.delete(e.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(e), e.IsReleased() || e.Release());\n    }\n    Trigger(e) {\n      this._runtime.Trigger(e, this._pluginInstance, null);\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetTimelineDataManager() {\n      return this._timelineDataManager;\n    }\n    SetPluginInstance(e) {\n      this._pluginInstance = e;\n    }\n    GetPluginInstance() {\n      return this._pluginInstance;\n    }\n    *GetTimelines() {\n      for (const e of this._timelines) yield e;\n    }\n    *GetPlayingTimelines() {\n      for (const e of this._playingTimelines) yield e;\n    }\n    SetTimelineObjectClassToMap(e, i) {\n      this._objectClassToTimelineMap.has(e) || this._objectClassToTimelineMap.set(e, /* @__PURE__ */ new Set()), this._objectClassToTimelineMap.get(e).add(i);\n    }\n    SetTimelineObjectClassesToMap(e) {\n      for (const i of e.GetObjectClasses()) this.SetTimelineObjectClassToMap(i, e);\n    }\n    RemoveTimelineFromObjectClassMap(e) {\n      for (const [i, t] of this._objectClassToTimelineMap.entries()) t.has(e) && (t.delete(e), 0 === t.size && this._objectClassToTimelineMap.delete(i));\n    }\n    GetTimelinesForObjectClass(e) {\n      if (this._objectClassToTimelineMap.has(e)) return this._objectClassToTimelineMap.get(e);\n    }\n    GetTimelineOfTemplateForInstances(e, i) {\n      if (i) for (const t of this._timelines) {\n        if (i.every((e2) => t.HasTrackInstance(e2.instance, e2.trackId)) && t.GetName().includes(e.GetName())) return t;\n      }\n    }\n    GetTimelineByName(e) {\n      return this._timelinesByName.get(e.toLowerCase()) || null;\n    }\n    GetScheduledOrPlayingTimelineByName(e) {\n      for (const i of this._scheduledTimelines) if (i.GetName() === e) return i;\n      for (const i of this._playingTimelines) if (i.GetName() === e) return i;\n      return null;\n    }\n    *GetTimelinesByName(e) {\n      if (NAMES_REGEXP.test(e)) {\n        let i;\n        NAMES_REGEXP.lastIndex = 0;\n        const t = /* @__PURE__ */ new Set();\n        do {\n          if (i = NAMES_REGEXP.exec(e), i) {\n            const e2 = i[1].split(\",\");\n            for (const i2 of e2) t.add(i2);\n          }\n        } while (i);\n        for (const e2 of t.values()) {\n          const i2 = this.GetTimelineByName(e2);\n          i2 && (yield i2);\n        }\n        t.clear();\n      } else {\n        const i = this.GetTimelineByName(e);\n        i && (yield i);\n      }\n    }\n    *GetTimelinesByTags(e) {\n      for (const i of this._timelines) i.HasTags(e) && (yield i);\n    }\n    AddScheduledTimeline(e) {\n      this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e), this._MaybeEnableRuntimeListeners();\n    }\n    RemovePlayingTimeline(e) {\n      C33.arrayFindRemove(this._playingTimelines, e), this._MaybeDisableRuntimeListeners();\n    }\n    ScheduleTimeline(e) {\n      this._playingTimelines.includes(e) ? (e.SetPlaying(true), e.SetScheduled(false), e.SetMarkedForRemoval(false)) : (e.SetPlaying(false), e.SetScheduled(true), e.SetMarkedForRemoval(false), this._scheduledTimelines.includes(e) || this._scheduledTimelines.push(e)), this._MaybeEnableRuntimeListeners();\n    }\n    DeScheduleTimeline(e) {\n      e.SetPlaying(false), e.SetScheduled(false), e.ResolvePlayPromise(), C33.arrayFindRemove(this._scheduledTimelines, e), this._MaybeDisableRuntimeListeners();\n    }\n    CompleteTimeline(e) {\n      e.SetPlaying(false), e.SetScheduled(false), this._playingTimelines.includes(e) && (e.SetMarkedForRemoval(true), this._markedForRemovalTimelines.push(e), C33.arrayFindRemove(this._playingTimelines, e)), this._scheduledTimelines.includes(e) && e.SetMarkedForRemoval(true);\n    }\n    CompleteTimelineBeforeChangeOfLayout(e) {\n      e.SetPlaying(false), e.SetScheduled(false), e.SetMarkedForRemoval(false), e.SetPlaybackRate(1), C33.arrayFindRemove(this._playingTimelines, e);\n    }\n    CompleteTimelineAndResolve(e) {\n      this.CompleteTimeline(e), e.ResolvePlayPromise();\n    }\n    _OnTick() {\n      const e = this.GetRuntime();\n      if (e.IsLoadingState()) return;\n      if (!this._hasRuntimeListeners) return;\n      if (this._changingLayout) return;\n      let i = 0;\n      for (e.IsDebug() && (i = performance.now()), this._isTickingTimelines = true; this._scheduledTimelines.length; ) {\n        const e2 = this._scheduledTimelines.pop();\n        e2.IsMarkedForRemoval() ? (e2.SetInitialStateForce(), this._markedForRemovalTimelines.push(e2)) : (e2.SetInitialState(), this._playingTimelines.push(e2)), 0 !== e2.GetRenderChange() && (this._renderChange = 1);\n      }\n      const t = this._runtime._GetDtFast(), s = this._runtime.GetDt1(), n = this._runtime.GetTimeScale();\n      for (let e2 = this._playingTimelines.length - 1; e2 >= 0; e2--) {\n        const i2 = this._playingTimelines[e2];\n        i2 && i2.Tick(t, n, s);\n      }\n      this._isTickingTimelines = false, e.IsDebug() && globalThis.C3Debugger.AddTweensAndTimelinesTime(performance.now() - i), 0 !== this._renderChange && e.UpdateRender();\n    }\n    _OnTick2() {\n      const e = this.GetRuntime();\n      if (e.IsLoadingState()) return;\n      if (!this._hasRuntimeListeners) return;\n      if (this._changingLayout) return;\n      let i, t = 0;\n      e.IsDebug() && (t = performance.now());\n      for (let e2 = 0, t2 = this._markedForRemovalTimelines.length; e2 < t2; e2++) {\n        const t3 = this._markedForRemovalTimelines[e2];\n        i || (i = /* @__PURE__ */ new Set()), t3.Removed(), this._MaybeExecuteTimelineFinishTriggers(t3), i.add(t3);\n      }\n      if (i) {\n        C33.arrayRemoveAllInSet(this._markedForRemovalTimelines, i), this._renderChange = 0;\n        for (let e2 = 0, i2 = this._playingTimelines.length; e2 < i2; e2++) if (0 !== this._playingTimelines[e2].GetRenderChange()) {\n          this._renderChange = 1;\n          break;\n        }\n      }\n      this._MaybeDisableRuntimeListeners(), e.IsDebug() && globalThis.C3Debugger.AddTweensAndTimelinesTime(performance.now() - t);\n    }\n    _MaybeExecuteTimelineFinishTriggers(e) {\n      e.IsReleased() || e.HasValidTracks() && e.IsComplete() && e.InitialStateSet() && e.FinishTriggers();\n    }\n    _MaybeEnableRuntimeListeners() {\n      this._hasRuntimeListeners || (this._hasRuntimeListeners = true);\n    }\n    _MaybeDisableRuntimeListeners() {\n      this._markedForRemovalTimelines.length || this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = false);\n    }\n    _OnBeforeChangeLayout() {\n      for (this._changingLayout = true; this._scheduledTimelines.length; ) this.DeScheduleTimeline(this._scheduledTimelines.pop());\n      const e = /* @__PURE__ */ new Set();\n      for (const i of this._playingTimelines) {\n        i._OnBeforeChangeLayout() && (i.Removed(), e.add(i));\n      }\n      C33.arrayRemoveAllInSet(this._playingTimelines, e), e.clear();\n      for (const i of this._markedForRemovalTimelines) {\n        i._OnBeforeChangeLayout() && (i.Removed(), e.add(i));\n      }\n      C33.arrayRemoveAllInSet(this._markedForRemovalTimelines, e), this._MaybeDisableRuntimeListeners();\n      for (const e2 of this._timelines) e2.CleanCaches();\n    }\n    _OnAfterChangeLayout() {\n      this._changingLayout = false;\n    }\n    _OnInstanceDestroy(e) {\n      const i = e.GetObjectClass(), t = this.GetTimelinesForObjectClass(i);\n      if (t) if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(e);\n      else for (const e2 of t) e2.IsTemplate() || (e2.IsReleased() ? this.Remove(e2) : e2.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(e2), this.Remove(e2)));\n    }\n    _OnBeforeLoad() {\n      for (const e of this._scheduledTimelines.map((e2) => e2)) this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e);\n      for (const e of this._playingTimelines.map((e2) => e2)) this._MaybeExecuteTimelineFinishTriggers(e), this.Remove(e);\n    }\n    _OnAfterLoad() {\n      for (const e of this._destroyedWhileLoadingState) this._OnInstanceDestroy(e);\n      C33.clearArray(this._destroyedWhileLoadingState);\n      for (const e of this._timelines) e._OnAfterLoad();\n    }\n    _OnAfterLayoutStart() {\n      const e = this._runtime.GetLayoutManager().GetMainRunningLayout();\n      if (e) for (const i of this._timelines) {\n        const t = i.GetStartOnLayout();\n        t && (e.GetName() === t && this.ScheduleTimeline(i));\n      }\n    }\n    _SaveToJson() {\n      return { \"timelinesJson\": this._SaveTimelinesToJson(), \"scheduledTimelinesJson\": this._SaveScheduledTimelinesToJson(), \"playingTimelinesJson\": this._SavePlayingTimelinesToJson(), \"markedForRemovalTimelinesJson\": this._SaveMarkedForRemovalTimelinesToJson(), \"hasRuntimeListeners\": this._hasRuntimeListeners, \"changingLayout\": this._changingLayout, \"isTickingTimelines\": this._isTickingTimelines };\n    }\n    _LoadFromJson(e) {\n      e && (this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(e[\"timelinesJson\"]), this._LoadScheduledTimelinesFromJson(e[\"scheduledTimelinesJson\"]), this._LoadPlayingTimelinesFromJson(e[\"playingTimelinesJson\"]), this._LoadMarkedForRemovalTimelinesFromJson(e[\"markedForRemovalTimelinesJson\"]), this._hasRuntimeListeners = !e[\"hasRuntimeListeners\"], this._changingLayout = !!e[\"changingLayout\"], this._isTickingTimelines = !!e[\"isTickingTimelines\"], this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners());\n    }\n    _SaveTimelinesToJson() {\n      return this._timelines.map((e) => e._SaveToJson());\n    }\n    _LoadTimelinesFromJson(e) {\n      for (const i of e) {\n        let e2 = this.GetTimelineByName(i[\"name\"]);\n        if (e2) e2._LoadFromJson(i);\n        else {\n          const t = this._GetTemplateNameFromJson(i);\n          if (!t) continue;\n          const s = this.GetTimelineByName(t);\n          e2 = this.CreateFromTemplate(s), e2._LoadFromJson(i);\n        }\n        e2.HasTracks() || this.Remove(e2);\n      }\n    }\n    _GetTemplateNameFromJson(e) {\n      const i = e[\"name\"].split(\":\");\n      return i && 2 === i.length ? i[0] : null;\n    }\n    _SaveScheduledTimelinesToJson() {\n      return this._SaveTimelines(this._scheduledTimelines);\n    }\n    _LoadScheduledTimelinesFromJson(e) {\n      this._LoadTimelines(e, this._scheduledTimelines);\n    }\n    _SavePlayingTimelinesToJson() {\n      return this._SaveTimelines(this._playingTimelines);\n    }\n    _LoadPlayingTimelinesFromJson(e) {\n      this._LoadTimelines(e, this._playingTimelines);\n    }\n    _SaveMarkedForRemovalTimelinesToJson() {\n      return this._SaveTimelines(this._markedForRemovalTimelines);\n    }\n    _LoadMarkedForRemovalTimelinesFromJson(e) {\n      this._LoadTimelines(e, this._markedForRemovalTimelines);\n    }\n    _IsTimelineInJson(e, i) {\n      if (!i) return false;\n      for (const t of i) if (t === e.GetName()) return true;\n      return false;\n    }\n    _SaveTimelines(e) {\n      return e.map((e2) => e2.GetName());\n    }\n    _LoadTimelines(e, i) {\n      const t = /* @__PURE__ */ new Set();\n      for (const s of i) this._IsTimelineInJson(s, e) || t.add(s);\n      if (C33.arrayRemoveAllInSet(i, t), e) {\n        const t2 = (e2) => (i2) => i2.GetName() === e2;\n        for (const s of e) {\n          const e2 = this.GetTimelineByName(s);\n          if (e2) {\n            i.find(t2(s)) || i.push(e2);\n          }\n        }\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3, STEPS = 100, LENGTH_STEP_SIZE = 0.01, BEZIER_STEP_SIZE = 25, REFINE_ITERATIONS = 20, LOOKUP_STEPS_FROM_LAST = 5, TANGENT_RESULT = [0, 0], MAP_RESULT = [0, 0], SHORT_PROJECTION_RESULT = [0, 0], PROJECTION_RESULT = [0, 0, 0, 0, 0], REFINE_LUT = new Array(4), REFINE_LUT_OBJECTS = [{ x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }, { x: 0, y: 0, t: 0, distance: 0 }], REFINE_RESULT = { x: 0, y: 0, t: 0, distance: 0 };\n  C33.TimelineInfo = class {\n    constructor(t, i) {\n      this._initialized = false, this._timeline = t, this._segments = [];\n      let e = null;\n      if (e = i ? this._timeline.GetTrackById(i) : C33.first(this._timeline.GetTracks()), !e) return;\n      const s = e.GetPropertyTrack(\"offsetX\"), _ = e.GetPropertyTrack(\"offsetY\");\n      if (!s || !_) return;\n      this._xTrack = s, this._yTrack = _;\n      const h = s.GetPropertyKeyframeDataItemArrayIncludingDisabled(), n = _.GetPropertyKeyframeDataItemArrayIncludingDisabled();\n      for (let t2 = 1, i2 = Math.min(h.length, n.length); t2 < i2; ++t2) {\n        const i3 = h[t2], e2 = (i3.GetNext(), i3.GetPrevious()), s2 = n[t2], _2 = (s2.GetNext(), s2.GetPrevious());\n        e2 && \"cubic-bezier\" === e2.GetPathMode() && _2 && \"cubic-bezier\" === _2.GetPathMode() ? this._segments.push(C33.New(C33.TimelineCubicBezierSegmentInfo, e2, _2, i3, s2, this._segments.length)) : (e2 && \"line\" === e2.GetPathMode() && _2 && _2.GetPathMode(), this._segments.push(C33.New(C33.TimelineLineSegmentInfo, i3, s2, this._segments.length)));\n      }\n      this._initialized = true;\n    }\n    Release() {\n      for (const t of this._segments) t.Release();\n      C33.clearArray(this._segments), this._segments = null, this._timeline = null, this._xTrack = null, this._yTrack = null;\n    }\n    WasInitialized() {\n      return this._initialized;\n    }\n    segments() {\n      return this._segments;\n    }\n    SetOrigin(t) {\n      const i = \"relative\" === this._xTrack.GetResultMode() ? t.GetX() : 0, e = \"relative\" === this._yTrack.GetResultMode() ? t.GetY() : 0;\n      for (const t2 of this._segments) t2.SetOrigin(i, e);\n    }\n    Project(t, i, e) {\n      let s = NaN, _ = this._segments.length;\n      for (let e2 = 0; e2 < _; e2++) {\n        const _2 = this._segments[e2];\n        if (\"cubic-bezier\" === _2.GetType()) {\n          const e3 = _2.Project(t, i);\n          (isNaN(s) || e3[3] < s) && (s = e3[3], SHORT_PROJECTION_RESULT[0] = e3[2], SHORT_PROJECTION_RESULT[1] = _2.GetIndex());\n        }\n      }\n      return SHORT_PROJECTION_RESULT;\n    }\n    ProjectWithOptions(t, i, e) {\n      const s = e.tRange;\n      C33.IsFiniteNumber(s[0]) || (s[0] = 0), C33.IsFiniteNumber(s[1]) || (s[1] = 1);\n      let _ = NaN, h = this._segments.length;\n      for (let e2 = 0; e2 < h; e2++) {\n        const h2 = this._segments[e2];\n        if (\"cubic-bezier\" === h2.GetType()) {\n          const e3 = h2.ProjectWithRange(t, i, s);\n          (isNaN(_) || e3[3] < _) && (_ = e3[3], SHORT_PROJECTION_RESULT[0] = e3[2], SHORT_PROJECTION_RESULT[1] = h2.GetIndex());\n        }\n      }\n      return SHORT_PROJECTION_RESULT;\n    }\n    Tangent(t, i) {\n      return this._segments[i].Tangent(t);\n    }\n    TangentAngle(t, i) {\n      return this._segments[i].TangentAngle(t);\n    }\n  }, C33.TimelineCubicBezierSegmentInfo = class {\n    constructor(t, i, e, s, _) {\n      this._index = _;\n      const h = t.GetAddOn(\"cubic-bezier\"), n = e.GetAddOn(\"cubic-bezier\"), r = i.GetAddOn(\"cubic-bezier\"), a = s.GetAddOn(\"cubic-bezier\");\n      this._aX = t.GetValueWithResultMode(), this._aY = i.GetValueWithResultMode(), this._bX = t.GetValueWithResultMode() + h.GetStartAnchor(), this._bY = i.GetValueWithResultMode() + r.GetStartAnchor(), this._cX = e.GetValueWithResultMode() + n.GetEndAnchor(), this._cY = s.GetValueWithResultMode() + a.GetEndAnchor(), this._dX = e.GetValueWithResultMode(), this._dY = s.GetValueWithResultMode(), this._aXO = 0, this._aYO = 0, this._bXO = 0, this._bYO = 0, this._cXO = 0, this._cYO = 0, this._dXO = 0, this._dYO = 0, this._d0x = 0, this._d0y = 0, this._d1x = 0, this._d1y = 0, this._d2x = 0, this._d2y = 0, this._x1Factor = 0, this._x2Factor = 0, this._x3Factor = 0, this._y1Factor = 0, this._y2Factor = 0, this._y3Factor = 0, this._lutIndex = NaN, this._initialized = false, this._len = 100, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._length = 0, this._lut = [], this._lutObjects = [];\n      for (let t2 = 0; t2 < 100; t2++) this._lutObjects.push({ x: 0, y: 0, t: 0, distance: 0 });\n      this._CalculateLength();\n    }\n    Release() {\n      C33.clearArray(this._arcLengths), this._arcLengths = null, C33.clearArray(this._lut), this._lut = null, C33.clearArray(this._lutObjects), this._lutObjects = null;\n    }\n    GetType() {\n      return \"cubic-bezier\";\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetStepCount() {\n      return Math.floor(this._length / 25);\n    }\n    GetStepIncrement() {\n      return 1 / this.GetStepCount();\n    }\n    SetOrigin(t, i) {\n      this._originX = t, this._originY = i, this._arcLengths = new Array(this._len + 1), this._arcLengths[0] = 0, this._CalculateLength(), this._aXO = this._aX + this._originX, this._aYO = this._aY + this._originY, this._bXO = this._bX + this._originX, this._bYO = this._bY + this._originY, this._cXO = this._cX + this._originX, this._cYO = this._cY + this._originY, this._dXO = this._dX + this._originX, this._dYO = this._dY + this._originY, this._d0x = 3 * (this._bXO - this._aXO), this._d0y = 3 * (this._bYO - this._aYO), this._d1x = 3 * (this._cXO - this._bXO), this._d1y = 3 * (this._cYO - this._bYO), this._d2x = 3 * (this._dXO - this._cXO), this._d2y = 3 * (this._dYO - this._cYO), this._x1Factor = 3 * (this._bXO - this._aXO), this._x2Factor = 3 * (this._aXO + this._cXO - 2 * this._bXO), this._x3Factor = this._dXO - this._aXO + 3 * (this._bXO - this._cXO), this._y1Factor = 3 * (this._bYO - this._aYO), this._y2Factor = 3 * (this._aYO + this._cYO - 2 * this._bYO), this._y3Factor = this._dYO - this._aYO + 3 * (this._bYO - this._cYO);\n    }\n    Map(t) {\n      if (!this._initialized) return NaN;\n      const i = this._Map(t);\n      return MAP_RESULT[0] = this._X(i), MAP_RESULT[1] = this._Y(i), MAP_RESULT;\n    }\n    Project(t, i) {\n      const e = this._GenerateLUT(100), s = this._FindClosestFromLUT(t, i, e), _ = this._RefineProjection(t, i, e, s);\n      return PROJECTION_RESULT[0] = _.x, PROJECTION_RESULT[1] = _.y, PROJECTION_RESULT[2] = _.t, PROJECTION_RESULT[3] = _.distance, PROJECTION_RESULT;\n    }\n    ProjectWithRange(t, i, e) {\n      const s = this._GenerateLUT(100), _ = this._FindClosestFromLUTWithRange(t, i, s, e), h = this._RefineProjection(t, i, s, _);\n      return PROJECTION_RESULT[0] = h.x, PROJECTION_RESULT[1] = h.y, PROJECTION_RESULT[2] = h.t, PROJECTION_RESULT[3] = h.distance, PROJECTION_RESULT;\n    }\n    Tangent(t) {\n      const i = 1 - t, e = i * i, s = 2 * i * t, _ = t * t, h = e * this._d0x + s * this._d1x + _ * this._d2x, n = e * this._d0y + s * this._d1y + _ * this._d2y, r = C33.hypot2DFast(h, n);\n      return TANGENT_RESULT[0] = h / r, TANGENT_RESULT[1] = n / r, TANGENT_RESULT;\n    }\n    TangentAngle(t) {\n      const i = 1 - t, e = i * i, s = 2 * i * t, _ = t * t, h = e * this._d0x + s * this._d1x + _ * this._d2x, n = e * this._d0y + s * this._d1y + _ * this._d2y;\n      return Math.atan2(n, h);\n    }\n    _Map(t) {\n      if (!this._initialized) return;\n      let i = t * this._arcLengths[this._len], e = 0, s = this._len, _ = 0;\n      for (; e < s; ) _ = e + ((s - e) / 2 | 0), this._arcLengths[_] < i ? e = _ + 1 : s = _;\n      this._arcLengths[_] > i && _--;\n      const h = this._arcLengths[_];\n      return h === i ? _ / this._len : (_ + (i - h) / (this._arcLengths[_ + 1] - h)) / this._len;\n    }\n    _X(t) {\n      return this._initialized ? self.Ease.GetRuntimeEase(\"cubicbezier\")(t, this._aX + this._originX, this._bX + this._originX, this._cX + this._originX, this._dX + this._originX) : NaN;\n    }\n    _Y(t) {\n      return this._initialized ? self.Ease.GetRuntimeEase(\"cubicbezier\")(t, this._aY + this._originY, this._bY + this._originY, this._cY + this._originY, this._dY + this._originY) : NaN;\n    }\n    _GenerateLUT(t) {\n      if (t = t || 100, this._lut.length >= t) return this._lut;\n      this._lut = new Array(t), t++;\n      for (let i = 0; i < t - 1; i++) {\n        const e = i / (t - 1), s = e ** 2, _ = e ** 3, h = this._x1Factor * e, n = this._x2Factor * s, r = this._x3Factor * _, a = this._y1Factor * e, c = this._y2Factor * s, l = this._y3Factor * _, o = this._aXO + h + n + r, d = this._aYO + a + c + l;\n        this._lutObjects[i].x = o, this._lutObjects[i].y = d, this._lutObjects[i].t = e, this._lutObjects[i].distance = 0, this._lut[i] = this._lutObjects[i];\n      }\n      return this._lut;\n    }\n    _FindClosestFromLUT(t, i, e, s = null, _ = Number.MAX_SAFE_INTEGER) {\n      let h = 0;\n      if (isNaN(this._lutIndex)) for (let s2 = 0; s2 < 100; s2++) {\n        const n = e[s2], r = n.x - t, a = n.y - i;\n        n.distance = r * r + a * a, n.distance < _ && (_ = n.distance, h = s2);\n      }\n      else {\n        for (let s2 = this._lutIndex; s2 < this._lutIndex + 5 && !(s2 >= e.length); s2++) {\n          const n = e[s2], r = n.x - t, a = n.y - i;\n          n.distance = r * r + a * a, n.distance < _ && (_ = n.distance, h = s2);\n        }\n        for (let s2 = this._lutIndex; s2 > this._lutIndex - 5 && !(s2 < 0); s2--) {\n          const n = e[s2], r = n.x - t, a = n.y - i;\n          n.distance = r * r + a * a, n.distance < _ && (_ = n.distance, h = s2);\n        }\n      }\n      return this._lutIndex = h, h;\n    }\n    _FindClosestFromLUTWithRange(t, i, e, s, _ = Number.MAX_SAFE_INTEGER) {\n      let h = 0;\n      if (isNaN(this._lutIndex)) for (let n = 0; n < 100; n++) {\n        const r = e[n], a = r.x - t, c = r.y - i;\n        r.distance = a * a + c * c, r.t >= s[0] && r.t <= s[1] && r.distance < _ && (_ = r.distance, h = n);\n      }\n      else {\n        for (let n = this._lutIndex; n < this._lutIndex + 5 && !(n >= e.length); n++) {\n          const r = e[n], a = r.x - t, c = r.y - i;\n          r.distance = a * a + c * c, r.t >= s[0] && r.t <= s[1] && r.distance < _ && (_ = r.distance, h = n);\n        }\n        for (let n = this._lutIndex; n > this._lutIndex - 5 && !(n < 0); n--) {\n          const r = e[n], a = r.x - t, c = r.y - i;\n          r.distance = a * a + c * c, r.t >= s[0] && r.t <= s[1] && r.distance < _ && (_ = r.distance, h = n);\n        }\n      }\n      return this._lutIndex = h, h;\n    }\n    _RefineProjection(t, i, e, s) {\n      let _ = e[s], h = 1, n = Number.MAX_SAFE_INTEGER;\n      t: do {\n        const h2 = e.length;\n        let r = 0 === s ? 0 : s - 1, a = s === h2 - 1 ? h2 - 1 : s + 1, c = e[r].t, l = (e[a].t - c) / 4;\n        if (l < 1e-3) break;\n        REFINE_LUT[0] = e[r];\n        for (let e2 = 1; e2 <= 2; e2++) {\n          const h3 = c + e2 * l, r2 = h3 ** 2, a2 = h3 ** 3, o = this._x1Factor * h3, d = this._x2Factor * r2, u = this._x3Factor * a2, O = this._y1Factor * h3, T = this._y2Factor * r2, E = this._y3Factor * a2, R = this._aXO + o + d + u, g = this._aYO + O + T + E, N = R - t, I = g - i, S = N * N + I * I;\n          if (S < n) {\n            n = S, s = e2, REFINE_RESULT.x = R, REFINE_RESULT.y = g, REFINE_RESULT.t = h3, REFINE_RESULT.distance = S, _ = REFINE_RESULT;\n            break t;\n          }\n          const x = REFINE_LUT_OBJECTS[e2 - 1];\n          x.x = R, x.y = g, x.t = h3, x.distance = S, REFINE_LUT[e2] = x;\n        }\n        REFINE_LUT[3] = e[a], e = REFINE_LUT;\n      } while (h++ < 20);\n      return _;\n    }\n    _CalculateLength() {\n      this._initialized = true;\n      let t = this._X(0), i = this._Y(0), e = 0;\n      for (let s = 1; s <= this._len; s++) {\n        const _ = this._X(0.01 * s), h = this._Y(0.01 * s), n = t - _, r = i - h;\n        e += C33.hypot2DFast(n, r), this._arcLengths[s] = e, t = _, i = h;\n      }\n      this._length = e;\n    }\n  }, C33.TimelineLineSegmentInfo = class {\n    constructor(t, i, e) {\n      this._index = e, this._targetX = t.GetValueWithResultMode(), this._targetY = i.GetValueWithResultMode(), this._originX = 0, this._originY = 0;\n    }\n    Release() {\n    }\n    GetType() {\n      return \"line\";\n    }\n    GetIndex() {\n      return this._index;\n    }\n    SetOrigin(t, i) {\n      this._originX = t, this._originY = i;\n    }\n    GetX() {\n      return this._targetX + this._originX;\n    }\n    GetY() {\n      return this._targetY + this._originY;\n    }\n  };\n}\n{\n  const C33 = self.C3, PING_PONG_BEGIN = 0, PING_PONG_END = 1;\n  C33.TimelineState = class extends C33.DefendedBase {\n    constructor(t, e, i) {\n      super(), this._runtime = i.GetRuntime(), this._timelineManager = i, this._timelineDataItem = e, this._name = t, this._tracks = [], this._tracksLength = 0, this._beforeAndAfterTracks = null, this._beforeAndAfterTracksLength = 0, this.CreateTrackStates(), this._playPromise = null, this._playResolve = null, this._playheadTime = 0, this._overshoot = 0, this._playbackRate = 1, this._pingPongState = 0, this._resumePingPongState = -1, this._currentRepeatCount = 1, this._isPlaying = false, this._isScheduled = false, this._initialStateSet = false, this._complete = true, this._released = false, this._markedForRemoval = false, this._completedTick = -1, this._implicitPause = false, this._isTemplate = false, this._finishedTriggers = false, this._firstTick = false, this._lastDelta = NaN, this._tags = [\"\"], this._stringTags = \"\", this._tagsChanged = false, this._renderChange = 0, this._hasNestedContent = 0, this._stoppedKeyframeDataItem = null, this._iTimelineState = null;\n    }\n    static CreateInitial(t, e) {\n      const i = e.GetTimelineDataManager(), s = i.GetNameId(), a = i.Get(t[s]), n = C33.New(C33.TimelineState, t[s], a, e);\n      return n.SetIsTemplate(true), n;\n    }\n    static CreateFromTemplate(t, e, i) {\n      return C33.New(C33.TimelineState, t, e, i);\n    }\n    Release() {\n      if (this.IsReleased()) return;\n      const t = this._runtime.Dispatcher();\n      this._timelineManager.DeScheduleTimeline(this), this._timelineManager.CompleteTimelineAndResolve(this);\n      for (const t2 of this._tracks) t2.Release();\n      C33.clearArray(this._tracks), this._tracks = null, this._runtime = null, this._timelineManager = null, this._timelineDataItem = null, this._released = true, this._playPromise = null, this._playResolve = null, this.FireReleaseEvent(t);\n    }\n    FireReleaseEvent(t) {\n      const e = C33.New(C33.Event, \"timelinestatereleased\");\n      e.timelineState = this, t.dispatchEvent(e);\n    }\n    GetType() {\n      return 0;\n    }\n    CreateTrackStates() {\n      for (const t of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracksLength = this._tracks.push(C33.TrackState.Create(this, t));\n    }\n    GetTimelineManager() {\n      return this._timelineManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetTracks() {\n      return this._tracks;\n    }\n    GetSimilarPropertyTracks(t, e, i, s) {\n      if (!this._hasNestedContent) return;\n      let a;\n      for (let n = 0; n < this._tracks.length; n++) {\n        let r = this._tracks[n];\n        if (t !== r.GetInstance()) continue;\n        const h = r.GetPropertyTrack(i);\n        h && (e.constructor === h.GetSourceAdapter().constructor && h.GetResultMode() === s.GetResultMode() && (a || (a = []), a.push(h)));\n      }\n      return a;\n    }\n    HasTracks() {\n      return !!this._tracks.length;\n    }\n    GetTrackById(t) {\n      for (const e of this._tracks) if (C33.equalsNoCase(e.GetId(), t)) return e;\n      return null;\n    }\n    GetTrackByName(t) {\n      for (const e of this._tracks) if (!e.IsInstanceTrack() && C33.equalsNoCase(e.GetName(), t)) return e;\n      return null;\n    }\n    SetName(t) {\n      this._name = t;\n    }\n    GetName() {\n      return this._name;\n    }\n    GetTimelineDataItem() {\n      return this._timelineDataItem;\n    }\n    GetTemplateName() {\n      return this._timelineDataItem.GetName();\n    }\n    GetTotalTime() {\n      return this._timelineDataItem.GetTotalTime();\n    }\n    SetTotalTime(t) {\n      this._timelineDataItem.SetTotalTime(t);\n    }\n    GetStep() {\n      return this._timelineDataItem.GetStep();\n    }\n    SetStep(t) {\n      this._timelineDataItem.SetStep(t);\n    }\n    GetInterpolationMode() {\n      return this._timelineDataItem.GetInterpolationMode();\n    }\n    SetInterpolationMode(t) {\n      this._timelineDataItem.SetInterpolationMode(t);\n    }\n    GetResultMode() {\n      return this._timelineDataItem.GetResultMode();\n    }\n    SetResultMode(t) {\n      this._timelineDataItem.GetResultMode(t);\n    }\n    SetEase(t) {\n      for (const e of this.GetTracks()) e.SetEase(t);\n    }\n    GetLoop() {\n      return this._timelineDataItem.GetLoop();\n    }\n    SetLoop(t) {\n      return this._timelineDataItem.SetLoop(t);\n    }\n    GetPingPong() {\n      return this._timelineDataItem.GetPingPong();\n    }\n    SetPingPong(t) {\n      return this._timelineDataItem.SetPingPong(t);\n    }\n    GetRepeatCount() {\n      return this._timelineDataItem.GetRepeatCount();\n    }\n    SetRepeatCount(t) {\n      return this._timelineDataItem.SetRepeatCount(t);\n    }\n    SetPlaybackRate(t) {\n      return this._playbackRate = t;\n    }\n    GetPlaybackRate() {\n      return this._playbackRate;\n    }\n    GetStartOnLayout() {\n      return this._timelineDataItem.GetStartOnLayout();\n    }\n    GetTransformWithSceneGraph() {\n      return this._timelineDataItem.GetTransformWithSceneGraph();\n    }\n    GetUseSystemTimescale() {\n      return this._timelineDataItem.GetUseSystemTimescale();\n    }\n    GetPingPongState() {\n      return this._pingPongState;\n    }\n    IsForwardPlayBack() {\n      return !this.IsPlaying() || this._playbackRate > 0;\n    }\n    GetPlayPromise() {\n      return this._playPromise || (this._playPromise = new Promise((t) => {\n        this._playResolve = t;\n      })), this._playPromise;\n    }\n    ResolvePlayPromise() {\n      this._playPromise && (this._playResolve(), this._playPromise = null, this._playResolve = null);\n    }\n    SetTags(t) {\n      this._tags = C33.TimelineState._GetTagArray(t), this._tagsChanged = true;\n    }\n    GetTags() {\n      return this._tags;\n    }\n    GetStringTags() {\n      return this._tagsChanged && (this._stringTags = this._tags.join(\" \")), this._tagsChanged = false, this._stringTags;\n    }\n    HasTags(t) {\n      if (!this._tags) return false;\n      if (!this._tags.length) return false;\n      const e = C33.TimelineState._GetTagArray(t);\n      return !!e && (!!e.length && e.every(C33.TimelineState._HasTag, this));\n    }\n    OnStarted() {\n      C33.Plugins.Timeline && this.constructor === C33.TimelineState && (C33.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineStarted), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineStartedByName), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineStartedByTags), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnAnyTimelineStarted), C33.Plugins.Timeline.Cnds.PopTriggerTimeline());\n    }\n    OnCompleted() {\n      this._completedTick = this._runtime.GetTickCount();\n    }\n    FinishTriggers() {\n      this._finishedTriggers || (this._finishedTriggers = true, C33.Plugins.Timeline && this.constructor === C33.TimelineState && (C33.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineFinishedByName), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnAnyTimelineFinished), C33.Plugins.Timeline.Cnds.PopTriggerTimeline()));\n    }\n    SetPlaying(t) {\n      this._isPlaying = t;\n    }\n    IsCompletedTick() {\n      return this._completedTick === this._runtime.GetTickCount();\n    }\n    IsPlaying(t = false) {\n      return !!this.IsCompletedTick() || (!(!this.IsScheduled() || t) || this._isPlaying);\n    }\n    _IsPlaying() {\n      return this.IsPlaying(true);\n    }\n    IsPaused() {\n      return this._IsPaused();\n    }\n    _IsPaused() {\n      return !this.IsReleased() && (!this.IsScheduled() && (!this._IsPlaying() && !this.IsComplete()));\n    }\n    SetScheduled(t) {\n      this._isScheduled = t;\n    }\n    IsScheduled() {\n      return this._isScheduled;\n    }\n    SetComplete(t) {\n      this._complete = t;\n      const e = this.GetLoop(), i = this.GetPingPong();\n      if (e || i) {\n        if (e && !i) ;\n        else if (!e && i) {\n          const t2 = this.GetTime();\n          1 === this._pingPongState && (t2 <= 0 || t2 >= this.GetTotalTime()) && (this._complete = true);\n        }\n      } else {\n        const t2 = this.GetTime();\n        (t2 <= 0 || t2 >= this.GetTotalTime()) && (this._complete = true);\n      }\n    }\n    IsComplete() {\n      return this._complete;\n    }\n    IsReleased() {\n      return this._released;\n    }\n    SetMarkedForRemoval(t) {\n      this._markedForRemoval = t;\n    }\n    IsMarkedForRemoval() {\n      return this._markedForRemoval;\n    }\n    SetImplicitPause(t) {\n      this._implicitPause = t;\n    }\n    IsImplicitPause() {\n      return this._implicitPause;\n    }\n    SetIsTemplate(t) {\n      this._isTemplate = !!t;\n    }\n    IsTemplate() {\n      return this._isTemplate;\n    }\n    InitialStateSet() {\n      return this._initialStateSet;\n    }\n    GetTime() {\n      return this._playheadTime;\n    }\n    SetTime(t) {\n      const e = this.GetTime();\n      this._SetTime(t), this.SetComplete(false), this.IsComplete() || this.SetImplicitPause(true), (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet) && (this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime()), this._SetUpdateStateBefore(), this._Interpolate(this.GetTime(), false, true, true, e), this._SetUpdateStateAfter(), this._renderChange && this.GetRuntime().UpdateRender(), this._OnSetTime();\n    }\n    _SetTime(t) {\n      C33.IsFiniteNumber(t) || (t = this.GetTotalTime()), t < 0 ? this._playheadTime = 0 : t >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = t;\n    }\n    _SetTimeAndReset(t) {\n      C33.IsFiniteNumber(t) || (t = this.GetTotalTime()), t < 0 ? this._playheadTime = 0 : t >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = t;\n      for (const t2 of this._tracks) t2.SetResetState();\n    }\n    _OnSetTime() {\n      C33.Plugins.Timeline && this.constructor === C33.TimelineState && (C33.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(C33.Plugins.Timeline.Cnds.OnTimeSetByTags), C33.Plugins.Timeline.Cnds.PopTriggerTimeline());\n    }\n    _CanResume() {\n      if (this.GetLoop()) return true;\n      if (this.GetPingPong() && 1 === this._pingPongState) {\n        if (this.IsForwardPlayBack()) {\n          if (this.GetTime() >= this.GetTotalTime()) return false;\n        } else if (this.GetTime() <= 0) return false;\n      } else if (!this.GetLoop() && !this.GetPingPong()) {\n        if (this.IsForwardPlayBack()) {\n          if (this.GetTime() >= this.GetTotalTime()) return false;\n        } else if (this.GetTime() <= 0) return false;\n      }\n      return true;\n    }\n    Resume() {\n      this.IsReleased() || this._CanResume() && this.Play(true);\n    }\n    Play(t = false) {\n      return !this.IsReleased() && (!this.IsScheduled() && (this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : !this._IsPlaying() && (!!(this.IsComplete() || t || this.IsImplicitPause()) && this._ScheduleStoppedTimeline())));\n    }\n    _SchedulePlayingTimeline() {\n      return this.SetImplicitPause(false), this._timelineManager.RemovePlayingTimeline(this), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;\n    }\n    _ScheduleStoppedTimeline() {\n      return this.SetImplicitPause(false), this._timelineManager.ScheduleTimeline(this), this.GetPlayPromise(), true;\n    }\n    Stop(t = false) {\n      this.IsReleased() || (this.SetComplete(t), this._timelineManager.CompleteTimeline(this), this.IsComplete() && this.ResolvePlayPromise());\n    }\n    Reset(t = true, e = false) {\n      if (this.IsReleased()) return;\n      if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this);\n      if (this.IsComplete()) return;\n      this.Stop(true), this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());\n      const i = this.GetTime();\n      this._SetUpdateStateBefore(), e ? this._InterpolateBeforeChangeLayout(i) : this._Interpolate(i, false, false, true), t && this._OnSetTime(), this._SetUpdateStateAfter(), this._renderChange && t && this.GetRuntime().UpdateRender();\n    }\n    ResetBeforeChangeLayout() {\n      this.Reset(false, true);\n    }\n    _InterpolateBeforeChangeLayout(t) {\n      this._Interpolate(t, false, false, true, NaN, false, true);\n    }\n    _OnBeforeChangeLayout() {\n      return !!this.IsReleased() || !(!this.GetRuntime().IsLoadingState() && this.HasValidGlobalTracks()) && (this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.GetRuntime().IsLoadingState() || this.ResetBeforeChangeLayout(), true);\n    }\n    SetInitialStateFromSetTime() {\n      this.SetInitialState(true);\n    }\n    SetInitialStateForce() {\n      this.SetInitialState(false, true), this.SetPlaying(false), this.SetScheduled(false);\n    }\n    SetInitialState(t = false, e = false) {\n      if (!this.IsMarkedForRemoval() || e) if (t) {\n        this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this._SetUpdateStateBefore();\n        for (const t2 of this._tracks) t2.SetInitialState();\n        this._SetUpdateStateAfter();\n      } else if (this.SetPlaying(true), this.SetScheduled(false), this.OnStarted(), this.IsComplete()) {\n        this._completedTick = -1, 0 !== this._pingPongState && (this._playbackRate = Math.abs(this._playbackRate)), this._pingPongState = 0, this._resumePingPongState = -1, this._currentRepeatCount = 1, this._complete = false, this._finishedTriggers = false, this._initialStateSet = true, this._firstTick = true, this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime()), this._SetUpdateStateBefore();\n        for (const t2 of this._tracks) t2.SetInitialState();\n        this._SetUpdateStateAfter();\n      } else {\n        -1 !== this._resumePingPongState && (this._pingPongState = this._resumePingPongState), this._firstTick = true, this._finishedTriggers = false, this._SetUpdateStateBefore();\n        for (const t2 of this._tracks) t2.SetResumeState();\n        this._SetUpdateStateAfter();\n      }\n    }\n    GetRenderChange() {\n      return this._renderChange;\n    }\n    _SetUpdateStateBefore() {\n      this._hasNestedContent = 0;\n      for (const t of this._tracks) t.IsNested() && (this._hasNestedContent = 1);\n    }\n    _SetUpdateStateAfter() {\n      this._renderChange = 0;\n      for (const t of this._tracks) t._SetUpdateState(), 0 === this._renderChange && 1 === t.GetRenderChange() && (this._renderChange = 1), this._beforeAndAfterTracks || 1 !== t.GetNeedsBeforeAndAfter() || (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []), this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(t));\n    }\n    Tick(t, e, i) {\n      if (this.GetUseSystemTimescale()) {\n        if (0 === t && 0 === this._lastDelta) return;\n        this._lastDelta = t, t = i;\n      } else {\n        if (0 === i && 0 === this._lastDelta) return;\n        this._lastDelta = i, t = i, e = 1;\n      }\n      const s = this._playheadTime + this._overshoot, a = s + t * e * this._playbackRate, n = this._timelineDataItem._totalTime;\n      a < 0 ? (this._playheadTime = 0, this._overshoot = -a) : a >= n ? (this._playheadTime = n, this._overshoot = this._playheadTime - a) : (this._playheadTime = a, this._overshoot = 0);\n      let r = false, h = false;\n      const l = this.GetLoop(), o = this.GetPingPong();\n      let m;\n      l || o ? l && !o ? this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTimeAndReset(0), h = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(n), h = true) : !l && o ? this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTime(n), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : r = true : 0 === this._pingPongState && (this._pingPongState = 1)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : r = true : 0 === this._pingPongState && (this._pingPongState = 1)) : l && o && (this._playbackRate > 0 ? this._playheadTime >= n && (this._SetTime(n), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, this._pingPongState++, C33.wrap(this._pingPongState, 0, 2)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), h = true, this._pingPongState++, C33.wrap(this._pingPongState, 0, 2))) : this._playbackRate > 0 ? this._playheadTime >= n && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), h = true) : (this._SetTime(n), r = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(n), h = true) : (this._SetTime(0), r = true));\n      const _ = this._tracksLength;\n      if (r) {\n        for (m = 0; m < _; m++) this._tracks[m].SetEndState();\n        return this.Stop(true), void this.OnCompleted();\n      }\n      const c = this._beforeAndAfterTracksLength;\n      for (m = 0; m < c; m++) this._beforeAndAfterTracks[m].BeforeInterpolate();\n      if (1 === this._hasNestedContent) for (m = 0; m < _; m++) {\n        const t2 = this._tracks[m], e2 = t2.GetStartOffset();\n        this._playheadTime - e2 < 0 && s - e2 > 0 ? (this._playheadTime = e2 < 0 ? 0 : e2 >= n ? n : e2, t2.Interpolate(e2, true, false, h, this._firstTick, false)) : t2.Interpolate(this._playheadTime, true, false, h, this._firstTick, false);\n      }\n      else for (m = 0; m < _; m++) this._tracks[m].Interpolate(this._playheadTime, true, false, h, this._firstTick, false);\n      if (!this.IsPlaying() && this._stoppedKeyframeDataItem) {\n        const t2 = this._stoppedKeyframeDataItem.GetTime() + this._stoppedKeyframeDataItem.GetKeyframeData().GetTrackDataItem().GetStartOffset(), e2 = this._playheadTime - t2;\n        this._playheadTime -= e2, 0 !== this._overshoot && (this._overshoot -= e2), this._stoppedKeyframeDataItem = null;\n      }\n      for (m = 0; m < c; m++) this._beforeAndAfterTracks[m].AfterInterpolate();\n      this._firstTick && (this._firstTick = false);\n    }\n    SetStoppedOnKeyframe(t) {\n      this._stoppedKeyframeDataItem = t;\n    }\n    GetStoppedOnKeyframe() {\n      return this._stoppedKeyframeDataItem;\n    }\n    _Interpolate(t, e = false, i = false, s = false, a = NaN, n = false, r = false) {\n      for (const t2 of this._tracks) t2.BeforeInterpolate();\n      for (const n2 of this._tracks) {\n        let h = t;\n        if (\"number\" == typeof a && !isNaN(a)) {\n          const t2 = this.GetTime() - n2.GetStartOffset(), e2 = a - n2.GetStartOffset();\n          t2 < 0 && e2 > 0 && (h = n2.GetStartOffset(), this._SetTime(h));\n        }\n        n2.Interpolate(h, e, i, s, this._firstTick, r);\n      }\n      for (const t2 of this._tracks) t2.AfterInterpolate();\n      this._firstTick && n && (this._firstTick = false);\n    }\n    AddTrack() {\n      const t = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), e = C33.TrackState.Create(this, t);\n      return this._tracksLength = this._tracks.push(e), e;\n    }\n    Removed() {\n      if (!this.IsReleased()) for (const t of this._tracks) t.TimelineRemoved();\n    }\n    CleanCaches() {\n      for (const t of this._tracks) t.CleanCaches();\n    }\n    ClearTrackInstances() {\n      for (const t of this._tracks) t.ClearInstance();\n    }\n    SetTrackInstance(t, e, i) {\n      if (e) {\n        if (\"number\" == typeof i && i >= 0) {\n          const t2 = this._tracks[i];\n          if (!t2) return;\n          return t2.SetInstance(e), void this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);\n        }\n        for (const i2 of this._tracks) if (i2.IsInstanceTrack()) {\n          if (t) {\n            if (i2.GetId() !== t) continue;\n            i2.SetInstance(e), this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);\n            break;\n          }\n          if (!i2.HasInstance()) {\n            i2.SetInstance(e), this._timelineManager.SetTimelineObjectClassToMap(e.GetObjectClass(), this);\n            break;\n          }\n        }\n      }\n    }\n    HasTrackInstance(t, e) {\n      for (const i of this._tracks) if (i.IsInstanceTrack()) {\n        if (e) {\n          if (e === i.GetId() && t === i.GetInstance()) return true;\n        } else if (t === i.GetInstance()) return true;\n      }\n      return false;\n    }\n    HasValidTracks() {\n      return this._tracks.some((t) => !t.IsInstanceTrack() || t.CanInstanceBeValid());\n    }\n    HasValidGlobalTracks() {\n      return this._tracks.some((t) => {\n        if (t.IsInstanceTrack()) {\n          if (!t.CanInstanceBeValid()) return false;\n          const e = t.GetObjectClass();\n          return !!e && e.IsGlobal();\n        }\n        return false;\n      });\n    }\n    GetPropertyTrack(t) {\n      for (const e of this.GetTracks()) for (const i of e.GetPropertyTracks()) if (i.GetPropertyName() === t) return i;\n    }\n    GetTrackFromInstance(t) {\n      for (const e of this._tracks) if (t === e.GetInstance()) return e;\n      return null;\n    }\n    GetKeyframeWithTags(t) {\n      let e = t ? t.split(\" \") : [];\n      const i = new Set(e.map((t2) => t2.toLowerCase().trim()));\n      e = [...i.values()];\n      for (const t2 of this.GetTracks()) for (const i2 of t2.GetKeyframeDataItems()) {\n        if (e.every((t3) => i2.HasTag(t3))) return i2;\n      }\n    }\n    GetObjectClasses() {\n      const t = [];\n      for (const e of this.GetTracks()) t.push(e.GetObjectClass());\n      return t.filter((t2) => t2);\n    }\n    _OnAfterLoad() {\n      for (const t of this.GetTracks()) t._OnAfterLoad();\n    }\n    _SaveToJson() {\n      return { \"tracksJson\": this._SaveTracksToJson(), \"name\": this._name, \"playheadTime\": this.GetTime(), \"playbackRate\": this._playbackRate, \"pingPongState\": this._pingPongState, \"resumePingPongState\": this._resumePingPongState, \"currentRepeatCount\": this._currentRepeatCount, \"isPlaying\": this._isPlaying, \"isScheduled\": this._isScheduled, \"initialStateSet\": this._initialStateSet, \"finishedTriggers\": this._finishedTriggers, \"complete\": this._complete, \"released\": this._released, \"markedForRemoval\": this._markedForRemoval, \"completedTick\": this._completedTick, \"implicitPause\": this._implicitPause, \"isTemplate\": this._isTemplate, \"tags\": this._tags.join(\" \"), \"stringTags\": this._stringTags, \"tagsChanged\": this._tagsChanged, \"firstTick\": this._firstTick };\n    }\n    _LoadFromJson(t) {\n      t && (this._LoadTracksFromJson(t[\"tracksJson\"]), this._name = t[\"name\"], this._playheadTime = t[\"playheadTime\"], this._playbackRate = t[\"playbackRate\"], this._pingPongState = t[\"pingPongState\"], this._resumePingPongState = t.hasOwnProperty(\"resumePingPongState\") ? t[\"resumePingPongState\"] : -1, this._currentRepeatCount = t[\"currentRepeatCount\"], this._isPlaying = !!t[\"isPlaying\"], this._isScheduled = !!t[\"isScheduled\"], this._initialStateSet = !!t[\"initialStateSet\"], this._finishedTriggers = !!t.hasOwnProperty(\"finishedTriggers\") && !!t[\"finishedTriggers\"], this._complete = !!t[\"complete\"], this._released = !!t[\"released\"], this._markedForRemoval = !!t[\"markedForRemoval\"], this._completedTick = t[\"completedTick\"], this._implicitPause = !!t[\"implicitPause\"], this._isTemplate = !!t[\"isTemplate\"], this._tags = t[\"tags\"].split(\" \"), this._stringTags = t[\"stringTags\"], this._tagsChanged = !!t[\"tagsChanged\"], this._firstTick = !!t[\"firstTick\"]);\n    }\n    _SaveTracksToJson() {\n      return this._tracks.map((t) => t._SaveToJson());\n    }\n    _LoadTracksFromJson(t) {\n      this.ClearTrackInstances(), t.forEach((t2, e) => {\n        this._tracks[e]._LoadFromJson(t2);\n      }), this._tracks.filter((t2) => t2.CanInstanceBeValid());\n    }\n    static _HasTag(t) {\n      const e = this.GetTags();\n      return \"\" === t ? 1 === e.length && \"\" === e[0] : e.map((t2) => t2.toLowerCase()).includes(t.toLowerCase());\n    }\n    static _GetTagArray(t) {\n      if (C33.IsArray(t)) return t.slice(0);\n      if (C33.IsString(t)) return t.split(\" \");\n      throw new Error(\"invalid tags\");\n    }\n    GetITimelineState() {\n      return this._iTimelineState || (this._iTimelineState = C33.New(self.ITimelineState, this)), this._iTimelineState;\n    }\n  };\n}\n{\n  const C33 = self.C3, INSTANCE_TRACK = 0, VALUE_TRACK = 1, AUDIO_TRACK = 2;\n  C33.TrackState = class extends C33.DefendedBase {\n    constructor(t, e) {\n      super(), this._timeline = t, this._trackDataItem = e, this._trackData = e.GetTrackData(), this._instanceUid = NaN, this._objectClassIndex = NaN, this._instance = null, this._worldInfo = null, this._cleared = false, this._isNested = e.GetStartOffset() > 0, this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this._instanceUidToLoad = NaN, this._lastKeyframeDataItem = null, this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray(), this._propertyTracks = [], this.CreatePropertyTrackStates(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0;\n    }\n    static Create(t, e) {\n      return C33.New(C33.TrackState, t, e);\n    }\n    Release() {\n      this._keyframeDataItems = null;\n      for (const t of this._propertyTracks) t.Release();\n      C33.clearArray(this._propertyTracks), this._propertyTracks = null, this._timeline = null, this._instance = null, this._worldInfo = null, this._trackDataItem = null, this._lastKeyframeDataItem = null;\n    }\n    CreatePropertyTrackStates() {\n      for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C33.PropertyTrackState.Create(this, t));\n    }\n    TimelineRemoved() {\n      for (const t of this._propertyTracks) t.TimelineRemoved();\n    }\n    CleanCaches() {\n      for (const t of this._propertyTracks) t.CleanCaches();\n      this._instance = null, this._worldInfo = null;\n    }\n    GetTimeline() {\n      return this._timeline;\n    }\n    GetRuntime() {\n      return this._timeline.GetRuntime();\n    }\n    GetKeyframeDataItems() {\n      return this._keyframeDataItems || (this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()), this._keyframeDataItems;\n    }\n    GetPropertyTracks() {\n      return this._propertyTracks;\n    }\n    GetPropertyTrack(t) {\n      for (let e = 0; e < this._propertyTracks.length; e++) {\n        const a = this._propertyTracks[e];\n        if (a.GetPropertyName() === t) return a;\n      }\n    }\n    MaybeGetInstance() {\n      this._instance || this.GetInstance();\n    }\n    IsInstanceValid() {\n      return !!this._instance && !this._instance.IsDestroyed();\n    }\n    CanInstanceBeValid() {\n      if (!this.IsInstanceTrack()) return false;\n      const t = this.GetInstanceUID(), e = this.GetRuntime().GetInstanceByUID(t);\n      return !!e && !e.IsDestroyed();\n    }\n    GetObjectClass() {\n      if (!this.IsInstanceTrack()) return;\n      const t = this.GetObjectClassIndex();\n      return -1 !== t ? this.GetRuntime().GetObjectClassByIndex(t) : void 0;\n    }\n    GetTrackIndexInTimeline() {\n      return this._timeline.GetTracks().indexOf(this);\n    }\n    ClearInstance() {\n      this._instance = null, this._instanceUid = NaN, this._worldInfo = null, this._objectClassIndex = NaN, this._cleared = true;\n    }\n    HasInstance() {\n      return !!this._instance;\n    }\n    GetInstance() {\n      if (this._cleared) return;\n      if (this._instance && this.IsInstanceValid()) return this._instance;\n      const t = this.GetInstanceUID();\n      return this._instance = this.GetRuntime().GetInstanceByUID(t), this._instance;\n    }\n    SetInstance(t) {\n      if (this._cleared = false, this._instance !== t) {\n        this.CleanCaches(), this._instance = t, this._objectClassIndex = t.GetObjectClass().GetIndex(), this._instanceUid = t.GetUID(), this._worldInfo = t.GetWorldInfo();\n        for (const e of this.propertyTrackItems()) {\n          const a = e.propertyTrack, s = e.sourceAdapter;\n          switch (a.GetSourceAdapterId()) {\n            case \"instance-variable\": {\n              s.GetEditorIndex();\n              const a2 = t.GetObjectClass(), r = a2.GetInstanceVariableIndexByName(e.name), i = a2.GetInstanceVariableName(r), n = a2.GetInstanceVariableType(r);\n              i === e.name && n === e.type && s.UpdateInstanceVariableIndex(r);\n              break;\n            }\n            case \"behavior\": {\n              const a2 = e.behaviorType, r = this.GetObjectClass(), i = t.GetObjectClass(), n = s.GetBehaviorType(i);\n              if (a2 && n) {\n                const t2 = a2.GetName();\n                r.GetBehaviorIndexByName(t2), i.GetBehaviorIndexByName(t2), s.GetEditorIndex();\n                s.UpdateBehaviorTypeSid(n.GetSID());\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    *propertyTrackItems() {\n      for (const t of this._propertyTracks) {\n        const e = t.GetSourceAdapter(), a = this.GetObjectClass(), s = { propertyTrack: t, sourceAdapter: e };\n        switch (t.GetSourceAdapterId()) {\n          case \"world-instance\":\n            s.property = t.GetPropertyName();\n            break;\n          case \"instance-variable\": {\n            const t2 = e.GetEditorIndex();\n            s.name = a.GetInstanceVariableName(t2), s.type = a.GetInstanceVariableType(t2);\n            break;\n          }\n          case \"effect\": {\n            const t2 = a.GetEffectList(), r = e.GetEffectType(t2);\n            s.effectType = r;\n            break;\n          }\n          case \"behavior\": {\n            const t2 = e.GetBehaviorType(a);\n            s.behaviorType = t2;\n            break;\n          }\n          case \"plugin\":\n            s.plugin = a.GetPlugin();\n        }\n        yield s;\n      }\n    }\n    GetWorldInfo() {\n      if (this._worldInfo && this.IsInstanceValid()) return this._worldInfo;\n      const t = this.GetInstance();\n      return t && (this._worldInfo = t.GetWorldInfo()), this._worldInfo;\n    }\n    GetTrackDataItem() {\n      return this._trackDataItem;\n    }\n    GetInstanceUID() {\n      return isNaN(this._instanceUid) ? this._trackDataItem.GetInstanceUID() : this._instanceUid;\n    }\n    SetInstanceUID(t) {\n      this._trackDataItem.SetInstanceUID(t);\n    }\n    GetInterpolationMode() {\n      return this._trackDataItem.GetInterpolationMode();\n    }\n    SetInterpolationMode(t) {\n      this._trackDataItem.SetInterpolationMode(t);\n    }\n    GetResultMode() {\n      return this._trackDataItem.GetResultMode();\n    }\n    GetId() {\n      return this._trackDataItem.GetId();\n    }\n    GetStartOffset() {\n      return this._trackDataItem.GetStartOffset();\n    }\n    GetLocalTotalTime() {\n      return this._trackDataItem.GetLocalTotalTime();\n    }\n    SetLocalTotalTime(t) {\n      this._trackDataItem.SetLocalTotalTime(t);\n    }\n    SetResultMode(t) {\n      this._trackDataItem.SetResultMode(t);\n    }\n    SetEase(t) {\n      for (const e of this.GetKeyframeDataItems()) e.SetEase(t);\n      for (const e of this.GetPropertyTracks()) e.SetEase(t);\n    }\n    GetEnable() {\n      return this._trackDataItem.GetEnable();\n    }\n    SetEnable(t) {\n      this._trackDataItem.SetEnable(t);\n    }\n    GetObjectClassIndex() {\n      return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex;\n    }\n    SetObjectClassIndex(t) {\n      this._trackDataItem.SetObjectClassIndex(t);\n    }\n    SetOriginalWidth(t) {\n      this._trackDataItem.SetOriginalWidth(t);\n    }\n    GetOriginalWidth() {\n      const t = this.GetInstance();\n      if (t) {\n        if (t.GetSdkInstance().IsOriginalSizeKnown()) return t.GetSdkInstance().GetOriginalWidth();\n      }\n      return this._trackDataItem.GetOriginalWidth();\n    }\n    SetOriginalHeight(t) {\n      this._trackDataItem.SetOriginalHeight(t);\n    }\n    GetOriginalHeight() {\n      const t = this.GetInstance();\n      if (t) {\n        if (t.GetSdkInstance().IsOriginalSizeKnown()) return t.GetSdkInstance().GetOriginalHeight();\n      }\n      return this._trackDataItem.GetOriginalHeight();\n    }\n    GetType() {\n      return this._trackDataItem.GetType();\n    }\n    GetName() {\n      return this._trackDataItem.GetName();\n    }\n    IsInstanceTrack() {\n      return 0 === this.GetType();\n    }\n    IsValueTrack() {\n      return 1 === this.GetType();\n    }\n    IsAudioTrack() {\n      return 2 === this.GetType();\n    }\n    GetWorldInfoChange() {\n      return this._worldInfoChange;\n    }\n    GetRenderChange() {\n      return this._renderChange;\n    }\n    GetNeedsBeforeAndAfter() {\n      return this._needsBeforeAndAfter;\n    }\n    IsNested() {\n      return this._isNested;\n    }\n    SetResetState() {\n      for (const t of this._propertyTracks) t.SetResetState();\n    }\n    SetInitialState() {\n      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;\n      const t = this.GetTimeline().IsForwardPlayBack(), e = t ? 0 : this.GetLocalTotalTime();\n      for (const t2 of this._propertyTracks) t2.SetInitialState(e), 0 === this._worldInfoChange && 1 === t2.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === t2.GetRenderChange() && (this._renderChange = 1);\n      this._needsBeforeAndAfter = 0;\n      this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = t ? this._GetLastKeyFrameBeforeTime(e) : this._GetFirstKeyFrameAfterTime(e), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(e), this.OnInitialKeyframeReached(this._lastKeyframeDataItem);\n    }\n    SetResumeState() {\n      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;\n      const t = this._timeline.IsForwardPlayBack(), e = this._timeline.GetTime() - this.GetStartOffset();\n      this._lastKeyframeDataItem = t ? this._GetLastKeyFrameBeforeTime(e) : this._GetFirstKeyFrameAfterTime(e);\n      for (const t2 of this._propertyTracks) t2.SetResumeState(e);\n    }\n    SetEndState() {\n      if (!this.GetTimeline().IsComplete() && (this.MaybeGetInstance(), (this.IsInstanceValid() || !this.IsInstanceTrack()) && !this._isNested)) {\n        const t = this._timeline.GetTime();\n        t >= this.GetStartOffset() + this.GetLocalTotalTime() ? this.Interpolate(this.GetLocalTotalTime(), true, false, true, false, false, true) : t <= 0 && this.Interpolate(0, true, false, true, false, false, true);\n      }\n    }\n    _SetUpdateState() {\n      for (let t = 0, e = this._propertyTracks.length; t < e; t++) {\n        const e2 = this._propertyTracks[t];\n        e2._SetUpdateState(), 0 === this._worldInfoChange && 1 === e2.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === e2.GetRenderChange() && (this._renderChange = 1);\n      }\n    }\n    BeforeInterpolate() {\n      const t = this._propertyTracks.length;\n      for (let e = 0; e < t; e++) this._propertyTracks[e].BeforeInterpolate();\n    }\n    Interpolate(t, e = false, a = false, s = false, r = false, i = false, n = false) {\n      this._instance || this.GetInstance();\n      const o = this._instance && !this._instance.IsDestroyed(), h = 0 === this._trackDataItem._type;\n      if ((o || !h) && !(i && h && this.GetObjectClass().IsGlobal() || (t -= this.GetStartOffset()) < 0)) {\n        this.MaybeSetInitialStateOfNestedTrack(t, e), this.MaybeTriggerKeyframeReachedConditions(t, e, r), !this.GetTimeline().IsPlaying() && this.GetTimeline().GetStoppedOnKeyframe() && (t = this.GetTimeline().GetStoppedOnKeyframe().GetTime());\n        for (let e2 = 0, r2 = this._propertyTracks.length; e2 < r2; e2++) this._propertyTracks[e2].Interpolate(t, a, s, n);\n        this.MaybeSetEndStateOfNestedTrack(t, e), 0 !== this._worldInfoChange && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged());\n      }\n    }\n    AfterInterpolate() {\n      const t = this._propertyTracks.length;\n      for (let e = 0; e < t; e++) this._propertyTracks[e].AfterInterpolate();\n    }\n    MaybeSetInitialStateOfNestedTrack(t, e) {\n      if (!e) return;\n      if (!this._isNested) return;\n      if (this._initialStateOfNestedSet) return;\n      if (this.GetTimeline().IsForwardPlayBack()) {\n        if (t < 0) return;\n      } else if (t > this.GetLocalTotalTime()) return;\n      for (const t2 of this._propertyTracks) t2.SetInitialState();\n      this._initialStateOfNestedSet = true;\n    }\n    MaybeSetEndStateOfNestedTrack(t, e) {\n      if (!e) return;\n      if (!this._isNested) return;\n      if (this._endStateOfNestedSet) return;\n      if (this.GetTimeline().IsForwardPlayBack()) {\n        if (t >= this.GetLocalTotalTime()) {\n          for (const t2 of this._propertyTracks) t2.Interpolate(this.GetLocalTotalTime(), false, true);\n          this._endStateOfNestedSet = true;\n        }\n      } else if (t <= 0) {\n        for (const t2 of this._propertyTracks) t2.Interpolate(0, false, true);\n        this._endStateOfNestedSet = true;\n      }\n    }\n    MaybeTriggerKeyframeReachedConditions(t, e, a) {\n      if (a) return;\n      if (!e) return;\n      if (!C33.Plugins.Timeline) return;\n      const s = this.GetTimeline();\n      if (s.IsForwardPlayBack()) {\n        const e2 = this._lastKeyframeDataItem.GetNext(), a2 = this._lastKeyframeDataItem.GetTime(), r = e2 ? e2.GetTime() : s.GetTotalTime();\n        (t <= a2 || t >= r) && (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem), e2 && this.OnKeyframeReached(this._lastKeyframeDataItem));\n      } else {\n        if (!this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem)) return;\n        this._lastKeyframeDataItem || (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem));\n        const e2 = this._lastKeyframeDataItem.GetLast(), a2 = this._lastKeyframeDataItem.GetTime(), s2 = e2 ? e2.GetTime() : 0;\n        (t >= a2 || t <= s2) && (this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem), this._lastKeyframeDataItem && this.OnKeyframeReached(this._lastKeyframeDataItem));\n      }\n    }\n    _GetLastKeyFrameBeforeTime(t) {\n      const e = this._trackData.GetKeyFrameDataItemAtTime(t, this._trackDataItem);\n      return e || this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(t, this._trackDataItem);\n    }\n    _GetFirstKeyFrameAfterTime(t) {\n      const e = this._trackData.GetKeyFrameDataItemAtTime(t, this._trackDataItem);\n      return e || this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(t, this._trackDataItem);\n    }\n    OnKeyframeReached(t, e = false) {\n      if (!C33.Plugins.Timeline) return;\n      const a = this.GetTimeline(), s = a.GetTimelineManager();\n      C33.Plugins.Timeline.Cnds.PushTriggerTimeline(a), C33.Plugins.Timeline.Cnds.PushTriggerKeyframe(t), s.Trigger(C33.Plugins.Timeline.Cnds.OnAnyKeyframeReached), s.Trigger(C33.Plugins.Timeline.Cnds.OnKeyframeReached), a.IsPlaying() || e || a.SetStoppedOnKeyframe(t), C33.Plugins.Timeline.Cnds.PopTriggerTimeline(a), C33.Plugins.Timeline.Cnds.PopTriggerKeyframe(t);\n    }\n    OnInitialKeyframeReached(t) {\n      this.OnKeyframeReached(t, true);\n    }\n    AddKeyframe() {\n      return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem();\n    }\n    AddPropertyTrack() {\n      const t = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem(), e = C33.PropertyTrackState.Create(this, t);\n      return this._propertyTracks.push(e), e;\n    }\n    DeleteKeyframes(t) {\n      this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(t);\n    }\n    DeletePropertyKeyframes(t) {\n      for (const e of this._propertyTracks) e.DeletePropertyKeyframes(t);\n    }\n    SaveState() {\n      for (const t of this._propertyTracks) t.SaveState();\n    }\n    CompareInitialStateWithCurrent() {\n      if (this.MaybeGetInstance(), this.IsInstanceValid() || !this.IsInstanceTrack()) for (const t of this._propertyTracks) t.CompareInitialStateWithCurrent();\n    }\n    CompareSaveStateWithCurrent() {\n      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;\n      let t = false;\n      for (const e of this._propertyTracks) {\n        const a = e.CompareSaveStateWithCurrent();\n        !t && a && (t = true);\n      }\n      if (t) {\n        const t2 = this.AddKeyframe();\n        t2.SetTime(this.GetTimeline().GetTime()), t2.SetEase(\"noease\"), t2.SetEnable(true), t2.SetTags(\"\");\n      }\n    }\n    _OnAfterLoad() {\n      isNaN(this._instanceUidToLoad) || this._LoadInstanceFromJson(this._instanceUidToLoad), this._instanceUidToLoad = NaN;\n    }\n    _SaveToJson() {\n      const t = this.GetInstance(), e = t ? t.GetUID() : this.GetInstanceUID();\n      return { \"propertyTracksJson\": this._SavePropertyTracksToJson(), \"lastKeyframeDataItemJson\": this._SaveLastKeyframeDataItemToJson(), \"initialStateOfNestedSet\": this._initialStateOfNestedSet, \"endStateOfNestedSet\": this._endStateOfNestedSet, \"instanceUid\": e, \"cleared\": this._cleared };\n    }\n    _LoadFromJson(t) {\n      if (t) {\n        this._LoadPropertyTracksFromJson(t[\"propertyTracksJson\"]), this._LoadLastKeyframeDataItemFromJson(t[\"lastKeyframeDataItemJson\"]), this._instanceUidToLoad = t[\"instanceUid\"], this._initialStateOfNestedSet = false, t.hasOwnProperty[\"initialStateOfNestedSet\"] && (this._initialStateOfNestedSet = t[\"initialStateOfNestedSet\"]), this._endStateOfNestedSet = false, t.hasOwnProperty[\"endStateOfNestedSet\"] && (this._endStateOfNestedSet = t[\"endStateOfNestedSet\"]), this._cleared = !!t.hasOwnProperty(\"cleared\") && t[\"cleared\"];\n        for (const t2 of this._propertyTracks) 0 === this._worldInfoChange && 1 === t2.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === t2.GetRenderChange() && (this._renderChange = 1);\n        this._needsBeforeAndAfter = 0, this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);\n      }\n    }\n    _SaveLastKeyframeDataItemToJson() {\n      return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem);\n    }\n    _SavePropertyTracksToJson() {\n      return this._propertyTracks.map((t) => t._SaveToJson());\n    }\n    _LoadPropertyTracksFromJson(t) {\n      t.forEach((t2, e) => {\n        this._propertyTracks[e]._LoadFromJson(t2);\n      });\n    }\n    _LoadInstanceFromJson(t) {\n      if (!C33.IsFiniteNumber(t)) return;\n      const e = this.GetRuntime().GetInstanceByUID(t);\n      if (!e) return;\n      this.GetTimeline().SetTrackInstance(this._trackDataItem.GetId(), e, this.GetTrackIndexInTimeline());\n    }\n    _LoadLastKeyframeDataItemFromJson(t) {\n      const e = this._trackDataItem.GetKeyframeData();\n      this._lastKeyframeDataItem = e.GetKeyframeDataItemFromIndex(t);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.PropertyTrackState = class extends C33.DefendedBase {\n    constructor(e, t) {\n      super(), this._track = e, this._propertyTrackDataItem = t, this._propertyTrackData = t.GetPropertyTrackData(), this._worldInfoChange = 0, this._renderChange = 0, this._needsBeforeAndAfter = 0, this._sourceAdapter = this.GetSourceAdapter(), this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), this._lastPropertyKeyframeDataItem = null, this._absoluteValueObject = null;\n    }\n    static Create(e, t) {\n      return C33.New(C33.PropertyTrackState, e, t);\n    }\n    Release() {\n      this._track = null, this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter = null), this._propertyKeyframeDataItems = null, this._propertyTrackDataItem = null, this._propertyTrackData = null;\n    }\n    GetWorldInfoChange() {\n      return this._worldInfoChange;\n    }\n    GetRenderChange() {\n      return this._renderChange;\n    }\n    GetNeedsBeforeAndAfter() {\n      return this._needsBeforeAndAfter;\n    }\n    HasAbsoluteValueObject() {\n      return !!this._absoluteValueObject;\n    }\n    SetAbsoluteValueObject(e) {\n      this._absoluteValueObject = e;\n    }\n    GetAbsoluteValueObject() {\n      return this._absoluteValueObject;\n    }\n    GetTrack() {\n      return this._track;\n    }\n    GetPropertyTrackDataItem() {\n      return this._propertyTrackDataItem;\n    }\n    GetPropertyTrackData() {\n      return this._propertyTrackData;\n    }\n    GetTimeline() {\n      return this._track.GetTimeline();\n    }\n    GetRuntime() {\n      return this._track.GetRuntime();\n    }\n    GetInstance() {\n      return this._track.GetInstance();\n    }\n    GetSourceAdapter() {\n      if (this._sourceAdapter) return this._sourceAdapter;\n      let e;\n      switch (this._propertyTrackDataItem.GetSourceAdapterId()) {\n        case \"behavior\":\n          e = new C33.PropertyTrackState.BehaviorSourceAdapter(this);\n          break;\n        case \"effect\":\n          e = new C33.PropertyTrackState.EffectSourceAdapter(this), this._renderChange = 1;\n          break;\n        case \"instance-variable\":\n          e = new C33.PropertyTrackState.InstanceVariableSourceAdapter(this);\n          break;\n        case \"plugin\":\n          e = new C33.PropertyTrackState.PluginSourceAdapter(this), this._renderChange = 1;\n          break;\n        case \"world-instance\":\n          e = new C33.PropertyTrackState.PropertySourceAdapter(this), this._renderChange = 1, this._worldInfoChange = 1;\n          break;\n        case \"value\":\n          e = new C33.PropertyTrackState.ValueSourceAdapter(this);\n          break;\n        case \"audio\":\n          e = new C33.PropertyTrackState.AudioSourceAdapter(this);\n      }\n      return this._sourceAdapter = e, this._sourceAdapter;\n    }\n    GetSourceAdapterId() {\n      return this._propertyTrackDataItem.GetSourceAdapterId();\n    }\n    SetSourceAdapterId(e) {\n      this._propertyTrackDataItem.SetSourceAdapterId(e);\n    }\n    GetSourceAdapterArgs() {\n      return this._propertyTrackDataItem.GetSourceAdapterArguments();\n    }\n    SetSourceAdapterArgs(e) {\n      this._propertyTrackDataItem.SetSourceAdapterArguments(e);\n    }\n    GetSourceAdapterValue() {\n      return this.GetSourceAdapter().GetValue();\n    }\n    GetPropertyName() {\n      return this._propertyTrackDataItem.GetProperty();\n    }\n    SetPropertyName(e) {\n      this._propertyTrackDataItem.SetProperty(e);\n    }\n    GetPropertyType() {\n      return this._propertyTrackDataItem.GetType();\n    }\n    SetPropertyType(e) {\n      this._propertyTrackDataItem.SetType(e);\n    }\n    GetPropertyKeyframeType() {\n      return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType();\n    }\n    GetMin() {\n      return this._propertyTrackDataItem.GetMin();\n    }\n    SetMin(e) {\n      this._propertyTrackDataItem.SetMin(e);\n    }\n    GetMax() {\n      return this._propertyTrackDataItem.GetMax();\n    }\n    SetMax(e) {\n      this._propertyTrackDataItem.SetMax(e);\n    }\n    GetEnable() {\n      return this._propertyTrackDataItem.GetEnable();\n    }\n    SetEnable(e) {\n      this._propertyTrackDataItem.SetEnable(e);\n    }\n    GetInterpolationMode() {\n      return this._propertyTrackDataItem.GetInterpolationMode();\n    }\n    SetInterpolationMode(e) {\n      this._propertyTrackDataItem.SetInterpolationMode(e);\n    }\n    GetResultMode() {\n      return this._propertyTrackDataItem.GetResultMode();\n    }\n    SetResultMode(e) {\n      this._propertyTrackDataItem.SetResultMode(e);\n    }\n    SetEase(e) {\n      for (const t of this.GetPropertyKeyframeDataItems()) t.SetEase(e);\n    }\n    CanHavePropertyKeyframes() {\n      return this._propertyTrackDataItem.CanHavePropertyKeyframes();\n    }\n    GetPropertyKeyframeDataItems() {\n      return this._propertyKeyframeDataItems || (this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()), this._propertyKeyframeDataItems;\n    }\n    GetPropertyKeyframeDataItemArrayIncludingDisabled() {\n      return this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArrayIncludingDisabled();\n    }\n    GetPropertyKeyFrameDataItemAtTime(e) {\n      return this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);\n    }\n    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e) {\n      return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);\n    }\n    GetPropertyKeyframeDataItemPairForTime(e) {\n      let t, r = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);\n      return r ? t = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(e, this._propertyTrackDataItem) : (r = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), t = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem)), { start: r, end: t };\n    }\n    *GetPropertyKeyframeValues() {\n      for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetValueWithResultMode();\n    }\n    *GetPropertyKeyframeTimes() {\n      for (const e of this.GetPropertyKeyframeDataItems()) yield e.GetTime();\n    }\n    TimelineRemoved() {\n      this.GetSourceAdapter().TimelineRemoved();\n    }\n    CleanCaches() {\n      this.GetSourceAdapter().CleanCaches();\n    }\n    GetCurrentState() {\n      return this.GetSourceAdapter().GetCurrentState();\n    }\n    SetResetState() {\n      this.GetSourceAdapter().SetResetState();\n    }\n    SetInitialState(e) {\n      this.GetSourceAdapter().SetInitialState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e), this._SetUpdateState();\n    }\n    SetResumeState(e) {\n      this.GetSourceAdapter().SetResumeState(), this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(e);\n    }\n    _SetUpdateState() {\n      const e = this.GetTrack();\n      if (this._needsBeforeAndAfter = 0, e.IsInstanceTrack()) {\n        const t = this.GetTimeline(), r = e.GetInstance(), a = this.GetSourceAdapter(), o = this.GetPropertyName();\n        if (a.MayNeedBeforeAndAfterInterpolate()) {\n          const e2 = t.GetSimilarPropertyTracks(r, a, o, this);\n          e2 && e2.length && (this._needsBeforeAndAfter = 1);\n        } else this._needsBeforeAndAfter = 0;\n      }\n    }\n    _GetLastPropertyKeyFrameBeforeTime(e) {\n      const t = this.GetTimeline(), r = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(e, this._propertyTrackDataItem);\n      return r || (t.IsForwardPlayBack() ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem) : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, this._propertyTrackDataItem));\n    }\n    BeforeInterpolate() {\n      this._sourceAdapter.BeforeInterpolate();\n    }\n    Interpolate(e, t = false, r = false, a = false) {\n      let o, s, p = false;\n      if (t) o = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);\n      else {\n        if (this._lastPropertyKeyframeDataItem) {\n          const t2 = this.GetTimeline(), r2 = this._lastPropertyKeyframeDataItem.GetNext(), a2 = this._lastPropertyKeyframeDataItem.GetTime(), o2 = r2 ? r2.GetTime() : t2.GetTotalTime();\n          (e <= a2 || e >= o2) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p = true);\n        } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem), p = true;\n        o = this._lastPropertyKeyframeDataItem;\n      }\n      o && (s = o.GetNext()), this._sourceAdapter.Interpolate(e, o, s, t, r, a, p);\n    }\n    GetInterpolatedValue(e) {\n      if (this._lastPropertyKeyframeDataItem) {\n        const t2 = this.GetTimeline(), r2 = this._lastPropertyKeyframeDataItem.GetNext(), a = this._lastPropertyKeyframeDataItem.GetTime(), o = r2 ? r2.GetTime() : t2.GetTotalTime();\n        (e <= a || e >= o) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem));\n      } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, this._propertyTrackDataItem);\n      const t = this._lastPropertyKeyframeDataItem, r = t.GetNext();\n      return this._sourceAdapter.GetInterpolatedValue(e, t, r);\n    }\n    GetInterpolatedValueFast(e, t, r) {\n      return this._sourceAdapter.GetInterpolatedValue(e, t, r);\n    }\n    AfterInterpolate() {\n      this._sourceAdapter.AfterInterpolate();\n    }\n    static GetStartPropertyKeyframeForTime(e, t) {\n      const r = t.GetPropertyTrackDataItem();\n      return t._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, r);\n    }\n    static GetEndPropertyKeyframeForTime(e, t) {\n      const r = t.GetPropertyTrackDataItem();\n      return t._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, r);\n    }\n    AddPropertyKeyframe() {\n      const e = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();\n      return this._lastPropertyKeyframeDataItem = null, e;\n    }\n    DeletePropertyKeyframes(e) {\n      this._lastPropertyKeyframeDataItem = null;\n      this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(e);\n    }\n    SaveState() {\n      this.GetSourceAdapter().SaveState();\n    }\n    CompareInitialStateWithCurrent() {\n      if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {\n        const e = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem), t = this.GetSourceAdapter().GetCurrentState();\n        e.SetAbsoluteValue(t);\n      }\n    }\n    CompareSaveStateWithCurrent() {\n      const e = this.GetSourceAdapter().CompareSaveStateWithCurrent();\n      return e && this.AddPropertyKeyframeAtCurrentTime(), this.GetSourceAdapter().ClearSaveState(), e;\n    }\n    AddPropertyKeyframeAtCurrentTime() {\n      const e = this.GetTimeline().GetTime(), t = this.GetSourceAdapter(), r = C33.PropertyTrackState.GetStartPropertyKeyframeForTime(e, this), a = this.AddPropertyKeyframe();\n      a.SetType(r.GetType()), a.SetTime(e), a.SetEase(r.GetEase()), a.SetEnable(true), a.SetValue(t.GetValueAtTime()), a.SetAbsoluteValue(t.GetCurrentState());\n    }\n    _SaveToJson() {\n      return { \"sourceAdapterJson\": this.GetSourceAdapter()._SaveToJson() };\n    }\n    _LoadFromJson(e) {\n      e && this.GetSourceAdapter()._LoadFromJson(e[\"sourceAdapterJson\"]);\n    }\n  };\n}\n{\n  const C33 = self.C3, NS = C33.PropertyTrackState;\n  NS.PropertySourceAdapter = class {\n    constructor(e) {\n      this._propertyTrack = e, this._propertyAdapter = null, this.GetPropertyAdapter();\n    }\n    Release() {\n      this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null), this._propertyTrack = null;\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate();\n    }\n    GetPropertyTrack() {\n      return this._propertyTrack;\n    }\n    TimelineRemoved() {\n      this._propertyAdapter && this._propertyAdapter.TimelineRemoved();\n    }\n    CleanCaches() {\n      this._propertyAdapter && this._propertyAdapter.CleanCaches();\n    }\n    GetPropertyAdapter() {\n      return this._propertyAdapter || (this._propertyAdapter = this._CreatePropertyAdapter()), this._propertyAdapter;\n    }\n    GetEditorIndex() {\n    }\n    GetIndex() {\n      return this.GetEditorIndex();\n    }\n    GetTarget() {\n    }\n    SetResetState() {\n      this.GetPropertyAdapter().SetResetState();\n    }\n    SetInitialState() {\n      this.GetPropertyAdapter().SetInitialState();\n    }\n    SetResumeState() {\n      this.GetPropertyAdapter().SetResumeState();\n    }\n    BeforeInterpolate() {\n      this._propertyAdapter.BeforeChangeProperty();\n    }\n    Interpolate(e, t, r, p, a, o, n) {\n      let s;\n      switch (this._propertyTrack.GetPropertyKeyframeType()) {\n        case \"numeric\":\n          s = NS.NumericTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n          break;\n        case \"angle\":\n          s = NS.AngleTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n          break;\n        case \"boolean\":\n          s = NS.BooleanTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n          break;\n        case \"color\":\n          s = NS.ColorTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n          break;\n        case \"text\":\n          s = NS.TextTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n      }\n      this._propertyAdapter.ChangeProperty(e, s, t, r, p, a, o, n);\n    }\n    GetInterpolatedValue(e, t, r) {\n      switch (this._propertyTrack.GetPropertyKeyframeType()) {\n        case \"numeric\":\n          return NS.NumericTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n        case \"angle\":\n          return NS.AngleTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n        case \"boolean\":\n          return NS.BooleanTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n        case \"color\":\n          return NS.ColorTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n        case \"text\":\n          return NS.TextTypeAdapter.Interpolate(e, t, r, this._propertyTrack);\n      }\n    }\n    AfterInterpolate() {\n      this._propertyAdapter.AfterChangeProperty();\n    }\n    SaveState() {\n      this.GetPropertyAdapter().SetSaveState();\n    }\n    ClearSaveState() {\n      this.GetPropertyAdapter().ClearSaveState();\n    }\n    GetCurrentState() {\n      return this.GetPropertyAdapter().GetCurrentState();\n    }\n    CompareInitialStateWithCurrent() {\n      return this.GetPropertyAdapter().CompareInitialStateWithCurrent();\n    }\n    CompareSaveStateWithCurrent() {\n      return this.GetPropertyAdapter().CompareSaveStateWithCurrent();\n    }\n    GetValueAtTime() {\n      const e = this._propertyTrack, t = e.GetTrack().GetTimeline().GetTime(), r = NS.GetStartPropertyKeyframeForTime(t, e), p = r.GetNext();\n      switch (e.GetPropertyKeyframeType()) {\n        case \"numeric\":\n          return NS.NumericTypeAdapter.Interpolate(t, r, p, e);\n        case \"angle\":\n          return NS.AngleTypeAdapter.Interpolate(t, r, p, e);\n        case \"boolean\":\n          return NS.BooleanTypeAdapter.Interpolate(t, r, p, e);\n        case \"color\":\n          return NS.ColorTypeAdapter.Interpolate(t, r, p, e);\n        case \"text\":\n          return NS.TextTypeAdapter.Interpolate(t, r, p, e);\n      }\n    }\n    _CreatePropertyAdapter() {\n      const e = this._propertyTrack;\n      switch (e.CanHavePropertyKeyframes() ? e.GetPropertyKeyframeType() : \"\") {\n        case \"combo\":\n        case \"boolean\":\n        case \"text\":\n        case \"string\":\n          return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this);\n        case \"numeric\":\n        case \"number\":\n        case \"angle\":\n          return \"combo\" === this._propertyTrack.GetPropertyType() ? new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);\n        case \"color\":\n        case \"offsetColor\":\n          return new NS.PropertyInterpolationAdapter.ColorInterpolationAdapter(this);\n        default:\n          return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);\n      }\n    }\n    _SaveToJson() {\n      return { \"propertyAdapterJson\": this.GetPropertyAdapter()._SaveToJson() };\n    }\n    _LoadFromJson(e) {\n      e && this.GetPropertyAdapter()._LoadFromJson(e[\"propertyAdapterJson\"]);\n    }\n  };\n}\n{\n  const C33 = self.C3, INDEX = 0;\n  class InstanceVariableSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {\n    constructor(e) {\n      super(e), this._updatedIndex = NaN;\n    }\n    GetEditorIndex() {\n      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];\n    }\n    GetIndex() {\n      return this._updatedIndex ? this._updatedIndex : super.GetIndex();\n    }\n    GetTarget() {\n      return this._propertyTrack.GetTrack().GetInstance();\n    }\n    UpdateInstanceVariableIndex(e) {\n      this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== e && (this._updatedIndex = e);\n    }\n    Interpolate(e, t, r, a, n, d, p) {\n      this.GetPropertyAdapter().CanChange(t.GetValue()) && super.Interpolate(e, t, r, a, n, d, p);\n    }\n    GetInterpolatedValue(e, t, r) {\n      if (this.GetPropertyAdapter().CanChange(t.GetValue())) return super.GetInterpolatedValue(e, t, r);\n    }\n    _SaveToJson() {\n      return Object.assign(super._SaveToJson(), { \"index\": this._updatedIndex });\n    }\n    _LoadFromJson(e) {\n      e && (super._LoadFromJson(e), this._updatedIndex = e[\"index\"]);\n    }\n  }\n  C33.PropertyTrackState.InstanceVariableSourceAdapter = InstanceVariableSourceAdapter;\n}\n{\n  const C33 = self.C3, SID = 0, INDEX = 1, NAME = 2;\n  class BehaviorSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {\n    constructor(e) {\n      super(e), this._sid = NaN;\n    }\n    GetEditorIndex() {\n      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1];\n    }\n    GetTarget() {\n      const e = this._propertyTrack.GetPropertyTrackDataItem(), t = this._propertyTrack.GetTrack(), r = this._sid ? this._sid : e.GetSourceAdapterArguments()[0], a = t.GetInstance(), s = a.GetBehaviorIndexBySID(r);\n      return a.GetBehaviorInstances()[s].GetSdkInstance();\n    }\n    GetBehaviorType(e) {\n      const t = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2];\n      return e.GetBehaviorTypeByName(t);\n    }\n    UpdateBehaviorTypeSid(e) {\n      this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== e && (this._sid = e);\n    }\n    Interpolate(e, t, r, a, s, o, p) {\n      const c = this._propertyTrack.GetTrack().GetInstance();\n      this.GetBehaviorType(c.GetObjectClass()) && super.Interpolate(e, t, r, a, s, o, p);\n    }\n    GetInterpolatedValue(e, t, r) {\n      const a = this._propertyTrack.GetTrack().GetInstance();\n      if (this.GetBehaviorType(a.GetObjectClass())) return super.GetInterpolatedValue(e, t, r);\n    }\n    _SaveToJson() {\n      return Object.assign(super._SaveToJson(), { \"sid\": this._sid });\n    }\n    _LoadFromJson(e) {\n      e && (super._LoadFromJson(e), this._sid = e[\"sid\"]);\n    }\n  }\n  C33.PropertyTrackState.BehaviorSourceAdapter = BehaviorSourceAdapter;\n}\n{\n  const C33 = self.C3, NAME = 0, INDEX = 1;\n  class EffectSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {\n    constructor(e) {\n      super(e);\n    }\n    GetEditorIndex() {\n      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1];\n    }\n    GetTarget() {\n      const e = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList(), t = e.GetEffectList(), r = this.GetEffectType(t).GetIndex();\n      return e.IsEffectIndexActive(r) ? e.GetEffectParametersForIndex(r) : null;\n    }\n    GetEffectType(e) {\n      const t = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];\n      return e.GetEffectTypeByName(t);\n    }\n    Interpolate(e, t, r, c, f, a, s) {\n      this._IsEffectActive() && super.Interpolate(e, t, r, c, f, a, s);\n    }\n    GetInterpolatedValue(e, t, r) {\n      if (this._IsEffectActive()) return super.GetInterpolatedValue(e, t, r);\n    }\n    _IsEffectActive() {\n      const e = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList(), t = e.GetEffectList(), r = this.GetEffectType(t);\n      if (!r) return;\n      const c = r.GetIndex();\n      return e.IsEffectIndexActive(c);\n    }\n  }\n  C33.PropertyTrackState.EffectSourceAdapter = EffectSourceAdapter;\n}\n{\n  const C33 = self.C3, INDEX = 0;\n  class PluginSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {\n    constructor(t) {\n      super(t);\n    }\n    GetEditorIndex() {\n      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];\n    }\n    GetTarget() {\n      return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance();\n    }\n    Interpolate(t, e, r, n, a, i, s) {\n      const c = this._propertyTrack.GetTrack();\n      c.GetObjectClass().GetPlugin() === c.GetInstance().GetObjectClass().GetPlugin() && super.Interpolate(t, e, r, n, a, i, s);\n    }\n    GetInterpolatedValue(t, e, r) {\n      const n = this._propertyTrack.GetTrack();\n      if (n.GetObjectClass().GetPlugin() === n.GetInstance().GetObjectClass().GetPlugin()) return super.GetInterpolatedValue(t, e, r);\n    }\n    GetOptionalCallbacks() {\n      const t = this._propertyTrack.GetTrack(), e = t.GetObjectClass().GetPlugin();\n      if (C33.Plugins.Sprite && e instanceof C33.Plugins.Sprite && (\"initial-frame\" === this._propertyTrack.GetPropertyName() || \"initial-animation\" === this._propertyTrack.GetPropertyName())) switch (this._propertyTrack.GetResultMode()) {\n        case \"relative\":\n          return { onFrameChange: (e2, r, n, a, i) => {\n            if (r !== a) {\n              const n2 = a / r, i2 = t.GetPropertyTrack(\"offsetWidth\"), s = t.GetPropertyTrack(\"offsetScaleX\");\n              if (i2 || s) {\n                const c = i2?.GetSourceAdapter()?.GetPropertyAdapter(), o = s?.GetSourceAdapter()?.GetPropertyAdapter();\n                if (e2.HasParent() && e2.GetTransformWithParentWidth()) o && o.SetOriginalSizeProperty(a), e2.SetWidth(this.GetNewWidth(a, r, e2, t, c, o));\n                else {\n                  const r2 = a * ((e2._GetSceneGraphInfo()?._GetStartWidth() ?? this.GetInstanceOriginalWidth(e2, t)) / this.GetInstanceOriginalWidth(e2, t));\n                  o && o.SetOriginalSizeProperty(a);\n                  const i3 = c?.GetChangeAccumulatorProperty() ?? 0, s2 = o?.GetChangeAccumulatorProperty() ?? 0;\n                  e2.SetWidth(r2 + (i3 + s2 * n2));\n                }\n              } else e2.SetWidth(e2.GetWidth() * n2);\n            }\n            if (n !== i) {\n              const r2 = i / n, a2 = t.GetPropertyTrack(\"offsetHeight\"), s = t.GetPropertyTrack(\"offsetScaleY\");\n              if (a2 || s) {\n                const c = a2?.GetSourceAdapter()?.GetPropertyAdapter(), o = s?.GetSourceAdapter()?.GetPropertyAdapter();\n                if (e2.HasParent() && e2.GetTransformWithParentHeight()) o && o.SetOriginalSizeProperty(i), e2.SetHeight(this.GetNewHeight(i, n, e2, t, c, o));\n                else {\n                  const n2 = i * ((e2._GetSceneGraphInfo()?._GetStartHeight() ?? this.GetInstanceOriginalHeight(e2, t)) / this.GetInstanceOriginalHeight(e2, t));\n                  o && o.SetOriginalSizeProperty(i);\n                  const a3 = c?.GetChangeAccumulatorProperty() ?? 0, s2 = o?.GetChangeAccumulatorProperty() ?? 0;\n                  e2.SetHeight(n2 + (a3 + s2 * r2));\n                }\n              } else e2.SetHeight(e2.GetHeight() * r2);\n            }\n          } };\n        case \"absolute\":\n          return null;\n      }\n    }\n    GetLastPropertyKeyframeValue(t, e, r, n = 0) {\n      const a = e.GetTimeline().GetTrackFromInstance(t.GetInstance());\n      if (!a) return n;\n      const i = a.GetPropertyTrack(r);\n      if (!i) return n;\n      const s = i.GetPropertyTrackDataItem().GetPropertyKeyframeData();\n      if (!s) return n;\n      const c = s.GetLastPropertyKeyframeDataItem();\n      return c ? c.GetValue() : n;\n    }\n    GetInstanceOriginalWidth(t, e) {\n      const r = e.GetTimeline().GetTrackFromInstance(t.GetInstance());\n      if (r) return r.GetOriginalWidth();\n      const n = t.GetInstance().GetSdkInstance();\n      return n.IsOriginalSizeKnown() ? n.GetOriginalWidth() : t._GetSceneGraphInfo()._GetStartWidth();\n    }\n    GetInstanceOriginalHeight(t, e) {\n      const r = e.GetTimeline().GetTrackFromInstance(t.GetInstance());\n      if (r) return r.GetOriginalHeight();\n      const n = t.GetInstance().GetSdkInstance();\n      return n.IsOriginalSizeKnown() ? n.GetOriginalHeight() : t._GetSceneGraphInfo()._GetStartHeight();\n    }\n    GetNewWidth(t, e, r, n, a, i) {\n      const s = r._GetSceneGraphInfo()._GetStartWidth(), c = s / r.GetParent()._GetSceneGraphInfo()._GetStartWidth();\n      let o = 1;\n      const G = i?.GetAbsoluteScaleXOffsetProperty() ?? 0;\n      if (0 !== G) {\n        const t2 = s / this.GetInstanceOriginalWidth(r, n);\n        o = (t2 + G) / (0 === t2 ? Number.EPSILON : t2);\n      }\n      const p = s * (t / e);\n      let l = a?.GetAbsoluteWidthOffsetProperty() ?? 0;\n      l += p - s;\n      const h = (s + l) / (0 === s ? Number.EPSILON : s);\n      return r.GetParent().GetWidth() * c * o * h;\n    }\n    GetNewHeight(t, e, r, n, a, i) {\n      const s = r._GetSceneGraphInfo()._GetStartHeight(), c = s / r.GetParent()._GetSceneGraphInfo()._GetStartHeight();\n      let o = 1;\n      const G = i?.GetAbsoluteScaleYOffsetProperty() ?? 0;\n      if (0 !== G) {\n        const t2 = s / this.GetInstanceOriginalHeight(r, n);\n        o = (t2 + G) / (0 === t2 ? Number.EPSILON : t2);\n      }\n      const p = s * (t / e);\n      let l = a?.GetAbsoluteHeightOffsetProperty() ?? 0;\n      l += p - s;\n      const h = (s + l) / (0 === s ? Number.EPSILON : s);\n      return r.GetParent().GetHeight() * c * o * h;\n    }\n  }\n  C33.PropertyTrackState.PluginSourceAdapter = PluginSourceAdapter;\n}\n{\n  const C33 = self.C3;\n  class ValueSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {\n    constructor(t) {\n      super(t), this._value = 0, this._init = false;\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return false;\n    }\n    SetInitialState() {\n      const t = this._propertyTrack.GetPropertyTrackData();\n      let e = this._propertyTrack.GetPropertyTrackDataItem();\n      e = t.GetFirstPropertyKeyframeDataItem(e), this._value = e.GetValueWithResultMode();\n    }\n    SetResumeState() {\n    }\n    GetValue() {\n      return this._init || this._propertyTrack.Interpolate(0), this._value;\n    }\n    Interpolate(t, e, r, a, i, o, u) {\n      this._value = C33.PropertyTrackState.NumericTypeAdapter.Interpolate(t, e, r, this._propertyTrack), this._init = true;\n    }\n    SaveState() {\n    }\n    ClearSaveState() {\n    }\n    GetCurrentState() {\n      return this._value;\n    }\n    CompareInitialStateWithCurrent() {\n      return false;\n    }\n    CompareSaveStateWithCurrent() {\n      return false;\n    }\n    _SaveToJson() {\n      return { \"value\": this._value, \"init\": this._init };\n    }\n    _LoadFromJson(t) {\n      t && (this._value = t[\"value\"], this._init = !t.hasOwnProperty(\"init\") || t[\"init\"]);\n    }\n  }\n  C33.PropertyTrackState.ValueSourceAdapter = ValueSourceAdapter;\n}\n{\n  const C33 = self.C3, PROJECT_FILE = 0, PROJECT_FILE_NAME = 0, PROJECT_FILE_TYPE = 1, START_OFFSET = 1, AUDIO_DURATION = 2, AUDIO_TAG = 3;\n  class AudioSourceAdapter extends C33.PropertyTrackState.PropertySourceAdapter {\n    constructor(t) {\n      super(t), this._audioPlaybackStarted = false, this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = this._propertyTrack.GetTimeline(), this._track = this._propertyTrack.GetTrack(), this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs(), this._fileArgs = this._sourceAdapterArgs[0], this._startOffsetTime = this._sourceAdapterArgs[1], this._sourceAdapterArgs[3] ? this._audioTag = this._sourceAdapterArgs[3] : this._audioTag = Math.random().toString(36).slice(2), this._pauseTime = NaN, this._pauseVolume = NaN, this._volume = NaN, this._audioSource = null, this._Initialize();\n    }\n    Release() {\n      super.Release(), this._sdkInstance = null, this._actions = null, this._expressions = null, this._timeline = null, this._track = null, this._sourceAdapterArgs = null, this._fileArgs = null, this._audioSource = null;\n    }\n    _Initialize() {\n      if (!self.C3.Plugins.Audio) return;\n      const t = this._propertyTrack.GetRuntime().GetSingleGlobalObjectClassByCtor(self.C3.Plugins.Audio);\n      t && (this._sdkInstance = t.GetSingleGlobalInstance().GetSdkInstance()), this._actions = self.C3.Plugins.Audio.Acts, this._expressions = self.C3.Plugins.Audio.Exps;\n    }\n    _MaybeSetAudioSource() {\n      if (this._audioSource) return;\n      const t = this._propertyTrack.GetTrack().GetPropertyTrack(\"audioSource\");\n      t && (this._audioSource = t.GetSourceAdapter());\n    }\n    _GetPauseVolume() {\n      const t = this._propertyTrack.GetTrack().GetPropertyTrack(\"volume\");\n      return t ? t.GetSourceAdapter()._pauseVolume : this._pauseVolume;\n    }\n    TimelineRemoved() {\n      super.TimelineRemoved(), this._audioPlaybackStarted = false, this._sdkInstance && (this._expressions && (this._pauseTime = this._expressions.PlaybackTime.call(this._sdkInstance, this._audioTag), this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)), this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag));\n    }\n    GetAudioTag() {\n      return this._audioTag;\n    }\n    GetVolume() {\n      return this._volume;\n    }\n    SetVolume(t) {\n      this._volume = t;\n    }\n    SetInitialState() {\n      super.SetInitialState(), this._pauseTime = NaN, this._audioPlaybackStarted = false;\n    }\n    SetResumeState() {\n      super.SetResumeState();\n      const t = this._propertyTrack.GetTimeline().GetTime();\n      switch (this._pauseTime = t - this._startOffsetTime, this._propertyTrack.GetPropertyName()) {\n        case \"audioSource\":\n          break;\n        case \"volume\":\n          this._pauseVolume = this._propertyTrack.GetInterpolatedValue(t);\n      }\n      this._audioPlaybackStarted = false;\n    }\n    Interpolate(t, e, s, i, a, o, r) {\n      if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {\n        case \"audioSource\": {\n          if (!this._timeline.IsForwardPlayBack()) return;\n          if (i) return void (this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag));\n          if (t < this._startOffsetTime) return void (this._audioPlaybackStarted = false);\n          const e2 = this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag), s2 = this._timeline.GetPlaybackRate();\n          if (s2 !== e2 && this._actions.SetPlaybackRate.call(this._sdkInstance, this._audioTag, s2), this._audioPlaybackStarted) return;\n          if (!this._propertyTrack.GetTimeline().IsPlaying()) return;\n          if (this._audioPlaybackStarted = true, isNaN(this._pauseTime)) {\n            const e3 = self[\"performance\"].now(), s3 = t - this._startOffsetTime;\n            if (\"suspended\" === this._sdkInstance.GetAudioContextState()) return void (this._audioPlaybackStarted = false);\n            const i2 = s3 + (self[\"performance\"].now() - e3) / 1e3;\n            if (this._actions) {\n              let t2 = this.GetVolume();\n              isNaN(t2) ? (this.SetVolume(0), t2 = 0) : this.SetVolume(t2), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, t2, this._audioTag, i2);\n            }\n          } else {\n            const t2 = this._pauseTime;\n            this._pauseTime = NaN;\n            const e3 = this._GetPauseVolume();\n            this._pauseVolume = NaN;\n            if (\"suspended\" === this._sdkInstance.GetAudioContextState()) return void (this._audioPlaybackStarted = false);\n            this._actions && (this.SetVolume(e3), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, e3, this._audioTag, t2));\n          }\n          break;\n        }\n        case \"volume\":\n          this._MaybeSetAudioSource(), super.Interpolate(t, e, s, i, a, o, r);\n      }\n    }\n    GetInterpolatedValue(t, e, s) {\n      if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {\n        case \"audioSource\":\n          return;\n        case \"volume\":\n          return this._MaybeSetAudioSource(), super.GetInterpolatedValue(t, e, s);\n      }\n    }\n    Getter(t, e) {\n      return this._audioSource ? this._audioSource.GetVolume() : 0;\n    }\n    Setter(t, e, s, i) {\n      this._audioSource && this._audioSource.SetVolume(this.Getter() + e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());\n    }\n    AbsoluteSetter(t, e, s) {\n      this._audioSource && this._audioSource.SetVolume(e), this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume());\n    }\n    DoesRounding() {\n      return true;\n    }\n    _SaveToJson() {\n      return { \"audioPlaybackStarted\": this._audioPlaybackStarted, \"audioTag\": this._audioTag, \"pauseTime\": this._pauseTime, \"pauseVolume\": this._pauseVolume, \"volume\": this._volume };\n    }\n    _LoadFromJson(t) {\n      t && (this._audioPlaybackStarted = t[\"audioPlaybackStarted\"], this._audioTag = t[\"audioTag\"], this._pauseTime = t[\"pauseTime\"], this._pauseVolume = t[\"pauseVolume\"], this._volume = t[\"volume\"], this._Initialize());\n    }\n  }\n  C33.PropertyTrackState.AudioSourceAdapter = AudioSourceAdapter;\n}\n{\n  const C33 = self.C3;\n  C33.PropertyTrackState.PropertyInterpolationAdapter = class {\n    constructor(t) {\n      this._sourceAdapter = t, this._propertyTrack = t.GetPropertyTrack(), this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo(), this._property = this._propertyTrack.GetPropertyName(), this._firstAbsoluteUpdate = false, this._saveState = null, this._target = null;\n    }\n    Release() {\n      this._sourceAdapter = null, this._propertyTrack = null, this._worldInfo = null, this._saveState = null, this._target = null;\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return false;\n    }\n    TimelineRemoved() {\n    }\n    CleanCaches() {\n      this._worldInfo = null, this._saveState = null, this._target = null;\n    }\n    GetSourceAdapter() {\n      return this._sourceAdapter;\n    }\n    GetPropertyTrack() {\n      return this._propertyTrack;\n    }\n    GetWorldInfo() {\n      return this._worldInfo || (this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()), this._worldInfo;\n    }\n    SetFirstAbsoluteUpdate(t) {\n      this._firstAbsoluteUpdate = !!t;\n    }\n    GetFirstAbsoluteUpdate() {\n      return this._firstAbsoluteUpdate;\n    }\n    SetResetState() {\n    }\n    SetInitialState() {\n    }\n    SetResumeState() {\n    }\n    SetSaveState() {\n      this._saveState = this.GetCurrentState();\n    }\n    ClearSaveState() {\n      this._saveState = null;\n    }\n    GetCurrentState() {\n    }\n    CompareInitialStateWithCurrent() {\n    }\n    CompareSaveStateWithCurrent() {\n    }\n    CanChange(t) {\n      return typeof this._Getter() === typeof t;\n    }\n    BeforeChangeProperty() {\n    }\n    ChangeProperty(t, e, r, a, s, o, i, n) {\n    }\n    AfterChangeProperty() {\n    }\n    _FirstKeyframeGetter() {\n      return this._PickTimelinePlaybackMode(() => {\n        const t = this._propertyTrack.GetPropertyTrackDataItem();\n        return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(t);\n      }, () => {\n        const t = this._propertyTrack.GetPropertyTrackDataItem();\n        return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(t);\n      }).GetAbsoluteValue();\n    }\n    _CurrentKeyframeGetter() {\n      const t = this._propertyTrack.GetTimeline().GetTime() - this._propertyTrack.GetTrack().GetStartOffset();\n      return this._PickTimelinePlaybackMode(() => {\n        const e = this._propertyTrack.GetPropertyTrackDataItem();\n        return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, e);\n      }, () => {\n        const e = this._propertyTrack.GetPropertyTrackDataItem(), r = this._propertyTrack.GetPropertyTrackData(), a = r.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t, e);\n        return a || r.GetLastPropertyKeyframeDataItem(e);\n      }).GetAbsoluteValue();\n    }\n    _PickTimelinePlaybackMode(t, e) {\n      return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? t() : e();\n    }\n    _PickResultMode(t, e) {\n      return \"relative\" === this._propertyTrack.GetResultMode() ? t() : e();\n    }\n    _PickFirstAbsoluteUpdate(t, e) {\n      return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(false), t()) : e();\n    }\n    _GetAbsoluteInitialValue(t) {\n    }\n    _GetIndex() {\n      return this._sourceAdapter.GetIndex();\n    }\n    _GetTarget() {\n      return this._target || (this._target = this._sourceAdapter.GetTarget()), this._target;\n    }\n    _PickSource(t, e, r, a, s, o) {\n      switch (this._propertyTrack.GetSourceAdapterId()) {\n        case \"behavior\":\n          return t();\n        case \"effect\":\n          return e();\n        case \"instance-variable\":\n          return r();\n        case \"plugin\":\n          return a();\n        case \"world-instance\":\n          return s();\n        case \"audio\":\n          return o();\n      }\n    }\n    _SaveToJson() {\n      return { \"firstAbsoluteUpdate\": this._firstAbsoluteUpdate, \"saveState\": this._saveState };\n    }\n    _LoadFromJson(t) {\n      t && (this._firstAbsoluteUpdate = t[\"firstAbsoluteUpdate\"], this._saveState = t[\"saveState\"]);\n    }\n    _GetPropertyKeyframeStubs(t, e = false) {\n      const r = [];\n      for (const a of t) {\n        const t2 = a.GetTrack().GetStartOffset();\n        for (const s of a.GetPropertyKeyframeDataItems()) e && 0 === s.GetTime() ? r.push({ time: t2 + s.GetTime(), value: s.GetAbsoluteValue() }) : e || r.push({ time: t2 + s.GetTime(), value: s.GetAbsoluteValue() });\n      }\n      return r.sort((t2, e2) => t2.time - e2.time);\n    }\n    _GetLastPropertyKeyframeStub(t, e, r) {\n      return this._GetPropertyKeyframeStubLowerThanPlayhead(e, r);\n    }\n    _GetPropertyKeyframeStubLowerThanPlayhead(t, e) {\n      for (let r = e.length - 1; r >= 0; r--) {\n        if (e[r].time <= t) return e[r];\n      }\n      return null;\n    }\n  };\n}\n{\n  const C33 = self.C3, TMP_COLORS_MAP = /* @__PURE__ */ new Map(), TMP_COLOR = [0, 0, 0];\n  class ColorInterpolationAdapter extends C33.PropertyTrackState.PropertyInterpolationAdapter {\n    constructor(e) {\n      super(e);\n    }\n    SetResetState() {\n    }\n    SetInitialState() {\n    }\n    SetResumeState() {\n    }\n    GetCurrentState() {\n      const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();\n      switch (e) {\n        case \"behavior\":\n        case \"plugin\":\n          return this._ToColorArray(t.GetPropertyValueByIndex(r));\n        case \"effect\":\n          return this._ToColorArray(t[r]);\n        case \"world-instance\":\n          return this._ToColorArray(this._Getter());\n      }\n    }\n    CompareInitialStateWithCurrent() {\n      const e = this._FirstKeyframeGetter();\n      return !this._CompareColors(e, this._Getter());\n    }\n    CompareSaveStateWithCurrent() {\n      return !C33.IsNullOrUndefined(this._saveState) && !this._CompareColors(this._saveState, this._Getter());\n    }\n    _CompareColors(e, t) {\n      return e = this._GetColorFromArray(e), t = this._GetColorFromArray(t), e.equalsIgnoringAlpha(t);\n    }\n    _FirstKeyframeGetter() {\n      const e = super._FirstKeyframeGetter();\n      return this._GetColorFromArray(e);\n    }\n    _CurrentKeyframeGetter() {\n      const e = super._CurrentKeyframeGetter();\n      return this._GetColorFromArray(e);\n    }\n    _GetAbsoluteInitialValue(e) {\n    }\n    _ToColorArray(e) {\n      return C33.IsInstanceOf(e, C33.Color) ? e.toArray().slice(0, 3) : e.slice(0, 3);\n    }\n    _GetColorFromArray(e) {\n      return C33.IsInstanceOf(e, C33.Color) ? e : new C33.Color(e[0], e[1], e[2], 1);\n    }\n    CanChange(e) {\n      return true;\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return true;\n    }\n    BeforeChangeProperty() {\n      const e = this._propertyTrack.GetTimeline(), t = this._propertyTrack.GetInstance(), r = this._propertyTrack.GetSourceAdapter(), o = e.GetSimilarPropertyTracks(t, r, this._property, this._propertyTrack);\n      if (o && o.length > 1) {\n        TMP_COLORS_MAP.has(t) || TMP_COLORS_MAP.set(t, /* @__PURE__ */ new Map());\n        const e2 = TMP_COLORS_MAP.get(t), r2 = this._propertyTrack.GetSourceAdapterId();\n        e2.has(r2) || e2.set(r2, /* @__PURE__ */ new Map());\n        const o2 = e2.get(r2);\n        o2.has(this._property) || o2.set(this._property, { used: false, color: new C33.Color(0, 0, 0, 1) });\n      }\n    }\n    _GetTmpColor(e, t, r) {\n      const o = TMP_COLORS_MAP.get(e).get(t).get(r);\n      return o.used = true, o.color;\n    }\n    ChangeProperty(e, t, r, o, s, a, n, i) {\n      const p = this._propertyTrack.GetTimeline(), _ = this._propertyTrack.GetTrack(), c = this._propertyTrack.GetInstance(), l = this._propertyTrack.GetSourceAdapter(), h = this._propertyTrack.GetSourceAdapterId(), C = this._property, y = p.GetSimilarPropertyTracks(c, l, C, this._propertyTrack);\n      if (y && y.length > 1) {\n        const e2 = this._GetPropertyKeyframeStubs(y, true), r2 = this._GetLastPropertyKeyframeStub(p, p.GetTime(), e2);\n        if (r2) {\n          const e3 = _.GetStartOffset(), o2 = r2.time - e3;\n          if (0 === o2) this._GetTmpColor(c, h, this._property).addRgb(t[0], t[1], t[2]);\n          else {\n            if (o2 < 0) return;\n            const e4 = t[0], r3 = t[1], s2 = t[2], a2 = this._propertyTrack.Interpolate(o2, false, true), n2 = C33.Color.DiffChannel(e4, a2[0]), i2 = C33.Color.DiffChannel(r3, a2[1]), p2 = C33.Color.DiffChannel(s2, a2[2]);\n            this._GetTmpColor(c, h, this._property).addRgb(n2, i2, p2);\n          }\n        }\n      } else this._Setter(t[0], t[1], t[2]);\n    }\n    AfterChangeProperty() {\n      const e = this._propertyTrack.GetInstance();\n      if (!TMP_COLORS_MAP.has(e)) return;\n      const t = TMP_COLORS_MAP.get(e), r = this._propertyTrack.GetSourceAdapterId();\n      if (!t.has(r)) return;\n      const o = t.get(r);\n      if (!o.has(this._property)) return;\n      const s = o.get(this._property), a = s.used, n = s.color;\n      a && this._Setter(n.getR(), n.getG(), n.getB()), 0 === o.size && t.delete(r), 0 === t.size && TMP_COLORS_MAP.delete(e);\n    }\n    _Getter() {\n      const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();\n      switch (e) {\n        case \"behavior\":\n        case \"plugin\":\n          return this._GetColorFromArray(t.GetPropertyValueByIndex(r));\n        case \"effect\":\n          return t[r].clone();\n        case \"world-instance\":\n          return this.GetWorldInfo().GetUnpremultipliedColor().clone();\n      }\n    }\n    _Setter(e, t, r) {\n      const o = this._propertyTrack.GetSourceAdapterId(), s = this._GetTarget(), a = this._GetIndex();\n      switch (o) {\n        case \"behavior\":\n        case \"plugin\":\n          TMP_COLOR[0] = e, TMP_COLOR[1] = t, TMP_COLOR[2] = r, s.SetPropertyValueByIndex(a, TMP_COLOR);\n          break;\n        case \"effect\":\n          s[a].setRgb(e, t, r);\n          break;\n        case \"world-instance\":\n          this.GetWorldInfo().SetUnpremultipliedColorRGB(e, t, r);\n      }\n    }\n    _SaveToJson() {\n    }\n    _LoadFromJson(e) {\n    }\n  }\n  C33.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = ColorInterpolationAdapter;\n}\n{\n  const C33 = self.C3, NS = C33.PropertyTrackState;\n  class NoInterpolationAdapter extends C33.PropertyTrackState.PropertyInterpolationAdapter {\n    constructor(e) {\n      super(e);\n    }\n    SetResetState() {\n    }\n    SetInitialState() {\n    }\n    SetResumeState() {\n    }\n    GetCurrentState() {\n      return this._Getter();\n    }\n    CompareInitialStateWithCurrent() {\n      return this._FirstKeyframeGetter() !== this.GetCurrentState();\n    }\n    CompareSaveStateWithCurrent() {\n      return !C33.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return false;\n    }\n    ChangeProperty(e, t, r, a, n, i, s, o) {\n      const p = this._propertyTrack, c = p.GetTrack(), l = p.GetSourceAdapterId(), h = p.GetTimeline(), u = c.GetInstance(), S = p.GetSourceAdapter(), G = this._property, d = h.GetSimilarPropertyTracks(u, S, G, p);\n      if (d && d.length > 1) {\n        const r2 = this._GetPropertyKeyframeStubs(d), a2 = e + c.GetStartOffset(), n2 = this._GetLastPropertyKeyframeStub(h, a2, r2);\n        n2 && (t = n2.value);\n      }\n      switch (p.GetPropertyKeyframeType()) {\n        case \"numeric\":\n          if (!NS.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) return;\n          break;\n        case \"angle\":\n          if (!NS.AngleTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) return;\n          break;\n        case \"boolean\":\n          if (!NS.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) return;\n          break;\n        case \"color\":\n          if (!NS.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) return;\n          break;\n        case \"text\":\n          if (!NS.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), t, l)) return;\n      }\n      this._Setter(t);\n    }\n    _Getter() {\n      const e = this._propertyTrack.GetSourceAdapterId(), t = this._GetTarget(), r = this._GetIndex();\n      switch (e) {\n        case \"behavior\":\n        case \"plugin\":\n          return t.GetPropertyValueByIndex(r);\n        case \"effect\":\n          return t[r];\n        case \"instance-variable\":\n          return t.GetInstanceVariableValue(r);\n      }\n    }\n    _Setter(e) {\n      const t = this._propertyTrack.GetSourceAdapterId(), r = this._GetTarget(), a = this._GetIndex();\n      switch (t) {\n        case \"behavior\":\n        case \"plugin\":\n          r.SetPropertyValueByIndex(a, e);\n          break;\n        case \"effect\":\n          r[a] = e;\n          break;\n        case \"instance-variable\":\n          r.SetInstanceVariableValue(a, e);\n      }\n    }\n  }\n  C33.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = NoInterpolationAdapter;\n}\n{\n  const C33 = self.C3, NS = C33.PropertyTrackState.PropertyInterpolationAdapter, INSTANCE_FUNC_MAP = /* @__PURE__ */ new Map(), add = (t, e, a, r, i, s = false, o = null, n = null) => {\n    INSTANCE_FUNC_MAP.set(t, { setter: e, absolute_setter: a, getter: r, round: i, fRound: s, init: o, reset: n });\n  }, get_original_size = (t, e) => {\n    const a = e.GetTimeline().GetTrackFromInstance(t.GetInstance());\n    if (a) return a.GetOriginalWidth();\n    const r = t.GetInstance().GetSdkInstance();\n    return r.IsOriginalSizeKnown() ? r.GetOriginalWidth() : t._GetSceneGraphInfo()._GetStartWidth();\n  }, get_last_property_keyframe_value = (t, e, a, r = 0) => {\n    const i = e.GetTimeline().GetTrackFromInstance(t.GetInstance());\n    if (!i) return r;\n    const s = i.GetPropertyTrack(a);\n    if (!s) return r;\n    const o = s.GetPropertyTrackDataItem().GetPropertyKeyframeData();\n    if (!o) return r;\n    const n = o.GetLastPropertyKeyframeDataItem();\n    return n ? n.GetValue() : r;\n  }, get_parents = (t) => {\n    const e = [];\n    let a = t.GetParent();\n    for (; a; ) e.push(a), a = a.GetParent();\n    return e.reverse(), e;\n  };\n  add(\"offsetX\", (t, e, a, r) => {\n    \"relative\" === r._propertyTrack.GetResultMode() ? t.OffsetX(e, a.GetTimeline().GetTransformWithSceneGraph()) : t.OffsetX(e);\n  }, (t, e) => t.SetX(e), (t) => t.GetX(), true), add(\"offsetY\", (t, e, a, r) => {\n    \"relative\" === r._propertyTrack.GetResultMode() ? t.OffsetY(e, a.GetTimeline().GetTransformWithSceneGraph()) : t.OffsetY(e);\n  }, (t, e) => t.SetY(e), (t) => t.GetY(), true), add(\"offsetWidth\", (t, e, a, r, i = false, s = true) => {\n    if (0 === e) return;\n    const o = \"relative\" === r._propertyTrack.GetResultMode(), n = 1 === r._typeAdapter.GetType();\n    if ((o || n) && t.HasParent() && t.GetTransformWithParentWidth()) {\n      if (isNaN(r._absoluteToFactor)) {\n        const e2 = get_parents(t);\n        let a3;\n        if (n) {\n          a3 = e2[e2.length - 1].GetWidth();\n        } else {\n          a3 = e2[e2.length - 1]._GetSceneGraphInfo()._GetStartWidth();\n        }\n        r._absoluteToFactor = 0 === a3 ? Number.EPSILON : a3;\n      }\n      if (i) return;\n      r._absoluteWidthOffset += e;\n      const a2 = e / r._absoluteToFactor;\n      t.OffsetWidth(a2, s), r._changeAccumulator += a2;\n    } else t.OffsetWidth(e), r._changeAccumulator += e;\n  }, (t, e) => t.SetWidth(e), (t) => t.GetWidth(), true, false, null, (t) => {\n    t._changeAccumulator = 0, t._absoluteWidthOffset = 0;\n  }), add(\"offsetHeight\", (t, e, a, r, i = false, s = true) => {\n    if (0 === e) return;\n    const o = \"relative\" === r._propertyTrack.GetResultMode(), n = 1 === r._typeAdapter.GetType();\n    if ((o || n) && t.HasParent() && t.GetTransformWithParentHeight()) {\n      if (isNaN(r._absoluteToFactor)) {\n        const e2 = get_parents(t);\n        let a3;\n        if (n) {\n          a3 = e2[e2.length - 1].GetHeight();\n        } else {\n          a3 = e2[e2.length - 1]._GetSceneGraphInfo()._GetStartHeight();\n        }\n        r._absoluteToFactor = 0 === a3 ? Number.EPSILON : a3;\n      }\n      if (i) return;\n      r._absoluteHeightOffset += e;\n      const a2 = e / r._absoluteToFactor;\n      t.OffsetHeight(a2, s), r._changeAccumulator += a2;\n    } else t.OffsetHeight(e), r._changeAccumulator += e;\n  }, (t, e) => t.SetHeight(e), (t) => t.GetHeight(), true, false, null, (t) => {\n    t._changeAccumulator = 0, t._absoluteHeightOffset = 0;\n  }), add(\"offsetAngle\", (t, e, a, r, i) => {\n    t.OffsetAngle(e);\n  }, (t, e) => t.SetAngle(e), (t) => t.GetAngle(), false, true), add(\"offsetOpacity\", (t, e, a, r, i) => {\n    e /= r._opacityFactor ? r._opacityFactor : 1;\n    const s = t.GetOpacity() + e;\n    if (0 === r._clampAccumulator) s > 1 ? r._clampAccumulator += s - 1 : s < 0 && (r._clampAccumulator += s), t.OffsetOpacity(e);\n    else {\n      const a2 = t.GetOpacity() + e;\n      e > 0 && r._clampAccumulator > 0 ? a2 > 1 && (r._clampAccumulator += a2 - 1) : e > 0 && r._clampAccumulator < 0 ? (r._clampAccumulator += e, r._clampAccumulator > 0 && (t.OffsetOpacity(r._clampAccumulator), r._clampAccumulator = 0)) : e < 0 && r._clampAccumulator > 0 ? (r._clampAccumulator += e, r._clampAccumulator < 0 && (t.OffsetOpacity(r._clampAccumulator), r._clampAccumulator = 0)) : e < 0 && r._clampAccumulator < 0 && a2 < 0 && (r._clampAccumulator += a2);\n    }\n  }, (t, e) => {\n    t.SetOpacity(e);\n  }, (t) => t.GetOpacity(), false, true, (t, e, a) => {\n    switch (t._clampAccumulator = 0, t._propertyTrack.GetResultMode()) {\n      case \"relative\": {\n        t._propertyTrack.GetPropertyTrackData();\n        const e2 = t._propertyTrack.GetPropertyTrackDataItem().GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();\n        let a2 = t.GetWorldInfo().GetOpacity(), r2 = a2;\n        for (const i2 of e2) {\n          const e3 = i2.GetTime();\n          r2 = a2 + t._propertyTrack.GetInterpolatedValue(e3), r2 = C33.clamp(r2, 0, 1);\n        }\n        t._totalForewardOpacityDelta = a2 - r2, t._totalForewardOpacityDelta = Math.round(100 * (t._totalForewardOpacityDelta + Number.EPSILON)) / 100, r2 = a2;\n        for (let a3 = e2.length - 1; a3 >= 0; a3--) {\n          const i2 = e2[a3].GetTime();\n          r2 -= t._propertyTrack.GetInterpolatedValue(i2), r2 = C33.clamp(r2, 0, 1);\n        }\n        t._totalBackwardOpacityDelta = r2, t._totalBackwardOpacityDelta = Math.round(100 * (t._totalBackwardOpacityDelta + Number.EPSILON)) / 100;\n        break;\n      }\n    }\n    const r = \"relative\" === t._propertyTrack.GetResultMode(), i = 1 === t._typeAdapter.GetType();\n    if ((r || i) && e.HasParent() && e.GetTransformWithParentOpacity()) {\n      const r2 = get_parents(e);\n      let i2 = r2[0]._GetSceneGraphInfo().GetStartOpacity();\n      i2 += get_last_property_keyframe_value(r2[0], a, \"offsetOpacity\");\n      for (let t2 = 1; t2 < r2.length; t2++) i2 += get_last_property_keyframe_value(r2[t2], a, \"offsetOpacity\");\n      t._opacityFactor = 0 === i2 ? 1 : i2;\n    }\n  }, (t) => {\n    switch (t._propertyTrack.GetResultMode()) {\n      case \"relative\": {\n        t._clampAccumulator = 0;\n        const e = t.GetWorldInfo();\n        let a = e.GetOpacity();\n        a = Math.round(100 * (a + Number.EPSILON)) / 100, t._propertyTrack.GetTimeline().IsForwardPlayBack() ? (e.SetOpacity(a + t._totalForewardOpacityDelta), t._lastValue = 0) : (e.SetOpacity(a - t._totalBackwardOpacityDelta), t._lastValue = t.GetSourceAdapter().GetValueAtTime());\n        break;\n      }\n    }\n  }), add(\"offsetOriginX\", (t, e) => t.OffsetOriginX(e), (t, e) => t.SetOriginX(e), (t) => t.GetOriginX(), false), add(\"offsetOriginY\", (t, e) => t.OffsetOriginY(e), (t, e) => t.SetOriginY(e), (t) => t.GetOriginY(), false), add(\"offsetZElevation\", (t, e) => t.OffsetZElevation(e), (t, e) => t.SetZElevation(e), (t) => t.GetZElevation(), true), add(\"offsetScaleX\", (t, e, a, r) => {\n    if (0 === e) return;\n    const i = t.GetWidth() < 0 ? -1 : 1;\n    if (r._absoluteScaleXOffset += e, \"relative\" === r._propertyTrack.GetResultMode() && t.HasParent() && t.GetTransformWithParentWidth()) {\n      const s = get_last_property_keyframe_value(t, a, \"offsetWidth\"), o = isNaN(r._originalSize) ? a.GetOriginalWidth() : r._originalSize, n = (o + s / (t._GetSceneGraphInfo()._GetStartWidth() / o)) * i * e;\n      isNaN(r._absoluteToFactor) && INSTANCE_FUNC_MAP.get(\"offsetWidth\").setter(t, 1, a, r, true);\n      const l = n / r._absoluteToFactor;\n      t.OffsetWidth(l, true), r._changeAccumulator += l;\n    } else {\n      const s = (isNaN(r._originalSize) ? a.GetOriginalWidth() : r._originalSize) * i * e;\n      t.OffsetWidth(s), r._changeAccumulator += s;\n    }\n  }, (t, e, a) => {\n    t.SetWidth(a.GetOriginalWidth() * e);\n  }, (t, e) => {\n    const a = t.GetWidth() < 0 ? -1 : 1;\n    if (t.GetTransformWithParentWidth()) {\n      const r = t.GetParent(), i = e.GetTimeline().GetTrackFromInstance(r.GetInstance());\n      let s = NaN;\n      if (i) s = r.GetWidth() / i.GetOriginalWidth();\n      else {\n        const t2 = r.GetInstance().GetSdkInstance();\n        s = t2.IsOriginalSizeKnown() ? r.GetWidth() / t2.GetOriginalWidth() : 1;\n      }\n      return t.GetWidth() * a / (e.GetOriginalWidth() * s);\n    }\n    return t.GetWidth() * a / e.GetOriginalWidth();\n  }, false, false, null, (t) => {\n    t._changeAccumulator = 0, t._originalSize = NaN, t._absoluteScaleXOffset = 0;\n  }), add(\"offsetScaleY\", (t, e, a, r) => {\n    if (0 === e) return;\n    const i = t.GetHeight() < 0 ? -1 : 1;\n    if (r._absoluteScaleYOffset += e, \"relative\" === r._propertyTrack.GetResultMode() && t.HasParent() && t.GetTransformWithParentHeight()) {\n      const s = get_last_property_keyframe_value(t, a, \"offsetHeight\"), o = isNaN(r._originalSize) ? a.GetOriginalHeight() : r._originalSize, n = (o + s / (t._GetSceneGraphInfo()._GetStartHeight() / o)) * i * e;\n      isNaN(r._absoluteToFactor) && INSTANCE_FUNC_MAP.get(\"offsetHeight\").setter(t, 1, a, r, true);\n      const l = n / r._absoluteToFactor;\n      t.OffsetHeight(l, true), r._changeAccumulator += l;\n    } else {\n      const s = (isNaN(r._originalSize) ? a.GetOriginalHeight() : r._originalSize) * i * e;\n      t.OffsetHeight(s), r._changeAccumulator += s;\n    }\n  }, (t, e, a) => {\n    t.SetHeight(a.GetOriginalHeight() * e);\n  }, (t, e) => {\n    const a = t.GetHeight() < 0 ? -1 : 1;\n    if (t.GetTransformWithParentHeight()) {\n      const r = t.GetParent(), i = e.GetTimeline().GetTrackFromInstance(r.GetInstance());\n      let s = NaN;\n      if (i) s = r.GetHeight() / i.GetOriginalHeight();\n      else {\n        const t2 = r.GetInstance().GetSdkInstance();\n        s = t2.IsOriginalSizeKnown() ? r.GetHeight() / t2.GetOriginalHeight() : 1;\n      }\n      return t.GetHeight() * a / (e.GetOriginalHeight() * s);\n    }\n    return t.GetHeight() * a / e.GetOriginalHeight();\n  }, false, false, null, (t) => {\n    t._changeAccumulator = 0, t._originalSize = NaN, t._absoluteScaleYOffset = 0;\n  });\n  class NumericInterpolationAdapter extends C33.PropertyTrackState.PropertyInterpolationAdapter {\n    constructor(t) {\n      super(t), this._lastValue = 0, this._clampAccumulator = 0, this._totalForewardOpacityDelta = 0, this._totalBackwardOpacityDelta = 0, this._opacityFactor = NaN, this._absoluteToFactor = NaN, this._changeAccumulator = 0, this._originalSize = NaN, this._absoluteWidthOffset = 0, this._absoluteScaleXOffset = 0, this._absoluteHeightOffset = 0, this._absoluteScaleYOffset = 0, this._angleReflectMirrorOrFlip = void 0, this._angleReflectMirrorAndFlip = void 0, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, this._round = false, this._fRound = false, C33.IsInstanceOf(this._propertyTrack.GetTimeline(), C33.TweenState) ? this._typeAdapter = new C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);\n      const e = this._propertyTrack.GetPropertyName();\n      switch (this._propertyTrack.GetSourceAdapterId()) {\n        case \"world-instance\": {\n          const t2 = INSTANCE_FUNC_MAP.get(e);\n          this._instance_getter = t2.getter, this._instance_setter = t2.setter, this._instance_absolute_setter = t2.absolute_setter, this._round = t2.round, this._fRound = t2.fRound, this._init_action = t2.init, this._reset_action = t2.reset;\n          break;\n        }\n        case \"audio\":\n          this._source_adapter_getter = t.Getter, this._source_adapter_setter = t.Setter, this._source_adapter_absolute_setter = t.AbsoluteSetter, this._round = !!t.DoesRounding(), this._fRound = false;\n      }\n    }\n    Release() {\n      this._typeAdapter = null, this._instance_getter = null, this._instance_setter = null, this._instance_absolute_setter = null, this._reset_action = null, this._init_action = null, this._source_adapter_getter = null, this._source_adapter_setter = null, this._source_adapter_absolute_setter = null, super.Release();\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return this._typeAdapter.MayNeedBeforeAndAfterInterpolate();\n    }\n    GetLastValue() {\n      return this._lastValue;\n    }\n    SetLastValue(t) {\n      this._lastValue = t;\n    }\n    SetResetState() {\n      this._reset_action && this._reset_action(this);\n    }\n    SetInitialState() {\n      const t = this._typeAdapter.SetInitialState();\n      if (\"number\" == typeof t && (this._lastValue = t), this._init_action) {\n        const t2 = this.GetWorldInfo(), e = this._propertyTrack.GetTrack();\n        this._init_action(this, t2, e);\n      }\n    }\n    SetResumeState() {\n      const t = this._typeAdapter.SetResumeState();\n      \"number\" == typeof t && (this._lastValue = t);\n    }\n    GetCurrentState() {\n      return this._Getter();\n    }\n    CompareInitialStateWithCurrent() {\n      return this._FirstKeyframeGetter() !== this.GetCurrentState();\n    }\n    CompareSaveStateWithCurrent() {\n      return !C33.IsNullOrUndefined(this._saveState) && this._saveState !== this.GetCurrentState();\n    }\n    BeforeChangeProperty() {\n      this._typeAdapter.BeforeChangeProperty();\n    }\n    ChangeProperty(t, e, a, r, i, s, o, n) {\n      return this._typeAdapter.ChangeProperty(t, e, a, r, i, s, o, n);\n    }\n    AfterChangeProperty() {\n      this._typeAdapter.AfterChangeProperty();\n    }\n    _Getter() {\n      const t = this._GetTarget(), e = this._GetIndex(), a = this.GetWorldInfo(), r = this._propertyTrack.GetTrack();\n      switch (this._propertyTrack.GetSourceAdapterId()) {\n        case \"behavior\":\n        case \"plugin\":\n          return t.GetPropertyValueByIndex(e);\n        case \"effect\":\n          return t[e];\n        case \"instance-variable\":\n          return t.GetInstanceVariableValue(e);\n        case \"world-instance\":\n          return this._instance_getter(a, r);\n        case \"audio\":\n          return this._source_adapter_getter.call(this.GetSourceAdapter(), a, r);\n      }\n    }\n    _Setter(t, e, a, r = true) {\n      const i = this._GetTarget(), s = this._GetIndex(), o = this.GetWorldInfo(), n = this._propertyTrack.GetTrack();\n      switch (this._propertyTrack.GetSourceAdapterId()) {\n        case \"behavior\":\n          i.OffsetPropertyValueByIndex(s, t);\n          break;\n        case \"effect\":\n          i[s] += t;\n          break;\n        case \"instance-variable\":\n          i.SetInstanceVariableOffset(s, t);\n          break;\n        case \"plugin\":\n          i.OffsetPropertyValueByIndex(s, t, this.GetSourceAdapter().GetOptionalCallbacks());\n          break;\n        case \"world-instance\":\n          this._instance_setter(o, t, n, this, false, r);\n          break;\n        case \"audio\":\n          this._source_adapter_setter.call(this.GetSourceAdapter(), o, t, n, this);\n      }\n    }\n    _SetterAbsolute(t, e, a) {\n      let r = this._propertyTrack.GetInterpolationMode();\n      if (r = \"default\" === r ? \"continuous\" : r, \"discrete\" === r && !e) return;\n      if (\"discrete\" === r && a) {\n        const t2 = this._propertyTrack.GetTimeline().GetTime();\n        if (!this._propertyTrack.GetPropertyKeyFrameDataItemAtTime(t2)) return;\n      }\n      const i = this._GetTarget(), s = this._GetIndex(), o = this.GetWorldInfo(), n = this._propertyTrack.GetTrack();\n      switch (this._propertyTrack.GetSourceAdapterId()) {\n        case \"behavior\":\n          i.SetPropertyValueByIndex(s, t);\n          break;\n        case \"effect\":\n          i[s] = t;\n          break;\n        case \"instance-variable\":\n          i.SetInstanceVariableValue(s, t);\n          break;\n        case \"plugin\":\n          i.SetPropertyValueByIndex(s, t, this.GetSourceAdapter().GetOptionalCallbacks());\n          break;\n        case \"world-instance\":\n          this._instance_absolute_setter(o, t, n);\n          break;\n        case \"audio\":\n          this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), o, t, n);\n      }\n    }\n    _MaybeEnsureValue(t, e, a, r, i, s, o, n) {\n      this._typeAdapter._MaybeEnsureValue(t, e, a, r, i, s, o, n);\n    }\n    _AddDelta(t, e, a, r, i) {\n      if (\"angle\" === this._propertyTrack.GetPropertyType()) t = C33.toDegrees(t);\n      const s = (t.toString().split(\".\")[1] || \"\").length, o = this._Getter();\n      let n;\n      if (0 === s) if (this._round) n = Math.round(o);\n      else if (this._fRound) if (\"angle\" === this._propertyTrack.GetPropertyType()) n = C33.toRadians(Math.round(C33.toDegrees(o)));\n      else n = Number(C33.toFixed(o, 2));\n      else n = o;\n      else n = this._round ? Number(C33.toFixed(o, s)) : (this._fRound, o);\n      switch (this._Setter(n - o, e, a, false), this._propertyTrack.GetPropertyName()) {\n        case \"offsetWidth\":\n        case \"offsetScaleX\": {\n          const t2 = this.GetWorldInfo(), e2 = t2.GetWidth(), a2 = Number(C33.toFixed(e2, 2));\n          t2.OffsetWidth(a2 - e2);\n          break;\n        }\n        case \"offsetHeight\":\n        case \"offsetScaleY\": {\n          const t2 = this.GetWorldInfo(), e2 = t2.GetHeight(), a2 = Number(C33.toFixed(e2, 2));\n          t2.OffsetHeight(a2 - e2);\n          break;\n        }\n      }\n    }\n    _SaveToJson() {\n      return Object.assign(super._SaveToJson(), { \"v\": this._lastValue, \"a\": this._clampAccumulator, \"fod\": this._totalForewardOpacityDelta, \"bod\": this._totalBackwardOpacityDelta, \"of\": this._opacityFactor, \"sf\": this._absoluteToFactor, \"armorf\": this._angleReflectMirrorOrFlip, \"armandf\": this._angleReflectMirrorAndFlip, \"ca\": this._changeAccumulator, \"os\": this._originalSize, \"awo\": this._absoluteWidthOffset, \"aho\": this._absoluteHeightOffset, \"asxo\": this._absoluteScaleXOffset, \"asyo\": this._absoluteScaleYOffset });\n    }\n    _LoadFromJson(t) {\n      t && (super._LoadFromJson(t), this._lastValue = t[\"v\"], this._clampAccumulator = t[\"a\"], this._totalForewardOpacityDelta = C33.IsFiniteNumber(t[\"fod\"]) ? t[\"fod\"] : 0, this._totalBackwardOpacityDelta = C33.IsFiniteNumber(t[\"bod\"]) ? t[\"bod\"] : 0, this._opacityFactor = C33.IsFiniteNumber(t[\"of\"]) ? t[\"of\"] : NaN, this._absoluteToFactor = C33.IsFiniteNumber(t[\"sf\"]) ? t[\"sf\"] : NaN, this._angleReflectMirrorOrFlip = C33.IsFiniteNumber(t[\"armorf\"]) ? t[\"armorf\"] : void 0, this._angleReflectMirrorAndFlip = C33.IsFiniteNumber(t[\"armandf\"]) ? t[\"armandf\"] : void 0, this._changeAccumulator = C33.IsFiniteNumber(t[\"ca\"]) ? t[\"ca\"] : 0, this._originalSize = C33.IsFiniteNumber(t[\"os\"]) ? t[\"os\"] : NaN, this._absoluteWidthOffset = C33.IsFiniteNumber(t[\"awo\"]) ? t[\"awo\"] : 0, this._absoluteHeightOffset = C33.IsFiniteNumber(t[\"aho\"]) ? t[\"aho\"] : 0, this._absoluteScaleXOffset = C33.IsFiniteNumber(t[\"asxo\"]) ? t[\"asxo\"] : 0, this._absoluteScaleYOffset = C33.IsFiniteNumber(t[\"asyo\"]) ? t[\"asyo\"] : 0);\n    }\n    SetOriginalSizeProperty(t) {\n      this._originalSize = t;\n    }\n    GetChangeAccumulatorProperty() {\n      return this._changeAccumulator;\n    }\n    GetAbsoluteWidthOffsetProperty() {\n      return this._absoluteWidthOffset;\n    }\n    GetAbsoluteHeightOffsetProperty() {\n      return this._absoluteHeightOffset;\n    }\n    GetAbsoluteScaleXOffsetProperty() {\n      return this._absoluteScaleXOffset;\n    }\n    GetAbsoluteScaleYOffsetProperty() {\n      return this._absoluteScaleYOffset;\n    }\n  }\n  C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = NumericInterpolationAdapter;\n}\n{\n  const C33 = self.C3;\n  class AbsoluteValueObject {\n    constructor(e) {\n      this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false, this._propertyTracks = e;\n      for (let e2 = 0, t = this._propertyTracks.length; e2 < t; e2++) this._propertyTracks[e2].SetAbsoluteValueObject(this);\n    }\n    GetPropertyTracks() {\n      return this._propertyTracks;\n    }\n    SetUsed() {\n      this._used = true;\n    }\n    GetUsed() {\n      return this._used;\n    }\n    SetValue(e) {\n      this._value = e;\n    }\n    GetValue() {\n      return this._value;\n    }\n    SetPropertyKeyframeReached(e) {\n      this._propertyKeyframeReached = e;\n    }\n    GetPropertyKeyframeReached() {\n      return this._propertyKeyframeReached;\n    }\n    SetEndState(e) {\n      this._endState = e;\n    }\n    GetEndState() {\n      return this._endState;\n    }\n    Reset() {\n      this._used = false, this._value = 0, this._propertyKeyframeReached = false, this._endState = false;\n    }\n  }\n  class NumericInterpolationAdapterForTimeline {\n    constructor(e) {\n      this._numericInterpolationAdapter = e;\n    }\n    Release() {\n      this._numericInterpolationAdapter = null;\n    }\n    GetType() {\n      return 0;\n    }\n    SetInitialState() {\n      const e = this._numericInterpolationAdapter;\n      this._numericInterpolationAdapter.GetPropertyTrack();\n      return e._PickResultMode(() => e._PickTimelinePlaybackMode(() => 0, () => e.GetSourceAdapter().GetValueAtTime()), () => {\n      });\n    }\n    SetResumeState() {\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      this._numericInterpolationAdapter;\n      switch (this._numericInterpolationAdapter.GetPropertyTrack().GetResultMode()) {\n        case \"relative\":\n          return false;\n        case \"absolute\":\n          return true;\n      }\n    }\n    BeforeChangeProperty() {\n      this._numericInterpolationAdapter;\n      const e = this._numericInterpolationAdapter.GetPropertyTrack(), t = e.GetPropertyName();\n      switch (e.GetResultMode()) {\n        case \"relative\":\n          break;\n        case \"absolute\":\n          if (e.HasAbsoluteValueObject()) {\n            e.GetAbsoluteValueObject().Reset();\n          } else {\n            const r = e.GetTimeline(), a = e.GetInstance(), s = e.GetSourceAdapter(), o = r.GetSimilarPropertyTracks(a, s, t, e);\n            o && o.length > 1 && new AbsoluteValueObject(o);\n          }\n      }\n    }\n    ChangeProperty(e, t, r, a, s, o, i, n) {\n      const l = this._numericInterpolationAdapter, u = this._numericInterpolationAdapter.GetPropertyTrack();\n      switch (u.GetResultMode()) {\n        case \"relative\": {\n          const i2 = l.GetLastValue();\n          l._Setter(t - i2, r, a), o && this._MaybeEnsureValue(e, r, a, s, i2, t), l.SetLastValue(t);\n          break;\n        }\n        case \"absolute\": {\n          const e2 = u.GetTimeline(), r2 = u.GetTrack();\n          u.GetInstance(), u.GetSourceAdapter();\n          if (u.HasAbsoluteValueObject()) {\n            const a2 = u.GetAbsoluteValueObject(), s2 = a2.GetPropertyTracks(), o2 = l._GetPropertyKeyframeStubs(s2, true), c = l._GetLastPropertyKeyframeStub(e2, e2.GetTime(), o2);\n            if (c) {\n              const e3 = r2.GetStartOffset(), s3 = c.time - e3;\n              if (0 === s3) a2.SetEndState(i), a2.SetPropertyKeyframeReached(n), a2.SetUsed(), a2.SetValue(a2.GetValue() + t);\n              else {\n                if (s3 < 0) return;\n                const e4 = u.GetInterpolatedValue(s3);\n                a2.SetEndState(i), a2.SetPropertyKeyframeReached(n), a2.SetUsed(), a2.SetValue(a2.GetValue() + (t - e4));\n              }\n            }\n          } else l._SetterAbsolute(t, n, i);\n          break;\n        }\n      }\n    }\n    AfterChangeProperty() {\n      const e = this._numericInterpolationAdapter, t = this._numericInterpolationAdapter.GetPropertyTrack();\n      switch (t.GetResultMode()) {\n        case \"relative\":\n          break;\n        case \"absolute\":\n          if (t.HasAbsoluteValueObject()) {\n            const r = t.GetAbsoluteValueObject();\n            r.GetUsed() && e._SetterAbsolute(r.GetValue(), r.GetPropertyKeyframeReached(), r.GetEndState());\n          }\n      }\n    }\n    _MaybeEnsureValue(e, t, r, a, s, o) {\n      const i = this._numericInterpolationAdapter;\n      a || (t && e === t.GetTime() ? i._AddDelta(t.GetValueWithResultMode(), t, r) : r && e === r.GetTime() ? i._AddDelta(r.GetValueWithResultMode(), t, r) : o - s == 0 && i._AddDelta(t.GetValueWithResultMode(), t, r));\n    }\n  }\n  C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = NumericInterpolationAdapterForTimeline;\n}\n{\n  const C33 = self.C3;\n  class NumericInterpolationAdapterForTween {\n    constructor(e) {\n      this._numericInterpolationAdapter = e;\n    }\n    Release() {\n      this._numericInterpolationAdapter = null;\n    }\n    GetType() {\n      return 1;\n    }\n    SetInitialState() {\n      const e = this._numericInterpolationAdapter;\n      return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._FirstKeyframeGetter());\n    }\n    SetResumeState() {\n      const e = this._numericInterpolationAdapter;\n      if (e._FirstKeyframeGetter() !== e._CurrentKeyframeGetter()) return e.SetFirstAbsoluteUpdate(true), this._GetAbsoluteInitialValue(e._CurrentKeyframeGetter());\n    }\n    MayNeedBeforeAndAfterInterpolate() {\n      return false;\n    }\n    BeforeChangeProperty() {\n    }\n    ChangeProperty(e, t, r, a, n, i, o, l) {\n      const s = this._numericInterpolationAdapter, u = s.GetLastValue();\n      switch (s.GetPropertyTrack().GetResultMode()) {\n        case \"relative\":\n          s._Setter(t - u, r, a), i && this._MaybeEnsureValue(e, r, a, n, u, t, false, o);\n          break;\n        case \"absolute\":\n          s.GetFirstAbsoluteUpdate() ? (s.SetFirstAbsoluteUpdate(false), s._Setter(u, r, a)) : 0 === e && 0 === s.GetPropertyTrack().GetTimeline().GetTotalTime() ? s._SetterAbsolute(t, true, false) : (s._Setter(t - u, r, a), i && this._MaybeEnsureValue(e, r, a, n, u, t, this._ForceEndValue(), o));\n      }\n      s.SetLastValue(t);\n    }\n    AfterChangeProperty() {\n    }\n    _GetAbsoluteInitialValue(e) {\n      return e - this._numericInterpolationAdapter.GetCurrentState();\n    }\n    _ForceEndValue() {\n      const e = this._numericInterpolationAdapter, t = e.GetWorldInfo().GetInstance(), r = e.GetPropertyTrack().GetRuntime().GetTimelineManager();\n      let a = 0;\n      for (const e2 of r.GetPlayingTimelines()) 0 === e2.GetType() ? e2.HasTrackInstance(t) && a++ : 1 === e2.GetType() && e2.GetInstance() === t && a++;\n      return a <= 1;\n    }\n    _MaybeEnsureValue(e, t, r, a, n, i, o, l) {\n      const s = this._numericInterpolationAdapter;\n      a ? t && e === t.GetTime() ? s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : r && e === r.GetTime() ? s._AddDelta(r.GetValueWithResultMode(), t, r, o, l) : r || s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : t && e === t.GetTime() ? s._AddDelta(t.GetValueWithResultMode(), t, r, o, l) : r && e === r.GetTime() ? s._AddDelta(r.GetValueWithResultMode(), t, r, o, l) : i - n == 0 && s._AddDelta(t.GetValueWithResultMode(), t, r, o, l);\n    }\n  }\n  C33.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = NumericInterpolationAdapterForTween;\n}\n{\n  const C33 = self.C3, Ease = self.Ease;\n  C33.PropertyTrackState.NumericTypeAdapter = class {\n    constructor() {\n    }\n    static WillChange(e, t, a, r) {\n      let s;\n      switch (r) {\n        case \"behavior\":\n        case \"plugin\":\n          s = t.GetPropertyValueByIndex(e);\n          break;\n        case \"effect\":\n          s = t[e];\n          break;\n        case \"instance-variable\":\n          s = t.GetInstanceVariableValue(e);\n      }\n      return s !== a;\n    }\n    static Interpolate(e, t, a, r) {\n      if (!a) {\n        let e2 = r.GetPropertyTrackDataItem();\n        return e2 = r.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode();\n      }\n      let s = r.GetInterpolationMode();\n      if (\"default\" === s && (s = \"continuous\"), \"combo\" === r.GetPropertyType() && (s = \"discrete\"), \"discrete\" === s) return t.GetValueWithResultMode();\n      if (\"continuous\" === s || \"step\" === s) {\n        const n = r.GetTimeline().GetStep();\n        if (\"step\" === s && 0 !== n) {\n          const t2 = 1 / n;\n          e = Math.floor(e * t2) / t2;\n        }\n        const i = t.GetValueWithResultMode(), c = a.GetValueWithResultMode(), o = t.GetAddOn(\"cubic-bezier\"), l = a.GetAddOn(\"cubic-bezier\"), u = o && o.GetStartEnable() && l && l.GetEndEnable();\n        if (!u && i === c) return i;\n        const G = t.GetTime(), p = a.GetTime();\n        \"step\" === s && 0 !== n && (e = C33.clamp(e, G, p));\n        const d = C33.normalize(e, G, p), b = t.GetEase();\n        let f;\n        if (u) {\n          const e2 = p - G;\n          f = Ease.GetRuntimeEase(b)(e2 * d, 0, 1, e2), f = Ease.GetRuntimeEase(\"cubicbezier\")(f, i, i + o.GetStartAnchor(), c + l.GetEndAnchor(), c);\n        } else f = Ease.GetRuntimeEase(b)((p - G) * d, i, c - i, p - G);\n        return \"integer\" === r.GetPropertyType() ? Math.floor(f) : f;\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.PropertyTrackState.AngleTypeAdapter = class {\n    constructor() {\n    }\n    static WillChange(e, t, a, r) {\n      let s;\n      switch (r) {\n        case \"behavior\":\n        case \"plugin\":\n          s = t.GetPropertyValueByIndex(e);\n          break;\n        case \"effect\":\n          s = t[e];\n          break;\n        case \"instance-variable\":\n          s = t.GetInstanceVariableValue(e);\n      }\n      return s !== a;\n    }\n    static Interpolate(e, t, a, r) {\n      if (!a) {\n        let e2 = r.GetPropertyTrackDataItem();\n        return e2 = r.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode();\n      }\n      let s = r.GetInterpolationMode();\n      if (\"default\" === s && (s = \"continuous\"), \"combo\" === r.GetPropertyType() && (s = \"discrete\"), \"discrete\" === s) return t.GetValueWithResultMode();\n      if (\"continuous\" === s || \"step\" === s) {\n        const n = r.GetTimeline().GetStep();\n        if (\"step\" === s && 0 !== n) {\n          const t2 = 1 / n;\n          e = Math.floor(e * t2) / t2;\n        }\n        const i = t.GetTime(), o = a.GetTime(), c = t.GetValueWithResultMode(), l = a.GetValueWithResultMode();\n        \"step\" === s && 0 !== n && (e = C33.clamp(e, i, o));\n        const u = t.GetAddOn(\"angle\");\n        if (!u) {\n          if (c === l) return c;\n          const a2 = C33.normalize(e, i, o), r2 = self.Ease.GetRuntimeEase(t.GetEase());\n          return C33.angleLerp(c, l, r2(a2, 0, 1, 1));\n        }\n        {\n          const a2 = u.GetRevolutions();\n          if (c === l && 0 === a2) return c;\n          const r2 = C33.normalize(e, i, o), s2 = self.Ease.GetRuntimeEase(t.GetEase())(r2, 0, 1, 1);\n          switch (u.GetDirection()) {\n            case \"closest\":\n              return C33.angleLerp(c, l, s2, a2);\n            case \"clockwise\":\n              return C33.angleLerpClockwise(c, l, s2, a2);\n            case \"anti-clockwise\":\n              return C33.angleLerpAntiClockwise(c, l, s2, a2);\n          }\n        }\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.PropertyTrackState.BooleanTypeAdapter = class {\n    constructor() {\n    }\n    static WillChange(e, t, a, r) {\n      let c;\n      switch (r) {\n        case \"behavior\":\n        case \"plugin\":\n          c = t.GetPropertyValueByIndex(e);\n          break;\n        case \"effect\":\n          c = t[e];\n          break;\n        case \"instance-variable\":\n          c = t.GetInstanceVariableValue(e);\n      }\n      return !!c != !!a;\n    }\n    static Interpolate(e, t, a, r) {\n      if (!a) {\n        let e2 = r.GetPropertyTrackDataItem();\n        return e2 = r.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode() ? 1 : 0;\n      }\n      return t.GetValueWithResultMode() ? 1 : 0;\n    }\n  };\n}\n{\n  const C33 = self.C3, TEMP_COLOR_ARRAY = [0, 0, 0], TEMP_COLOR_ARRAY_2 = [0, 0, 0], TEMP_COLOR_ARRAY_3 = [0, 0, 0];\n  C33.PropertyTrackState.ColorTypeAdapter = class {\n    constructor() {\n    }\n    static WillChange(R, _, e, t) {\n      let A;\n      switch (t) {\n        case \"behavior\":\n        case \"plugin\":\n          A = _.GetPropertyValueByIndex(R);\n          break;\n        case \"effect\":\n          A = _[R];\n          break;\n        case \"instance-variable\":\n          A = _.GetInstanceVariableValue(R);\n      }\n      return Array.isArray(e) ? (TEMP_COLOR_ARRAY[0] = e[0], TEMP_COLOR_ARRAY[1] = e[1], TEMP_COLOR_ARRAY[2] = e[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(e), TEMP_COLOR_ARRAY[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), Array.isArray(A) ? (TEMP_COLOR_ARRAY_2[0] = A[0], TEMP_COLOR_ARRAY_2[1] = A[1], TEMP_COLOR_ARRAY_2[2] = A[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(A), TEMP_COLOR_ARRAY_2[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY_2[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY_2[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB())), TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0] || (TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1] || TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2]);\n    }\n    static Interpolate(R, _, e, t) {\n      if (!e) {\n        let R2 = t.GetPropertyTrackDataItem();\n        R2 = t.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(R2);\n        const _2 = R2.GetValueWithResultMode();\n        return TEMP_COLOR_ARRAY[0] = _2[0], TEMP_COLOR_ARRAY[1] = _2[1], TEMP_COLOR_ARRAY[2] = _2[2], TEMP_COLOR_ARRAY;\n      }\n      let A = t.GetInterpolationMode();\n      if (\"default\" === A && (A = \"continuous\"), \"discrete\" === A) {\n        const R2 = _.GetValueWithResultMode();\n        return TEMP_COLOR_ARRAY[0] = R2[0], TEMP_COLOR_ARRAY[1] = R2[1], TEMP_COLOR_ARRAY[2] = R2[2], TEMP_COLOR_ARRAY;\n      }\n      if (\"continuous\" === A || \"step\" === A) {\n        const O = t.GetTimeline().GetStep();\n        if (\"step\" === A && 0 !== O) {\n          const _2 = 1 / O;\n          R = Math.floor(R * _2) / _2;\n        }\n        const a = _.GetTime(), r = e.GetTime(), M = _.GetValueWithResultMode(), C = e.GetValueWithResultMode();\n        \"step\" === A && 0 !== O && (R = C33.clamp(R, a, r));\n        const T = C33.normalize(R, a, r), o = _.GetEase(), P = M[0], E = M[1], L = M[2], Y = C[0], s = C[1], l = C[2], i = self.Ease.GetRuntimeEase(o), n = r - a, c = n * T;\n        return TEMP_COLOR_ARRAY[0] = P === Y ? P : i(c, P, Y - P, n), TEMP_COLOR_ARRAY[1] = E === s ? E : i(c, E, s - E, n), TEMP_COLOR_ARRAY[2] = L === l ? L : i(c, L, l - L, n), TEMP_COLOR_ARRAY;\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.PropertyTrackState.TextTypeAdapter = class {\n    constructor() {\n    }\n    static WillChange(e, t, a, r) {\n      let c;\n      switch (r) {\n        case \"behavior\":\n        case \"plugin\":\n          c = t.GetPropertyValueByIndex(e);\n          break;\n        case \"effect\":\n          c = t[e];\n          break;\n        case \"instance-variable\":\n          c = t.GetInstanceVariableValue(e);\n      }\n      return c !== a;\n    }\n    static Interpolate(e, t, a, r) {\n      if (!a) {\n        let e2 = r.GetPropertyTrackDataItem();\n        return e2 = r.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e2), e2.GetValueWithResultMode();\n      }\n      return t.GetValueWithResultMode();\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.TimelineDataManager = class {\n    constructor() {\n      this._timelineDataItems = /* @__PURE__ */ new Map();\n    }\n    Release() {\n      for (const e of this._timelineDataItems.values()) e.Release();\n      this._timelineDataItems.clear(), this._timelineDataItems = null;\n    }\n    Add(e) {\n      const a = new C33.TimelineDataItem(e), t = a.GetName();\n      this._timelineDataItems.set(t, a);\n    }\n    Get(e) {\n      return this._timelineDataItems.get(e);\n    }\n    GetNameId() {\n      return 0;\n    }\n    static _CreateDataItems(e, a, t, s) {\n      if (a) for (const i of a) C33.TimelineDataManager._CreateDataItem(\"create\", i, e, t, s);\n    }\n    static _CreateDataItemsIncludingDisabled(e, a, t, s) {\n      if (a) for (const i of a) C33.TimelineDataManager._CreateDataItem(\"create-including-disabled\", i, e, t, s);\n    }\n    static _LoadDataItemsFromJson(e, a, t, s) {\n      e.length ? a.forEach((a2, t2) => {\n        e[t2]._LoadFromJson(a2);\n      }) : a.forEach((a2) => {\n        C33.TimelineDataManager._CreateDataItem(\"load\", a2, e, t, s);\n      });\n    }\n    static _CreateDataItem(e, a, t, s, i) {\n      let n;\n      if (\"function\" == typeof s) switch (e) {\n        case \"load\":\n          n = new s(null, i);\n          break;\n        case \"create\":\n        case \"create-including-disabled\":\n          n = new s(a, i);\n      }\n      else if (\"object\" == typeof s) {\n        const t2 = a[s.prop], c = s.map.get(t2);\n        switch (e) {\n          case \"load\":\n            n = new c(null, i);\n            break;\n          case \"create\":\n          case \"create-including-disabled\":\n            n = new c(a, i);\n        }\n      }\n      switch (e) {\n        case \"load\":\n          n._LoadFromJson(a), t.push(n);\n          break;\n        case \"create\":\n          if (\"function\" == typeof n.GetEnable && !n.GetEnable()) return n.Release();\n          t.push(n);\n          break;\n        case \"create-including-disabled\":\n          t.push(n);\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3, NAME = 0, TOTAL_TIME = 1, STEP = 2, INTERPOLATION_MODE = 3, RESULT_MODE = 4, TRACKS = 5, LOOP = 6, PING_PONG = 7, REPEAT_COUNT = 8, START_ON_LAYOUT = 9, TRANSFORM_WITH_SCENE_GRAPH = 10, USE_SYSTEM_TIMESCALE = 11;\n  C33.TimelineDataItem = class {\n    constructor(t) {\n      this._name = \"\", this._totalTime = NaN, this._step = 0, this._interpolationMode = \"default\", this._resultMode = \"default\", this._loop = false, this._pingPong = false, this._repeatCount = 1, this._trackData = null, this._startOnLayout = \"\", this._transformWithSceneGraph = false, this._useSystemTimescale = true, t && (this._name = t[0], this._totalTime = t[1], this._step = t[2], this._interpolationMode = t[3], this._resultMode = t[4], this._loop = !!t[6], this._pingPong = !!t[7], this._repeatCount = t[8], this._startOnLayout = t[9], this._transformWithSceneGraph = !!t[10], this._useSystemTimescale = !!t[11], this._trackData = new C33.TrackData(t[5], this));\n    }\n    Release() {\n      this._trackData.Release(), this._trackData = null;\n    }\n    GetTrackData() {\n      return this._trackData || (this._trackData = new C33.TrackData(null, this)), this._trackData;\n    }\n    GetName() {\n      return this._name;\n    }\n    SetName(t) {\n      this._name = t;\n    }\n    GetTotalTime() {\n      return this._totalTime;\n    }\n    SetTotalTime(t) {\n      this._totalTime = t;\n    }\n    GetStep() {\n      return this._step;\n    }\n    SetStep(t) {\n      this._step = t;\n    }\n    GetInterpolationMode() {\n      return this._interpolationMode;\n    }\n    SetInterpolationMode(t) {\n      this._interpolationMode = t;\n    }\n    GetResultMode() {\n      return this._resultMode;\n    }\n    SetResultMode(t) {\n      this._resultMode = t;\n    }\n    GetLoop() {\n      return this._loop;\n    }\n    SetLoop(t) {\n      this._loop = t;\n    }\n    GetPingPong() {\n      return this._pingPong;\n    }\n    SetPingPong(t) {\n      this._pingPong = t;\n    }\n    GetRepeatCount() {\n      return this._repeatCount;\n    }\n    SetRepeatCount(t) {\n      this._repeatCount = t;\n    }\n    GetStartOnLayout() {\n      return this._startOnLayout;\n    }\n    GetTransformWithSceneGraph() {\n      return this._transformWithSceneGraph;\n    }\n    GetUseSystemTimescale() {\n      return this._useSystemTimescale;\n    }\n    _SaveToJson() {\n      return { \"trackDataJson\": this._trackData._SaveToJson(), \"name\": this._name, \"totalTime\": this._totalTime, \"step\": this._step, \"interpolationMode\": this._interpolationMode, \"resultMode\": this._resultMode, \"loop\": this._loop, \"pingPong\": this._pingPong, \"repeatCount\": this._repeatCount, \"startOnLayout\": this._startOnLayout, \"transformWithSceneGraph\": !!this._transformWithSceneGraph, \"useSystemTimescale\": this._useSystemTimescale };\n    }\n    _LoadFromJson(t) {\n      t && (this.GetTrackData()._LoadFromJson(t[\"trackDataJson\"]), this._name = t[\"name\"], this._totalTime = t[\"totalTime\"], this._step = t[\"step\"], this._interpolationMode = t[\"interpolationMode\"], this._resultMode = t[\"resultMode\"], this._loop = t[\"loop\"], this._pingPong = t[\"pingPong\"], this._repeatCount = t[\"repeatCount\"], this._startOnLayout = t[\"startOnLayout\"], this._transformWithSceneGraph = !!t[\"transformWithSceneGraph\"], this._useSystemTimescale = !!t[\"useSystemTimescale\"]);\n    }\n  };\n}\n{\n  const C33 = self.C3, WI_DATA = 0, OC_INDEX = 1, WI_UID = 2, INTERPOLATION_MODE = 1, RESULT_MODE = 2, ENABLED = 3, KEYFRAMES = 4, PROPERTY_TRACKS = 5, ID = 6, NESTED_DATA = 7, START_OFFSET = 0, LOCAL_TOTAL_TIME = 1, WI_ADDITIONAL_DATA = 8, ORIGINAL_WIDTH = 0, ORIGINAL_HEIGHT = 1, TRACK_TYPE = 9, TRACK_NAME = 10;\n  class TrackDataItem {\n    constructor(t, a) {\n      this._trackData = a, this._instanceData = null, this._additionalInstanceData = null, this._instanceUid = NaN, this._objectClassIndex = NaN, this._interpolationMode = \"default\", this._resultMode = \"default\", this._enabled = false, this._keyframeData = null, this._propertyTrackData = null, this._id = \"\", this._nestedData = null, this._startOffset = 0, this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), this._type = 0, this._name = \"\", t && (t[0] && (this._instanceData = t[0], this._instanceUid = t[0][2], this._objectClassIndex = t[0][1]), this._interpolationMode = t[1], this._resultMode = t[2], this._enabled = !!t[3], t[6] && (this._id = t[6]), t[7] && (this._nestedData = t[7], this._startOffset = t[7][0], this._localTotalTime = t[7][1]), t[8] && (this._additionalInstanceData = t[8]), t[8] && (this._additionalInstanceData = t[8]), t[9] && (this._type = t[9]), t[10] && (this._name = t[10]), this._keyframeData = new C33.KeyframeData(t[4], this), this._propertyTrackData = new C33.PropertyTrackData(t[5], this));\n    }\n    Release() {\n      this._instanceData = null, this._trackData = null, this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null), this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData = null), this._nestedData = null;\n    }\n    GetTrackData() {\n      return this._trackData;\n    }\n    GetKeyframeData() {\n      return this._keyframeData || (this._keyframeData = new C33.KeyframeData(null, this)), this._keyframeData;\n    }\n    GetPropertyTrackData() {\n      return this._propertyTrackData || (this._propertyTrackData = new C33.PropertyTrackData(null, this)), this._propertyTrackData;\n    }\n    GetInstanceData() {\n      return this._instanceData;\n    }\n    GetObjectClassIndex() {\n      return this._objectClassIndex;\n    }\n    SetObjectClassIndex(t) {\n      this._objectClassIndex = t;\n    }\n    GetInstanceUID() {\n      return this._instanceUid;\n    }\n    SetInstanceUID(t) {\n      this._instanceUid = t;\n    }\n    GetInterpolationMode() {\n      return this._interpolationMode;\n    }\n    SetInterpolationMode(t) {\n      this._interpolationMode = t;\n    }\n    GetResultMode() {\n      return this._resultMode;\n    }\n    SetResultMode(t) {\n      this._resultMode = t;\n    }\n    GetEnable() {\n      return this._enabled;\n    }\n    SetEnable(t) {\n      this._enabled = !!t;\n    }\n    GetId() {\n      return this._id;\n    }\n    GetStartOffset() {\n      return this._startOffset;\n    }\n    GetLocalTotalTime() {\n      return this._localTotalTime;\n    }\n    SetLocalTotalTime(t) {\n      this._localTotalTime = t;\n    }\n    GetOriginalWidth() {\n      return this._additionalInstanceData[0];\n    }\n    SetOriginalWidth(t) {\n      this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[0] = t;\n    }\n    GetOriginalHeight() {\n      return this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[1];\n    }\n    SetOriginalHeight(t) {\n      this._additionalInstanceData || (this._additionalInstanceData = []), this._additionalInstanceData[1] = t;\n    }\n    GetType() {\n      return this._type;\n    }\n    GetName() {\n      return this._name;\n    }\n    _SaveToJson() {\n      return { \"keyframeDataJson\": this._keyframeData._SaveToJson(), \"propertyTrackDataJson\": this._propertyTrackData._SaveToJson(), \"instanceData\": this._instanceData, \"additionalInstanceData\": this._additionalInstanceData, \"instanceUid\": this._instanceUid, \"objectClassIndex\": this._objectClassIndex, \"interpolationMode\": this._interpolationMode, \"resultMode\": this._resultMode, \"enabled\": this._enabled, \"id\": this._id, \"nestedData\": this._nestedData, \"type\": this._type, \"name\": this._name };\n    }\n    _LoadFromJson(t) {\n      t && (this._instanceData = t[\"instanceData\"], this._instanceUid = t[\"instanceUid\"], this._objectClassIndex = t[\"objectClassIndex\"], this._interpolationMode = t[\"interpolationMode\"], this._resultMode = t[\"resultMode\"], this._enabled = t[\"enabled\"], this._id = t[\"id\"], this._type = t[\"type\"] ? t[\"type\"] : 0, this._name = t[\"name\"] ? t[\"name\"] : \"\", this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), t[\"nestedData\"] && (this._nestedData = t[\"nestedData\"], this._startOffset = this._nestedData[0], this._localTotalTime = this._nestedData[1]), t[\"additionalInstanceData\"] && (this._additionalInstanceData = t[\"additionalInstanceData\"]), this.GetKeyframeData()._LoadFromJson(t[\"keyframeDataJson\"]), this.GetPropertyTrackData()._LoadFromJson(t[\"propertyTrackDataJson\"]));\n    }\n  }\n  C33.TrackData = class {\n    constructor(t, a) {\n      this._timelineDataItem = a, this._trackDataItems = [], C33.TimelineDataManager._CreateDataItems(this._trackDataItems, t, TrackDataItem, this);\n    }\n    Release() {\n      this._timelineDataItem = null;\n      for (const t of this._trackDataItems) t.Release();\n      C33.clearArray(this._trackDataItems), this._trackDataItems = null;\n    }\n    GetTimelineDataItem() {\n      return this._timelineDataItem;\n    }\n    AddEmptyTrackDataItem() {\n      const t = new TrackDataItem(null, this);\n      return this._trackDataItems.push(t), t;\n    }\n    GetFirstKeyframeDataItem(t) {\n      return t.GetKeyframeData().GetKeyframeDataItemArray()[0];\n    }\n    GetLastKeyframeDataItem(t) {\n      return t.GetKeyframeData().GetKeyframeDataItemArray().at(-1);\n    }\n    GetKeyFrameDataItemAtTime(t, a) {\n      const e = a.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;\n      for (let a2 = 0; a2 < s; a2++) {\n        const s2 = e[a2];\n        if (s2.GetTime() === t) return s2;\n      }\n    }\n    GetFirstKeyFrameDataItemHigherThan(t, a) {\n      const e = a.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;\n      for (let a2 = 0; a2 < s; a2++) {\n        const s2 = e[a2];\n        if (s2.GetTime() > t) return s2;\n      }\n    }\n    GetFirstKeyFrameDataItemHigherOrEqualThan(t, a) {\n      const e = a.GetKeyframeData().GetKeyframeDataItemArray(), s = e.length;\n      for (let a2 = 0; a2 < s; a2++) {\n        const s2 = e[a2];\n        if (s2.GetTime() >= t) return s2;\n      }\n    }\n    GetFirstKeyFrameDataItemLowerOrEqualThan(t, a) {\n      const e = a.GetKeyframeData().GetKeyframeDataItemArray();\n      for (let a2 = e.length - 1; a2 >= 0; a2--) {\n        const s = e[a2];\n        if (s.GetTime() <= t) return s;\n      }\n    }\n    *trackDataItems() {\n      for (const t of this._trackDataItems) yield t;\n    }\n    _SaveToJson() {\n      return { \"trackDataItemsJson\": this._trackDataItems.map((t) => t._SaveToJson()) };\n    }\n    _LoadFromJson(t) {\n      t && C33.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, t[\"trackDataItemsJson\"], TrackDataItem, this);\n    }\n  };\n}\n{\n  const C33 = self.C3, SOURCE_DATA = 0, SOURCE = 0, PROPERTY = 1, TYPE = 2, MIN = 3, MAX = 4, INTERPOLATION_MODE = 5, RESULT_MODE = 6, ENABLED = 7, PROPERTY_KEYFRAMES = 8, CAN_HAVE_PROPERTY_KEYFRAMES = 9;\n  class PropertyTrackDataItem {\n    constructor(t, e) {\n      this._propertyTrackData = e, this._sourceAdapterId = \"\", this._sourceAdapterArguments = null, this._property = null, this._type = null, this._min = NaN, this._max = NaN, this._interpolationMode = \"default\", this._resultMode = \"default\", this._enabled = false, this._propertyKeyframeData = null, this._canHavePropertyKeyframes = true, t && (this._sourceAdapterId = t[0][0], this._sourceAdapterArguments = t[0].slice(1), this._property = t[1], this._type = t[2], this._min = t[3], this._max = t[4], this._interpolationMode = t[5], this._resultMode = t[6], this._enabled = !!t[7], this._propertyKeyframeData = new C33.PropertyKeyframeData(t[8], this), this._canHavePropertyKeyframes = t[9]);\n    }\n    Release() {\n      this._propertyKeyframeData.Release(), this._propertyKeyframeData = null, this._propertyTrackData = null, this._sourceAdapterArguments = null;\n    }\n    GetPropertyTrackData() {\n      return this._propertyTrackData;\n    }\n    GetPropertyKeyframeData() {\n      return this._propertyKeyframeData || (this._propertyKeyframeData = new C33.PropertyKeyframeData(null, this)), this._propertyKeyframeData;\n    }\n    GetSourceAdapterId() {\n      return this._sourceAdapterId;\n    }\n    SetSourceAdapterId(t) {\n      this._sourceAdapterId = t;\n    }\n    GetSourceAdapterArguments() {\n      return this._sourceAdapterArguments;\n    }\n    SetSourceAdapterArguments(t) {\n      this._sourceAdapterArguments = t;\n    }\n    GetProperty() {\n      return this._property;\n    }\n    SetProperty(t) {\n      this._property = t;\n    }\n    GetType() {\n      return this._type;\n    }\n    SetType(t) {\n      this._type = t;\n    }\n    GetMin() {\n      return this._min;\n    }\n    SetMin(t) {\n      this._min = t;\n    }\n    GetMax() {\n      return this._max;\n    }\n    SetMax(t) {\n      this._max = t;\n    }\n    GetInterpolationMode() {\n      return this._interpolationMode;\n    }\n    SetInterpolationMode(t) {\n      this._interpolationMode = t;\n    }\n    GetResultMode() {\n      return this._resultMode;\n    }\n    SetResultMode(t) {\n      this._resultMode = t;\n    }\n    GetEnable() {\n      return this._enabled;\n    }\n    SetEnable(t) {\n      this._enabled = !!t;\n    }\n    CanHavePropertyKeyframes() {\n      return !!this._canHavePropertyKeyframes;\n    }\n    _SaveToJson() {\n      return { \"propertyKeyframeDataJson\": this._propertyKeyframeData._SaveToJson(), \"sourceAdapterId\": this._sourceAdapterId, \"sourceAdapterArguments\": this._sourceAdapterArguments, \"property\": this._property, \"type\": this._type, \"min\": this._min, \"max\": this._max, \"interpolationMode\": this._interpolationMode, \"resultMode\": this._resultMode, \"enabled\": this._enabled, \"canHavePropertyKeyframes\": this._canHavePropertyKeyframes };\n    }\n    _LoadFromJson(t) {\n      t && (this._sourceAdapterId = t[\"sourceAdapterId\"], this._sourceAdapterArguments = t[\"sourceAdapterArguments\"], this._property = t[\"property\"], this._type = t[\"type\"], this._min = t[\"min\"], this._max = t[\"max\"], this._interpolationMode = t[\"interpolationMode\"], this._resultMode = t[\"resultMode\"], this._enabled = t[\"enabled\"], this._canHavePropertyKeyframes = t[\"canHavePropertyKeyframes\"], this.GetPropertyKeyframeData()._LoadFromJson(t[\"propertyKeyframeDataJson\"]));\n    }\n  }\n  C33.PropertyTrackData = class {\n    constructor(t, e) {\n      this._trackDataItem = e, this._propertyTrackDataItems = [], C33.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, t, PropertyTrackDataItem, this);\n    }\n    Release() {\n      this._trackDataItem = null;\n      for (const t of this._propertyTrackDataItems) t.Release();\n      C33.clearArray(this._propertyTrackDataItems), this._propertyTrackDataItems = null;\n    }\n    GetTrackDataItem() {\n      return this._trackDataItem;\n    }\n    AddEmptyPropertyTrackDataItem() {\n      const t = new PropertyTrackDataItem(null, this);\n      return this._propertyTrackDataItems.push(t), t;\n    }\n    GetFirstPropertyKeyframeDataItem(t) {\n      return t.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0];\n    }\n    GetLastPropertyKeyframeDataItem(t) {\n      return t.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray().at(-1);\n    }\n    GetPropertyKeyFrameDataItemAtTime(t, e) {\n      const r = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a = r.length;\n      for (let e2 = 0; e2 < a; e2++) {\n        const a2 = r[e2];\n        if (a2.GetTime() === t) return a2;\n      }\n    }\n    GetFirstPropertyKeyFrameDataItemHigherThan(t, e) {\n      const r = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a = r.length;\n      for (let e2 = 0; e2 < a; e2++) {\n        const a2 = r[e2];\n        if (a2.GetTime() > t) return a2;\n      }\n    }\n    GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(t, e) {\n      const r = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(), a = r.length;\n      for (let e2 = 0; e2 < a; e2++) {\n        const a2 = r[e2];\n        if (a2.GetTime() >= t) return a2;\n      }\n    }\n    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, e) {\n      const r = e.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();\n      for (let e2 = r.length - 1; e2 >= 0; e2--) {\n        const a = r[e2];\n        if (a.GetTime() <= t) return a;\n      }\n    }\n    *propertyTrackDataItems() {\n      for (const t of this._propertyTrackDataItems) yield t;\n    }\n    _SaveToJson() {\n      return { \"propertyTrackDataItemsJson\": this._propertyTrackDataItems.map((t) => t._SaveToJson()) };\n    }\n    _LoadFromJson(t) {\n      t && C33.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, t[\"propertyTrackDataItemsJson\"], PropertyTrackDataItem, this);\n    }\n  };\n}\n{\n  const C33 = self.C3, TIME = 0, EASE = 1, ENABLE = 2, TAGS = 3;\n  class KeyframeDataItem {\n    constructor(e, t) {\n      if (this._keyframeData = t, this._time = -1, this._ease = \"noease\", this._enable = false, this._tags = null, this._lowerTags = null, !e) return;\n      this._time = e[0], this._ease = e[1], this._enable = !!e[2];\n      const a = e[3];\n      this._tags = a ? a.split(\" \") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())), this._next = null, this._last = null;\n    }\n    Release() {\n      this._keyframeData = null, C33.clearArray(this._tags), this._tags = null, this._lowerTags.clear(), this._lowerTags = null, this._next = null;\n    }\n    GetKeyframeData() {\n      return this._keyframeData;\n    }\n    GetNext() {\n      return this._next;\n    }\n    SetNext(e) {\n      this._next = e;\n    }\n    GetLast() {\n      return this._last;\n    }\n    SetLast(e) {\n      this._last = e;\n    }\n    GetTime() {\n      return this._time;\n    }\n    SetTime(e) {\n      this._time = e, this._keyframeData._LinkKeyframeDataItems();\n    }\n    GetEase() {\n      return this._ease;\n    }\n    SetEase(e) {\n      this._ease = e;\n    }\n    GetEnable() {\n      return this._enable;\n    }\n    SetEnable(e) {\n      this._enable = !!e;\n    }\n    GetTags() {\n      return this._tags;\n    }\n    SetTags(e) {\n      this._tags = e ? e.split(\" \") : [], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase()));\n    }\n    GetLowerTags() {\n      return this._lowerTags;\n    }\n    HasTag(e) {\n      return this._lowerTags.has(e.toLowerCase());\n    }\n    _SaveToJson() {\n      return { \"time\": this._time, \"ease\": this._ease, \"enable\": this._enable, \"tags\": this._tags };\n    }\n    _LoadFromJson(e) {\n      e && (this._time = e[\"time\"], this._ease = e[\"ease\"], this._enable = e[\"enable\"], this._tags = e[\"tags\"], this._lowerTags = new Set(this._tags.map((e2) => e2.toLowerCase())));\n    }\n  }\n  C33.KeyframeData = class {\n    constructor(e, t) {\n      this._trackDataItem = t, this._keyframeDataItems = [], C33.TimelineDataManager._CreateDataItems(this._keyframeDataItems, e, KeyframeDataItem, this), this._LinkKeyframeDataItems();\n    }\n    Release() {\n      this._trackDataItem = null;\n      for (const e of this._keyframeDataItems) e.Release();\n      C33.clearArray(this._keyframeDataItems), this._keyframeDataItems = null;\n    }\n    _LinkKeyframeDataItems() {\n      this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());\n      for (let e = 0; e < this._keyframeDataItems.length; e++) {\n        const t = this._keyframeDataItems[e];\n        t.SetNext(this._keyframeDataItems[e + 1]), t.SetLast(this._keyframeDataItems[e - 1]);\n      }\n    }\n    GetTrackDataItem() {\n      return this._trackDataItem;\n    }\n    GetKeyframeDataItemCount() {\n      return this._keyframeDataItems.length;\n    }\n    GetKeyframeDataItemArray() {\n      return this._keyframeDataItems;\n    }\n    AddEmptyKeyframeDataItem() {\n      const e = new KeyframeDataItem(null, this);\n      return this._keyframeDataItems.push(e), this._LinkKeyframeDataItems(), e;\n    }\n    DeleteKeyframeDataItems(e) {\n      for (const t of this._keyframeDataItems) {\n        if (!e(t)) continue;\n        const a = this._keyframeDataItems.indexOf(t);\n        -1 !== a && (t.Release(), this._keyframeDataItems.splice(a, 1));\n      }\n      this.SortKeyframeDataItems(), this._LinkKeyframeDataItems();\n    }\n    SortKeyframeDataItems() {\n      this._keyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());\n    }\n    GetKeyframeDataItemIndex(e) {\n      return this._keyframeDataItems.indexOf(e);\n    }\n    GetKeyframeDataItemFromIndex(e) {\n      return this._keyframeDataItems[e];\n    }\n    *keyframeDataItems() {\n      for (const e of this._keyframeDataItems) yield e;\n    }\n    *keyframeDataItemsReverse() {\n      for (let e = this._keyframeDataItems.length - 1; e >= 0; e--) yield this._keyframeDataItems[e];\n    }\n    _SaveToJson() {\n      return { \"keyframeDataItemsJson\": this._keyframeDataItems.map((e) => e._SaveToJson()) };\n    }\n    _LoadFromJson(e) {\n      e && (C33.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, e[\"keyframeDataItemsJson\"], KeyframeDataItem, this), this._LinkKeyframeDataItems());\n    }\n  };\n}\n{\n  const C33 = self.C3, VALUE_DATA = 0, VALUE_DATA_VALUE = 0, VALUE_DATA_ABSOLUTE_VALUE = 1, VALUE_DATA_TYPE = 2, TIME = 1, EASE = 2, ENABLE = 3, ADDONS = 4, PATH_MODE = 5;\n  class PropertyKeyframeDataItem {\n    constructor(e, t) {\n      this._propertyKeyframeData = t, this._value = null, this._aValue = null, this._type = \"\", this._time = NaN, this._ease = \"noease\", this._enable = false, this._addonData = null, this._addonInstance = void 0, this._pathMode = \"line\", e && (this._value = e[0][0], this._aValue = e[0][1], this._type = e[0][2], this._time = e[1], this._ease = e[2], this._enable = !!e[3], this._pathMode = e[5], this._addonData = null, e[4] && (this._addonData = new C33.AddonData(e[4], this)), this._next = null, this._prev = null);\n    }\n    Release() {\n      this._propertyKeyframeData = null, this._addonData && (this._addonData.Release(), this._addonData = null), this._next = null, this._prev = null;\n    }\n    GetAddonData() {\n      return this._addonData;\n    }\n    SetNext(e) {\n      this._next = e;\n    }\n    GetNext() {\n      return this._next;\n    }\n    SetPrevious(e) {\n      this._prev = e;\n    }\n    GetPrevious() {\n      return this._prev;\n    }\n    GetValue() {\n      return this._value;\n    }\n    SetValue(e) {\n      \"color\" === this._type && C33.IsFiniteNumber(e) ? (this._value[0] = C33.GetRValue(e), this._value[1] = C33.GetGValue(e), this._value[2] = C33.GetBValue(e)) : this._value = e;\n    }\n    GetAbsoluteValue() {\n      return this._aValue;\n    }\n    SetAbsoluteValue(e) {\n      \"color\" === this._type && C33.IsFiniteNumber(e) ? (this._aValue[0] = C33.GetRValue(e), this._aValue[1] = C33.GetGValue(e), this._aValue[2] = C33.GetBValue(e)) : this._aValue = e;\n    }\n    GetValueWithResultMode() {\n      const e = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();\n      return \"relative\" === e ? this.GetValue() : \"absolute\" === e ? this.GetAbsoluteValue() : void 0;\n    }\n    GetType() {\n      return this._type;\n    }\n    SetType(e) {\n      this._type = e;\n    }\n    GetTime() {\n      return this._time;\n    }\n    SetTime(e) {\n      this._time = e, this._propertyKeyframeData._LinkPropertyKeyframeDataItems();\n    }\n    GetEase() {\n      return this._ease;\n    }\n    SetEase(e) {\n      this._ease = e;\n    }\n    GetEnable() {\n      return this._enable;\n    }\n    SetEnable(e) {\n      this._enable = !!e;\n    }\n    GetPathMode() {\n      return this._pathMode;\n    }\n    GetAddOn(e) {\n      if (!this._addonData) return;\n      if (this._addonInstance || null === this._addonInstance) return this._addonInstance;\n      const t = this._addonData.GetAddDataItemArray();\n      if (!t) return this._addonInstance = null, this._addonInstance;\n      const a = t.length;\n      for (let r = 0; r < a; r++) {\n        const a2 = t[r];\n        if (a2.GetId() === e) return this._addonInstance = a2, this._addonInstance;\n      }\n      return this._addonInstance = null, this._addonInstance;\n    }\n    _SaveToJson() {\n      const e = this._addonData;\n      return { \"addonDataJson\": e ? e._SaveToJson() : e, \"value\": this._value, \"aValue\": this._aValue, \"type\": this._type, \"time\": this._time, \"ease\": this._ease, \"enable\": this._enable };\n    }\n    _LoadFromJson(e) {\n      e && (e[\"addonDataJson\"] && this._addonData._SetFromJson(e[\"addonDataJson\"]), this._value = e[\"value\"], this._aValue = e[\"aValue\"], this._type = e[\"type\"], this._time = e[\"time\"], this._ease = e[\"ease\"], this._enable = e[\"enable\"]);\n    }\n  }\n  C33.PropertyKeyframeData = class {\n    constructor(e, t) {\n      this._propertyTrackDataItem = t, this._propertyKeyframeDataItems = [], this._propertyKeyframeDataItemsIncludingDisabled = [], C33.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, e, PropertyKeyframeDataItem, this), C33.TimelineDataManager._CreateDataItemsIncludingDisabled(this._propertyKeyframeDataItemsIncludingDisabled, e, PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems();\n    }\n    Release() {\n      this._propertyTrackDataItem = null;\n      for (const e of this._propertyKeyframeDataItems) e.Release();\n      C33.clearArray(this._propertyKeyframeDataItems), this._propertyKeyframeDataItems = null;\n      for (const e of this._propertyKeyframeDataItemsIncludingDisabled) e.Release();\n      C33.clearArray(this._propertyKeyframeDataItemsIncludingDisabled), this._propertyKeyframeDataItemsIncludingDisabled = null;\n    }\n    _LinkPropertyKeyframeDataItems() {\n      let e = this._propertyKeyframeDataItems;\n      e.sort((e2, t) => e2.GetTime() - t.GetTime());\n      for (let t = 0; t < e.length; t++) {\n        const a = e[t];\n        t + 1 < e.length && a.SetNext(e[t + 1]), t - 1 >= 0 && a.SetPrevious(e[t - 1]);\n      }\n      e = this._propertyKeyframeDataItemsIncludingDisabled, e.sort((e2, t) => e2.GetTime() - t.GetTime());\n      for (let t = 0; t < e.length; t++) {\n        const a = e[t];\n        t + 1 < e.length && a.SetNext(e[t + 1]), t - 1 >= 0 && a.SetPrevious(e[t - 1]);\n      }\n    }\n    AddEmptyPropertyKeyframeDataItem() {\n      const e = new PropertyKeyframeDataItem(null, this);\n      return this._propertyKeyframeDataItems.push(e), this._LinkPropertyKeyframeDataItems(), e;\n    }\n    DeletePropertyKeyframeDataItems(e) {\n      for (const t of this._propertyKeyframeDataItems) {\n        if (!e(t)) continue;\n        const a = this._propertyKeyframeDataItems.indexOf(t);\n        -1 !== a && (t.Release(), this._propertyKeyframeDataItems.splice(a, 1));\n      }\n      this.SortPropertyKeyFrameDataItems(), this._LinkPropertyKeyframeDataItems();\n    }\n    SortPropertyKeyFrameDataItems() {\n      this._propertyKeyframeDataItems.sort((e, t) => e.GetTime() - t.GetTime());\n    }\n    GetPropertyTrackDataItem() {\n      return this._propertyTrackDataItem;\n    }\n    GetPropertyKeyframeDataItemCount() {\n      return this._propertyKeyframeDataItems.length;\n    }\n    GetLastPropertyKeyframeDataItem() {\n      return this._propertyKeyframeDataItems[this._propertyKeyframeDataItems.length - 1];\n    }\n    GetPropertyKeyframeDataItemArray() {\n      return this._propertyKeyframeDataItems;\n    }\n    GetPropertyKeyframeDataItemArrayIncludingDisabled() {\n      return this._propertyKeyframeDataItemsIncludingDisabled;\n    }\n    *propertyKeyframeDataItems() {\n      for (const e of this._propertyKeyframeDataItems) yield e;\n    }\n    *propertyKeyframeDataItemsReverse() {\n      for (let e = this._propertyKeyframeDataItems.length - 1; e >= 0; e--) yield this._propertyKeyframeDataItems[e];\n    }\n    _SaveToJson() {\n      const e = this._propertyKeyframeDataItems, t = this._propertyKeyframeDataItemsIncludingDisabled;\n      return { \"propertyKeyframeDataItemsJson\": e.map((e2) => e2._SaveToJson()), \"propertyKeyframeDataItemsIncludingDisabledJson\": t.map((e2) => e2._SaveToJson()) };\n    }\n    _LoadFromJson(e) {\n      e && (C33.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, e[\"propertyKeyframeDataItemsJson\"], PropertyKeyframeDataItem, this), C33.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItemsIncludingDisabled, e[\"propertyKeyframeDataItemsIncludingDisabledJson\"], PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems());\n    }\n  };\n}\n{\n  const C33 = self.C3, ADDON_ID = 0, ADDON_DATA = 1;\n  class AddonDataItem {\n    constructor(t, a) {\n      this._addonData = a, this._id = t[0], this._data = t[1];\n    }\n    Release() {\n      this._addonData = null, this._data = null;\n    }\n    GetAddonData() {\n      return this._addonData;\n    }\n    GetId() {\n      return this._id;\n    }\n    _SaveToJson() {\n      return { \"id\": this._id, \"data\": this._data };\n    }\n    _LoadFromJson(t) {\n      t && (this._id = t[\"id\"], this._data = t[\"data\"]);\n    }\n  }\n  const START_ANCHOR = 0, START_ENABLE = 1, END_ANCHOR = 2, END_ENABLE = 3;\n  class AddonDataCubicBezierItem extends AddonDataItem {\n    constructor(t, a) {\n      super(t, a), this._startAnchor = this._data[0], this._startEnable = !!this._data[1], this._endAnchor = this._data[2], this._endEnable = !!this._data[3];\n    }\n    Release() {\n      super.Release();\n    }\n    GetStartAnchor() {\n      return this._startAnchor;\n    }\n    GetStartEnable() {\n      return this._startEnable;\n    }\n    GetEndAnchor() {\n      return this._endAnchor;\n    }\n    GetEndEnable() {\n      return this._endEnable;\n    }\n    _SaveToJson() {\n      return Object.assign(super._SaveToJson(), { \"startAnchor\": this._startAnchor, \"startEnable\": !!this._startEnable, \"endAnchor\": this._endAnchor, \"endEnable\": !!this._endEnable });\n    }\n    _LoadFromJson(t) {\n      t && (super._LoadFromJson(t), this._startAnchor = t[\"startAnchor\"], this._startEnable = !!t[\"startEnable\"], this._endAnchor = t[\"endAnchor\"], this._endEnable = !!t[\"endEnable\"]);\n    }\n  }\n  const DIRECTION = 0, REVOLUTIONS = 1;\n  class AddonDataAngleItem extends AddonDataItem {\n    constructor(t, a) {\n      super(t, a), this._direction = this._data[0], this._revolutions = this._data[1];\n    }\n    Release() {\n      super.Release();\n    }\n    GetDirection() {\n      return this._direction;\n    }\n    GetRevolutions() {\n      return this._revolutions;\n    }\n    _SaveToJson() {\n      return Object.assign(super._SaveToJson(), { \"direction\": this._direction, \"revolutions\": this._revolutions });\n    }\n    _LoadFromJson(t) {\n      t && (super._LoadFromJson(t), this._direction = t[\"direction\"], this._revolutions = t[\"revolutions\"]);\n    }\n  }\n  C33.AddonData = class {\n    constructor(t, a) {\n      this._propertyKeyframeDataItem = a, this._addonDataItems = [], C33.TimelineDataManager._CreateDataItems(this._addonDataItems, t, { prop: 0, map: /* @__PURE__ */ new Map([[\"cubic-bezier\", AddonDataCubicBezierItem], [\"angle\", AddonDataAngleItem]]) }, this);\n    }\n    Release() {\n      this._propertyKeyframeDataItem = null;\n      for (const t of this._addonDataItems) t.Release();\n      C33.clearArray(this._addonDataItems), this._addonDataItems = null;\n    }\n    GetPropertyKeyframeDataItem() {\n      return this._propertyKeyframeDataItem;\n    }\n    GetAddDataItemArray() {\n      return this._addonDataItems;\n    }\n    *addonDataItems() {\n      for (const t of this._addonDataItems) yield t;\n    }\n    _SaveToJson() {\n      return { \"addonDataItemsJson\": this._addonDataItems.map((t) => t._SaveToJson()) };\n    }\n    _LoadFromJson(t) {\n      t && C33.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, t[\"addonDataItemsJson\"], { prop: \"id\", map: /* @__PURE__ */ new Map([[\"cubic-bezier\", AddonDataCubicBezierItem], [\"angle\", AddonDataAngleItem]]) }, this);\n    }\n  };\n}\n{\n  const C33 = self.C3, INITIAL_VALUE_MODE_START_VALUE = \"start-value\", INITIAL_VALUE_MODE_CURRENT_STATE = \"current-state\", PING_PONG_BEGIN = 0, PING_PONG_END = 1;\n  let createdTweens = 0;\n  C33.TweenState = class extends C33.TimelineState {\n    constructor(e, t) {\n      super(\"tween-\" + createdTweens++, e, t), this._id = \"\", this._destroyInstanceOnComplete = false, this._initialValueMode = \"start-value\", this._instance = null, this._on_completed_callbacks = null, this._on_started_callbacks = null, this._behInst = null, this._track = null, this._iTweenState = null;\n    }\n    FireReleaseEvent(e) {\n      const t = C33.New(C33.Event, \"tweenstatereleased\");\n      t.tweenState = this, e.dispatchEvent(t);\n    }\n    GetType() {\n      return 1;\n    }\n    CreateTrackStates() {\n      for (const e of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(C33.TweenTrackState.Create(this, e));\n      this._track = this._tracks[0];\n    }\n    AddTrack() {\n      const e = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem(), t = C33.TweenTrackState.Create(this, e);\n      return this._tracks.push(t), this._CacheTrack(), t;\n    }\n    _CacheTrack() {\n      this._track = this._tracks[0];\n    }\n    GetPropertyTrack(e) {\n      return this._track.GetPropertyTracks()[0];\n    }\n    SetPropertyType(e) {\n      this._propertyType = e;\n    }\n    GetInstance() {\n      const e = this.GetTracks();\n      if (!e || !e.length) return;\n      const t = e[0];\n      if (this._track = t, !t) return;\n      const n = t.GetInstance();\n      return t.IsInstanceValid() ? n : void 0;\n    }\n    SetBehaviorInstance(e) {\n      this._behInst = e;\n    }\n    AddStartedCallback(e) {\n      this._on_started_callbacks || (this._on_started_callbacks = []), this._on_started_callbacks.push(e);\n    }\n    AddCompletedCallback(e) {\n      this._on_completed_callbacks || (this._on_completed_callbacks = []), this._on_completed_callbacks.push(e);\n    }\n    RemoveStartedCallback(e) {\n      if (!this._on_started_callbacks) return;\n      const t = this._on_started_callbacks.indexOf(e);\n      -1 !== t && this._on_started_callbacks.splice(t, 1);\n    }\n    RemoveCompletedCallback(e) {\n      if (!this._on_completed_callbacks) return;\n      const t = this._on_completed_callbacks.indexOf(e);\n      -1 !== t && this._on_completed_callbacks.splice(t, 1);\n    }\n    SetStartValue(e, t) {\n      for (const n of this._tracks) for (const s of n._propertyTracks) {\n        if (s.GetPropertyName() !== t) continue;\n        const n2 = s.GetPropertyTrackData(), i = s.GetPropertyTrackDataItem(), a = n2.GetFirstPropertyKeyframeDataItem(i);\n        a.SetValue(e), a.SetAbsoluteValue(e);\n      }\n    }\n    _GetPropertyTrackState(e) {\n      for (const t of this._tracks) for (const n of t._propertyTracks) if (n.GetPropertyName() === e) return n;\n    }\n    BeforeSetEndValues(e) {\n      for (const t of e) {\n        const e2 = this._GetPropertyTrackState(t);\n        this.SetStartValue(e2.GetCurrentState(), t);\n      }\n      if (this.IsForwardPlayBack()) {\n        const e2 = this.GetTotalTime() - this.GetTime();\n        this.SetTotalTime(e2);\n        for (const t of this._tracks) t.SetLocalTotalTime(e2);\n        this._SetTime(0);\n      } else {\n        const e2 = this.GetTime();\n        this.SetTotalTime(e2);\n        for (const t of this._tracks) t.SetLocalTotalTime(e2);\n        this._SetTime(e2);\n      }\n      this.SetInitialStateFromSetTime();\n    }\n    SetEndValue(e, t) {\n      const n = this._GetPropertyTrackState(t), s = n.GetPropertyTrackData(), i = n.GetPropertyTrackDataItem(), a = s.GetLastPropertyKeyframeDataItem(i);\n      a.SetTime(this.GetTotalTime()), a.SetValue(e), a.SetAbsoluteValue(e);\n    }\n    SetId(e) {\n      this._id = e;\n    }\n    GetId() {\n      return this._id;\n    }\n    SetInitialValueMode(e) {\n      this._initialValueMode = e;\n    }\n    GetInitialValueMode() {\n      return this._initialValueMode;\n    }\n    SetDestroyInstanceOnComplete(e) {\n      this._destroyInstanceOnComplete = e;\n    }\n    GetDestroyInstanceOnComplete() {\n      return this._destroyInstanceOnComplete;\n    }\n    OnStarted() {\n      if (this._on_started_callbacks) for (const e of this._on_started_callbacks) e(this);\n      if (!this.IsComplete()) for (const e of this._tracks) e.CompareSaveStateWithCurrent();\n    }\n    OnCompleted() {\n      this._completedTick = this._runtime.GetTickCount();\n    }\n    FinishTriggers() {\n      if (!this._finishedTriggers && (this._finishedTriggers = true, this._on_completed_callbacks)) for (const e of this._on_completed_callbacks) e(this);\n    }\n    SetTime(e) {\n      this._DeleteIntermediateKeyframes(), super.SetTime(e);\n    }\n    _SetTimeAndReset(e) {\n      C33.IsFiniteNumber(e) || (e = this.GetTotalTime()), e < 0 ? this._playheadTime = 0 : e >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = e, this._track.SetResetState();\n    }\n    SetInitialState(e) {\n      if (!this.InitialStateSet() && \"current-state\" === this.GetInitialValueMode()) for (const e2 of this._tracks) e2.CompareInitialStateWithCurrent();\n      super.SetInitialState(e);\n    }\n    Stop(e = false) {\n      if (super.Stop(e), !this.IsComplete()) for (const e2 of this._tracks) e2.SaveState();\n    }\n    Reset(e = true, t = false) {\n      this._DeleteIntermediateKeyframes(), super.Reset(e, t);\n    }\n    _DeleteIntermediateKeyframes() {\n      for (const e of this._tracks) {\n        const t = (e2) => {\n          const t2 = e2.GetTime(), n = this.GetTotalTime();\n          return 0 !== t2 && t2 !== n;\n        };\n        e.DeleteKeyframes(t), e.DeletePropertyKeyframes(t);\n      }\n    }\n    _OnBeforeChangeLayout() {\n      if (this.IsReleased()) return true;\n      const e = this.GetInstance();\n      return (!e || !e.GetObjectClass().IsGlobal()) && (this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this), this.ResetBeforeChangeLayout(), true);\n    }\n    Tick(e, t, n) {\n      if (this._instance || (this._instance = this.GetInstance()), !this._instance || this._instance.IsDestroyed()) return this.Stop(true), void this.OnCompleted();\n      const s = this._instance.GetTimeScale();\n      if (-1 !== s && (e = n * s), 0 === e && 0 === this._lastDelta) return;\n      this._lastDelta = e;\n      const i = this._playheadTime + this._overshoot + e * this._playbackRate, a = this._timelineDataItem._totalTime;\n      i < 0 ? (this._playheadTime = 0, this._overshoot = -i) : i >= a ? (this._playheadTime = a, this._overshoot = this._playheadTime - i) : (this._playheadTime = i, this._overshoot = 0);\n      let r = false, o = false;\n      const h = this.GetLoop(), T = this.GetPingPong();\n      if (h || T ? h && !T ? this._playbackRate > 0 ? this._playheadTime >= a && (this._SetTimeAndReset(0), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), o = true) : this._playheadTime <= 0 && (this._SetTimeAndReset(a), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), o = true) : !h && T ? this._playbackRate > 0 ? this._playheadTime >= a && (this._SetTime(a), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 0 : this._resumePingPongState = 0) : (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), r = true) : 0 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 1 : this._resumePingPongState = 1)) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o = true, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 0 : this._resumePingPongState = 0) : (r = true, this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)) : 0 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong), this.IsPlaying() ? this._pingPongState = 1 : this._resumePingPongState = 1)) : h && T && (this._playbackRate > 0 ? this._playheadTime >= a && (this._SetTime(a), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o = true, 0 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), 1 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), this.IsPlaying() ? (this._pingPongState++, this._pingPongState = C33.wrap(this._pingPongState, 0, 2)) : (this._resumePingPongState = this._pingPongState + 1, this._resumePingPongState = C33.wrap(this._resumePingPongState, 0, 2))) : this._playheadTime <= 0 && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), o = true, 0 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), 1 === this._pingPongState && (this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensPingPong)), this.IsPlaying() ? (this._pingPongState++, this._pingPongState = C33.wrap(this._pingPongState, 0, 2)) : (this._resumePingPongState = this._pingPongState + 1, this._resumePingPongState = C33.wrap(this._resumePingPongState, 0, 2)))) : this._playbackRate > 0 ? this._playheadTime >= a && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), o = true) : (this._SetTime(a), r = true)) : this._playheadTime <= 0 && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(a), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C33.Behaviors.Tween.Cnds.OnTweensLoop), o = true) : (this._SetTime(0), r = true)), this.IsPlaying()) {\n        if (r) return this._track.SetEndState(), this.Stop(true), void this.OnCompleted();\n        this._track.Interpolate(this._playheadTime, true, false, o, this._firstTick, false), this._firstTick && (this._firstTick = false);\n      }\n    }\n    _TweenTrigger(e) {\n      const t = this.GetInstance();\n      this._behInst.PushTriggerTween(this), this._runtime.Trigger(e, t, this._behInst.GetBehaviorType()), this._behInst.PopTriggerTween();\n    }\n    _SaveToJson() {\n      const e = super._SaveToJson(), t = this.GetTimelineDataItem();\n      return Object.assign(e, { \"tweenDataItemJson\": t._SaveToJson(), \"id\": this._id, \"destroyInstanceOnComplete\": this._destroyInstanceOnComplete, \"initialValueMode\": this._initialValueMode });\n    }\n    _LoadFromJson(e) {\n      if (!e) return;\n      this.GetTimelineDataItem()._LoadFromJson(e[\"tweenDataItemJson\"]), super._LoadFromJson(e), this._id = e[\"id\"], this._destroyInstanceOnComplete = e[\"destroyInstanceOnComplete\"], this._initialValueMode = e[\"initialValueMode\"], this._CacheTrack();\n    }\n    static IsPlaying(e) {\n      return e.IsPlaying();\n    }\n    static IsPaused(e) {\n      return e.IsPaused();\n    }\n    static IsPing(e) {\n      return !!e.GetPingPong() && 0 === e.GetPingPongState();\n    }\n    static IsPong(e) {\n      return !!e.GetPingPong() && 1 === e.GetPingPongState();\n    }\n    static Build(e) {\n      const t = e.runtime.GetTimelineManager(), n = new C33.TimelineDataItem();\n      if (e.json) {\n        n._LoadFromJson(e.json[\"tweenDataItemJson\"]);\n        const s = new C33.TweenState(n, t);\n        return s._LoadFromJson(e.json), s;\n      }\n      {\n        const s = new C33.TweenState(n, t);\n        C33.IsArray(e.propertyTracksConfig) || (e.propertyTracksConfig = [e.propertyTracksConfig]), s.SetId(e.id), s.SetTags(e.tags), s.SetInitialValueMode(e.initialValueMode), s.SetDestroyInstanceOnComplete(e.releaseOnComplete), s.SetLoop(e.loop), s.SetPingPong(e.pingPong), s.SetTotalTime(e.time), s.SetStep(0), s.SetInterpolationMode(\"default\"), s.SetResultMode(e.propertyTracksConfig[0].resultMode), s.SetRepeatCount(e.repeatCount);\n        const i = s.AddTrack();\n        i.SetInstanceUID(e.instance.GetUID()), i.SetInterpolationMode(\"default\"), i.SetResultMode(e.propertyTracksConfig[0].resultMode), i.SetEnable(true), i.SetObjectClassIndex(e.instance.GetObjectClass().GetIndex());\n        const a = e.instance.GetSdkInstance(), r = a.IsOriginalSizeKnown() ? a.GetOriginalWidth() : e.instance.GetWorldInfo().GetWidth(), o = a.IsOriginalSizeKnown() ? a.GetOriginalHeight() : e.instance.GetWorldInfo().GetHeight();\n        i.SetOriginalWidth(r), i.SetOriginalHeight(o);\n        const h = i.AddKeyframe();\n        h.SetTime(0), h.SetEase(\"noease\"), h.SetEnable(true), h.SetTags(\"\");\n        const T = i.AddKeyframe();\n        T.SetTime(e.time), T.SetEase(\"noease\"), T.SetEnable(true), T.SetTags(\"\");\n        for (const t2 of e.propertyTracksConfig) {\n          const n2 = i.AddPropertyTrack();\n          n2.SetSourceAdapterId(t2.sourceId), n2.SetSourceAdapterArgs(t2.sourceArgs), n2.SetPropertyName(t2.property), n2.SetPropertyType(t2.type), n2.SetMin(NaN), n2.SetMax(NaN), n2.SetInterpolationMode(\"default\"), n2.SetResultMode(t2.resultMode), n2.SetEnable(true);\n          const s2 = n2.AddPropertyKeyframe();\n          s2.SetType(t2.valueType), s2.SetTime(0), s2.SetEase(t2.ease), s2.SetEnable(true), s2.SetValue(t2.startValue), s2.SetAbsoluteValue(t2.startValue);\n          const a2 = n2.AddPropertyKeyframe();\n          a2.SetType(t2.valueType), a2.SetTime(e.time), a2.SetEase(t2.ease), a2.SetEnable(true), a2.SetValue(t2.endValue), a2.SetAbsoluteValue(t2.endValue), n2.GetSourceAdapter();\n        }\n        return s;\n      }\n    }\n    static SetInstanceUID(e, t) {\n      if (!isNaN(t)) for (const n of e.GetTracks()) n.SetInstanceUID(t);\n    }\n    static SetBehaviorInstance(e, t) {\n      e.SetBehaviorInstance(t);\n    }\n    GetITweenState(e, t) {\n      return this._iTweenState || (this._iTweenState = C33.New(self.ITweenState, this, e, t)), this._iTweenState;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.TweenTrackState = class extends C33.TrackState {\n    constructor(t, e) {\n      super(t, e), this._firstPropertyTrack = null, this._secondPropertyTrack = null;\n    }\n    static Create(t, e) {\n      return C33.New(C33.TweenTrackState, t, e);\n    }\n    _CachePropertyTracks() {\n      1 === this._propertyTracks.length ? this._firstPropertyTrack = this._propertyTracks[0] : (this._firstPropertyTrack = this._propertyTracks[0], this._secondPropertyTrack = this._propertyTracks[1]);\n    }\n    CreatePropertyTrackStates() {\n      for (const t of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(C33.TweenPropertyTrackState.Create(this, t));\n      this._CachePropertyTracks();\n    }\n    AddPropertyTrack() {\n      const t = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem(), e = C33.TweenPropertyTrackState.Create(this, t);\n      return this._propertyTracks.push(e), this._CachePropertyTracks(), e;\n    }\n    SetInitialState() {\n      if (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack()) return;\n      const t = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();\n      for (const e of this._propertyTracks) e.SetInitialState(t), 0 === this._worldInfoChange && 1 === e.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === e.GetRenderChange() && (this._renderChange = 1);\n      this._needsBeforeAndAfter = 0;\n      this._propertyTracks.some((t2) => t2.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1), this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(t), this._initialStateOfNestedSet = false, this._endStateOfNestedSet = false, this.Interpolate(t);\n    }\n    BeforeInterpolate() {\n    }\n    Interpolate(t, e = false, r = false, s = false, a = false, o = false, n = false) {\n      if (this._instance || this.GetInstance(), !this._instance) return;\n      return !this._instance.IsDestroyed() && ((!o || !this.GetObjectClass().IsGlobal()) && (this._secondPropertyTrack ? (this._firstPropertyTrack.Interpolate(t, r, s, n), this._secondPropertyTrack.Interpolate(t, r, s, n)) : this._firstPropertyTrack.Interpolate(t, r, s, n), void (0 !== this._firstPropertyTrack.GetWorldInfoChange() && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged()))));\n    }\n    AfterInterpolate() {\n    }\n    _LoadFromJson(t) {\n      super._LoadFromJson(t), this._CachePropertyTracks();\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.TweenPropertyTrackState = class extends C33.PropertyTrackState {\n    constructor(t, e) {\n      super(t, e), this._basic = false;\n    }\n    static Create(t, e) {\n      return C33.New(C33.TweenPropertyTrackState, t, e);\n    }\n    Interpolate(t, e = false, r = false, a = false) {\n      let s, o;\n      if (this._basic) s = this._propertyKeyframeDataItems[0], o = this._propertyKeyframeDataItems[1];\n      else if (e) s = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem), o = s.GetNext();\n      else {\n        if (this._lastPropertyKeyframeDataItem) {\n          const e2 = this.GetTimeline(), r2 = this._lastPropertyKeyframeDataItem.GetNext(), a2 = this._lastPropertyKeyframeDataItem.GetTime(), s2 = r2 ? r2.GetTime() : e2.GetTotalTime();\n          (t <= a2 || t >= s2) && (this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem));\n        } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(t, this._propertyTrackDataItem);\n        s = this._lastPropertyKeyframeDataItem, o = s.GetNext();\n      }\n      this._sourceAdapter.Interpolate(t, s, o, e, r, a);\n    }\n    AddPropertyKeyframe() {\n      const t = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();\n      return this._lastPropertyKeyframeDataItem = null, this._basic = this.GetPropertyKeyframeDataItems().length <= 2, t;\n    }\n    DeletePropertyKeyframes(t) {\n      this._lastPropertyKeyframeDataItem = null;\n      this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(t), this._basic = this.GetPropertyKeyframeDataItems().length <= 2;\n    }\n    _SaveToJson() {\n      return { \"sourceAdapterJson\": this.GetSourceAdapter()._SaveToJson(), \"basic\": this._basic };\n    }\n    _LoadFromJson(t) {\n      t && (this.GetSourceAdapter()._LoadFromJson(t[\"sourceAdapterJson\"]), this._basic = t[\"basic\"]);\n    }\n  };\n}\n{\n  const C33 = self.C3, Ease = self.Ease, NAME = 0, TRANSITION_KEYFRAMES = 1, LINEAR = 2;\n  C33.Transition = class extends C33.DefendedBase {\n    constructor(e, t = true) {\n      super(), this._name = e[0], this._linear = e[2], this._transitionKeyframes = [];\n      for (const t2 of e[1]) {\n        const e2 = C33.TransitionKeyframe.Create(this, t2);\n        this._transitionKeyframes.push(e2);\n      }\n      for (let e2 = 0; e2 < this._transitionKeyframes.length; e2++) {\n        const t2 = this._transitionKeyframes[e2], a = this._transitionKeyframes[e2 + 1], s = this._transitionKeyframes[e2 - 1];\n        t2.SetNext(a), t2.SetPrevious(s);\n      }\n      this._precalculatedSamples = /* @__PURE__ */ new Map(), this._transitionKeyframeCache = /* @__PURE__ */ new Map(), this._PreCalcSamples(), t && Ease.AddCustomEase(this._name, (e2, t2, a, s) => this.Interpolate(e2, t2, a, s), null, { transition: this });\n    }\n    static Create(e) {\n      return C33.New(C33.Transition, e);\n    }\n    Release() {\n      for (const e of this._transitionKeyframes) e.Release();\n      C33.clearArray(this._transitionKeyframes), this._transitionKeyframes = null, this._precalculatedSamples.clear(), this._precalculatedSamples = null, this._transitionKeyframeCache.clear(), this._transitionKeyframeCache = null;\n    }\n    MakeLinear(e) {\n      this._linear = !!e;\n    }\n    GetTransitionKeyFrameAt(e) {\n      const t = this._transitionKeyframeCache.get(e);\n      if (t) return t;\n      for (const t2 of this._transitionKeyframes) if (t2.GetValueX() === e) return this._transitionKeyframeCache.set(e, t2), t2;\n    }\n    GetFirstTransitionKeyFrameLowerOrEqualThan(e) {\n      for (let t = this._transitionKeyframes.length - 1; t >= 0; t--) {\n        const a = this._transitionKeyframes[t], s = a.GetValueX();\n        if (s <= e) {\n          let t2 = a;\n          if (s < e) return t2;\n          if (s === e) {\n            for (; t2; ) {\n              const e2 = t2.GetPrevious();\n              if (!e2) break;\n              if (e2.GetValueX() !== t2.GetValueX()) break;\n              t2 = e2;\n            }\n            return t2;\n          }\n        }\n      }\n    }\n    Interpolate(e, t, a, s) {\n      let n = e / s;\n      if (this._linear) {\n        const n2 = this.GetTransitionKeyFrameAt(0), r2 = this.GetTransitionKeyFrameAt(1), i2 = t + (t + a) * n2.GetValueY(), l2 = (t + a) * r2.GetValueY() - i2;\n        return 0 === s ? i2 + l2 : Ease.NoEase(e, i2, l2, s);\n      }\n      0 === s && (n = 1);\n      let r = this.GetFirstTransitionKeyFrameLowerOrEqualThan(n), i = r.GetNext();\n      if (!i) {\n        const e2 = r.GetPrevious(), t2 = r;\n        r = e2, i = t2;\n      }\n      const l = i.GetValueX() - r.GetValueX(), o = C33.mapToRange(n, r.GetValueX(), i.GetValueX(), 0, l);\n      if (r.IsSegmentLinear() || 0 === l) {\n        const e2 = t + (t + a) * r.GetValueY(), s2 = (t + a) * i.GetValueY() - e2;\n        return 0 === l ? 1 === o ? e2 + s2 : e2 : Ease.NoEase(o, e2, s2, l);\n      }\n      const h = r.GetValueX(), u = r.GetValueY(), c = r.GetValueX() + r.GetStartAnchorX(), f = r.GetValueY() + r.GetStartAnchorY(), G = i.GetValueX() + i.GetEndAnchorX(), m = i.GetValueY() + i.GetEndAnchorY(), _ = i.GetValueX(), y = i.GetValueY();\n      let K = Ease.GetRuntimeEase(\"spline\")(o, h, u, c, f, G, m, _, y, this._precalculatedSamples.get(r));\n      return K += r.GetValueY(), (1 - K) * t + K * (t + a);\n    }\n    _PreCalcSamples() {\n      this._precalculatedSamples.clear();\n      for (let e = 0; e < this._transitionKeyframes.length - 1; e++) {\n        const t = this._transitionKeyframes[e];\n        if (!t.GetStartEnable()) continue;\n        const a = t, s = this._transitionKeyframes[e + 1];\n        if (!s.GetEndEnable()) continue;\n        const n = a.GetValueX(), r = a.GetValueX() + a.GetStartAnchorX(), i = s.GetValueX() + s.GetEndAnchorX(), l = s.GetValueX();\n        this._precalculatedSamples.set(a, Ease.GetBezierSamples(n, r, i, l));\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3, VALUE_X = 0, VALUE_Y = 1, START_ANCHOR_X = 2, START_ANCHOR_Y = 3, END_ANCHOR_X = 4, END_ANCHOR_Y = 5, START_ENABLE = 6, END_ENABLE = 7, SEGMENT_MODE = 8;\n  C33.TransitionKeyframe = class extends C33.DefendedBase {\n    constructor(t, e) {\n      super(), this._transition = t, this._valueX = e[0], this._valueY = e[1], this._startAnchorX = e[2], this._startAnchorY = e[3], this._endAnchorX = e[4], this._endAnchorY = e[5], this._startEnable = e[6], this._endEnable = e[7], this._segmentMode = e[8], this._next = null, this._prev = null;\n    }\n    Release() {\n      this._transition = null;\n    }\n    static Create(t, e) {\n      return C33.New(C33.TransitionKeyframe, t, e);\n    }\n    SetNext(t) {\n      this._next = t;\n    }\n    GetNext() {\n      return this._next;\n    }\n    SetPrevious(t) {\n      this._prev = t;\n    }\n    GetPrevious() {\n      return this._prev;\n    }\n    GetValueX() {\n      return this._valueX;\n    }\n    GetValueY() {\n      return this._valueY;\n    }\n    GetStartAnchorX() {\n      return this._startAnchorX;\n    }\n    GetStartAnchorY() {\n      return this._startAnchorY;\n    }\n    GetEndAnchorX() {\n      return this._endAnchorX;\n    }\n    GetEndAnchorY() {\n      return this._endAnchorY;\n    }\n    GetStartEnable() {\n      return this._startEnable;\n    }\n    GetEndEnable() {\n      return this._endEnable;\n    }\n    IsSegmentLinear() {\n      return \"linear\" === this._segmentMode;\n    }\n    IsSegmentCubic() {\n      return \"cubic\" === this._segmentMode;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.TransitionManager = class extends C33.DefendedBase {\n    constructor(s) {\n      super(), this._runtime = s, this._transitions = [];\n    }\n    Release() {\n      for (const s of this._transitions) s.Release();\n      C33.clearArray(this._transitions), this._transitions = null;\n    }\n    Create(s) {\n      this._transitions.push(C33.Transition.Create(s));\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.TemplateManager = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e, this._templateDataMap = null, this._instanceToTemplateNameMap = null, this._instanceDestroy = (e2) => this._OnInstanceDestroy(e2.instance);\n    }\n    Release() {\n      if (this.RemoveRuntimeListeners(), this._templateDataMap) {\n        for (const e of this._templateDataMap.values()) e.clear();\n        this._templateDataMap.clear();\n      }\n      this._templateDataMap = null, this._runtime = null;\n    }\n    Create(e) {\n      if (this._templateDataMap || (this._templateDataMap = /* @__PURE__ */ new Map()), !e) return;\n      const t = e[0][16][0], a = e[1];\n      this._templateDataMap.has(a) || this._templateDataMap.set(a, /* @__PURE__ */ new Map());\n      this._templateDataMap.get(a).set(t, e);\n    }\n    AddRuntimeListeners() {\n      const e = this._runtime.Dispatcher();\n      e && e.addEventListener(\"instancedestroy\", this._instanceDestroy);\n    }\n    RemoveRuntimeListeners() {\n      const e = this._runtime.Dispatcher();\n      e && e.removeEventListener(\"instancedestroy\", this._instanceDestroy);\n    }\n    HasTemplates() {\n      return !!this._templateDataMap && 0 !== this._templateDataMap.size;\n    }\n    GetTemplateData(e, t) {\n      let a = 0;\n      if (a = e instanceof C33.ObjectClass ? e.GetIndex() : e, !this._templateDataMap.has(a)) return;\n      const s = this._templateDataMap.get(a).get(t);\n      return s ? JSON.parse(JSON.stringify(s)) : void 0;\n    }\n    MapInstanceToTemplateName(e, t) {\n      this._instanceToTemplateNameMap || (this._instanceToTemplateNameMap = /* @__PURE__ */ new WeakMap()), this._instanceToTemplateNameMap.has(e) || this._instanceToTemplateNameMap.set(e, t);\n    }\n    GetInstanceTemplateName(e) {\n      if (!this._instanceToTemplateNameMap) return \"\";\n      const t = this._instanceToTemplateNameMap.get(e);\n      return t || \"\";\n    }\n    _OnInstanceDestroy(e) {\n      this._instanceToTemplateNameMap && this._instanceToTemplateNameMap.has(e) && this._instanceToTemplateNameMap.delete(e);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.FlowchartManager = class {\n    constructor(a) {\n      this._runtime = a, this._flowchartDataManager = new C33.FlowchartDataManager();\n    }\n    Release() {\n      this._flowchartDataManager.Release(), this._flowchartDataManager = null, this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    Create(a) {\n      this._flowchartDataManager.Add(a);\n    }\n    GetFlowchartDataItemByName(a) {\n      return this._flowchartDataManager.Get(a);\n    }\n    HasFlowcharts() {\n      return this._flowchartDataManager.HasFlowcharts();\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.FlowchartState = class {\n    constructor(t, e, r, a, o, h, s) {\n      this._runtime = o.GetRuntime(), this._flowchartManager = o, this._flowchartName = t, this._startNodeTag = r, this._flowchartDataItem = a, this._tag = e, this._pluginInstance = h, this._pluginUID = s ?? h.GetInstance().GetUID(), this._SetStartFlowchartNode(), this._currentFlowchartNodeId = this._startFlowchartNode?.GetFlowchartId() ?? -1, this._previousFlowchartNodeIds = [], this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = \"\", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = \"\", this._rootFlowchartStateTag = \"\", this._triggerCount = 0, this._markForRelease = false, this._released = false;\n    }\n    Release() {\n      this._released || (C33.clearArray(this._previousFlowchartNodeIds), this._previousFlowchartNodeIds = null, this._runtime = null, this._flowchartManager = null, this._flowchartDataItem = null, this._pluginInstance = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates = null, this._currentReferenceFlowchartState = null, this._rootFlowchartState = null, this._previousFlowchartStateTag = \"\", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = \"\", this._rootFlowchartStateTag = \"\", this._released = true);\n    }\n    WasReleased() {\n      return this._released;\n    }\n    GetFlowchartManager() {\n      return this._flowchartManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetName() {\n      return this._flowchartName;\n    }\n    GetFlowchartDataItem() {\n      return this._flowchartDataItem;\n    }\n    GetTag() {\n      return this._tag;\n    }\n    GetPluginInstance() {\n      return this._pluginInstance || (this._pluginInstance = this._runtime.GetInstanceByUID(this._pluginUID).GetSdkInstance()), this._pluginInstance;\n    }\n    GetCurrentNode() {\n      return this.GetFlowchartElementById(this._currentFlowchartNodeId);\n    }\n    GetCurrentNodeTag() {\n      const t = this.GetCurrentNode();\n      return t ? t.GetTag() : \"\";\n    }\n    GetCurrentNodeTags() {\n      const t = this.GetCurrentNode();\n      return t ? t.GetTags() : [];\n    }\n    CurrentNodeHasTags(t) {\n      const e = this.GetCurrentNodeTags();\n      if (!e) return false;\n      if (!e.length) return false;\n      const r = C33.FlowchartState._GetTagArray(t);\n      return !(!r || !r.length) && r.every(C33.FlowchartState._HasTag, e);\n    }\n    CurrentNodeCompareTags(t, e) {\n      const r = this.GetCurrentNodeTags();\n      if (!r) return false;\n      if (!r.length) return false;\n      const a = C33.FlowchartState._GetTagArray(t);\n      return !(!a || !a.length) && a.every((t2) => C33.FlowchartState._CompareTag.call(r, t2, e));\n    }\n    static _HasTag(t) {\n      const e = this;\n      return \"\" === t ? 1 === e.length && \"\" === e[0] : e.map((t2) => t2.trim().toLowerCase()).includes(t.trim().toLowerCase());\n    }\n    static _GetTagArray(t) {\n      return t.trim().split(\" \");\n    }\n    static _CompareTag(t, e) {\n      const r = this;\n      return \"\" === t ? 1 === r.length && \"\" === r[0] : r.some((r2) => C33.compare(r2.trim(), e, t.trim()));\n    }\n    GetCurrentNodeParent(t) {\n      const e = this.GetCurrentNode();\n      if (e) {\n        if (C33.IsFiniteNumber(t)) {\n          const r = e.GetParentFlowchartIds(), a = r ? r[t] : void 0;\n          if (C33.IsFiniteNumber(a)) return this.GetFlowchartElementById(a);\n        }\n        if (\"string\" == typeof t) for (const r of e.GetParentFlowchartIds()) {\n          const e2 = this.GetFlowchartElementById(r);\n          if (e2.HasTags(t)) return this.GetFlowchartElementById(e2.GetFlowchartId());\n        }\n      }\n    }\n    GetCurrentNodeParentTag(t) {\n      const e = this.GetCurrentNodeParent(t);\n      return e ? e.GetTag() : \"\";\n    }\n    GetCurrentNodeParentTags(t) {\n      const e = this.GetCurrentNodeParent(t);\n      return e ? e.GetTags() : \"\";\n    }\n    GetCurrentNodeParentIndex(t) {\n      const e = this.GetCurrentNode();\n      if (!e) return -1;\n      const r = e.GetParentFlowchartIds();\n      if (!r) return -1;\n      const a = this.GetCurrentNodeParent(t);\n      return a ? r.indexOf(a.GetFlowchartId()) : -1;\n    }\n    GetCurrentNodeParentCount() {\n      const t = this.GetCurrentNode();\n      if (!t) return 0;\n      const e = t.GetParentFlowchartIds();\n      return e ? e.length : 0;\n    }\n    GetFlowchartElementById(t) {\n      return this._flowchartDataItem.GetFlowchartElementById(t);\n    }\n    Reset() {\n      this._GetRootFlowchartState()._Reset(true);\n    }\n    _Reset(t) {\n      if (this._GetReferenceFlowchartStates()) {\n        for (const [t2, e] of this._GetReferenceFlowchartStates().entries()) e._Reset(false);\n        this._GetReferenceFlowchartStates().clear();\n      }\n      if (this._referenceFlowchartStates = null, this._previousFlowchartState = null, this._previousFlowchartStateStartNode = null, this._currentReferenceFlowchartState = null, this._previousFlowchartStateTag = \"\", this._referenceFlowchartStatesJson = null, this._currentReferenceFlowchartStateTag = \"\", this._rootFlowchartStateTag = \"\", this._previousFlowchartNodeIds = [], t) {\n        this._flowchartManager.SetCurrentFlowchartState(this);\n        const t2 = this._startFlowchartNode.GetFlowchartId();\n        t2 !== this._currentFlowchartNodeId && this._GotoFlowchartNode(t2);\n      } else this._currentFlowchartNodeId = this._startFlowchartNode.GetFlowchartId();\n    }\n    GetCurrentNodeOutputCount() {\n      const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);\n      return t ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemCount() : 0;\n    }\n    IsIndexOfDefaultOutput(t) {\n      return !(t < 0) && t === this.GetDefaultOutputIndex();\n    }\n    GetDefaultOutputIndex() {\n      const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);\n      if (!t) return -1;\n      let e = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();\n      return e ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems().indexOf(e) : -1;\n    }\n    GetCurrentNodeOutputNameAt(t) {\n      const e = this._GetFlowchartNodeOutputAt(t);\n      return e ? e.GetName() : \"\";\n    }\n    GetCurrentNodeOutputValueAt(t) {\n      let e;\n      return C33.IsFiniteNumber(t) && (e = this._GetFlowchartNodeOutputAt(t)), \"string\" == typeof t && (e = this._GetFlowchartNodeOutputByName(t)), \"number\" != typeof t && \"string\" != typeof t && console.warn(\"[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression\"), e ? e.GetValue() : \"\";\n    }\n    _MaybeByPassNodes(t, e) {\n      if (t.GetEnable()) return t.GetFlowchartId();\n      {\n        const r = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();\n        if (!r) return e.GetFlowchartId();\n        const a = r.GetConnectedFlowchartNodeFlowchartId();\n        if (!C33.IsFiniteNumber(a)) return e.GetFlowchartId();\n        const o = this.GetFlowchartElementById(a);\n        return o ? this._MaybeByPassNodes(o, e) : e.GetFlowchartId();\n      }\n    }\n    _MaybeByPassNodesInReferenceFlowchart(t, e) {\n      if (t.GetEnable()) {\n        if (\"reference\" === t.GetType()) {\n          const e2 = t.GetReferenceFlowchartName(), r = t.GetReferenceFlowchartStartNodeTag(), a = this._flowchartManager.GetFlowchartDataItemByName(e2);\n          if (!a) return [-1, null];\n          const o = a.GetFlowchartNodeByTags(r);\n          return o ? this._MaybeByPassNodesInReferenceFlowchart(o, a) : this._MaybeByPassNodesInReferenceFlowchart(a.GetFlowchartStartNode(), a);\n        }\n        return [t.GetFlowchartId(), e];\n      }\n      {\n        const r = t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault();\n        if (!r) return [-1, null];\n        const a = r.GetConnectedFlowchartNodeFlowchartId();\n        if (!C33.IsFiniteNumber(a)) return [-1, null];\n        const o = e.GetFlowchartElementById(a);\n        return o ? this._MaybeByPassNodesInReferenceFlowchart(o, e) : [-1, null];\n      }\n    }\n    _ProcessAllByPasses(t, e) {\n      let r = this.GetFlowchartElementById(t);\n      if (r) {\n        if (!r.GetEnable()) {\n          const e2 = this.GetFlowchartElementById(this._currentFlowchartNodeId);\n          t = this._MaybeByPassNodes(r, e2);\n        }\n        if (C33.IsFiniteNumber(t) && t !== this._currentFlowchartNodeId) if (r = this.GetFlowchartElementById(t), \"reference\" === r.GetType()) {\n          const a = r.GetReferenceFlowchartName(), o = r.GetReferenceFlowchartStartNodeTag(), h = this._flowchartManager.GetFlowchartDataItemByName(a);\n          let s = h.GetFlowchartNodeByTags(o);\n          if (s) {\n            const r2 = this._MaybeByPassNodesInReferenceFlowchart(s, h);\n            if (-1 === r2[0]) return;\n            e(this._currentFlowchartNodeId, t, r2[1], r2[0]);\n          } else e(this._currentFlowchartNodeId, t);\n        } else e(this._currentFlowchartNodeId, t);\n      }\n    }\n    GotoNextFlowchartNode(t) {\n      let e;\n      if (C33.IsFiniteNumber(t) && (e = this._GetFlowchartNodeOutputAt(t)), \"string\" == typeof t && (e = this._GetFlowchartNodeOutputByName(t)), !e) return;\n      let r = e.GetConnectedFlowchartNodeFlowchartId();\n      C33.IsFiniteNumber(r) && this._ProcessAllByPasses(r, (t2, e2, r2, a) => {\n        this._previousFlowchartNodeIds.push(t2), this._GotoFlowchartNode(e2, r2, a);\n      });\n    }\n    GotoNextFlowchartNodeDefault() {\n      const t = this._GetFlowchartNodeOutputDefault();\n      if (!t) return;\n      const e = t.GetConnectedFlowchartNodeFlowchartId();\n      C33.IsFiniteNumber(e) && this._ProcessAllByPasses(e, (t2, e2, r, a) => {\n        this._previousFlowchartNodeIds.push(t2), this._GotoFlowchartNode(e2, r, a);\n      });\n    }\n    GotoAnyFlowchartNode(t) {\n      const e = this._flowchartDataItem.GetFlowchartNodeByTags(t);\n      if (!e) return;\n      const r = e.GetFlowchartId();\n      C33.IsFiniteNumber(r) && this._ProcessAllByPasses(r, (t2, e2, r2, a) => {\n        this._previousFlowchartNodeIds.push(t2), this._GotoFlowchartNode(e2, r2, a);\n      });\n    }\n    GotoPreviousFlowchartNode() {\n      const t = this._previousFlowchartNodeIds.pop();\n      C33.IsFiniteNumber(t) ? this._GotoFlowchartNode(t) : this._GetPreviousFlowchartState() && (this._flowchartManager.SetCurrentFlowchartState(this._GetPreviousFlowchartState(), true, false, false), this._GetPreviousFlowchartState()._GotoFlowchartNode(this._GetPreviousFlowchartStateStartNodeId()), this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(this._GetPreviousFlowchartState()));\n    }\n    GotoParentFlowchartNode(t) {\n      if (!this.GetCurrentNode()) return;\n      const e = this.GetCurrentNodeParent(t);\n      if (e) {\n        if (!e.GetEnable()) return;\n        const t2 = e.GetFlowchartId();\n        if (!C33.IsFiniteNumber(t2)) return;\n        this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(e.GetFlowchartId());\n      }\n    }\n    HasOutput(t) {\n      if (C33.IsFiniteNumber(t)) {\n        return !!this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems()[t];\n      }\n      if (\"string\" == typeof t) {\n        const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();\n        for (let r = 0; r < e.length; r++) if (e[r].GetName() === t) return true;\n        return false;\n      }\n      return false;\n    }\n    MarkForRelease() {\n      this._markForRelease = true;\n    }\n    IsInTriggerState() {\n      return this._triggerCount > 0;\n    }\n    PushIsTriggerState() {\n      this._triggerCount++;\n    }\n    PopIsTriggerState() {\n      this._triggerCount--, 0 === this._triggerCount && this._markForRelease && this._flowchartManager.RemoveFlowchartState(this);\n    }\n    _GotoFlowchartNode(t, e, r) {\n      const a = this._currentFlowchartNodeId, o = this.GetPluginInstance().GetInstance();\n      this.PushIsTriggerState(), this._flowchartManager.PushFlowchartState(this), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChange, o), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChange, o), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChangeInFlowchart, o), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChangeInFlowchart, o), this._currentFlowchartNodeId = t;\n      let h = this.GetFlowchartElementById(this._currentFlowchartNodeId);\n      if (\"dictionary\" === h.GetType()) this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChange, o), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChange, o), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, o), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, o);\n      if (this._flowchartManager.PopFlowchartState(), this.PopIsTriggerState(), !this.WasReleased() && (h = this.GetFlowchartElementById(this._currentFlowchartNodeId), \"reference\" === h.GetType())) {\n        const t2 = e ? e.GetName() : h.GetReferenceFlowchartName();\n        if (this._HasReferenceFlowchartState(h)) {\n          this._previousFlowchartNodeIds.pop();\n          const t3 = this._GetReferenceFlowchartState(h);\n          this._flowchartManager.SetCurrentFlowchartState(t3, true, true, false), t3._SetPreviousFlowchart(this, a);\n          this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(t3);\n        } else {\n          const e2 = \"number\" == typeof r ? r : h.GetReferenceFlowchartStartNodeTag();\n          if (t2) {\n            this._previousFlowchartNodeIds.pop();\n            let r2 = h.GetReferenceFlowchartTag();\n            if (r2) {\n              let t3 = this._flowchartManager.GetFlowchartState(r2);\n              for (; t3; ) r2 = C33.IncrementNumberAtEndOf(r2), t3 = this._flowchartManager.GetFlowchartState(r2);\n            } else {\n              r2 = `${t2}-ref`;\n              let e3 = this._flowchartManager.GetFlowchartState(r2);\n              for (; e3; ) r2 = C33.IncrementNumberAtEndOf(r2), e3 = this._flowchartManager.GetFlowchartState(r2);\n            }\n            const o2 = this._flowchartManager.AddFlowchartState(t2, e2, r2, this._pluginInstance, true);\n            o2._SetPreviousFlowchart(this, a), this._SetReferenceFlowchartState(h, o2);\n            const s = this._GetRootFlowchartState();\n            o2._SetRootFlowchartState(s), s._SetCurrentReferenceFlowchart(o2);\n          }\n        }\n      }\n    }\n    _GetFlowchartNodeOutputDefault() {\n      const t = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);\n      return t ? t.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDefault() : null;\n    }\n    _GetFlowchartNodeOutputAt(t) {\n      const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);\n      if (!e) return null;\n      const r = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();\n      if (!r) return null;\n      const a = r[t];\n      return a || null;\n    }\n    _GetFlowchartNodeOutputByName(t) {\n      const e = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);\n      if (!e) return null;\n      const r = e.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemByName(t);\n      return r || null;\n    }\n    _SetStartFlowchartNode(t) {\n      if (\"number\" == typeof t) {\n        let e = this.GetFlowchartElementById(t);\n        e || (e = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = e;\n      } else if (\"number\" == typeof this._startNodeTag) {\n        let t2 = this.GetFlowchartElementById(this._startNodeTag);\n        t2 || (t2 = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = t2;\n      } else {\n        let t2 = this._flowchartDataItem.GetFlowchartNodeByTags(this._startNodeTag);\n        t2 || (t2 = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = t2;\n      }\n    }\n    _SaveToJson() {\n      return this._markForRelease ? null : { \"flowchartName\": this._flowchartName, \"flowchartTag\": this._tag, \"startNodeTag\": this._startNodeTag, \"currentNodeId\": this._currentFlowchartNodeId, \"previousNodeIds\": this._previousFlowchartNodeIds, \"pluginUID\": this._pluginInstance.GetInstance().GetUID(), \"reference\": { \"previousFlowchartTag\": this._GetPreviousFlowchartState() ? this._GetPreviousFlowchartState().GetTag() : \"\", \"previousStartNodeId\": C33.IsFiniteNumber(this._GetPreviousFlowchartStateStartNodeId()) ? this._GetPreviousFlowchartStateStartNodeId() : NaN, \"referencesJson\": this._GetFlowchartReferencesJson(), \"currentReferenceFlowchartTag\": this.GetCurrentReferenceFlowchart() ? this.GetCurrentReferenceFlowchart().GetTag() : \"\", \"rootFlowchartTag\": this._GetRootFlowchartState() ? this._GetRootFlowchartState().GetTag() : \"\" } };\n    }\n    _GetFlowchartReferencesJson() {\n      if (!this._HasReferenceFlowchartStates()) return null;\n      const t = [];\n      for (const [e, r] of this._GetReferenceFlowchartStates().entries()) t.push({ \"flowchartElementId\": e.GetFlowchartId(), \"flowchartStateTag\": r.GetTag() });\n      return t.length ? t : null;\n    }\n    _LoadFromJson(t) {\n      if (t) {\n        if (this._flowchartName = t[\"flowchartName\"], this._tag = t[\"flowchartTag\"], this._startNodeTag = t[\"startNodeTag\"], this._currentFlowchartNodeId = t[\"currentNodeId\"], this._previousFlowchartNodeIds = t[\"previousNodeIds\"], this._pluginUID = t[\"pluginUID\"], t.hasOwnProperty(\"reference\")) {\n          const e = t[\"reference\"];\n          this._previousFlowchartStateTag = e[\"previousFlowchartTag\"], this._previousFlowchartStateStartNodeId = e[\"previousStartNodeId\"], this._referenceFlowchartStatesJson = e[\"referencesJson\"], this._currentReferenceFlowchartStateTag = e[\"currentReferenceFlowchartTag\"], this._rootFlowchartStateTag = e[\"rootFlowchartTag\"];\n        }\n        this._SetStartFlowchartNode();\n      }\n    }\n    _GetPreviousFlowchartState() {\n      return \"string\" == typeof this._previousFlowchartStateTag && this._previousFlowchartStateTag && (this._previousFlowchartState = this._flowchartManager.GetFlowchartState(this._previousFlowchartStateTag), this._previousFlowchartStateTag = \"\"), this._previousFlowchartState;\n    }\n    _GetPreviousFlowchartStateStartNodeId() {\n      return this._previousFlowchartStateStartNodeId;\n    }\n    _SetPreviousFlowchart(t, e) {\n      this._previousFlowchartState = t, this._previousFlowchartStateStartNodeId = e;\n    }\n    GetCurrentReferenceFlowchart() {\n      return \"string\" == typeof this._currentReferenceFlowchartStateTag && this._currentReferenceFlowchartStateTag && (this._currentReferenceFlowchartState = this._flowchartManager.GetFlowchartState(this._currentReferenceFlowchartStateTag), this._currentReferenceFlowchartStateTag = \"\"), this._currentReferenceFlowchartState;\n    }\n    _SetCurrentReferenceFlowchart(t) {\n      this._currentReferenceFlowchartState = t, this._currentReferenceFlowchartState === this && (this._currentReferenceFlowchartState = null);\n    }\n    _GetRootFlowchartState() {\n      return \"string\" == typeof this._rootFlowchartStateTag && this._rootFlowchartStateTag && (this._rootFlowchartState = this._flowchartManager.GetFlowchartState(this._rootFlowchartStateTag), this._rootFlowchartStateTag = \"\"), this._rootFlowchartState ? this._rootFlowchartState : this;\n    }\n    _SetRootFlowchartState(t) {\n      this._rootFlowchartState = t;\n    }\n    _HasReferenceFlowchartStates() {\n      return this._RebuildReferenceFlowchartStates(), !!this._referenceFlowchartStates;\n    }\n    _HasReferenceFlowchartState(t) {\n      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates && this._referenceFlowchartStates.has(t);\n    }\n    _RebuildReferenceFlowchartStates() {\n      if (this._referenceFlowchartStatesJson) {\n        this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map());\n        for (const t of this._referenceFlowchartStatesJson) {\n          const e = this._flowchartManager.GetFlowchartState(t[\"flowchartStateTag\"]), r = e.GetFlowchartElementById(t[\"flowchartElementId\"]);\n          this._referenceFlowchartStates.set(r, e);\n        }\n        this._referenceFlowchartStatesJson = null;\n      }\n    }\n    _GetReferenceFlowchartStates() {\n      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates;\n    }\n    _GetReferenceFlowchartState(t) {\n      return this._RebuildReferenceFlowchartStates(), this._referenceFlowchartStates.get(t);\n    }\n    _SetReferenceFlowchartState(t, e) {\n      this._referenceFlowchartStates || (this._referenceFlowchartStates = /* @__PURE__ */ new Map()), this._referenceFlowchartStates.set(t, e);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.FlowchartStateManager = class {\n    constructor(t) {\n      this._runtime = t, this._flowchartStates = /* @__PURE__ */ new Map(), this._currentFlowchartState = null, this._flowchartStateStack = [], this._on_after_load = () => this._OnAfterLoad(), this._loadJson = null;\n    }\n    Release() {\n      C33.clearArray(this._flowchartStateStack), this._flowchartStateStack = null, this._flowchartStates.clear(), this._flowchartStates = null, this._currentFlowchartState = null, this._runtime = null, this._loadJson = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetFlowchartDataItemByName(t) {\n      return this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(t);\n    }\n    AddFlowchartState(t, e, a, r, h, s) {\n      const o = this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(t);\n      if (!o) return void console.warn(`[Flowcharts] no flowchart found with name '${t}'`);\n      if (this._flowchartStates.has(a)) {\n        const t2 = this._flowchartStates.get(a);\n        t2 && this.RemoveFlowchartState(t2);\n      }\n      const n = new C33.FlowchartState(t, a, e, o, this, r, s);\n      return this._flowchartStates.set(a, n), h && this.SetCurrentFlowchartState(n, true), n;\n    }\n    RemoveFlowchartState(t) {\n      if (t.MarkForRelease(), t.IsInTriggerState()) return;\n      const e = t.GetTag();\n      this._flowchartStates.delete(e), t.Release(), this._currentFlowchartState === t && (this._currentFlowchartState = null);\n    }\n    ResetFlowchartState(t) {\n      t.Reset();\n    }\n    GetFlowchartState(t) {\n      return this._flowchartStates.get(t);\n    }\n    PushFlowchartState(t) {\n      this._flowchartStateStack.push(t);\n    }\n    PopFlowchartState() {\n      this._flowchartStateStack.pop();\n    }\n    SetCurrentFlowchartState(t, e = false, a = false, r = true) {\n      if (r) {\n        const e2 = t.GetCurrentReferenceFlowchart();\n        t = e2 || t;\n      }\n      t !== this._currentFlowchartState && (this._TriggerBeforeFlowchartChange(), this._TriggerAfterFlowchartChange(t, e, a));\n    }\n    GetCurrentFlowchartState(t) {\n      return \"string\" == typeof t ? this.GetFlowchartState(t) : this._flowchartStateStack.length ? this._flowchartStateStack[this._flowchartStateStack.length - 1] : this._currentFlowchartState;\n    }\n    _TriggerBeforeFlowchartChange() {\n      if (!this._currentFlowchartState) return;\n      if (this._currentFlowchartState.WasReleased()) return;\n      const t = this._currentFlowchartState.GetPluginInstance().GetInstance();\n      this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnBeforeFlowchartChange, t), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();\n    }\n    _TriggerAfterFlowchartChange(t, e = false, a = false) {\n      if (this._currentFlowchartState = t, !this._currentFlowchartState) return;\n      if (this._currentFlowchartState.WasReleased()) return;\n      const r = this._currentFlowchartState.GetPluginInstance().GetInstance();\n      this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnFlowchartChange, r), true !== a && \"number\" != typeof a || this._currentFlowchartState._SetStartFlowchartNode(a), e && (this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChange, r), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChange, r), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, r), this._runtime.Trigger(C33.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, r)), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState();\n    }\n    _SaveToJson() {\n      return { \"flowchartJsonObjects\": [...this._flowchartStates.values()].map((t) => t._SaveToJson()), \"currentFlowchartTag\": this._currentFlowchartState ? this._currentFlowchartState.GetTag() : null };\n    }\n    _LoadFromJson(t) {\n      if (!t) return;\n      this._loadJson = t;\n      const e = /* @__PURE__ */ new Map();\n      for (const t2 of this._loadJson[\"flowchartJsonObjects\"]) {\n        const a = t2[\"flowchartTag\"];\n        if (this._flowchartStates.has(a)) {\n          const r = this._flowchartStates.get(a);\n          r._LoadFromJson(t2), e.set(a, r);\n        } else {\n          const a2 = this.AddFlowchartState(t2[\"flowchartName\"], t2[\"startNodeTag\"], t2[\"flowchartTag\"], null, false, t2[\"pluginUID\"]);\n          a2._LoadFromJson(t2), e.set(t2[\"flowchartTag\"], a2);\n        }\n      }\n      for (const [t2, a] of this._flowchartStates.entries()) e.has(t2) || a.Release();\n      this._flowchartStates.clear(), this._flowchartStates = e, this._runtime.IsLoadingState() ? this._runtime.Dispatcher().addEventListener(\"afterload\", this._on_after_load) : this._OnAfterLoad();\n    }\n    _OnAfterLoad() {\n      this._runtime.Dispatcher().removeEventListener(\"afterload\", this._on_after_load);\n      const t = this._flowchartStates.get(this._loadJson[\"currentFlowchartTag\"]);\n      t && this.SetCurrentFlowchartState(t, true), this._loadJson = null;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.FlowchartDataManager = class {\n    constructor() {\n      this._flowchartDataItems = /* @__PURE__ */ new Map();\n    }\n    Release() {\n      for (const t of this._flowchartDataItems.values()) t.Release();\n      this._flowchartDataItems.clear(), this._flowchartDataItems = null;\n    }\n    Add(t) {\n      const a = new C33.FlowchartDataItem(t), s = a.GetName();\n      this._flowchartDataItems.set(s, a);\n    }\n    Get(t) {\n      return this._flowchartDataItems.get(t);\n    }\n    HasFlowcharts() {\n      return !!this._flowchartDataItems.size;\n    }\n    static CreateDataItems(t, a, s, e) {\n      if (a) for (const o of a) {\n        const a2 = new s(o, e);\n        t.push(a2);\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3, NAME = 0, NODES = 1;\n  C33.FlowchartDataItem = class {\n    constructor(t) {\n      this._name = t[0], this._flowchartNodeData = new C33.FlowchartNodeData(t[1], this);\n    }\n    Release() {\n      this._flowchartNodeData.Release(), this._flowchartNodeData = null;\n    }\n    GetFlowchartNodeData() {\n      return this._flowchartNodeData;\n    }\n    GetFlowchartElementById(t) {\n      return this._flowchartNodeData.GetFlowchartElementById(t);\n    }\n    GetFlowchartNodeByTags(t) {\n      return this._flowchartNodeData.GetFlowchartNodeByTags(t);\n    }\n    GetFlowchartStartNode() {\n      return this._flowchartNodeData.GetFlowchartStartNode();\n    }\n    GetName() {\n      return this._name;\n    }\n  };\n}\n{\n  const C33 = self.C3, FLOWCHART_ID = 0, TAG = 1, PARENT_FLOWCHART_IDS = 2, PARENT_OUTPUT_FLOWCHART_IDS = 3, CHILDREN_FLOWCHART_IDS = 4, OUTPUTS = 5, IS_START = 6, TYPE = 7, DICTIONARY_ENABLE = 8, REFERENCE_FLOWCHART = 8, REFERENCE_FLOWCHART_START_NODE = 9, REFERENCE_FLOWCHART_TAG = 10, REFERENCE_FLOWCHART_ENABLE = 11;\n  class FlowchartNodeDataItem {\n    constructor(t, e) {\n      this._flowchartNodeData = e, this._type = t[7], this._flowchartId = t[0], this._tag = t[1], this._tag ? this._tags = this._tag.trim().split(\" \").map((t2) => t2.trim()) : this._tags = [], this._parentFlowchartIds = t[2], this._parentOutputFlowchartIds = null, this._childrenFlowchartIds = null, this._enable = false, \"dictionary\" === this._type && (this._parentOutputFlowchartIds = t[3], this._childrenFlowchartIds = t[4], this._enable = t[8]), this._isStart = t[6], this._referenceFlowchartName = null, this._referenceFlowchartStartNodeTag = null, this._referenceFlowchartTag = null, \"reference\" === this._type && (this._referenceFlowchartName = t[8], this._referenceFlowchartStartNodeTag = t[9], this._referenceFlowchartTag = t[10], this._enable = t[11]), this._flowchartNodeOutputData = new C33.FlowchartNodeOutputData(t[5], this);\n    }\n    Release() {\n      this._flowchartNodeData = null;\n    }\n    GetFlowchartNodeData() {\n      return this._flowchartNodeData;\n    }\n    GetFlowchartNodeOutputData() {\n      return this._flowchartNodeOutputData;\n    }\n    GetFlowchartId() {\n      return this._flowchartId;\n    }\n    GetTag() {\n      return this._tag;\n    }\n    GetTags() {\n      return this._tags;\n    }\n    HasTags(t) {\n      if (!this._tags) return false;\n      if (!this._tags.length) return false;\n      const e = C33.FlowchartState._GetTagArray(t);\n      return !(!e || !e.length) && e.every(C33.FlowchartState._HasTag, this._tags);\n    }\n    GetIsStart() {\n      return this._isStart;\n    }\n    SetIsStart(t) {\n      this._isStart = !!t;\n    }\n    CanBeStartNode() {\n      if (\"dictionary\" === this._type) return true;\n      if (\"reference\" === this._type) return false;\n      throw new Error(`unexpected flowchart node type: ${this._type}`);\n    }\n    GetParentFlowchartIds() {\n      return this._parentFlowchartIds;\n    }\n    GetParentOutputFlowchartIds() {\n      return this._parentOutputFlowchartIds;\n    }\n    GetChildrenFlowchartIds() {\n      return this._childrenFlowchartIds;\n    }\n    GetType() {\n      return this._type;\n    }\n    GetEnable() {\n      return this._enable;\n    }\n    GetReferenceFlowchartName() {\n      return this._referenceFlowchartName;\n    }\n    GetReferenceFlowchartStartNodeTag() {\n      return this._referenceFlowchartStartNodeTag;\n    }\n    GetReferenceFlowchartTag() {\n      return this._referenceFlowchartTag;\n    }\n  }\n  C33.FlowchartNodeData = class {\n    constructor(t, e) {\n      this._flowchartDataItem = e, this._flowchartNodeItems = [], this._flowchartNodeItemsIdMap = /* @__PURE__ */ new Map(), this._flowchartNodeItemsTagMap = /* @__PURE__ */ new Map(), this._flowchartNodeStartItem = null, C33.FlowchartDataManager.CreateDataItems(this._flowchartNodeItems, t, FlowchartNodeDataItem, this);\n      for (const t2 of this._flowchartNodeItems) {\n        const e2 = t2.GetFlowchartId(), a = t2.GetTag(), r = t2.GetTags(), s = t2.GetIsStart();\n        if (this._flowchartNodeItemsIdMap.set(e2, t2), a) for (const e3 of r) this._flowchartNodeItemsTagMap.has(e3) || this._flowchartNodeItemsTagMap.set(e3, /* @__PURE__ */ new Set()), this._flowchartNodeItemsTagMap.get(e3).add(t2);\n        s && (this._flowchartNodeStartItem = t2);\n        const o = t2.GetFlowchartNodeOutputData();\n        for (const t3 of o.flowchartNodeOutputDataItems()) {\n          const e3 = t3.GetFlowchartId();\n          this._flowchartNodeItemsIdMap.set(e3, t3);\n        }\n      }\n      this._flowchartNodeStartItem || this._SetStartNodeIfMissing();\n    }\n    Release() {\n      this._flowchartDataItem = null;\n      for (const t of this._flowchartNodeItems) t.Release();\n      C33.clearArray(this._flowchartNodeItems), this._flowchartNodeItems = null;\n    }\n    GetFlowchartDataItem() {\n      return this._flowchartDataItem;\n    }\n    GetFlowchartElementById(t) {\n      return this._flowchartNodeItemsIdMap.get(t);\n    }\n    GetFlowchartNodeByTags(t) {\n      if (!t || !t.length) return null;\n      const e = [];\n      for (const a of t.trim().split(\" \")) {\n        let t2 = this._flowchartNodeItemsTagMap.get(a.trim()) ?? /* @__PURE__ */ new Set();\n        if (0 === t2.size) return null;\n        e.push(t2);\n      }\n      return [...e.reduce((t2, e2) => e2.size < t2.size ? e2 : t2)].filter((t2) => e.every((e2) => e2.has(t2)))[0];\n    }\n    GetFlowchartStartNode() {\n      return this._flowchartNodeStartItem;\n    }\n    *flowchartNodeDataItems() {\n      for (const t of this._flowchartNodeItems) yield t;\n    }\n    _SetStartNodeIfMissing() {\n      let t = 0;\n      for (const e of this.flowchartNodeDataItems()) e.GetIsStart() && t++;\n      if (0 === t) {\n        for (const t2 of this.flowchartNodeDataItems()) if (t2.CanBeStartNode() && !t2.GetIsStart()) return void t2.SetIsStart(true);\n      } else {\n        if (1 === t) return;\n        if (t > 1) {\n          let t2 = true;\n          for (const e of this.flowchartNodeDataItems()) e.CanBeStartNode() && (e.GetIsStart() && t2 ? t2 = false : e.GetIsStart() && !t2 && e.SetIsStart(false));\n        }\n      }\n      for (const t2 of this.flowchartNodeDataItems()) if (t2.CanBeStartNode() && t2.GetIsStart()) return void (this._flowchartNodeStartItem = t2);\n    }\n  };\n}\n{\n  const C33 = self.C3, FLOWCHART_ID = 0, NAME = 1, VALUE = 2, CONNECTED_FLOWCHART_NODE_FLOWCHART_ID = 3, ENABLE = 4, DEFAULT = 5;\n  class FlowchartNodeDataOutputItem {\n    constructor(t, e) {\n      this._flowchartNodeOutputData = e, this._flowchartId = t[0], this._name = t[1], this._value = t[2], this._connectedFlowchartNodeFlowchartId = t[3], this._enable = t[4], this._default = t[5];\n    }\n    Release() {\n      this._flowchartNodeOutputData = null;\n    }\n    GetFlowchartNodeOutputData() {\n      return this._flowchartNodeOutputData;\n    }\n    GetFlowchartId() {\n      return this._flowchartId;\n    }\n    GetName() {\n      return this._name;\n    }\n    GetValue() {\n      return this._value;\n    }\n    GetConnectedFlowchartNodeFlowchartId() {\n      return this._connectedFlowchartNodeFlowchartId;\n    }\n    GetEnable() {\n      return this._enable;\n    }\n    GetDefault() {\n      return this._default;\n    }\n  }\n  C33.FlowchartNodeOutputData = class {\n    constructor(t, e) {\n      this._flowchartDataNodeItem = e, this._flowchartNodeOutputItems = [], this._flowchartNodeOutputItemsNameMap = /* @__PURE__ */ new Map(), C33.FlowchartDataManager.CreateDataItems(this._flowchartNodeOutputItems, t, FlowchartNodeDataOutputItem, this), this._enabledFlowchartNodeOutputItems = this._flowchartNodeOutputItems.filter((t2) => t2.GetEnable());\n      for (const t2 of this._enabledFlowchartNodeOutputItems) this._flowchartNodeOutputItemsNameMap.set(t2.GetName(), t2);\n    }\n    Release() {\n      this._flowchartDataNodeItem = null;\n      for (const t of this._flowchartNodeOutputItems) t.Release();\n      C33.clearArray(this._flowchartNodeOutputItems), this._flowchartNodeOutputItems = null, C33.clearArray(this._enabledFlowchartNodeOutputItems), this._enabledFlowchartNodeOutputItems = null;\n    }\n    GetFlowchartNodeDataItem() {\n      return this._flowchartDataNodeItem;\n    }\n    GetFlowchartNodeOutputDataItemCount() {\n      return this._enabledFlowchartNodeOutputItems.length;\n    }\n    GetFlowchartNodeOutputDataItems() {\n      return this._enabledFlowchartNodeOutputItems;\n    }\n    GetFlowchartNodeOutputDataItemByName(t) {\n      return this._flowchartNodeOutputItemsNameMap.get(t);\n    }\n    GetFlowchartNodeOutputDefault() {\n      for (const t of this._enabledFlowchartNodeOutputItems) if (t.GetDefault()) return t;\n    }\n    *flowchartNodeOutputDataItems() {\n      for (const t of this._enabledFlowchartNodeOutputItems) yield t;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.SolStack = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._objectClass = t, this._stack = [], this._stack.push(C33.New(C33.Sol, this)), this._index = 0, this._current = this._stack[0];\n    }\n    Release() {\n      for (const t of this._stack) t.Release();\n      C33.clearArray(this._stack), this._current = null, this._objectClass = null;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetCurrentSol() {\n      return this._current;\n    }\n    GetOneBelowCurrentSol() {\n      return this._stack[this._index - 1];\n    }\n    Clear() {\n      this.GetCurrentSol().Clear();\n    }\n    PushClean() {\n      const t = this._stack, s = ++this._index;\n      if (s === t.length) {\n        const s2 = C33.New(C33.Sol, this);\n        t.push(s2), this._current = s2;\n      } else {\n        const e = t[s];\n        e.Reset(), this._current = e;\n      }\n    }\n    PushCopy() {\n      const t = this._stack, s = ++this._index;\n      s === t.length && t.push(C33.New(C33.Sol, this));\n      const e = t[s];\n      e.Copy(t[s - 1]), this._current = e;\n    }\n    Pop() {\n      this._current = this._stack[--this._index];\n    }\n    RemoveInstances(t) {\n      const s = this._stack;\n      for (let e = 0, n = s.length; e < n; ++e) s[e].RemoveInstances(t);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Sol = class extends C33.DefendedBase {\n    constructor(s) {\n      super(), this._stack = s, this._objectClass = this._stack.GetObjectClass(), this._eventStack = this._objectClass.GetRuntime().GetEventStack(), this._selectAll = true, this._instances = [], this._elseInstances = [];\n    }\n    Release() {\n      this.ClearArrays(), this._stack = null, this._objectClass = null, this._eventStack = null;\n    }\n    ClearArrays() {\n      C33.clearArray(this._instances), C33.clearArray(this._elseInstances);\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    IsSelectAll() {\n      return this._selectAll;\n    }\n    HasAnyInstances() {\n      return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length;\n    }\n    GetInstances() {\n      return this._selectAll ? this._objectClass.GetInstances() : this._instances;\n    }\n    HasAnyElseInstances() {\n      return !!this._elseInstances.length;\n    }\n    GetElseInstances() {\n      return this._elseInstances;\n    }\n    GetExpressionInstances() {\n      const s = this.GetInstances();\n      return s.length ? s : this._elseInstances;\n    }\n    Reset() {\n      this._selectAll = true, C33.clearArray(this._elseInstances);\n    }\n    Clear() {\n      this._selectAll = true;\n    }\n    Copy(s) {\n      s.IsSelectAll() ? this.Reset() : (this._selectAll = false, C33.shallowAssignArray(this._instances, s._instances), C33.clearArray(this._elseInstances));\n    }\n    _PushInstance(s) {\n      this._instances.push(s);\n    }\n    _PushElseInstance(s) {\n      this._elseInstances.push(s);\n    }\n    _SetSelectAll(s) {\n      this._selectAll = !!s;\n    }\n    _GetOwnInstances() {\n      return this._instances;\n    }\n    _GetOwnElseInstances() {\n      return this._elseInstances;\n    }\n    SetSinglePicked(s) {\n      this._selectAll = false, C33.clearArray(this._instances), this._instances.push(s);\n    }\n    SetArrayPicked(s) {\n      this._selectAll = false, C33.shallowAssignArray(this._instances, s);\n    }\n    SetSetPicked(s) {\n      this._selectAll = false, C33.clearArray(this._instances);\n      for (const e of s) this._instances.push(e);\n    }\n    AddElseInstances(s, e) {\n      for (const t of e) s.has(t) || this._elseInstances.push(t);\n    }\n    TransferElseInstancesToOwn(s) {\n      for (const e of s) this._instances.push(e);\n      C33.arrayRemoveAllInSet(this._elseInstances, s);\n    }\n    ClearElseInstances() {\n      C33.clearArray(this._elseInstances);\n    }\n    PickOne(s) {\n      if (s) if (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()) {\n        this.IsSelectAll() && (C33.clearArray(this._instances), C33.shallowAssignArray(this._elseInstances, s.GetObjectClass().GetInstances()), this._selectAll = false);\n        const e = this._elseInstances.indexOf(s);\n        -1 !== e && (this._instances.push(this._elseInstances[e]), this._elseInstances.splice(e, 1));\n      } else this.SetSinglePicked(s);\n    }\n    RemoveInstances(s) {\n      C33.arrayRemoveAllInSet(this._instances, s), C33.arrayRemoveAllInSet(this._elseInstances, s);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.EventStack = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._stack.push(C33.New(C33.EventStackFrame, this, null)), this._index = 0, this._expFuncStack = [];\n    }\n    Release() {\n      for (const t of this._stack) t.Release();\n      C33.clearArray(this._stack), C33.clearArray(this._expFuncStack), this._eventSheetManager = null, this._runtime = null;\n    }\n    GetEventSheetManager() {\n      return this._eventSheetManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetCurrentStackFrame() {\n      return this._stack[this._index];\n    }\n    GetAllStackFrames() {\n      return this._stack;\n    }\n    GetCurrentStackFrameIndex() {\n      return this._index;\n    }\n    Push(t) {\n      const e = this._stack, n = ++this._index;\n      if (n === e.length) {\n        const n2 = C33.New(C33.EventStackFrame, this, t);\n        return e.push(n2), n2;\n      }\n      {\n        const s = e[n];\n        return s.Reset(t), s;\n      }\n    }\n    Pop() {\n      --this._index;\n    }\n    PushExpFunc(t) {\n      this._expFuncStack.push(t);\n    }\n    PopExpFunc() {\n      this._expFuncStack.pop();\n    }\n    GetCurrentExpFuncStackFrame() {\n      const t = this._expFuncStack;\n      return 0 === t.length ? null : t.at(-1);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.EventStackFrame = class extends C33.DefendedBase {\n    constructor(t, e) {\n      super(), this._stack = t, this._runtime = this._stack.GetRuntime(), this._currentEvent = e, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._expressionObjectClass = null, this._functionReturnType = 0, this._functionReturnValue = 0, this._dynamicSolModifiers = null;\n    }\n    Release() {\n      this.Reset(null), this._stack = null, this._runtime = null;\n    }\n    Reset(t) {\n      this._currentEvent = t, this._cndIndex = 0, this._actIndex = 0, this._lastEventTrue = false, this._elseBranchRan = false, this._dynamicSolModifiers = null;\n    }\n    _Restore(t, e) {\n      this._currentEvent = t, this._cndIndex = 0, this._actIndex = e;\n    }\n    ResetQuick() {\n      this._cndIndex = 0, this._actIndex = 0;\n    }\n    GetCurrentEvent() {\n      return this._currentEvent;\n    }\n    SetCurrentEvent(t) {\n      this._currentEvent = t;\n    }\n    GetConditionIndex() {\n      return this._cndIndex;\n    }\n    SetConditionIndex(t) {\n      this._cndIndex = t;\n    }\n    GetActionIndex() {\n      return this._actIndex;\n    }\n    SetActionIndex(t) {\n      this._actIndex = t;\n    }\n    SetLastEventTrue(t) {\n      this._lastEventTrue = !!t;\n    }\n    GetLastEventTrue() {\n      return this._lastEventTrue;\n    }\n    SetElseBranchRan(t) {\n      this._elseBranchRan = !!t;\n    }\n    GetElseBranchRan() {\n      return this._elseBranchRan;\n    }\n    SetExpressionObjectClass(t) {\n      this._expressionObjectClass = t;\n    }\n    GetExpressionObjectClass() {\n      return this._expressionObjectClass;\n    }\n    InitCallFunctionExpression(t, e) {\n      this._functionReturnType = t, this._functionReturnValue = e;\n    }\n    GetFunctionReturnType() {\n      return this._functionReturnType;\n    }\n    SetFunctionReturnValue(t) {\n      this._functionReturnValue = t;\n    }\n    GetFunctionReturnValue() {\n      return this._functionReturnValue;\n    }\n    IsSolModifierAfterCnds() {\n      const t = this._currentEvent;\n      return !!t.IsSolWriterAfterCnds() || this._cndIndex < t.GetConditionCount() - 1 && !!t.GetSolModifiers().length;\n    }\n    SetDynamicSolModifiers(t) {\n      this._dynamicSolModifiers = t;\n    }\n    GetDynamicSolModifiers() {\n      return this._dynamicSolModifiers;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.LocalVarStack = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1, this._current = null, this._initialValues = [];\n    }\n    Release() {\n      C33.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;\n    }\n    _SetInitialValues(t) {\n      this._initialValues = t;\n      const e = this._initialValues.slice(0);\n      this._stack.push(e), this._index = 0, this._current = e;\n    }\n    GetEventSheetManager() {\n      return this._eventSheetManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetCurrent() {\n      return this._current;\n    }\n    Push() {\n      const t = ++this._index, e = this._stack;\n      t === e.length ? e.push(this._initialValues.slice(0)) : C33.shallowAssignArray(e[t], this._initialValues), this._current = e[t];\n    }\n    Pop() {\n      this._current = this._stack[--this._index];\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.LoopStack = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._eventSheetManager = t, this._runtime = this._eventSheetManager.GetRuntime(), this._stack = [], this._index = -1;\n    }\n    Release() {\n      C33.clearArray(this._stack), this._eventSheetManager = null, this._runtime = null;\n    }\n    GetEventSheetManager() {\n      return this._eventSheetManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    IsInLoop() {\n      return this._index >= 0;\n    }\n    GetCurrent() {\n      return this._stack[this._index];\n    }\n    Push() {\n      if (++this._index, this._index === this._stack.length) {\n        const t = C33.New(C33.Loop, this);\n        return this._stack.push(t), t;\n      }\n      {\n        const t = this._stack[this._index];\n        return t.Reset(), t;\n      }\n    }\n    Pop() {\n      --this._index;\n    }\n    FindByName(t) {\n      const e = this._stack;\n      for (let s = this._index; s >= 0; --s) {\n        const n = e[s];\n        if (n.GetName() === t) return n;\n      }\n      return null;\n    }\n    _GetStack() {\n      return this._stack.slice(0, this._index + 1);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Loop = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._loopStack = e, this._name = \"\", this._index = 0, this._isStopped = false, this._end = NaN;\n    }\n    Reset() {\n      this._name = \"\", this._index = 0, this._isStopped = false, this._end = NaN;\n    }\n    SetName(e) {\n      this._name = e;\n    }\n    GetName() {\n      return this._name;\n    }\n    SetIndex(e) {\n      this._index = e;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    Stop() {\n      this._isStopped = true;\n    }\n    IsStopped() {\n      return this._isStopped;\n    }\n    SetEnd(e) {\n      this._end = e;\n    }\n    GetEnd() {\n      return this._end;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.ArrayStack = class extends C33.DefendedBase {\n    constructor() {\n      super(), this._stack = [], this._index = -1;\n    }\n    Release() {\n      C33.clearArray(this._stack);\n    }\n    GetCurrent() {\n      return this._stack[this._index];\n    }\n    Push() {\n      if (++this._index, this._index === this._stack.length) {\n        const s = [];\n        return this._stack.push(s), s;\n      }\n      return this._stack[this._index];\n    }\n    Pop() {\n      --this._index;\n    }\n  };\n}\n{\n  let SortSolArray = function(t, e) {\n    return t.GetIndex() - e.GetIndex();\n  }, IsSolArrayIdentical = function(t, e) {\n    for (let s = 0, n = t.length; s < n; ++s) if (t[s] !== e[s]) return false;\n    return true;\n  };\n  SortSolArray2 = SortSolArray, IsSolArrayIdentical2 = IsSolArrayIdentical;\n  const C33 = self.C3, assert = self.assert;\n  C33.EventSheetManager = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._runtime = t, this._allSheets = [], this._sheetsByName = /* @__PURE__ */ new Map(), this._allGroups = [], this._groupsByName = /* @__PURE__ */ new Map(), this._blocksBySid = /* @__PURE__ */ new Map(), this._cndsBySid = /* @__PURE__ */ new Map(), this._actsBySid = /* @__PURE__ */ new Map(), this._allUniqueSolModifiers = /* @__PURE__ */ new Map(), this._eventVarsBySid = /* @__PURE__ */ new Map(), this._nextLocalVarIndex = 0, this._allGlobalVars = [], this._allLocalVars = [], this._localVarInitialValues = [], this._functionBlocksByName = /* @__PURE__ */ new Map(), this._customActionBlocksMap = /* @__PURE__ */ new Map(), this._eventStack = C33.New(C33.EventStack, this), this._localVarStack = C33.New(C33.LocalVarStack, this), this._loopStack = C33.New(C33.LoopStack, this), this._triggersToPostInit = [], this._queuedTriggers = [], this._queuedDebugTriggers = [], this._runningEventsDepth = 0, this._executingTriggerDepth = 0, this._blockFlushingDepth = 0, this._scheduledWaits = [], this._asyncActionPromises = [], this._signalTags = [], this._signalPromises = /* @__PURE__ */ new Map(), this._instSignals = /* @__PURE__ */ new Map(), self[\"c3_callFunction\"] = (t2, e) => this._InvokeFunctionFromJS(t2, e);\n    }\n    Release() {\n      this.ClearAllScheduledWaits(), this._eventStack.Release(), this._eventStack = null, this._localVarStack.Release(), this._localVarStack = null, C33.clearArray(this._queuedTriggers), C33.clearArray(this._queuedDebugTriggers), this._runtime = null, C33.clearArray(this._allSheets), this._sheetsByName.clear();\n    }\n    Create(t) {\n      const e = C33.New(C33.EventSheet, this, t);\n      this._allSheets.push(e), this._sheetsByName.set(e.GetName().toLowerCase(), e);\n    }\n    _AddTriggerToPostInit(t) {\n      this._triggersToPostInit.push(t);\n    }\n    _PostInit() {\n      for (const t of this._customActionBlocksMap.values()) t._CheckOverrideState();\n      for (const t of this._functionBlocksByName.values()) t._PostInit();\n      for (const t of this._customActionBlocksMap.values()) t._PostInit();\n      for (const t of this._allSheets) t._PostInit();\n      for (const t of this._allSheets) t._UpdateDeepIncludes();\n      for (const t of this._triggersToPostInit) t._PostInit(false);\n      C33.clearArray(this._triggersToPostInit), this._localVarStack._SetInitialValues(this._localVarInitialValues);\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetEventSheetByName(t) {\n      return this._sheetsByName.get(t.toLowerCase()) || null;\n    }\n    _RegisterGroup(t) {\n      this._allGroups.push(t), this._groupsByName.set(t.GetGroupName(), t);\n    }\n    _RegisterEventBlock(t) {\n      this._blocksBySid.set(t.GetSID(), t);\n    }\n    _RegisterCondition(t) {\n      this._cndsBySid.set(t.GetSID(), t);\n    }\n    _RegisterAction(t) {\n      this._actsBySid.set(t.GetSID(), t);\n    }\n    _RegisterFunctionBlock(t) {\n      switch (t.GetFunctionType()) {\n        case 0:\n          this._functionBlocksByName.set(t.GetFunctionName().toLowerCase(), t);\n          break;\n        case 1:\n          this._customActionBlocksMap.set(t.GetFunctionName().toLowerCase(), t);\n      }\n    }\n    _RegisterEventVariable(t) {\n      this._eventVarsBySid.set(t.GetSID(), t), t.IsGlobal() ? this._allGlobalVars.push(t) : this._allLocalVars.push(t);\n    }\n    _DeduplicateSolModifierList(t) {\n      t.length >= 2 && t.sort(SortSolArray);\n      let e = this._allUniqueSolModifiers.get(t.length);\n      e || (e = [], this._allUniqueSolModifiers.set(t.length, e));\n      for (let s = 0, n = e.length; s < n; ++s) {\n        const n2 = e[s];\n        if (IsSolArrayIdentical(t, n2)) return n2;\n      }\n      return e.push(t), t;\n    }\n    _GetNextLocalVarIndex(t) {\n      return this._localVarInitialValues.push(t.GetInitialValue()), this._nextLocalVarIndex++;\n    }\n    GetEventStack() {\n      return this._eventStack;\n    }\n    GetCurrentEventStackFrame() {\n      return this.GetEventStack().GetCurrentStackFrame();\n    }\n    GetCurrentEvent() {\n      return this.GetCurrentEventStackFrame().GetCurrentEvent();\n    }\n    GetCurrentCondition() {\n      const t = this.GetCurrentEventStackFrame();\n      return t.GetCurrentEvent().GetConditionAt(t.GetConditionIndex());\n    }\n    GetCurrentAction() {\n      const t = this.GetCurrentEventStackFrame();\n      return t.GetCurrentEvent().GetActionAt(t.GetActionIndex());\n    }\n    GetLocalVarStack() {\n      return this._localVarStack;\n    }\n    GetLoopStack() {\n      return this._loopStack;\n    }\n    GetAllLocalVariablesInScope(t) {\n      const e = [];\n      for (t = t.GetScopeParent(); t; ) C33.appendArray(e, t._GetAllLocalVariablesInScope()), t = t.GetScopeParent();\n      return e;\n    }\n    _GetLocalVariablesScriptInterface(t) {\n      const e = {};\n      for (const s of this.GetAllLocalVariablesInScope(t)) e[s.GetJsPropName()] = s._GetScriptInterfaceDescriptor();\n      return Object.create(Object.prototype, e);\n    }\n    GetEventVariableBySID(t) {\n      return this._eventVarsBySid.get(t) || null;\n    }\n    GetEventBlockBySID(t) {\n      return this._blocksBySid.get(t) || null;\n    }\n    GetConditionBySID(t) {\n      return this._cndsBySid.get(t) || null;\n    }\n    GetActionBySID(t) {\n      return this._actsBySid.get(t) || null;\n    }\n    GetFunctionBlockByName(t) {\n      return this._functionBlocksByName.get(t.toLowerCase()) || null;\n    }\n    GetCustomActionBlockByName(t, e) {\n      let s = this._customActionBlocksMap.get((t.GetName() + \".\" + e).toLowerCase());\n      if (s) return s;\n      if (!t.IsFamily()) {\n        for (const n of t.GetFamilies()) if (s = this._customActionBlocksMap.get((n.GetName() + \".\" + e).toLowerCase()), s) return s;\n      }\n      return null;\n    }\n    GetAllGlobalVariables() {\n      return this._allGlobalVars;\n    }\n    GetAllLocalVariables() {\n      return this._allLocalVars;\n    }\n    ResetAllGlobalsToInitialValue(t) {\n      for (const t2 of this._allGlobalVars) t2.ResetToInitialValue();\n      if (t) for (const t2 of this._allLocalVars) t2.IsStatic() && t2.ResetToInitialValue();\n    }\n    GetEventGroupByName(t) {\n      return this._groupsByName.get(t.toLowerCase()) || null;\n    }\n    GetEventGroupBySID(t) {\n      const e = this._blocksBySid.get(t);\n      return e && e.IsGroup() ? e : null;\n    }\n    GetAllGroups() {\n      return this._allGroups;\n    }\n    ResetAllGroupsInitialActivation() {\n      for (const t of this._allGroups) t.ResetInitialActivation();\n    }\n    _ResetAllHasRunFlags() {\n      for (const t of this._allSheets) t._ResetHasRunFlag();\n    }\n    RunEvents(t) {\n      this._ResetAllHasRunFlags(), this._runningEventsDepth++;\n      for (const e of t.runningLayouts()) {\n        const t2 = e.GetEventSheet();\n        t2 && (this._runtime.PushCurrentLayout(e), t2.Run(), this._runtime.PopCurrentLayout());\n      }\n      this._runningEventsDepth--;\n    }\n    async DebugRunEvents(t) {\n      this._ResetAllHasRunFlags(), this._runningEventsDepth++;\n      for (const e of this._DebugRunEventsGen(t)) await this._runtime.DebugBreak(e);\n      this._runningEventsDepth--;\n    }\n    *_DebugRunEventsGen(t) {\n      for (const e of t.runningLayouts()) {\n        const t2 = e.GetEventSheet();\n        t2 && (this._runtime.PushCurrentLayout(e), yield* t2.DebugRun(), this._runtime.PopCurrentLayout());\n      }\n    }\n    _Trigger(t, e, s, n) {\n      let i = false;\n      if (!t.GetMainRunningLayout()) return this.QueueTrigger(e, s, n);\n      this._executingTriggerDepth++;\n      for (const r of t.runningLayouts()) {\n        const t2 = r.GetEventSheet();\n        if (!t2) continue;\n        this._runtime.PushCurrentLayout(r);\n        for (const r2 of t2.deepIncludes()) {\n          const t3 = r2._Trigger(e, s, n);\n          i = i || t3;\n        }\n        const o = t2._Trigger(e, s, n);\n        i = i || o, this._runtime.PopCurrentLayout();\n      }\n      return this._executingTriggerDepth--, i;\n    }\n    *_DebugTrigger(t, e, s, n) {\n      let i = false;\n      if (!t.GetMainRunningLayout()) return this.QueueTrigger(e, s, n);\n      this._executingTriggerDepth++;\n      for (const r of t.runningLayouts()) {\n        const t2 = r.GetEventSheet();\n        if (!t2) continue;\n        this._runtime.PushCurrentLayout(r);\n        for (const r2 of t2.deepIncludes()) {\n          const t3 = yield* r2._DebugTrigger(e, s, n);\n          i = i || t3;\n        }\n        const o = yield* t2._DebugTrigger(e, s, n);\n        i = i || o, this._runtime.PopCurrentLayout();\n      }\n      return this._executingTriggerDepth--, i;\n    }\n    QueueTrigger(t, e, s) {\n      return this._queuedTriggers.push([t, e, s]), false;\n    }\n    QueueDebugTrigger(t, e, s) {\n      let n = null;\n      const i = new Promise((t2) => n = t2);\n      return this._queuedDebugTriggers.push([t, e, s, n]), i;\n    }\n    *_RunQueuedDebugTriggersGen() {\n      if (this._runtime.HitBreakpoint()) throw new Error(\"should not be in breakpoint\");\n      const t = this._runtime.GetLayoutManager();\n      for (; this._queuedDebugTriggers.length; ) {\n        const [e, s, n, i] = this._queuedDebugTriggers.shift();\n        i(yield* this._DebugTrigger(t, e, s, n));\n      }\n    }\n    async RunQueuedDebugTriggersAsync() {\n      for (const t of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(t);\n    }\n    _FastTrigger(t, e, s, n) {\n      let i = false;\n      const r = t.GetMainRunningLayout(), o = r.GetEventSheet();\n      if (!o) return;\n      this._executingTriggerDepth++, this._runtime.PushCurrentLayout(r);\n      const a = o.deepIncludes();\n      for (let t2 = 0, r2 = a.length; t2 < r2; ++t2) {\n        const r3 = a[t2]._FastTrigger(e, s, n);\n        i = i || r3;\n      }\n      const l = o._FastTrigger(e, s, n);\n      return i = i || l, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, i;\n    }\n    *_DebugFastTrigger(t, e, s, n) {\n      let i = false;\n      const r = t.GetMainRunningLayout(), o = r.GetEventSheet();\n      if (!o) return;\n      this._executingTriggerDepth++, this._runtime.PushCurrentLayout(r);\n      const a = o.deepIncludes();\n      for (let t2 = 0, r2 = a.length; t2 < r2; ++t2) {\n        const r3 = yield* a[t2]._DebugFastTrigger(e, s, n);\n        i = i || r3;\n      }\n      const l = yield* o._DebugFastTrigger(e, s, n);\n      return i = i || l, this._runtime.PopCurrentLayout(), this._executingTriggerDepth--, i;\n    }\n    GetTriggerDepth() {\n      return this._executingTriggerDepth;\n    }\n    IsInTrigger() {\n      return this.GetTriggerDepth() > 0;\n    }\n    _IncTriggerDepth() {\n      return ++this._executingTriggerDepth;\n    }\n    _DecTriggerDepth() {\n      --this._executingTriggerDepth;\n    }\n    IsRunningEvents() {\n      return this._runningEventsDepth > 0;\n    }\n    IsInEventEngine() {\n      return this.IsRunningEvents() || this.IsInTrigger();\n    }\n    _RunQueuedTriggers(t) {\n      for (const [e, s, n] of this._queuedTriggers) this._Trigger(t, e, s, n);\n      C33.clearArray(this._queuedTriggers);\n    }\n    BlockFlushingInstances(t) {\n      t ? this._blockFlushingDepth++ : this._blockFlushingDepth--;\n    }\n    IsFlushingBlocked() {\n      return this._blockFlushingDepth > 0;\n    }\n    ClearSol(t) {\n      for (let e = 0, s = t.length; e < s; ++e) t[e].GetSolStack().Clear();\n    }\n    PushCleanSol(t) {\n      for (let e = 0, s = t.length; e < s; ++e) t[e].GetSolStack().PushClean();\n    }\n    PushCopySol(t) {\n      for (let e = 0, s = t.length; e < s; ++e) t[e].GetSolStack().PushCopy();\n    }\n    PopSol(t) {\n      for (let e = 0, s = t.length; e < s; ++e) t[e].GetSolStack().Pop();\n    }\n    GetDynamicSolModifiersSet(t) {\n      const e = /* @__PURE__ */ new Set(), s = this._eventStack.GetAllStackFrames(), n = this._eventStack.GetCurrentStackFrameIndex();\n      for (let i = 0; i <= n; ++i) {\n        const n2 = s[i].GetDynamicSolModifiers();\n        if (n2) for (const s2 of n2) t && t.has(s2) || e.add(s2);\n      }\n      return e;\n    }\n    PushCleanSolDynamic(t) {\n      const e = /* @__PURE__ */ new Set([...t]), s = this.GetDynamicSolModifiersSet(e);\n      if (s.size > 0) {\n        for (const t2 of s) t2.GetSolStack().PushClean();\n        return [...s];\n      }\n      return null;\n    }\n    AddScheduledWait() {\n      const t = C33.New(C33.ScheduledWait, this);\n      return this._scheduledWaits.push(t), t;\n    }\n    scheduledWaits() {\n      return this._scheduledWaits;\n    }\n    RunScheduledWaits() {\n      if (!this._scheduledWaits.length) return;\n      const t = this.GetCurrentEventStackFrame();\n      let e = false;\n      this._runningEventsDepth++;\n      for (let s = 0, n = this._scheduledWaits.length; s < n; ++s) {\n        const n2 = this._scheduledWaits[s];\n        n2._ShouldRun() && n2._Run(t), n2.ShouldRelease() && (e = true);\n      }\n      e && (this._FilterScheduledWaitsToRelease(), t.Reset(null)), this._runningEventsDepth--;\n    }\n    async DebugRunScheduledWaits() {\n      if (!this._scheduledWaits.length) return;\n      const t = this.GetCurrentEventStackFrame();\n      let e = false;\n      this._runningEventsDepth++;\n      for (let s = 0, n = this._scheduledWaits.length; s < n; ++s) {\n        const n2 = this._scheduledWaits[s];\n        n2._ShouldRun() && await n2._DebugRun(t), n2.ShouldRelease() && (e = true);\n      }\n      e && (this._FilterScheduledWaitsToRelease(), t.Reset(null)), this._runningEventsDepth--;\n    }\n    _FilterScheduledWaitsToRelease() {\n      const t = C33.arrayFilterOut(this._scheduledWaits, (t2) => t2.ShouldRelease());\n      for (const e of t) e.Release();\n    }\n    ClearAllScheduledWaits() {\n      for (const t of this._scheduledWaits) t.Release();\n      C33.clearArray(this._scheduledWaits);\n    }\n    _OnInstancesReleased(t) {\n      for (const e of this._scheduledWaits) e.RemoveInstances(t);\n      for (const e of t) {\n        const t2 = this._instSignals.get(e);\n        if (this._instSignals.delete(e), t2) for (const { resolve: e2 } of t2.signalPromises.values()) e2(true);\n      }\n    }\n    AddAsyncActionPromise(t) {\n      this._asyncActionPromises.push({ promise: t, triggerDepth: this.GetTriggerDepth() });\n    }\n    ClearAsyncActionPromises() {\n      C33.clearArray(this._asyncActionPromises);\n    }\n    GetPromiseForAllAsyncActions() {\n      const t = this.GetTriggerDepth(), e = Promise.all(this._asyncActionPromises.filter((e2) => e2.triggerDepth === t).map((t2) => t2.promise));\n      return this._asyncActionPromises = this._asyncActionPromises.filter((e2) => e2.triggerDepth < t), e;\n    }\n    Signal(t) {\n      const e = t.toLowerCase();\n      this._signalTags.push(e), this._runtime.Trigger(C33.Plugins.System.Cnds.OnSignal, null), this._signalTags.pop();\n      for (const t2 of this._runtime.GetEventSheetManager().scheduledWaits()) t2.IsSignal() && t2.GetSignalTag() === e && t2.SetSignalled();\n      const s = this._signalPromises.get(e);\n      s && (s.resolve(), this._signalPromises.delete(e));\n    }\n    WaitForSignal(t) {\n      const e = t.toLowerCase(), s = this._signalPromises.get(e);\n      if (s) return s.promise;\n      {\n        let t2 = null;\n        const s2 = new Promise((e2) => t2 = e2);\n        return this._signalPromises.set(e, { promise: s2, resolve: t2 }), s2;\n      }\n    }\n    GetCurrentSignalTag() {\n      if (0 === this._signalTags.length) throw new Error(\"not in a signal\");\n      return this._signalTags.at(-1);\n    }\n    _GetInstanceSignalState(t) {\n      let e = this._instSignals.get(t);\n      return e || (e = { signalTags: [], signalPromises: /* @__PURE__ */ new Map() }, this._instSignals.set(t, e)), e;\n    }\n    InstanceSignal(t, e) {\n      const s = this._GetInstanceSignalState(t), n = e.toLowerCase();\n      s.signalTags.push(n), this._runtime.Trigger(t.GetPlugin().GetConstructor().Cnds.OnInstanceSignal, t), s.signalTags.pop();\n      for (const e2 of this._runtime.GetEventSheetManager().scheduledWaits()) e2.IsInstanceSignals() && e2.GetSignalTag() === n && e2.SetInstanceSignalled(t);\n      const i = s.signalPromises.get(n);\n      i && (i.resolve(false), s.signalPromises.delete(n)), 0 === s.signalTags.length && 0 === s.signalPromises.size && this._instSignals.delete(t);\n    }\n    WaitForInstanceSignal(t, e) {\n      const s = this._GetInstanceSignalState(t), n = e.toLowerCase(), i = s.signalPromises.get(n);\n      if (i) return i.promise;\n      {\n        let t2 = null;\n        const e2 = new Promise((e3) => t2 = e3);\n        return s.signalPromises.set(n, { promise: e2, resolve: t2 }), e2;\n      }\n    }\n    GetCurrentInstanceSignalTag(t) {\n      const e = this._GetInstanceSignalState(t);\n      if (!e || 0 === e.signalTags.length) throw new Error(\"not in a signal\");\n      return e.signalTags.at(-1);\n    }\n    _SaveToJson() {\n      return { \"groups\": this._SaveGroupsToJson(), \"cnds\": this._SaveCndsToJson(), \"acts\": this._SaveActsToJson(), \"vars\": this._SaveVarsToJson(), \"waits\": this._SaveScheduledWaitsToJson() };\n    }\n    _LoadFromJson(t) {\n      this._LoadGroupsFromJson(t[\"groups\"]), this._LoadCndsFromJson(t[\"cnds\"]), this._LoadActsFromJson(t[\"acts\"]), this._LoadVarsFromJson(t[\"vars\"]), this._LoadScheduledWaitsFromJson(t[\"waits\"]);\n    }\n    _SaveGroupsToJson() {\n      const t = {};\n      for (const e of this.GetAllGroups()) t[e.GetSID().toString()] = e.IsGroupActive();\n      return t;\n    }\n    _LoadGroupsFromJson(t) {\n      for (const [e, s] of Object.entries(t)) {\n        const t2 = parseInt(e, 10), n = this.GetEventGroupBySID(t2);\n        n && n.SetGroupActive(s);\n      }\n    }\n    _SaveCndsToJson() {\n      const t = {};\n      for (const [e, s] of this._cndsBySid) {\n        const n = s._SaveToJson();\n        n && (t[e.toString()] = n);\n      }\n      return t;\n    }\n    _LoadCndsFromJson(t) {\n      const e = /* @__PURE__ */ new Map();\n      for (const [s, n] of Object.entries(t)) e.set(parseInt(s, 10), n);\n      for (const [t2, s] of this._cndsBySid) s._LoadFromJson(e.get(t2) || null);\n    }\n    _SaveActsToJson() {\n      const t = {};\n      for (const [e, s] of this._actsBySid) {\n        const n = s._SaveToJson();\n        n && (t[e.toString()] = n);\n      }\n      return t;\n    }\n    _LoadActsFromJson(t) {\n      const e = /* @__PURE__ */ new Map();\n      for (const [s, n] of Object.entries(t)) e.set(parseInt(s, 10), n);\n      for (const [t2, s] of this._actsBySid) s._LoadFromJson(e.get(t2) || null);\n    }\n    _SaveVarsToJson() {\n      const t = {};\n      for (const [e, s] of this._eventVarsBySid) s.IsConstant() || !s.IsGlobal() && !s.IsStatic() || (t[e.toString()] = s.GetValue());\n      return t;\n    }\n    _LoadVarsFromJson(t) {\n      for (const [e, s] of Object.entries(t)) {\n        const t2 = parseInt(e, 10), n = this.GetEventVariableBySID(t2);\n        n && n.SetValue(s);\n      }\n    }\n    _SaveScheduledWaitsToJson() {\n      return this._scheduledWaits.filter((t) => !t.IsPromise()).map((t) => t._SaveToJson());\n    }\n    _LoadScheduledWaitsFromJson(t) {\n      this.ClearAllScheduledWaits();\n      for (const e of t) {\n        const t2 = C33.ScheduledWait._CreateFromJson(this, e);\n        t2 && this._scheduledWaits.push(t2);\n      }\n    }\n    _GetPerfRecords() {\n      return [...this._runtime.GetLayoutManager().runningLayouts()].map((t) => t.GetEventSheet()).filter((t) => t).map((t) => t._GetPerfRecord());\n    }\n    FindFirstFunctionBlockParent(t) {\n      for (; t; ) {\n        const e = t.GetScopeParent();\n        if (e instanceof C33.FunctionBlock) return e;\n        t = e;\n      }\n      return null;\n    }\n    _InvokeFunctionFromJS(t, e) {\n      Array.isArray(e) || (e = []);\n      const s = this.GetFunctionBlockByName(t.toLowerCase());\n      if (!s) return null;\n      if (!s.IsEnabled()) return s.GetDefaultReturnValue();\n      const n = s.GetFunctionParameters();\n      if (e.length < n.length) {\n        e = e.slice(0);\n        do {\n          e.push(n[e.length].GetInitialValue());\n        } while (e.length < n.length);\n      }\n      const i = s.GetEventBlock();\n      return i.RunAsExpressionFunctionCall(i.GetSolModifiersIncludingParents(), false, s.GetReturnType(), s.GetDefaultReturnValue(), ...e);\n    }\n  };\n}\nvar SortSolArray2;\nvar IsSolArrayIdentical2;\n{\n  const C33 = self.C3;\n  C33.EventSheet = class extends C33.DefendedBase {\n    constructor(e, t) {\n      super(), this._eventSheetManager = e, this._runtime = e.GetRuntime(), this._name = t[0], this._events = [], this._triggers = /* @__PURE__ */ new Map(), this._fastTriggers = /* @__PURE__ */ new Map(), this._eventsByDisplayNumber = /* @__PURE__ */ new Map(), this._hasRun = false, this._shallowIncludes = [], this._deepIncludes = [], this._alreadyIncludedSheets = /* @__PURE__ */ new Set();\n      for (const e2 of t[1]) this._CreateEvent(e2, null, this._events);\n      this._perfRecord = this._runtime.IsDebug() ? { type: \"sheet\", name: this._name, totalTimeCounter: 0, children: [] } : null;\n    }\n    Release() {\n      this._eventSheetManager = null, this._runtime = null;\n    }\n    _CreateEvent(e, t, s) {\n      switch (e[0]) {\n        case 0:\n        case 3:\n          this._CreateEventBlock(e, t, s);\n          break;\n        case 1:\n          this._CreateEventVariable(e, t, s);\n          break;\n        case 2:\n          this._CreateInclude(e, t, s);\n          break;\n        case 4:\n          this._CreateFunctionBlock(e, t);\n          break;\n        case 5:\n          this._CreateScriptBlock(e, t, s);\n          break;\n        case 6:\n          this._CreateCustomACEBlock(e, t);\n          break;\n        default:\n          throw new Error(\"invalid event type\");\n      }\n    }\n    _CreateEventBlock(e, t, s) {\n      const n = C33.EventBlock.Create(this, t, e);\n      if (n.IsOrBlock()) {\n        s.push(n);\n        const e2 = n.GetConditions();\n        for (let t2 = 0, s2 = e2.length; t2 < s2; ++t2) e2[t2].IsTrigger() && this._InitTrigger(n, t2);\n      } else n.IsTrigger() ? this._InitTrigger(n, 0) : s.push(n);\n    }\n    _CreateFunctionBlock(e, t) {\n      const s = C33.FunctionBlock.CreateFunctionBlock(this, t, e);\n      this._eventSheetManager._RegisterFunctionBlock(s);\n    }\n    _CreateCustomACEBlock(e, t) {\n      const s = C33.FunctionBlock.CreateCustomACEBlock(this, t, e);\n      this._eventSheetManager._RegisterFunctionBlock(s);\n    }\n    _CreateEventVariable(e, t, s) {\n      const n = C33.EventVariable.Create(this, t, e);\n      s.push(n);\n    }\n    _CreateInclude(e, t, s) {\n      const n = C33.EventInclude.Create(this, t, e);\n      s.push(n);\n    }\n    _CreateScriptBlock(e, t, s) {\n      const n = C33.EventScript.Create(this, t, e);\n      s.push(n);\n    }\n    _InitTrigger(e, t) {\n      e.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(e);\n      const s = e.GetConditionAt(t), n = s._GetFunc(), r = s.GetObjectClass();\n      if (s.IsFastTrigger()) {\n        let i = this._fastTriggers.get(r);\n        i || (i = /* @__PURE__ */ new Map(), this._fastTriggers.set(r, i));\n        const l = s.GetFastTriggerValue().toLowerCase();\n        let o = i.get(n);\n        o || (o = /* @__PURE__ */ new Map(), i.set(n, o));\n        let a = o.get(l);\n        a || (a = [], o.set(l, a)), a.push([e, t]);\n      } else {\n        let i = this._triggers.get(r);\n        i || (i = { methodMap: /* @__PURE__ */ new Map(), behaviors: /* @__PURE__ */ new Map() }, this._triggers.set(r, i));\n        const l = s.GetBehaviorType();\n        let o;\n        l ? (o = i.behaviors.get(l), o || (o = /* @__PURE__ */ new Map(), i.behaviors.set(l, o))) : o = i.methodMap;\n        let a = o.get(n);\n        a || (a = [], o.set(n, a)), a.push([e, t]);\n      }\n    }\n    _PostInit() {\n      const e = this._events;\n      for (let t = 0, s = e.length; t < s; ++t) {\n        const n = t < s - 1 && e[t + 1] instanceof C33.EventBlock && e[t + 1].IsElseBlock();\n        e[t]._PostInit(n);\n      }\n    }\n    _AddShallowInclude(e) {\n      this._shallowIncludes.push(e);\n    }\n    _UpdateDeepIncludes() {\n      C33.clearArray(this._deepIncludes), this._AddDeepIncludes(this), this._alreadyIncludedSheets.clear();\n    }\n    _AddDeepIncludes(e) {\n      const t = e._deepIncludes, s = e._alreadyIncludedSheets;\n      for (const n of this._shallowIncludes) {\n        const r = n.GetIncludeSheet();\n        n.IsActive() && e !== r && !s.has(r) && (s.add(r), r._AddDeepIncludes(e), t.push(r));\n      }\n    }\n    deepIncludes() {\n      return this._deepIncludes;\n    }\n    GetEventSheetManager() {\n      return this._eventSheetManager;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetName() {\n      return this._name;\n    }\n    _RegisterEventByDisplayNumber(e, t) {\n      this._eventsByDisplayNumber.set(t, e);\n    }\n    _GetEventByDisplayNumber(e) {\n      return this._eventsByDisplayNumber.get(e) || null;\n    }\n    _ResetHasRunFlag() {\n      this._hasRun = false;\n    }\n    Run() {\n      if (this._hasRun) return;\n      const e = this._runtime, t = e.IsCPUProfiling(), s = t ? performance.now() : 0;\n      this._hasRun = true;\n      const n = this.GetEventSheetManager(), r = n.GetCurrentEventStackFrame();\n      for (const t2 of this._events) t2.Run(r), n.ClearSol(t2.GetSolModifiers()), n.ClearAsyncActionPromises(), e.FlushPendingInstances();\n      r.Reset(null), t && (this._perfRecord.totalTimeCounter += performance.now() - s);\n    }\n    *DebugRun() {\n      if (this._hasRun) return;\n      this._hasRun = true;\n      const e = this._runtime, t = this.GetEventSheetManager(), s = t.GetCurrentEventStackFrame();\n      for (const n of this._events) yield* n.DebugRun(s), t.ClearSol(n.GetSolModifiers()), t.ClearAsyncActionPromises(), e.FlushPendingInstances();\n      s.Reset(null);\n    }\n    _Trigger(e, t, s) {\n      if (!t) return this._TriggerForClass(e, t, null, null);\n      {\n        const n = t.GetObjectClass();\n        let r = false, i = this._TriggerForClass(e, t, n, s);\n        r = r || i;\n        for (const l of n.GetFamilies()) i = this._TriggerForClass(e, t, l, s), r = r || i;\n      }\n    }\n    _TriggerForClass(e, t, s, n) {\n      const r = this._triggers.get(s);\n      if (!r) return false;\n      const i = n ? r.behaviors.get(n) : r.methodMap;\n      if (!i) return false;\n      const l = i.get(e);\n      if (!l) return false;\n      let o = false;\n      for (const [e2, s2] of l) {\n        const n2 = this._ExecuteTrigger(t, e2, s2);\n        o = o || n2;\n      }\n      return o;\n    }\n    *_DebugTrigger(e, t, s) {\n      if (!t) return yield* this._DebugTriggerForClass(e, t, null, null);\n      {\n        const n = t.GetObjectClass();\n        let r = false, i = yield* this._DebugTriggerForClass(e, t, n, s);\n        r = r || i;\n        for (const l of n.GetFamilies()) i = yield* this._DebugTriggerForClass(e, t, l, s), r = r || i;\n      }\n    }\n    *_DebugTriggerForClass(e, t, s, n) {\n      const r = this._triggers.get(s);\n      if (!r) return false;\n      const i = n ? r.behaviors.get(n) : r.methodMap;\n      if (!i) return false;\n      const l = i.get(e);\n      if (!l) return false;\n      let o = false;\n      for (const [e2, s2] of l) {\n        let n2;\n        n2 = e2.DebugCanRunFast() ? this._ExecuteTrigger(t, e2, s2) : yield* this._DebugExecuteTrigger(t, e2, s2), o = o || n2;\n      }\n      return o;\n    }\n    _FastTrigger(e, t, s) {\n      const n = t.GetObjectClass(), r = this._fastTriggers.get(n);\n      if (!r) return false;\n      const i = r.get(e);\n      if (!i) return false;\n      const l = i.get(s);\n      if (!l) return false;\n      let o = false;\n      for (let e2 = 0, t2 = l.length; e2 < t2; ++e2) {\n        const t3 = l[e2], s2 = this._ExecuteTrigger(null, t3[0], t3[1]);\n        o = o || s2;\n      }\n      return o;\n    }\n    *_DebugFastTrigger(e, t, s) {\n      const n = t.GetObjectClass(), r = this._fastTriggers.get(n);\n      if (!r) return false;\n      const i = r.get(e);\n      if (!i) return false;\n      const l = i.get(s);\n      if (!l) return false;\n      let o = false;\n      for (let e2 = 0, t2 = l.length; e2 < t2; ++e2) {\n        const t3 = l[e2], s2 = t3[0], n2 = t3[1];\n        let r2;\n        r2 = s2.DebugCanRunFast() ? this._ExecuteTrigger(null, s2, n2) : yield* this._DebugExecuteTrigger(null, s2, n2), o = o || r2;\n      }\n      return o;\n    }\n    _ExecuteTrigger(e, t, s) {\n      const n = this._runtime, r = this._eventSheetManager, i = r.GetCurrentEvent(), l = r.GetEventStack(), o = r.GetTriggerDepth();\n      let a = false;\n      i && r.PushCleanSol(i.GetSolModifiersIncludingParents()), r.PushCleanSol(t.GetSolModifiersIncludingParents());\n      const c = o > 1;\n      c && r.GetLocalVarStack().Push();\n      const u = l.Push(t);\n      if (e) {\n        t.GetConditions()[s].GetObjectClass().GetCurrentSol().SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();\n      }\n      let g = true;\n      if (t.GetParent()) {\n        const e2 = t.GetTriggerParents();\n        for (let t2 = 0, s2 = e2.length; t2 < s2; ++t2) if (!e2[t2].RunPreTrigger(u)) {\n          g = false;\n          break;\n        }\n      }\n      return g && (t.IsOrBlock() ? t.RunOrBlockTrigger(u, s) : t.Run(u), a = u.GetLastEventTrue()), l.Pop(), c && r.GetLocalVarStack().Pop(), r.PopSol(t.GetSolModifiersIncludingParents()), i && r.PopSol(i.GetSolModifiersIncludingParents()), i || 1 !== o || (r.ClearAsyncActionPromises(), r.IsFlushingBlocked() || n.FlushPendingInstances()), a;\n    }\n    *_DebugExecuteTrigger(e, t, s) {\n      const n = this._runtime, r = this._eventSheetManager, i = r.GetCurrentEvent(), l = r.GetEventStack(), o = r.GetTriggerDepth();\n      let a = false;\n      i && r.PushCleanSol(i.GetSolModifiersIncludingParents()), r.PushCleanSol(t.GetSolModifiersIncludingParents());\n      const c = o > 1;\n      c && r.GetLocalVarStack().Push();\n      const u = l.Push(t);\n      if (e) {\n        t.GetConditions()[s].GetObjectClass().GetCurrentSol().SetSinglePicked(e), e.IsInContainer() && e.SetSiblingsSinglePicked();\n      }\n      let g = true;\n      if (t.GetParent()) {\n        const e2 = t.GetTriggerParents();\n        for (let t2 = 0, s2 = e2.length; t2 < s2; ++t2) if (!(yield* e2[t2].DebugRunPreTrigger(u))) {\n          g = false;\n          break;\n        }\n      }\n      return g && (t.IsOrBlock() ? yield* t.DebugRunOrBlockTrigger(u, s) : yield* t.DebugRun(u), a = u.GetLastEventTrue()), l.Pop(), c && r.GetLocalVarStack().Pop(), r.PopSol(t.GetSolModifiersIncludingParents()), i && r.PopSol(i.GetSolModifiersIncludingParents()), i || 1 !== o || (r.ClearAsyncActionPromises(), r.IsFlushingBlocked() || n.FlushPendingInstances()), a;\n    }\n    _GetPerfRecord() {\n      return this._perfRecord;\n    }\n  };\n}\n{\n  let NoActions = function(t, e) {\n    return true;\n  };\n  NoActions2 = NoActions;\n  const C33 = self.C3, EMPTY_ARRAY = [];\n  function* DebugNoActions(t, e) {\n    return true;\n  }\n  C33.EventBlock = class extends C33.DefendedBase {\n    constructor(t, e, n) {\n      super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = e, this._scopeParent = null, this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._solModifiers = [], this._solModifiersIncludingParents = [], this._hasGotSolModifiersIncludingParents = false, this._isSolWriterAfterCnds = false, this._isTopLevelGroup = false, this._hasElseBlock = false, this._isOrBlock = !!n[2], this._isElseBlock = false, this._triggerParents = null, this._conditions = [], this._actions = [], this._subEvents = [], this._RunActions = NoActions, this._DebugRunActions = DebugNoActions, this._isGroup = false, this._isInitiallyActive = false, this._groupName = \"\", this._isGroupActive = false, this._containedIncludes = null, this._perfRecord = null, this._sid = n[4], this._displayNumber = n[5], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = this._runtime.IsDebug() ? { isBreakpoint: n[3][0], isBreakable: n[3][1], canRunAllConditionsFast: false, canRunAllActionsFast: false, canRunAllSubEventsFast: false, canRunSelfFast: false } : null, this.GetEventSheetManager()._RegisterEventBlock(this), 3 === n[0] && this._InitGroup(n[1]);\n      let s = 0;\n      for (const t2 of n[6]) {\n        const e2 = C33.Condition.Create(this, t2, s++);\n        this._conditions.push(e2), this._AddSolModifier(e2.GetObjectClass());\n      }\n      s = 0;\n      for (const t2 of n[7]) {\n        const e2 = C33.Action.Create(this, t2, s++);\n        this._actions.push(e2);\n      }\n      if (9 === n.length) {\n        const t2 = n[8];\n        for (const e2 of t2) this._eventSheet._CreateEvent(e2, this, this._subEvents);\n      }\n      this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() && this._conditions[0]._GetFunc() === C33.Plugins.System.Cnds.Else), 0 === this._conditions.length && (this._conditions = EMPTY_ARRAY), 0 === this._actions.length && (this._actions = EMPTY_ARRAY), 0 === this._subEvents.length && (this._subEvents = EMPTY_ARRAY);\n    }\n    static Create(t, e, n) {\n      return C33.New(C33.EventBlock, t, e, n);\n    }\n    _InitGroup(t) {\n      this._isGroup = true, this._isInitiallyActive = !!t[0], this._isGroupActive = this._isInitiallyActive, this._groupName = t[1].toLowerCase(), this._containedIncludes = [], this.GetEventSheetManager()._RegisterGroup(this), this._runtime.IsDebug() && (this._perfRecord = { type: \"group\", name: t[1], totalTimeCounter: 0, children: [] });\n    }\n    _AddContainedInclude(t) {\n      this._containedIncludes.push(t);\n    }\n    _AddContainerSolModifierToList(t, e) {\n      for (const n of t.GetContainer().objectTypes()) e.includes(n) || e.push(n);\n    }\n    _AddSolModifierToList(t, e) {\n      if (t) if (e.includes(t) || e.push(t), t.IsFamily()) for (const n of t.GetFamilyMembers()) n.IsInContainer() && this._AddContainerSolModifierToList(n, e);\n      else t.IsInContainer() && this._AddContainerSolModifierToList(t, e);\n    }\n    _AddSolModifier(t) {\n      this._AddSolModifierToList(t, this._solModifiers);\n    }\n    _AddParentSolModifier(t) {\n      this._AddSolModifierToList(t, this._solModifiersIncludingParents);\n    }\n    SetAllSolModifiers() {\n      this._solModifiers = this._runtime.GetAllObjectClasses();\n    }\n    _PostInit(t) {\n      this._hasElseBlock = !!t, this._IdentifyTopLevelGroup(), this._IdentifyTriggerParents();\n      for (const t2 of this._conditions) t2._PostInit();\n      if (this._actions.length > 0) {\n        let t2 = false;\n        for (const e2 of this._actions) e2._PostInit(), e2.HasReturnType() && (t2 = true);\n        t2 ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast, this._DebugRunActions = this._DebugRunActions_Fast);\n      }\n      const e = this._subEvents;\n      for (let t2 = 0, n = e.length; t2 < n; ++t2) {\n        const s = t2 < n - 1 && e[t2 + 1] instanceof C33.EventBlock && e[t2 + 1].IsElseBlock();\n        e[t2]._PostInit(s);\n      }\n      this._debugData && this._UpdateCanRunFast(), this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord);\n    }\n    _GetPerfRecord() {\n      return this._perfRecord;\n    }\n    _GetPerfRecordParent() {\n      let t = this.GetParent();\n      for (; t; ) {\n        if (t.IsGroup()) return t;\n        t = t.GetParent();\n      }\n      return this._eventSheet;\n    }\n    _UpdateCanRunFast() {\n      const t = this._debugData;\n      t.canRunAllConditionsFast = this._conditions.every((t2) => t2.DebugCanRunFast()), t.canRunAllActionsFast = this._actions.every((t2) => t2.DebugCanRunFast()), t.canRunAllSubEventsFast = this._subEvents.every((t2) => t2.DebugCanRunFast()), t.canRunSelfFast = t.canRunAllConditionsFast && t.canRunAllActionsFast && t.canRunAllSubEventsFast;\n    }\n    _UpdateCanRunFastRecursive() {\n      let t = this;\n      do {\n        t._UpdateCanRunFast(), t = t.GetParent();\n      } while (t);\n    }\n    _IdentifyTopLevelGroup() {\n      if (!this.IsGroup()) return;\n      let t = this.GetParent();\n      for (this._isTopLevelGroup = true; t; ) {\n        if (!t.IsGroup()) {\n          this._isTopLevelGroup = false;\n          break;\n        }\n        t = t.GetParent();\n      }\n    }\n    _IdentifySolModifiersIncludingParents() {\n      const t = this._runtime.GetAllObjectClasses();\n      if (this._solModifiers === t) this._solModifiersIncludingParents = t;\n      else {\n        this._solModifiersIncludingParents = C33.cloneArray(this._solModifiers);\n        let t2 = this.GetParent();\n        for (; t2; ) {\n          for (const e2 of t2._solModifiers) this._AddParentSolModifier(e2);\n          t2 = t2.GetParent();\n        }\n        const e = this.GetEventSheetManager();\n        this._solModifiers = e._DeduplicateSolModifierList(this._solModifiers), this._solModifiersIncludingParents = e._DeduplicateSolModifierList(this._solModifiersIncludingParents);\n      }\n    }\n    _IdentifyTriggerParents() {\n      if (!this.HasAnyTriggeredCondition()) return;\n      this._triggerParents = [];\n      let t = this.GetParent();\n      for (; t; ) this._triggerParents.push(t), t = t.GetParent();\n      this._triggerParents.reverse();\n    }\n    SetSolWriterAfterCnds() {\n      this._isSolWriterAfterCnds = true, this._parent && this._parent.SetSolWriterAfterCnds();\n    }\n    IsSolWriterAfterCnds() {\n      return this._isSolWriterAfterCnds;\n    }\n    GetSolModifiers() {\n      return this._solModifiers;\n    }\n    GetSolModifiersIncludingParents() {\n      return this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = true, this._IdentifySolModifiersIncludingParents()), this._solModifiersIncludingParents;\n    }\n    HasSolModifier(t) {\n      return this._solModifiers.includes(t);\n    }\n    GetTriggerParents() {\n      return this._triggerParents;\n    }\n    GetEventSheet() {\n      return this._eventSheet;\n    }\n    GetEventSheetManager() {\n      return this._eventSheet.GetEventSheetManager();\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetParent() {\n      return this._parent;\n    }\n    _SetScopeParent(t) {\n      this._scopeParent = t;\n    }\n    GetScopeParent() {\n      return this._scopeParent || this._parent;\n    }\n    GetDisplayNumber() {\n      return this._displayNumber;\n    }\n    IsDebugBreakable() {\n      return this._debugData && this._debugData.isBreakable;\n    }\n    IsDebugBreakpoint() {\n      return this.IsDebugBreakable() && this._debugData.isBreakpoint;\n    }\n    _SetDebugBreakpoint(t) {\n      this._debugData.isBreakpoint = !!t, this._UpdateCanRunFastRecursive();\n    }\n    IsGroup() {\n      return this._isGroup;\n    }\n    IsTopLevelGroup() {\n      return this._isTopLevelGroup;\n    }\n    IsElseBlock() {\n      return this._isElseBlock;\n    }\n    HasElseBlock() {\n      return this._hasElseBlock;\n    }\n    GetGroupName() {\n      return this._groupName;\n    }\n    IsGroupActive() {\n      return this._isGroupActive;\n    }\n    ResetInitialActivation() {\n      this.SetGroupActive(this._isInitiallyActive);\n    }\n    SetGroupActive(t) {\n      if (t = !!t, !this._isGroup) throw new Error(\"not a group\");\n      if (this._isGroupActive !== t) {\n        this._isGroupActive = t;\n        for (const t2 of this._containedIncludes) t2.UpdateActive();\n        if (this._containedIncludes.length) {\n          const t2 = this._runtime.GetCurrentLayout().GetEventSheet();\n          t2 && t2._UpdateDeepIncludes();\n        }\n      }\n    }\n    GetSID() {\n      return this._sid;\n    }\n    IsOrBlock() {\n      return this._isOrBlock;\n    }\n    IsTrigger() {\n      return this._conditions.length && this._conditions[0].IsTrigger();\n    }\n    IsForFunctionBlock() {\n      return this._scopeParent && this._scopeParent instanceof C33.FunctionBlock;\n    }\n    HasAnyTriggeredCondition() {\n      return this.IsForFunctionBlock() || this._conditions.some((t) => t.IsTrigger());\n    }\n    GetConditions() {\n      return this._conditions;\n    }\n    GetConditionCount() {\n      return this._conditions.length;\n    }\n    GetConditionAt(t) {\n      if ((t = Math.floor(t)) < 0 || t >= this._conditions.length) throw new RangeError(\"invalid condition index\");\n      return this._conditions[t];\n    }\n    GetConditionByDebugIndex(t) {\n      return this.GetConditionAt(t);\n    }\n    IsFirstConditionOfType(t) {\n      let e = t.GetIndex();\n      if (0 === e) return true;\n      --e;\n      const n = t.IsSystemOrSingleGlobalCondition() ? t.GetFirstObjectParameterObjectClass() : t.GetObjectClass();\n      for (; e >= 0; --e) {\n        const t2 = this._conditions[e];\n        if (n === t2.GetObjectClass() || t2.IsSystemOrSingleGlobalCondition() && t2.GetFirstObjectParameterObjectClass() === n) return false;\n      }\n      return true;\n    }\n    GetActions() {\n      return this._actions;\n    }\n    GetActionCount() {\n      return this._actions.length;\n    }\n    GetActionAt(t) {\n      if ((t = Math.floor(t)) < 0 || t >= this._actions.length) throw new RangeError(\"invalid action index\");\n      return this._actions[t];\n    }\n    GetActionByDebugIndex(t) {\n      t = Math.floor(t);\n      const e = this._actions.find((e2) => e2.GetDebugIndex() === t);\n      if (!e) throw new RangeError(\"invalid action debug index\");\n      return e;\n    }\n    _HasActionIndex(t) {\n      return (t = Math.floor(t)) >= 0 && t < this._actions.length;\n    }\n    GetSubEvents() {\n      return this._subEvents;\n    }\n    _GetAllLocalVariablesInScope() {\n      return this._subEvents.filter((t) => t instanceof C33.EventVariable);\n    }\n    RunPreTrigger(t) {\n      t.SetCurrentEvent(this);\n      const e = this._conditions;\n      let n = 0 === e.length;\n      for (let s = 0, i = e.length; s < i; ++s) {\n        const i2 = e[s];\n        if (t.SetConditionIndex(s), i2.IsLooping()) throw new Error(\"trigger cannot be used as sub-event to a loop\");\n        if (i2.Run()) n = true;\n        else if (!this._isOrBlock) return false;\n      }\n      return !this._isOrBlock || n;\n    }\n    RunOrBlockTrigger(t, e) {\n      t.SetCurrentEvent(this), t.SetConditionIndex(e), this._conditions[e].Run() && (this._RunActions(t, 0) && this._RunSubEvents(t), t.SetLastEventTrue(true));\n    }\n    *DebugRunPreTrigger(t) {\n      t.SetCurrentEvent(this);\n      const e = this._conditions;\n      let n = 0 === e.length;\n      for (let s = 0, i = e.length; s < i; ++s) {\n        const i2 = e[s];\n        if (t.SetConditionIndex(s), i2.IsLooping()) throw new Error(\"trigger cannot be used as sub-event to a loop\");\n        let o;\n        if (o = i2.DebugCanRunFast() ? i2.Run() : yield* i2.DebugRun(), o) n = true;\n        else if (!this._isOrBlock) return false;\n      }\n      return !this._isOrBlock || n;\n    }\n    *DebugRunOrBlockTrigger(t, e) {\n      t.SetCurrentEvent(this), t.SetConditionIndex(e);\n      const n = this._conditions[e];\n      let s;\n      if (s = n.DebugCanRunFast() ? n.Run() : yield* n.DebugRun(), s) {\n        let e2;\n        e2 = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield* this._DebugRunActions(t, 0), e2 && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), t.SetLastEventTrue(true);\n      }\n    }\n    Run(t) {\n      t.SetCurrentEvent(this), this._isElseBlock || t.SetElseBranchRan(false), this._isOrBlock ? this._RunOrBlock(t) : this._RunAndBlock(t);\n    }\n    *DebugRun(t) {\n      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), t.SetCurrentEvent(this), this._isElseBlock || t.SetElseBranchRan(false), this._isOrBlock ? yield* this._DebugRunOrBlock(t) : yield* this._DebugRunAndBlock(t);\n    }\n    _RunOrBlock(t) {\n      const e = this._conditions;\n      let n = 0 === e.length;\n      for (let s = 0, i = e.length; s < i; ++s) {\n        const i2 = e[s];\n        if (i2.IsTrigger()) continue;\n        t.SetConditionIndex(s);\n        const o = i2.Run();\n        n = n || o;\n      }\n      t.SetLastEventTrue(n), n && (this._RunActions(t, 0) && this._RunSubEvents(t), this._hasElseBlock && t.SetElseBranchRan(true));\n    }\n    *_DebugRunOrBlock(t) {\n      const e = this._conditions;\n      let n = 0 === e.length;\n      for (let s = 0, i = e.length; s < i; ++s) {\n        const i2 = e[s];\n        if (i2.IsTrigger()) continue;\n        let o;\n        t.SetConditionIndex(s), o = i2.DebugCanRunFast() ? i2.Run() : yield* i2.DebugRun(), n = n || o;\n      }\n      if (t.SetLastEventTrue(n), n) {\n        let e2;\n        e2 = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield* this._DebugRunActions(t, 0), e2 && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && t.SetElseBranchRan(true);\n      }\n    }\n    _RunAndBlock(t) {\n      const e = this._conditions;\n      for (let n = 0, s = e.length; n < s; ++n) {\n        const s2 = e[n];\n        t.SetConditionIndex(n);\n        if (!s2.Run()) return void t.SetLastEventTrue(false);\n      }\n      t.SetLastEventTrue(true), this._RunActions(t, 0) && this._RunSubEvents(t), t.GetLastEventTrue() && this._hasElseBlock && t.SetElseBranchRan(true);\n    }\n    *_DebugRunAndBlock(t) {\n      const e = this._conditions;\n      for (let n2 = 0, s = e.length; n2 < s; ++n2) {\n        const s2 = e[n2];\n        let i;\n        if (t.SetConditionIndex(n2), i = s2.DebugCanRunFast() ? s2.Run() : yield* s2.DebugRun(), !i) return void t.SetLastEventTrue(false);\n      }\n      let n;\n      t.SetLastEventTrue(true), n = this.DebugCanRunActionsFast() ? this._RunActions(t, 0) : yield* this._DebugRunActions(t, 0), n && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), t.GetLastEventTrue() && this._hasElseBlock && t.SetElseBranchRan(true);\n    }\n    _RunActions_Fast(t, e) {\n      const n = this._actions;\n      for (let s = e, i = n.length; s < i; ++s) {\n        const e2 = n[s];\n        t.SetActionIndex(s), e2.Run();\n      }\n      return true;\n    }\n    *_DebugRunActions_Fast(t, e) {\n      const n = this._actions;\n      for (let s = e, i = n.length; s < i; ++s) {\n        const e2 = n[s];\n        t.SetActionIndex(s), e2.DebugCanRunFast() ? e2.Run() : yield* e2.DebugRun();\n      }\n      return true;\n    }\n    _RunActions_ReturnValue(t, e) {\n      const n = this.GetEventSheetManager(), s = this._actions;\n      for (let i = e, o = s.length; i < o; ++i) {\n        const e2 = s[i];\n        t.SetActionIndex(i);\n        const o2 = e2.Run();\n        if (e2.CanBailOut() && true === o2) return false;\n        e2.IsAsync() && o2 instanceof Promise && n.AddAsyncActionPromise(o2);\n      }\n      return true;\n    }\n    *_DebugRunActions_ReturnValue(t, e) {\n      const n = this.GetEventSheetManager(), s = this._actions;\n      for (let i = e, o = s.length; i < o; ++i) {\n        const e2 = s[i];\n        let o2;\n        if (t.SetActionIndex(i), o2 = e2.DebugCanRunFast() ? e2.Run() : yield* e2.DebugRun(), e2.CanBailOut() && true === o2) return false;\n        e2.IsAsync() && o2 instanceof Promise && n.AddAsyncActionPromise(o2);\n      }\n      return true;\n    }\n    _ResumeActionsAndSubEvents(t) {\n      this._RunActions(t, t.GetActionIndex()) && this._RunSubEvents();\n    }\n    *_DebugResumeActionsAndSubEvents(t) {\n      (yield* this._DebugRunActions(t, t.GetActionIndex())) && (yield* this._DebugRunSubEvents());\n    }\n    _RunSubEvents() {\n      if (!this._subEvents.length) return;\n      const t = this.IsGroup() && this._runtime.IsCPUProfiling(), e = t ? performance.now() : 0, n = this._eventStack, s = n.Push(this);\n      this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(s) : this._RunSubEvents_Fast(s), n.Pop(), t && (this._perfRecord.totalTimeCounter += performance.now() - e);\n    }\n    _RunSubEvents_SolWriterAfterCnds(t) {\n      const e = this._isGroup, n = this._isTopLevelGroup, s = this.GetEventSheetManager(), i = this._subEvents;\n      for (let o = 0, r = i.length, u = r - 1; o < r; ++o) {\n        const r2 = i[o], l = r2.GetSolModifiers(), a = !n || !e && o < u;\n        a && s.PushCopySol(l), r2.Run(t), a ? s.PopSol(l) : s.ClearSol(l);\n      }\n    }\n    _RunSubEvents_Fast(t) {\n      const e = this._subEvents;\n      for (let n = 0, s = e.length; n < s; ++n) e[n].Run(t);\n    }\n    *_DebugRunSubEvents() {\n      if (!this._subEvents.length) return;\n      const t = this._eventStack, e = t.Push(this);\n      this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(e) : yield* this._DebugRunSubEvents_Fast(e), t.Pop();\n    }\n    *_DebugRunSubEvents_SolWriterAfterCnds(t) {\n      const e = this._isGroup, n = this._isTopLevelGroup, s = this.GetEventSheetManager(), i = this._subEvents;\n      for (let o = 0, r = i.length, u = r - 1; o < r; ++o) {\n        const r2 = i[o], l = r2.GetSolModifiers(), a = !n || !e && o < u;\n        a && s.PushCopySol(l), yield* r2.DebugRun(t), a ? s.PopSol(l) : s.ClearSol(l);\n      }\n    }\n    *_DebugRunSubEvents_Fast(t) {\n      const e = this._subEvents;\n      for (let n = 0, s = e.length; n < s; ++n) yield* e[n].DebugRun(t);\n    }\n    Retrigger(t, e) {\n      e.ResetQuick();\n      const n = this._conditions;\n      if (!this.IsOrBlock()) for (let s = t.GetConditionIndex() + 1, i = n.length; s < i; ++s) {\n        const t2 = n[s];\n        e.SetConditionIndex(s);\n        if (!t2.Run()) return false;\n      }\n      return this._RunActions(e, 0) && this._RunSubEvents(e), true;\n    }\n    *DebugRetrigger(t, e) {\n      e.ResetQuick();\n      const n = this._conditions;\n      if (!this.IsOrBlock()) for (let s2 = t.GetConditionIndex() + 1, i = n.length; s2 < i; ++s2) {\n        const t2 = n[s2];\n        let i2;\n        if (e.SetConditionIndex(s2), i2 = t2.DebugCanRunFast() ? t2.Run() : yield* t2.DebugRun(), !i2) return false;\n      }\n      let s;\n      return s = this.DebugCanRunActionsFast() ? this._RunActions(e, 0) : yield* this._DebugRunActions(e, 0), s && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), true;\n    }\n    DebugCanRunFast() {\n      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast;\n    }\n    DebugCanRunActionsFast() {\n      return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast;\n    }\n    DebugCanRunSubEventsFast() {\n      return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast;\n    }\n    _CheckParentsOKToRun(t) {\n      if (this.GetParent()) {\n        const e = this.GetTriggerParents();\n        for (let n = 0, s = e.length; n < s; ++n) if (!e[n].RunPreTrigger(t)) return false;\n      }\n      return true;\n    }\n    *_DebugCheckParentsOKToRun(t) {\n      if (this.GetParent()) {\n        const e = this.GetTriggerParents();\n        for (let n = 0, s = e.length; n < s; ++n) if (!(yield* e[n].DebugRunPreTrigger(t))) return false;\n      }\n      return true;\n    }\n    _EvaluateFunctionCallParameters(t, e, n) {\n      if (e.length > 0) if (n) {\n        const n2 = e.map((t2) => t2.Get(0));\n        t.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(n2);\n      } else this._scopeParent.EvaluateFunctionParameters(e);\n      else n && t.GetLocalVarStack().Push();\n    }\n    RunAsFunctionCall(t, e, n, s) {\n      let i, o;\n      const r = t.length > 0;\n      let u = null;\n      const l = this._runtime, a = this._eventStack, h = l.GetEventSheetManager(), c = this._scopeParent, _ = c.IsAsync(), d = h._IncTriggerDepth() > 1;\n      if (this._EvaluateFunctionCallParameters(h, e, d), r && (n ? h.PushCopySol(t) : h.PushCleanSol(t)), null !== s) {\n        if (s.copyFromObjectClass) {\n          const t2 = n ? s.copyFromObjectClass.GetCurrentSol() : s.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), e2 = s.copyToObjectClass.GetCurrentSol();\n          e2.SetArrayPicked(t2.GetInstances()), e2.ClearElseInstances(), n || s.copyToObjectClass.ApplySolToContainer();\n        } else if (s.pickObjectClass) {\n          const t2 = s.pickObjectClass.GetCurrentSol();\n          t2.SetArrayPicked(s.pickInstances), t2.ClearElseInstances();\n        }\n        s.pushCleanSolDynamic && (u = h.PushCleanSolDynamic(t));\n      }\n      const g = a.Push(this);\n      return n && g.SetDynamicSolModifiers(t), this._CheckParentsOKToRun(g) && (g.SetCurrentEvent(this), _ && ([o, i] = c.StartAsyncFunctionCall()), this._RunAndBlock(g), _ && c.MaybeFinishAsyncFunctionCall(o)), a.Pop(), d && h.GetLocalVarStack().Pop(), null !== u && h.PopSol(u), r && h.PopSol(t), h._DecTriggerDepth(), i;\n    }\n    *DebugRunAsFunctionCall(t, e, n, s) {\n      let i, o;\n      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);\n      const r = t.length > 0;\n      let u = null;\n      const l = this._runtime, a = this._eventStack, h = l.GetEventSheetManager(), c = this._scopeParent, _ = c.IsAsync(), d = h._IncTriggerDepth() > 1;\n      if (this._EvaluateFunctionCallParameters(h, e, d), r && (n ? h.PushCopySol(t) : h.PushCleanSol(t)), null !== s) {\n        if (s.copyFromObjectClass) {\n          const t2 = n ? s.copyFromObjectClass.GetCurrentSol() : s.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol(), e2 = s.copyToObjectClass.GetCurrentSol();\n          e2.SetArrayPicked(t2.GetInstances()), e2.ClearElseInstances(), n || s.copyToObjectClass.ApplySolToContainer();\n        } else if (s.pickObjectClass) {\n          const t2 = s.pickObjectClass.GetCurrentSol();\n          t2.SetArrayPicked(s.pickInstances), t2.ClearElseInstances();\n        }\n        s.pushCleanSolDynamic && (u = h.PushCleanSolDynamic(t));\n      }\n      const g = a.Push(this);\n      return n && g.SetDynamicSolModifiers(t), (yield* this._DebugCheckParentsOKToRun(g)) && (g.SetCurrentEvent(this), _ && ([o, i] = c.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(g), _ && c.MaybeFinishAsyncFunctionCall(o)), a.Pop(), d && h.GetLocalVarStack().Pop(), null !== u && h.PopSol(u), r && h.PopSol(t), h._DecTriggerDepth(), i;\n    }\n    RunAsMappedFunctionCall(t, e) {\n      const n = this.GetSolModifiersIncludingParents(), s = n.length > 0, i = this._runtime, o = this._eventStack, r = i.GetEventSheetManager(), u = r._IncTriggerDepth() > 1;\n      u && r.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t), s && (e ? r.PushCopySol(n) : r.PushCleanSol(n));\n      const l = o.Push(this);\n      this._CheckParentsOKToRun(l) && (l.SetCurrentEvent(this), this._RunAndBlock(l)), o.Pop(), u && r.GetLocalVarStack().Pop(), s && r.PopSol(n), r._DecTriggerDepth();\n    }\n    *DebugRunAsMappedFunctionCall(t, e) {\n      (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this);\n      const n = this.GetSolModifiersIncludingParents(), s = n.length > 0, i = this._runtime, o = this._eventStack, r = i.GetEventSheetManager(), u = r._IncTriggerDepth() > 1;\n      u && r.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(t), s && (e ? r.PushCopySol(n) : r.PushCleanSol(n));\n      const l = o.Push(this);\n      (yield* this._DebugCheckParentsOKToRun(l)) && (l.SetCurrentEvent(this), yield* this._DebugRunAndBlock(l)), o.Pop(), u && r.GetLocalVarStack().Pop(), s && r.PopSol(n), r._DecTriggerDepth();\n    }\n    RunAsExpressionFunctionCall(t, e, n, s, ...i) {\n      let o, r;\n      const u = t.length > 0, l = this._runtime, a = this._eventStack, h = l.GetEventSheetManager(), c = this._scopeParent, _ = c.IsAsync(), d = h._IncTriggerDepth() > 1;\n      d && h.GetLocalVarStack().Push(), i.length > 0 && this._scopeParent.SetFunctionParameters(i), u && (e ? h.PushCopySol(t) : h.PushCleanSol(t));\n      const g = a.Push(this);\n      return g.InitCallFunctionExpression(n, s), a.PushExpFunc(g), l.SetDebuggingEnabled(false), this._CheckParentsOKToRun(g) && (g.SetCurrentEvent(this), _ && ([r, o] = c.StartAsyncFunctionCall()), this._RunAndBlock(g), _ && c.MaybeFinishAsyncFunctionCall(r)), l.SetDebuggingEnabled(true), a.Pop(), a.PopExpFunc(), d && h.GetLocalVarStack().Pop(), u && h.PopSol(t), h._DecTriggerDepth(), o || g.GetFunctionReturnValue();\n    }\n  };\n}\nvar NoActions2;\n{\n  const C33 = self.C3, EMPTY_SOL_MODIFIERS = [];\n  let hadUserScriptException = false;\n  C33.EventScript = class extends C33.DefendedBase {\n    constructor(e, t, i) {\n      super();\n      const r = e.GetRuntime(), n = e.GetEventSheetManager();\n      this._eventSheet = e, this._eventSheetManager = n, this._runtime = e.GetRuntime(), this._parent = t;\n      const s = r.GetObjectReference(i[1]);\n      this._func = s, this._displayNumber = i[2], this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber), this._debugData = r.IsDebug() ? { isBreakpoint: i[3][0], isBreakable: i[3][1] } : null;\n    }\n    static Create(e, t, i) {\n      return C33.New(C33.EventScript, e, t, i);\n    }\n    _PostInit() {\n      const e = this._func, t = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);\n      this._func = e.bind(null, this._runtime.GetIRuntime(), t);\n    }\n    GetParent() {\n      return this._parent;\n    }\n    GetScopeParent() {\n      return this._parent;\n    }\n    GetEventSheet() {\n      return this._eventSheet;\n    }\n    GetDisplayNumber() {\n      return this._displayNumber;\n    }\n    IsDebugBreakable() {\n      return this._debugData && this._debugData.isBreakable;\n    }\n    IsDebugBreakpoint() {\n      return this.IsDebugBreakable() && this._debugData.isBreakpoint;\n    }\n    _SetDebugBreakpoint(e) {\n      this._debugData.isBreakpoint = !!e;\n    }\n    IsElseBlock() {\n      return false;\n    }\n    GetSolModifiers() {\n      return EMPTY_SOL_MODIFIERS;\n    }\n    GetSolModifiersIncludingParents() {\n      return this._parent ? this._parent.GetSolModifiersIncludingParents() : EMPTY_SOL_MODIFIERS;\n    }\n    Run(e) {\n      e.SetCurrentEvent(this), this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript());\n    }\n    async _RunUserScript() {\n      try {\n        await this._func();\n      } catch (e) {\n        console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, \"font-size: 1.2em; font-weight: bold;\", e), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), hadUserScriptException || (console.info(\"%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()\", \"font-weight: bold; text-decoration: underline\", \"\", \"font-weight: bold\"), hadUserScriptException = true);\n      }\n    }\n    *DebugRun(e) {\n      e.SetCurrentEvent(this), (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.Run(e);\n    }\n    DebugCanRunFast() {\n      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext();\n    }\n    static HadUserScriptException() {\n      return hadUserScriptException;\n    }\n    static SetHadUserScriptException() {\n      hadUserScriptException = true;\n    }\n  };\n}\n{\n  const C33 = self.C3, assert = self.assert;\n  C33.FunctionBlock = class extends C33.DefendedBase {\n    constructor(t, e, s) {\n      super(), this._eventSheet = t, this._runtime = t.GetRuntime(), this._parent = e, this._functionType = 0, this._functionName = \"\", this._returnType = 0, this._functionParameters = [], this._isEnabled = true, this._aceName = \"\", this._objectClass = null, this._hasOverrides = false, this._innerLocalVariables = [], this._isCopyPicked = false, this._isAsync = false, this._nextAsyncId = 0, this._currentAsyncId = -1, this._asyncMap = /* @__PURE__ */ new Map(), this._eventBlock = C33.EventBlock.Create(t, e, s), this._eventBlock._SetScopeParent(this);\n    }\n    InitFunctionBlock(t) {\n      this._functionType = 0, this._functionName = t[0], this._returnType = t[1], this._functionParameters = t[2].map((t2) => C33.EventVariable.Create(this._eventSheet, this, t2)), this._isEnabled = t[3], this._isAsync = t[4], this._isCopyPicked = t[5];\n    }\n    InitCustomACEBlock(t) {\n      this._functionType = 1, this._aceName = t[1], this._objectClass = this._runtime.GetObjectClassByIndex(t[2]), this._eventBlock._AddSolModifier(this._objectClass), this._functionName = this._objectClass.GetName() + \".\" + this._aceName, this._returnType = t[3], this._functionParameters = t[4].map((t2) => C33.EventVariable.Create(this._eventSheet, this, t2)), this._isEnabled = t[5], this._isAsync = t[6], this._isCopyPicked = t[7], this._objectClass.AddCustomAction(this);\n    }\n    static CreateFunctionBlock(t, e, s) {\n      const n = C33.New(C33.FunctionBlock, t, e, s), i = s[1];\n      return n.InitFunctionBlock(i), n;\n    }\n    static CreateCustomACEBlock(t, e, s) {\n      const n = C33.New(C33.FunctionBlock, t, e, s), i = s[1];\n      return n.InitCustomACEBlock(i), n;\n    }\n    _CheckOverrideState() {\n      if (this._objectClass && this._objectClass.IsFamily()) {\n        for (const t of this._objectClass.GetFamilyMembers()) if (t.HasOwnCustomActionByName(this._aceName)) {\n          this._hasOverrides = true;\n          break;\n        }\n      }\n    }\n    _PostInit() {\n      for (const t of this._functionParameters) t._PostInit();\n      this._eventBlock._PostInit(false);\n    }\n    GetFunctionType() {\n      return this._functionType;\n    }\n    _GetAllLocalVariablesInScope() {\n      return this._functionParameters;\n    }\n    GetFunctionParameters() {\n      return this._functionParameters;\n    }\n    GetFunctionParameterCount() {\n      return this._functionParameters.length;\n    }\n    _RegisterLocalVariable(t) {\n      this._innerLocalVariables.push(t);\n    }\n    _GetAllInnerLocalVariables() {\n      return this._innerLocalVariables;\n    }\n    EvaluateFunctionParameters(t) {\n      const e = this._functionParameters;\n      for (let s = 0, n = e.length; s < n; ++s) e[s].SetValue(t[s].Get(0));\n    }\n    SetFunctionParameters(t) {\n      const e = this._functionParameters;\n      for (let s = 0, n = e.length; s < n; ++s) e[s].SetValue(t[s]);\n    }\n    CaptureFunctionParameters() {\n      return this._functionParameters.map((t) => t.GetValue());\n    }\n    GetParent() {\n      return this._parent;\n    }\n    GetScopeParent() {\n      return this._parent;\n    }\n    GetFunctionName() {\n      return this._functionName;\n    }\n    GetACEName() {\n      return this._aceName;\n    }\n    HasCustomACEOverrides() {\n      return this._hasOverrides;\n    }\n    GetReturnType() {\n      return this._returnType;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    IsEnabled() {\n      return this._isEnabled;\n    }\n    GetDefaultReturnValue() {\n      switch (this._returnType) {\n        case 0:\n          return null;\n        case 2:\n          return \"\";\n        default:\n          return 0;\n      }\n    }\n    GetEventBlock() {\n      return this._eventBlock;\n    }\n    IsCopyPicked() {\n      return this._isCopyPicked;\n    }\n    IsAsync() {\n      return this._isAsync;\n    }\n    StartAsyncFunctionCall() {\n      const t = this._nextAsyncId++;\n      let e;\n      this._currentAsyncId = t;\n      const s = new Promise((t2) => e = t2);\n      return this._asyncMap.set(t, { resolve: e, pauseCount: 0 }), [t, s];\n    }\n    MaybeFinishAsyncFunctionCall(t) {\n      const e = this._asyncMap.get(t);\n      0 === e.pauseCount && (e.resolve(), this._asyncMap.delete(t)), this._currentAsyncId = -1;\n    }\n    PauseCurrentAsyncFunction() {\n      return this._asyncMap.get(this._currentAsyncId).pauseCount++, this._currentAsyncId;\n    }\n    ResumeAsyncFunction(t) {\n      this._currentAsyncId = t;\n      this._asyncMap.get(t).pauseCount--;\n    }\n    RunAsFamilyCustomActionWithOverrides(t, e) {\n      const s = /* @__PURE__ */ new Map(), n = [];\n      for (const t2 of this._objectClass.GetCurrentSol().GetInstances()) {\n        const e2 = t2.GetObjectClass();\n        if (e2.HasOwnCustomActionByName(this._aceName)) {\n          const n2 = s.get(e2);\n          Array.isArray(n2) ? n2.push(t2) : s.set(e2, [t2]);\n        } else n.push(t2);\n      }\n      if (n.length > 0 && this._eventBlock.RunAsFunctionCall(t, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n }), s.size > 0) for (const [n2, i] of s) {\n        const s2 = n2.GetOwnCustomActionByName(this._aceName).GetEventBlock(), a = [.../* @__PURE__ */ new Set([...t, ...s2.GetSolModifiers()])];\n        s2.RunAsFunctionCall(a, e, this._isCopyPicked, { pickObjectClass: n2, pickInstances: i });\n      }\n    }\n    *DebugRunAsFamilyCustomActionWithOverrides(t, e) {\n      const s = /* @__PURE__ */ new Map(), n = [];\n      for (const t2 of this._objectClass.GetCurrentSol().GetInstances()) {\n        const e2 = t2.GetObjectClass();\n        if (e2.HasOwnCustomActionByName(this._aceName)) {\n          const n2 = s.get(e2);\n          Array.isArray(n2) ? n2.push(t2) : s.set(e2, [t2]);\n        } else n.push(t2);\n      }\n      if (n.length > 0 && (yield* this._eventBlock.DebugRunAsFunctionCall(t, e, this._isCopyPicked, { pickObjectClass: this._objectClass, pickInstances: n })), s.size > 0) for (const [n2, i] of s) {\n        const s2 = n2.GetOwnCustomActionByName(this._aceName).GetEventBlock(), a = [.../* @__PURE__ */ new Set([...t, ...s2.GetSolModifiers()])];\n        yield* s2.DebugRunAsFunctionCall(a, e, this._isCopyPicked, { pickObjectClass: n2, pickInstances: i });\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3, EMPTY_SOL_MODIFIERS = [];\n  C33.EventVariable = class extends C33.DefendedBase {\n    constructor(t, e, s) {\n      super();\n      const i = t.GetEventSheetManager();\n      this._eventSheet = t, this._eventSheetManager = i, this._runtime = t.GetRuntime(), this._parent = e, this._localVarStack = i.GetLocalVarStack(), this._name = s[1], this._type = s[2], this._initialValue = s[3], this._isStatic = !!s[4], this._isConstant = !!s[5], this._isFunctionParameter = e instanceof C33.FunctionBlock, this._sid = s[6], this._jsPropName = this._runtime.GetJsPropName(s[8]), this._scriptSetter = (t2) => this.SetValue(t2), this._scriptGetter = () => this.GetValue(), this._hasSingleValue = !this._parent || this._isStatic || this._isConstant, this._value = this._initialValue, this._localIndex = -1, this.IsBoolean() && (this._value = this._value ? 1 : 0), !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = i._GetNextLocalVarIndex(this)), i._RegisterEventVariable(this);\n    }\n    static Create(t, e, s) {\n      return C33.New(C33.EventVariable, t, e, s);\n    }\n    _PostInit() {\n      if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {\n        const t = this._eventSheetManager.FindFirstFunctionBlockParent(this);\n        t && t._RegisterLocalVariable(this);\n      }\n    }\n    GetName() {\n      return this._name;\n    }\n    GetJsPropName() {\n      return this._jsPropName;\n    }\n    GetParent() {\n      return this._parent;\n    }\n    GetScopeParent() {\n      return this.GetParent();\n    }\n    IsGlobal() {\n      return !this.GetParent();\n    }\n    IsLocal() {\n      return !this.IsGlobal();\n    }\n    IsFunctionParameter() {\n      return this._isFunctionParameter;\n    }\n    IsStatic() {\n      return this._isStatic;\n    }\n    IsConstant() {\n      return this._isConstant;\n    }\n    IsNumber() {\n      return 0 === this._type;\n    }\n    IsString() {\n      return 1 === this._type;\n    }\n    IsBoolean() {\n      return 2 === this._type;\n    }\n    IsElseBlock() {\n      return false;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    GetInitialValue() {\n      return this._initialValue;\n    }\n    GetSolModifiers() {\n      return EMPTY_SOL_MODIFIERS;\n    }\n    Run(t) {\n      !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue());\n    }\n    DebugCanRunFast() {\n      return true;\n    }\n    *DebugRun(t) {\n      this.Run(t);\n    }\n    SetValue(t) {\n      this.IsNumber() ? \"number\" != typeof t && (t = parseFloat(t)) : this.IsString() ? \"string\" != typeof t && (t = t.toString()) : this.IsBoolean() && (t = t ? 1 : 0), this._hasSingleValue ? this._value = t : this._localVarStack.GetCurrent()[this._localIndex] = t;\n    }\n    GetValue() {\n      return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex];\n    }\n    GetTypedValue() {\n      let t = this.GetValue();\n      return this.IsBoolean() && (t = !!t), t;\n    }\n    ResetToInitialValue() {\n      this._value = this._initialValue;\n    }\n    _GetScriptInterfaceDescriptor() {\n      return { configurable: false, enumerable: true, get: this._scriptGetter, set: this._scriptSetter };\n    }\n  };\n}\n{\n  const C33 = self.C3, assert = self.assert, EMPTY_SOL_MODIFIERS = [];\n  C33.EventInclude = class extends C33.DefendedBase {\n    constructor(e, t, n) {\n      super();\n      const s = e.GetEventSheetManager();\n      this._eventSheet = e, this._eventSheetManager = s, this._runtime = e.GetRuntime(), this._parent = t, this._includeSheet = null, this._includeSheetName = n[1], this._isActive = true;\n    }\n    static Create(e, t, n) {\n      return C33.New(C33.EventInclude, e, t, n);\n    }\n    _PostInit() {\n      this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName), this._eventSheet._AddShallowInclude(this);\n      let e = this.GetParent();\n      for (; e; ) e instanceof C33.EventBlock && e.IsGroup() && e._AddContainedInclude(this), e = e.GetParent();\n      this.UpdateActive(), this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord());\n    }\n    GetParent() {\n      return this._parent;\n    }\n    GetSolModifiers() {\n      return EMPTY_SOL_MODIFIERS;\n    }\n    GetIncludeSheet() {\n      return this._includeSheet;\n    }\n    Run(e) {\n      const t = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();\n      t && this._eventSheetManager.PushCleanSol(n), this._includeSheet.Run(), t && this._eventSheetManager.PopSol(n);\n    }\n    *DebugRun(e) {\n      const t = !!this.GetParent(), n = this._runtime.GetAllObjectClasses();\n      t && this._eventSheetManager.PushCleanSol(n), yield* this._includeSheet.DebugRun(), t && this._eventSheetManager.PopSol(n);\n    }\n    DebugCanRunFast() {\n      return false;\n    }\n    IsActive() {\n      return this._isActive;\n    }\n    UpdateActive() {\n      let e = this.GetParent();\n      for (; e; ) {\n        if (e instanceof C33.EventBlock && e.IsGroup() && !e.IsGroupActive()) return void (this._isActive = false);\n        e = e.GetParent();\n      }\n      this._isActive = true;\n    }\n  };\n}\n{\n  let WrapIndex = function(e, t) {\n    return e >= t ? e % t : e < 0 ? (e <= -t && (e %= t), e < 0 && (e += t), e) : e;\n  };\n  WrapIndex2 = WrapIndex;\n  const C33 = self.C3, assert = self.assert;\n  C33.ExpNode = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._owner = e, this._runtime = e.GetRuntime();\n    }\n    _PostInit() {\n    }\n    static CreateNode(e, t) {\n      const s = t[0], n = [BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode];\n      return C33.New(n[s], e, t);\n    }\n  };\n  class SystemExpressionExpNode extends C33.ExpNode {\n    constructor(e, t) {\n      super(e), this._systemPlugin = this._runtime.GetSystemPlugin(), this._func = this._runtime.GetObjectReference(t[1]), this._func !== C33.Plugins.System.Exps.random && this._func !== C33.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance();\n    }\n    GetBoundMethod() {\n      return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin);\n    }\n  }\n  class CallFunctionExpressionExpNode extends C33.ExpNode {\n    constructor(e, t) {\n      super(e), this._functionBlock = null, this._functionName = t[1], this._owner.SetVariesPerInstance();\n    }\n    _PostInit() {\n      const e = this._runtime.GetEventSheetManager();\n      this._functionBlock = e.GetFunctionBlockByName(this._functionName), this._functionName = null;\n      const t = this._owner.GetEventBlock(), s = this._functionBlock.GetEventBlock();\n      this._combinedSolModifiers = [.../* @__PURE__ */ new Set([...t.GetSolModifiersIncludingParents(), ...s.GetSolModifiersIncludingParents()])], this._combinedSolModifiers = e._DeduplicateSolModifierList(this._combinedSolModifiers);\n    }\n    GetBoundMethod() {\n      const e = this._functionBlock;\n      if (e.IsEnabled()) {\n        const t = e.GetEventBlock();\n        return C33.EventBlock.prototype.RunAsExpressionFunctionCall.bind(t, this._combinedSolModifiers, e.IsCopyPicked(), e.GetReturnType(), e.GetDefaultReturnValue());\n      }\n      {\n        const t = e.GetDefaultReturnValue();\n        return () => t;\n      }\n    }\n  }\n  class ObjectExpressionNode extends C33.ExpNode {\n    constructor(e, t) {\n      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._func = this._runtime.GetObjectReference(t[2]), this._returnsString = !!t[3], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);\n    }\n    GetBoundMethod() {\n      return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance());\n    }\n    ExpObject(...e) {\n      const t = this._objectClass, s = t.GetCurrentSol().GetExpressionInstances(), n = s.length;\n      if (0 === n) return this._returnsString ? \"\" : 0;\n      const r = WrapIndex(this._owner.GetSolIndex(), n);\n      return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t), this._func.apply(s[r].GetSdkInstance(), e);\n    }\n    ExpObject_InstExpr(e, ...t) {\n      const s = this._objectClass, n = s.GetInstances(), r = n.length;\n      if (0 === r || \"number\" != typeof e) return this._returnsString ? \"\" : 0;\n      const i = WrapIndex(e, r);\n      return this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s), this._func.apply(n[i].GetSdkInstance(), t);\n    }\n  }\n  class InstVarExpressionNode extends C33.ExpNode {\n    constructor(e, t) {\n      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._varIndex = t[3], this._returnsString = !!t[2], this._owner._MaybeVaryFor(this._objectClass);\n    }\n    ExpInstVar() {\n      const e = this._objectClass.GetCurrentSol().GetExpressionInstances(), t = e.length;\n      if (0 === t) return this._returnsString ? \"\" : 0;\n      return e[WrapIndex(this._owner.GetSolIndex(), t)]._GetInstanceVariableValueUnchecked(this._varIndex);\n    }\n    ExpInstVar_Family() {\n      const e = this._objectClass, t = e.GetCurrentSol().GetExpressionInstances(), s = t.length;\n      if (0 === s) return this._returnsString ? \"\" : 0;\n      const n = t[WrapIndex(this._owner.GetSolIndex(), s)], r = n.GetObjectClass().GetFamilyInstanceVariableOffset(e.GetFamilyIndex());\n      return n._GetInstanceVariableValueUnchecked(this._varIndex + r);\n    }\n    ExpInstVar_InstExpr(e) {\n      const t = this._objectClass, s = t.GetInstances(), n = s.length;\n      if (0 === n || \"number\" != typeof e) return this._returnsString ? \"\" : 0;\n      const r = s[WrapIndex(e, n)];\n      let i = 0;\n      return t.IsFamily() && (i = r.GetObjectClass().GetFamilyInstanceVariableOffset(t.GetFamilyIndex())), r._GetInstanceVariableValueUnchecked(this._varIndex + i);\n    }\n  }\n  class BehaviorExpressionNode extends C33.ExpNode {\n    constructor(e, t) {\n      super(e), this._objectClass = this._runtime.GetObjectClassByIndex(t[1]), this._behaviorType = this._objectClass.GetBehaviorTypeByName(t[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(t[2]), this._func = this._runtime.GetObjectReference(t[3]), this._returnsString = !!t[4], this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._owner._MaybeVaryFor(this._objectClass);\n    }\n    ExpBehavior(...e) {\n      const t = this._objectClass, s = t.GetCurrentSol().GetExpressionInstances(), n = s.length;\n      if (0 === n) return this._returnsString ? \"\" : 0;\n      const r = WrapIndex(this._owner.GetSolIndex(), n);\n      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(t);\n      const i = s[r];\n      let o = 0;\n      return t.IsFamily() && (o = i.GetObjectClass().GetFamilyBehaviorOffset(t.GetFamilyIndex())), this._func.apply(i.GetBehaviorInstances()[this._behaviorIndex + o].GetSdkInstance(), e);\n    }\n    ExpBehavior_InstExpr(e, ...t) {\n      const s = this._objectClass, n = s.GetInstances(), r = n.length;\n      if (0 === r || \"number\" != typeof e) return this._returnsString ? \"\" : 0;\n      const i = WrapIndex(e, r);\n      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(s);\n      const o = n[i];\n      let a = 0;\n      return s.IsFamily() && (a = o.GetObjectClass().GetFamilyBehaviorOffset(s.GetFamilyIndex())), this._func.apply(o.GetBehaviorInstances()[this._behaviorIndex + a].GetSdkInstance(), t);\n    }\n  }\n  class EventVarExpNode extends C33.ExpNode {\n    constructor(e, t) {\n      super(e), this._eventVar = null, this._eventVarSid = t[1];\n    }\n    _PostInit() {\n      this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);\n    }\n    GetVar() {\n      return this._eventVar;\n    }\n  }\n}\nvar WrapIndex2;\n{\n  let GetExpressionFunc = function(t) {\n    const e = self.C3_ExpressionFuncs[t];\n    if (!e) throw new Error(\"invalid expression number\");\n    return e;\n  };\n  GetExpressionFunc2 = GetExpressionFunc;\n  const C33 = self.C3, assert = self.assert;\n  C33.Parameter = class extends C33.DefendedBase {\n    constructor(t, e, s) {\n      super(), this._owner = t, this._index = s, this._type = e, this.Get = null, this._variesPerInstance = false, this._isConstant = false;\n    }\n    static Create(t, e, s) {\n      const r = e[0], n = [ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter, TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter, FlowchartParameter];\n      return C33.New(n[r], t, r, s, e);\n    }\n    _PostInit() {\n    }\n    SetVariesPerInstance() {\n      this._variesPerInstance = true;\n    }\n    _MaybeVaryFor(t) {\n      this._variesPerInstance || t && (t.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = true));\n    }\n    VariesPerInstance() {\n      return this._variesPerInstance;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetRuntime() {\n      return this._owner.GetRuntime();\n    }\n    GetEventBlock() {\n      return this._owner.GetEventBlock();\n    }\n    IsConstant() {\n      return this._isConstant;\n    }\n    IsObjectParameter() {\n      return 4 === this._type;\n    }\n  };\n  class ExpressionParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._solIndex = 0;\n      const n = r[1];\n      this._expressionNumber = n[0], this._numberedNodes = [], this._expressionFunc = null;\n      for (let t2 = 1, e2 = n.length; t2 < e2; ++t2) this._numberedNodes.push(C33.ExpNode.CreateNode(this, n[t2]));\n      this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = GetExpressionFunc(this._expressionNumber), this._isConstant = true);\n    }\n    _GetNode(t) {\n      if (t < 0 || t >= this._numberedNodes.length) throw new RangeError(\"invalid numbered node\");\n      return this._numberedNodes[t];\n    }\n    _PostInit() {\n      for (const t2 of this._numberedNodes) t2._PostInit();\n      const t = GetExpressionFunc(this._expressionNumber);\n      this._numberedNodes.length ? this._expressionFunc = t(this) : this._expressionFunc = t;\n    }\n    GetSolIndex() {\n      return this._solIndex;\n    }\n    GetExpression(t) {\n      return this._solIndex = t, this._expressionFunc();\n    }\n  }\n  class StringExpressionParameter extends ExpressionParameter {\n    constructor(t, e, s, r) {\n      super(t, e, s, r), this.Get = this.GetStringExpression, 14 === e && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof C33.Action && this.GetEventBlock().SetSolWriterAfterCnds());\n    }\n    GetStringExpression(t) {\n      this._solIndex = t;\n      const e = this._expressionFunc();\n      return \"string\" == typeof e ? e : \"\";\n    }\n    _GetFastTriggerValue() {\n      return GetExpressionFunc(this._expressionNumber)();\n    }\n  }\n  class LayerExpressionParameter extends ExpressionParameter {\n    constructor(t, e, s, r) {\n      super(t, e, s, r), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetILayer : this.Get = this.GetLayer, this._isConstant = false;\n    }\n    GetLayer(t) {\n      this._solIndex = t;\n      const e = this._expressionFunc();\n      return this.GetRuntime().GetCurrentLayout().GetLayer(e);\n    }\n    GetILayer(t) {\n      const e = this.GetLayer(t);\n      return e ? e.GetILayer() : null;\n    }\n  }\n  class ComboParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._combo = r[1], this.Get = this.GetCombo, this._isConstant = true;\n    }\n    GetCombo() {\n      return this._combo;\n    }\n  }\n  class BooleanParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._bool = r[1], this.Get = this.GetBoolean, this._isConstant = true;\n    }\n    GetBoolean() {\n      return this._bool;\n    }\n  }\n  class ObjectParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._objectClass = this.GetRuntime().GetObjectClassByIndex(r[1]), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIObjectClass : this.Get = this.GetObjectClass;\n      const n = this.GetEventBlock();\n      n._AddSolModifier(this._objectClass), this._owner instanceof C33.Action ? n.SetSolWriterAfterCnds() : n.GetParent() && n.GetParent().SetSolWriterAfterCnds(), this._isConstant = true;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetIObjectClass() {\n      return this._objectClass ? this._objectClass.GetIObjectClass() : null;\n    }\n  }\n  class LayoutParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(r[1]), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetILayout : this.Get = this.GetLayout, this._isConstant = true;\n    }\n    GetLayout() {\n      return this._layout;\n    }\n    GetILayout() {\n      return this._layout ? this._layout.GetILayout() : null;\n    }\n  }\n  class TimelineParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(r[1]), t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetITimelineState : this.Get = this.GetTimeline, this._isConstant = true;\n    }\n    GetTimeline() {\n      return this._timeline;\n    }\n    GetITimelineState() {\n      return this._timeline ? this._timeline.GetITimelineState() : null;\n    }\n  }\n  class FileParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._fileInfo = r[1], this.Get = this.GetFile, this._isConstant = true;\n    }\n    GetFile() {\n      return this._fileInfo;\n    }\n  }\n  class InstVarParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._instVarIndex = r[1];\n      const n = this._owner.GetObjectClass();\n      this._owner instanceof C33.Condition && this._owner.IsStatic() ? (this.Get = this.GetInstanceVariable, this._isConstant = true) : n && n.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = true);\n    }\n    GetInstanceVariable() {\n      return this._instVarIndex;\n    }\n    GetFamilyInstanceVariable(t) {\n      t = t || 0;\n      const e = this._owner.GetObjectClass(), s = e.GetCurrentSol(), r = s.GetInstances();\n      let n = null;\n      if (r.length) n = r[t % r.length].GetObjectClass();\n      else if (s.HasAnyElseInstances()) {\n        const e2 = s.GetElseInstances();\n        n = e2[t % e2.length].GetObjectClass();\n      } else {\n        if (!(e.GetInstanceCount() > 0)) return 0;\n        {\n          const s2 = e.GetInstances();\n          n = s2[t % s2.length].GetObjectClass();\n        }\n      }\n      return this._instVarIndex + n.GetFamilyInstanceVariableOffset(e.GetFamilyIndex());\n    }\n  }\n  class EventVarParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._eventVarSid = r[1], this._eventVar = null, t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIEventVariable : this.Get = this.GetEventVariable, this._isConstant = true;\n    }\n    _PostInit() {\n      this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid);\n    }\n    GetEventVariable() {\n      return this._eventVar;\n    }\n    GetIEventVariable() {\n      return null;\n    }\n  }\n  class FunctionParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._functionBlockName = r[1], this._functionBlock = null, t.GetImplementationSdkVersion() >= 2 ? this.Get = this.GetIFunction : this.Get = this.GetFunction, this._isConstant = true;\n    }\n    _PostInit() {\n      this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName), this._functionBlockName = null;\n    }\n    GetFunction() {\n      return this._functionBlock;\n    }\n    GetIFunction() {\n      return null;\n    }\n  }\n  class VariadicParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._subParams = [], this._variadicRet = [], this._isConstant = true;\n      for (let t2 = 1, e2 = r.length; t2 < e2; ++t2) {\n        const e3 = C33.Parameter.Create(this._owner, r[t2], 0);\n        this._subParams.push(e3), this._variadicRet.push(0), e3.IsConstant() || (this._isConstant = false);\n      }\n      this.Get = this.GetVariadic;\n    }\n    _PostInit() {\n      for (const t of this._subParams) t._PostInit();\n    }\n    GetVariadic() {\n      const t = this._subParams, e = this._variadicRet;\n      for (let s = 0, r = t.length; s < r; ++s) e[s] = t[s].Get(0);\n      return e;\n    }\n  }\n  class EaseParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._easeIndex = r[1], this.Get = this.GetEase, this._isConstant = true;\n    }\n    GetEase() {\n      return this._easeIndex;\n    }\n  }\n  class TilemapBrushParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._brushIndex = r[1], this.Get = this.GetTilemapBrush, this._isConstant = true;\n    }\n    GetTilemapBrush() {\n      return this._brushIndex;\n    }\n  }\n  class TemplateExpressionParameter extends ExpressionParameter {\n    constructor(t, e, s, r) {\n      super(t, e, s, r), this.Get = this.GetTemplateName, this._isConstant = false;\n    }\n    GetTemplateName() {\n      return this._expressionFunc();\n    }\n  }\n  class FlowchartParameter extends C33.Parameter {\n    constructor(t, e, s, r) {\n      super(t, e, s), this._flowchartDataItem = this.GetRuntime().GetFlowchartManager().GetFlowchartDataItemByName(r[1]), this.Get = this.GetFlowchartName, this._isConstant = true;\n    }\n    GetFlowchartName() {\n      return this._flowchartDataItem.GetName();\n    }\n  }\n}\nvar GetExpressionFunc2;\n{\n  let EvalParams = function(t, e) {\n    for (let s = 0, n = t.length; s < n; ++s) e[s] = t[s].Get(0);\n  };\n  EvalParams2 = EvalParams;\n  const C33 = self.C3, assert = self.assert;\n  const EMPTY_PARAMS_ARRAY = [], noop = function() {\n  };\n  C33.Condition = class extends C33.DefendedBase {\n    constructor(t, e, s) {\n      if (super(), this._eventBlock = t, this._runtime = t.GetRuntime(), this._index = s, this._func = this._runtime.GetObjectReference(e[1]), this._isTrigger = e[3] > 0, this._isFastTrigger = 2 === e[3], this._isLooping = !!e[4], this._isInverted = !!e[5], this._isStatic = !!e[6], this._sid = e[7], this._isInOrBlock = this._eventBlock.IsOrBlock(), this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null, this._debugData = this._runtime.IsDebug() ? { isBreakpoint: e[8][0], canDebug: e[8][1] } : null, -1 === e[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(e[0]), e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])), this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds()), 10 === e.length) {\n        let t2 = e[9];\n        for (let e2 of t2) this._parameters.push(C33.Parameter.Create(this, e2, this._parameters.length)), this._results.push(0);\n      }\n      0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this._eventBlock.GetEventSheetManager()._RegisterCondition(this);\n    }\n    static Create(t, e, s) {\n      return C33.New(C33.Condition, t, e, s);\n    }\n    _PostInit() {\n      for (const t of this._parameters) t._PostInit(), t.VariesPerInstance() && (this._anyParamVariesPerInstance = true);\n      this._isFastTrigger ? (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject);\n    }\n    _SetSystemRunMethod() {\n      const t = this._systemPlugin, e = this._systemPlugin;\n      this._SetRunMethodForBoundFunc(t, e, this._RunSystem);\n    }\n    _SetSingleGlobalRunMethod() {\n      const t = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();\n      this._SetRunMethodForBoundFunc(t, e, this._RunSingleGlobal);\n    }\n    _SetRunMethodForBoundFunc(t, e, s) {\n      const n = this._func, i = this._isInverted, r = this._parameters;\n      if (0 === r.length) {\n        const s2 = t._GetBoundACEMethod(n, e);\n        this.Run = i ? function() {\n          return C33.xor(s2(), i);\n        } : s2;\n      } else if (1 === r.length) {\n        const s2 = r[0];\n        if (!i && s2.IsConstant()) this.Run = t._GetBoundACEMethod_1param(n, e, s2.Get(0));\n        else {\n          const r2 = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return C33.xor(r2(s2.Get(0)), i);\n          };\n        }\n      } else if (2 === r.length) {\n        const s2 = r[0], a = r[1];\n        if (!i && s2.IsConstant() && a.IsConstant()) this.Run = t._GetBoundACEMethod_2params(n, e, s2.Get(0), a.Get(0));\n        else {\n          const r2 = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return C33.xor(r2(s2.Get(0), a.Get(0)), i);\n          };\n        }\n      } else if (3 === r.length) {\n        const s2 = r[0], a = r[1], h = r[2];\n        if (!i && s2.IsConstant() && a.IsConstant() && h.IsConstant()) this.Run = t._GetBoundACEMethod_3params(n, e, s2.Get(0), a.Get(0), h.Get(0));\n        else {\n          const r2 = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return C33.xor(r2(s2.Get(0), a.Get(0), h.Get(0)), i);\n          };\n        }\n      } else this.Run = s;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    _GetFunc() {\n      return this._func;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetBehaviorType() {\n      return this._behaviorType;\n    }\n    GetImplementationAddon() {\n      return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;\n    }\n    GetImplementationSdkVersion() {\n      const t = this.GetImplementationAddon();\n      return t ? t.GetSdkVersion() : 1;\n    }\n    GetEventBlock() {\n      return this._eventBlock;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetDebugIndex() {\n      return this.GetIndex();\n    }\n    IsTrigger() {\n      return this._isTrigger;\n    }\n    IsFastTrigger() {\n      return this._isFastTrigger;\n    }\n    IsInverted() {\n      return this._isInverted;\n    }\n    IsLooping() {\n      return this._isLooping;\n    }\n    IsStatic() {\n      return this._isStatic;\n    }\n    IsBreakpoint() {\n      return this._debugData.isBreakpoint;\n    }\n    IsSystemCondition() {\n      return !!this._systemPlugin;\n    }\n    IsSystemOrSingleGlobalCondition() {\n      return this.IsSystemCondition() || this._objectClass.GetPlugin().IsSingleGlobal();\n    }\n    GetFirstObjectParameterObjectClass() {\n      for (const t of this._parameters) if (t.IsObjectParameter()) return t.GetObjectClass();\n      return null;\n    }\n    _SetBreakpoint(t) {\n      this._debugData.isBreakpoint = !!t, this._eventBlock._UpdateCanRunFastRecursive();\n    }\n    _DebugReturnsGenerator() {\n      return this._debugData.canDebug;\n    }\n    DebugCanRunFast() {\n      return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();\n    }\n    GetSavedDataMap() {\n      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;\n    }\n    GetUnsavedDataMap() {\n      return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;\n    }\n    _RunSystem() {\n      const t = this._results;\n      return EvalParams(this._parameters, t), C33.xor(this._func.apply(this._systemPlugin, t), this._isInverted);\n    }\n    *_DebugRunSystem() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._results;\n        EvalParams(this._parameters, t);\n        let e = this._func.apply(this._systemPlugin, t);\n        return C33.IsIterator(e) && (e = yield* e), C33.xor(e, this._isInverted);\n      }\n      return this.Run();\n    }\n    _RunSingleGlobal() {\n      const t = this._results;\n      EvalParams(this._parameters, t);\n      const e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();\n      return C33.xor(this._func.apply(e, t), this._isInverted);\n    }\n    *_DebugRunSingleGlobal() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._results;\n        EvalParams(this._parameters, t);\n        const e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();\n        let s = this._func.apply(e, t);\n        return C33.IsIterator(s) && (s = yield* s), C33.xor(s, this._isInverted);\n      }\n      return this.Run();\n    }\n    _RunFastTrigger() {\n      return true;\n    }\n    *_DebugRunFastTrigger() {\n      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), true;\n    }\n    _GetStaticConditionThis() {\n      return this._behaviorType ? this._behaviorType.GetBehavior().GetSdkVersion() >= 2 ? this._behaviorType.GetIBehaviorType() : this._behaviorType : this._objectClass.GetPlugin().GetSdkVersion() >= 2 ? this._objectClass.GetIObjectClass() : this._objectClass;\n    }\n    _RunStatic() {\n      const t = this._results;\n      EvalParams(this._parameters, t);\n      const e = this._func.apply(this._GetStaticConditionThis(), t);\n      return this._objectClass.ApplySolToContainer(), e;\n    }\n    *_DebugRunStatic() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._results;\n        EvalParams(this._parameters, t);\n        let e = this._func.apply(this._GetStaticConditionThis(), t);\n        return C33.IsIterator(e) && (e = yield* e), this._objectClass.ApplySolToContainer(), e;\n      }\n      return this.Run();\n    }\n    _RunObject() {\n      const t = this._parameters, e = this._results, s = this._objectClass.GetCurrentSol();\n      for (let s2 = 0, n = t.length; s2 < n; ++s2) {\n        const n2 = t[s2];\n        n2.VariesPerInstance() || (e[s2] = n2.Get(0));\n      }\n      return s.IsSelectAll() ? this._RunObject_FirstFilter(s) : this._RunObject_NextFilter(s);\n    }\n    *_DebugRunObject() {\n      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._RunObject();\n    }\n    _EvaluateVaryingParameters(t) {\n      const e = this._parameters, s = this._results;\n      for (let n = 0, i = e.length; n < i; ++n) {\n        const i2 = e[n];\n        i2.VariesPerInstance() && (s[n] = i2.Get(t));\n      }\n    }\n    _RunObject_FirstFilter(t) {\n      const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = this._behaviorIndex, r = i >= 0, a = e.GetInstances(), h = this._anyParamVariesPerInstance, o = this._results, l = this._func, u = this._isInverted, _ = this._isInOrBlock && !this._isTrigger;\n      t.ClearArrays();\n      for (let e2 = 0, c = a.length; e2 < c; ++e2) {\n        const c2 = a[e2];\n        let g;\n        if (h && this._EvaluateVaryingParameters(e2), r) {\n          const t2 = s ? c2.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;\n          g = l.apply(c2.GetBehaviorInstances()[i + t2].GetSdkInstance(), o);\n        } else g = l.apply(c2.GetSdkInstance(), o);\n        C33.xor(g, u) ? t._PushInstance(c2) : _ && t._PushElseInstance(c2);\n      }\n      return e.FinishCondition(true), t._SetSelectAll(false), e.ApplySolToContainer(), t.HasAnyInstances();\n    }\n    _RunObject_NextFilter(t) {\n      const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = e.IsInContainer(), r = this._behaviorIndex, a = r >= 0, h = this._anyParamVariesPerInstance, o = this._results, l = this._func, u = this._isInverted, _ = this._isInOrBlock && !this._isTrigger, c = t._GetOwnInstances(), g = t._GetOwnElseInstances(), d = _ && !this._eventBlock.IsFirstConditionOfType(this), I = d ? g : c;\n      let G = 0, b = false;\n      for (let t2 = 0, e2 = I.length; t2 < e2; ++t2) {\n        const e3 = I[t2];\n        let m2;\n        if (h && this._EvaluateVaryingParameters(t2), a) {\n          const t3 = s ? e3.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;\n          m2 = l.apply(e3.GetBehaviorInstances()[r + t3].GetSdkInstance(), o);\n        } else m2 = l.apply(e3.GetSdkInstance(), o);\n        C33.xor(m2, u) ? (b = true, d ? (c.push(e3), i && e3._PushSiblingsToSolInstances()) : (I[G] = e3, i && e3._SetSiblingsToSolInstancesIndex(G), ++G)) : d ? (I[G] = e3, i && e3._SetSiblingsToSolElseInstancesIndex(G), ++G) : _ && (g.push(e3), i && e3._PushSiblingsToSolElseInstances());\n      }\n      C33.truncateArray(I, G), i && e._TruncateContainerSols(d, G);\n      const m = b;\n      return d && !b && (b = this._OrBlockCheckInstances(c)), e.FinishCondition(m || _), _ ? b : t.HasAnyInstances();\n    }\n    _OrBlockCheckInstances(t) {\n      const e = this._objectClass, s = e.IsFamily(), n = e.GetFamilyIndex(), i = this._anyParamVariesPerInstance, r = this._behaviorIndex, a = r >= 0, h = this._results, o = this._func, l = this._isInverted;\n      for (let e2 = 0, u = t.length; e2 < u; ++e2) {\n        const u2 = t[e2];\n        let _;\n        if (i && this._EvaluateVaryingParameters(e2), a) {\n          const t2 = s ? u2.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;\n          _ = o.apply(u2.GetBehaviorInstances()[r + t2].GetSdkInstance(), h);\n        } else _ = o.apply(u2.GetSdkInstance(), h);\n        if (C33.xor(_, l)) return true;\n      }\n      return false;\n    }\n    ReevaluateParameter(t, e) {\n      return this._parameters[t].Get(e);\n    }\n    GetFastTriggerValue() {\n      const t = this._parameters;\n      if (!t.length) throw new Error(\"no parameters\");\n      return t[0]._GetFastTriggerValue();\n    }\n    _SaveToJson() {\n      if (!this._savedData || !this._savedData.size) return null;\n      const t = {};\n      for (const [e, s] of this._savedData.entries()) {\n        let n = s;\n        \"collmemory\" === e && (n = [...s.entries()].map((t2) => [t2[0].GetUID(), t2[1].GetUID(), t2[2]])), t[e] = n;\n      }\n      return { \"ex\": t };\n    }\n    _LoadFromJson(t) {\n      if (this._savedData && (this._savedData.clear(), this._savedData = null), !t) return;\n      const e = this._runtime, s = t[\"ex\"];\n      if (s) {\n        const t2 = this.GetSavedDataMap();\n        t2.clear();\n        for (const [n, i] of Object.entries(s)) {\n          let s2 = i;\n          \"collmemory\" === n && (s2 = C33.New(C33.PairMap, i.map((t3) => [e.GetInstanceByUID(t3[0]), e.GetInstanceByUID(t3[1]), t3[2]]).filter((t3) => t3[0] && t3[1]))), t2.set(n, s2);\n        }\n      }\n    }\n  };\n}\nvar EvalParams2;\n{\n  let EvalParams = function(t, e) {\n    for (let s = 0, n = t.length; s < n; ++s) e[s] = t[s].Get(0);\n  };\n  EvalParams2 = EvalParams;\n  const C33 = self.C3, assert = self.assert;\n  const EMPTY_PARAMS_ARRAY = [], noop = function() {\n  }, noopGenerator = function* () {\n  }, FLAG_CANPICKANYOBJECTCLASS = 1, FLAG_COPYPICKED = 2, FLAG_CUSTOM_ACE = 4, FLAG_IS_ASYNC = 8, FLAG_CAN_BAIL_OUT = 16;\n  C33.Action = class extends C33.DefendedBase {\n    constructor(t, e, s) {\n      super(), this._eventBlock = t;\n      const n = t.GetRuntime();\n      this._runtime = n, this._index = s, this._sid = e.length >= 4 ? e[3] : -1, this._actionType = e.length >= 5 ? 255 & e[4] : 0, this._flags = e.length >= 5 ? e[4] >> 8 : 0, this._func = null, this._objectClass = null, this._behaviorType = null, this._behaviorIndex = -1, this._systemPlugin = null, this._callFunctionName = \"\", this._callCustomAceObjectClass = null, this._callEventBlock = null, this.Run = noop, this.DebugRun = noop, this._parameters = [], this._results = [], this._anyParamVariesPerInstance = false, this._savedData = null, this._unsavedData = null;\n      const i = -3 === e[0], a = i ? e[2] : e[5];\n      if (this._debugData = n.IsDebug() || i ? { isBreakpoint: a[0], canDebug: a[1], index: a[2] } : null, -1 === e[0]) this._systemPlugin = n.GetSystemPlugin(), this._func = n.GetObjectReference(e[1]);\n      else if (-2 === e[0]) this._callFunctionName = e[1];\n      else if (i) {\n        const t2 = n.GetObjectReference(e[1]);\n        this._func = t2, this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._flags |= 8;\n      } else this._objectClass = n.GetObjectClassByIndex(e[0]), 4 & this._flags ? (this._callFunctionName = e[1], this._callCustomAceObjectClass = n.GetObjectClassByIndex(e[2])) : (e[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(e[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(e[2])), this._func = n.GetObjectReference(e[1]));\n      if (7 === e.length) {\n        const t2 = e[6];\n        for (const e2 of t2) this._parameters.push(C33.Parameter.Create(this, e2, this._parameters.length)), this._results.push(0);\n      }\n      0 === this._parameters.length && (this._parameters = EMPTY_PARAMS_ARRAY, this._results = EMPTY_PARAMS_ARRAY), this.CanPickAnyObjectClass() && (this._eventBlock.SetAllSolModifiers(), this._eventBlock.SetSolWriterAfterCnds()), this._eventBlock.GetEventSheetManager()._RegisterAction(this);\n    }\n    static Create(t, e, s) {\n      return C33.New(C33.Action, t, e, s);\n    }\n    _PostInit() {\n      for (const t of this._parameters) t._PostInit(), t.VariesPerInstance() && (this._anyParamVariesPerInstance = true);\n      if (this._systemPlugin) this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem;\n      else if (this._callFunctionName) 4 & this._flags ? this._SetCallCustomActionRunMethod() : this._SetCallFunctionRunMethod(), this._callFunctionName = \"\", this._callCustomAceObjectClass = null;\n      else if (this.Run === this.RunUserScript) {\n        const t = this._func, e = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);\n        this._func = t.bind(null, this._runtime.GetIRuntime(), e);\n      } else this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsStatic() ? (this.Run = this._RunObject_Static, this.DebugRun = this._DebugRunObject_Static) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this.CallBeforeAfterHooks() ? (this.Run = this._RunObject_BeforeAfterHooks, this.DebugRun = this._DebugRunObject_BeforeAfterHooks) : this._parameters.length ? this._parameters.every((t) => t.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary, this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every((t) => t.IsConstant()) ? (EvalParams(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst);\n    }\n    _SetSystemRunMethod() {\n      const t = this._systemPlugin, e = this._systemPlugin;\n      this._SetRunMethodForBoundFunc(t, e, this._RunSystem);\n    }\n    _SetSingleGlobalRunMethod() {\n      const t = this._objectClass.GetPlugin(), e = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();\n      this._SetRunMethodForBoundFunc(t, e, this._RunSingleGlobal);\n    }\n    _SetCallFunctionRunMethod() {\n      const t = this._eventBlock.GetEventSheetManager(), e = t.GetFunctionBlockByName(this._callFunctionName);\n      if (e.IsEnabled()) {\n        const s = !!(2 & this._flags);\n        this._callEventBlock = e.GetEventBlock();\n        let n = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])];\n        n = t._DeduplicateSolModifierList(n);\n        const i = !e.IsCopyPicked() && this._HasCopyPickedParent() ? { pushCleanSolDynamic: true } : null;\n        if (this.Run = C33.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, n, this._parameters, s, i), this._runtime.IsDebug()) {\n          const t2 = this;\n          this.DebugRun = function* () {\n            (t2.IsBreakpoint() || t2._runtime.DebugBreakNext()) && (yield t2);\n            return yield* t2._callEventBlock.DebugRunAsFunctionCall(n, t2._parameters, s, i);\n          };\n        } else this.DebugRun = noopGenerator;\n      } else this.Run = noop, this.DebugRun = noopGenerator;\n    }\n    _SetCallCustomActionRunMethod() {\n      const t = this._eventBlock.GetEventSheetManager(), e = t.GetCustomActionBlockByName(this._callCustomAceObjectClass, this._callFunctionName);\n      if (e.IsEnabled()) {\n        const s = !!(2 & this._flags);\n        this._callEventBlock = e.GetEventBlock();\n        let n = [.../* @__PURE__ */ new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents(), this._objectClass, e.GetObjectClass()])];\n        n = t._DeduplicateSolModifierList(n);\n        const i = !this._objectClass.IsFamily() && !e.GetObjectClass().IsFamily(), a = !this._objectClass.IsFamily() && e.GetObjectClass().IsFamily(), r = this._objectClass.IsFamily();\n        let o = null;\n        if (!e.IsCopyPicked() && this._HasCopyPickedParent() && (o = o || {}, o.pushCleanSolDynamic = true), !a && s || (o = o || {}, o.copyFromObjectClass = this._objectClass, o.copyToObjectClass = e.GetObjectClass()), i || a || r && !e.HasCustomACEOverrides() ? this.Run = C33.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, n, this._parameters, s, o) : r && (this.Run = C33.FunctionBlock.prototype.RunAsFamilyCustomActionWithOverrides.bind(e, n, this._parameters)), this._runtime.IsDebug()) {\n          const t2 = this;\n          i || a || r && !e.HasCustomACEOverrides() ? this.DebugRun = function* () {\n            (t2.IsBreakpoint() || t2._runtime.DebugBreakNext()) && (yield t2);\n            return yield* t2._callEventBlock.DebugRunAsFunctionCall(n, t2._parameters, s, o);\n          } : r && (this.DebugRun = function* () {\n            (t2.IsBreakpoint() || t2._runtime.DebugBreakNext()) && (yield t2);\n            return yield* e.DebugRunAsFamilyCustomActionWithOverrides(n, t2._parameters);\n          });\n        } else this.DebugRun = noopGenerator;\n      } else this.Run = noop, this.DebugRun = noopGenerator;\n    }\n    _SetRunMethodForBoundFunc(t, e, s) {\n      const n = this._func, i = this._parameters;\n      if (0 === i.length) this.Run = t._GetBoundACEMethod(n, e);\n      else if (1 === i.length) {\n        const s2 = i[0];\n        if (s2.IsConstant()) this.Run = t._GetBoundACEMethod_1param(n, e, s2.Get(0));\n        else {\n          const i2 = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return i2(s2.Get(0));\n          };\n        }\n      } else if (2 === i.length) {\n        const s2 = i[0], a = i[1];\n        if (s2.IsConstant() && a.IsConstant()) this.Run = t._GetBoundACEMethod_2params(n, e, s2.Get(0), a.Get(0));\n        else {\n          const i2 = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return i2(s2.Get(0), a.Get(0));\n          };\n        }\n      } else if (3 === i.length) {\n        const s2 = i[0], a = i[1], r = i[2];\n        if (s2.IsConstant() && a.IsConstant() && r.IsConstant()) this.Run = t._GetBoundACEMethod_3params(n, e, s2.Get(0), a.Get(0), r.Get(0));\n        else {\n          const i2 = t._GetBoundACEMethod(n, e);\n          this.Run = function() {\n            return i2(s2.Get(0), a.Get(0), r.Get(0));\n          };\n        }\n      } else this.Run = s;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    IsAsync() {\n      return !!(8 & this._flags);\n    }\n    CanBailOut() {\n      return !!(16 & this._flags);\n    }\n    CallBeforeAfterHooks() {\n      return 1 === this._actionType;\n    }\n    IsStatic() {\n      return 2 === this._actionType;\n    }\n    CanPickAnyObjectClass() {\n      return !!(1 & this._flags);\n    }\n    HasReturnType() {\n      return this.IsAsync() || this.CanBailOut();\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetImplementationAddon() {\n      return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null;\n    }\n    GetImplementationSdkVersion() {\n      const t = this.GetImplementationAddon();\n      return t ? t.GetSdkVersion() : 1;\n    }\n    GetEventBlock() {\n      return this._eventBlock;\n    }\n    _HasCopyPickedParent() {\n      let t = this._eventBlock;\n      do {\n        if (t instanceof C33.FunctionBlock && t.IsCopyPicked()) return true;\n        t = t.GetScopeParent();\n      } while (t);\n      return false;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetDebugIndex() {\n      return this._debugData.index;\n    }\n    IsBreakpoint() {\n      return this._debugData.isBreakpoint;\n    }\n    _SetBreakpoint(t) {\n      this._debugData.isBreakpoint = !!t, this._eventBlock._UpdateCanRunFastRecursive();\n    }\n    _DebugReturnsGenerator() {\n      return this._debugData.canDebug;\n    }\n    DebugCanRunFast() {\n      return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator();\n    }\n    GetSavedDataMap() {\n      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;\n    }\n    GetUnsavedDataMap() {\n      return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;\n    }\n    _RunSystem() {\n      const t = this._results;\n      return EvalParams(this._parameters, t), this._func.apply(this._systemPlugin, t);\n    }\n    *_DebugRunSystem() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._results;\n        EvalParams(this._parameters, t);\n        return yield* this._func.apply(this._systemPlugin, t);\n      }\n      return this.Run();\n    }\n    _RunSingleGlobal() {\n      const t = this._results;\n      return EvalParams(this._parameters, t), this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t);\n    }\n    *_DebugRunSingleGlobal() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._results;\n        EvalParams(this._parameters, t);\n        return yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), t);\n      }\n      return this.Run();\n    }\n    _RunObject_ParamsConst() {\n      const t = this._results, e = this._objectClass.GetCurrentSol().GetInstances();\n      for (let s = 0, n = e.length; s < n; ++s) this._func.apply(e[s].GetSdkInstance(), t);\n    }\n    *_DebugRunObject_ParamsConst() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._results, e = this._objectClass.GetCurrentSol().GetInstances();\n        for (let s = 0, n = e.length; s < n; ++s) yield* this._func.apply(e[s].GetSdkInstance(), t);\n      } else this._RunObject_ParamsConst();\n    }\n    _RunObject_ParamsDontVary() {\n      const t = this._results;\n      EvalParams(this._parameters, t);\n      const e = this._objectClass.GetCurrentSol().GetInstances();\n      for (let s = 0, n = e.length; s < n; ++s) this._func.apply(e[s].GetSdkInstance(), t);\n    }\n    *_DebugRunObject_ParamsDontVary() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._results;\n        EvalParams(this._parameters, t);\n        const e = this._objectClass.GetCurrentSol().GetInstances();\n        for (let s = 0, n = e.length; s < n; ++s) yield* this._func.apply(e[s].GetSdkInstance(), t);\n      } else this._RunObject_ParamsDontVary();\n    }\n    _RunObject_AllParamsVary() {\n      const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();\n      for (let i = 0, a = n.length; i < a; ++i) {\n        const a2 = n[i];\n        for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) e[s2] = t[s2].Get(i);\n        s.apply(a2.GetSdkInstance(), e);\n      }\n    }\n    *_DebugRunObject_AllParamsVary() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();\n        for (let i = 0, a = n.length; i < a; ++i) {\n          const a2 = n[i];\n          for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) e[s2] = t[s2].Get(i);\n          yield* s.apply(a2.GetSdkInstance(), e);\n        }\n      } else this._RunObject_AllParamsVary();\n    }\n    _RunObject_SomeParamsVary() {\n      const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();\n      for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) {\n        const n3 = t[s2];\n        n3.VariesPerInstance() || (e[s2] = n3.Get(0));\n      }\n      for (let i = 0, a = n.length; i < a; ++i) {\n        const a2 = n[i];\n        for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) {\n          const n3 = t[s2];\n          n3.VariesPerInstance() && (e[s2] = n3.Get(i));\n        }\n        s.apply(a2.GetSdkInstance(), e);\n      }\n    }\n    *_DebugRunObject_SomeParamsVary() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances();\n        for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) {\n          const n3 = t[s2];\n          n3.VariesPerInstance() || (e[s2] = n3.Get(0));\n        }\n        for (let i = 0, a = n.length; i < a; ++i) {\n          const a2 = n[i];\n          for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) {\n            const n3 = t[s2];\n            n3.VariesPerInstance() && (e[s2] = n3.Get(i));\n          }\n          yield* s.apply(a2.GetSdkInstance(), e);\n        }\n      } else this._RunObject_SomeParamsVary();\n    }\n    _RunObject_BeforeAfterHooks() {\n      const t = this._parameters, e = this._results, s = this._func, n = this._objectClass, i = n.GetSdkType(), a = n.GetCurrentSol().GetInstances();\n      i.BeforeRunAction(s);\n      for (let n2 = 0, i2 = a.length; n2 < i2; ++n2) {\n        const i3 = a[n2];\n        for (let s2 = 0, i4 = t.length; s2 < i4; ++s2) e[s2] = t[s2].Get(n2);\n        s.apply(i3.GetSdkInstance(), e);\n      }\n      i.AfterRunAction(s);\n    }\n    *_DebugRunObject_BeforeAfterHooks() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._parameters, e = this._results, s = this._func, n = this._objectClass, i = n.GetSdkType(), a = n.GetCurrentSol().GetInstances();\n        i.BeforeRunAction(s);\n        for (let n2 = 0, i2 = a.length; n2 < i2; ++n2) {\n          const i3 = a[n2];\n          for (let s2 = 0, i4 = t.length; s2 < i4; ++s2) e[s2] = t[s2].Get(n2);\n          yield* s.apply(i3.GetSdkInstance(), e);\n        }\n        i.AfterRunAction(s);\n      } else this._RunObject_BeforeAfterHooks();\n    }\n    _GetStaticActionThis() {\n      return this._behaviorType ? this._behaviorType.GetBehavior().GetSdkVersion() >= 2 ? this._behaviorType.GetIBehaviorType() : this._behaviorType : this._objectClass.GetPlugin().GetSdkVersion() >= 2 ? this._objectClass.GetIObjectClass() : this._objectClass;\n    }\n    _RunObject_Static() {\n      const t = this._results;\n      return EvalParams(this._parameters, t), this._func.apply(this._GetStaticActionThis(), t);\n    }\n    *_DebugRunObject_Static() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._results;\n        EvalParams(this._parameters, t);\n        let e = this._func.apply(this._GetStaticActionThis(), t);\n        return C33.IsIterator(e) && (e = yield* e), e;\n      }\n      return this._RunObject_Static();\n    }\n    _RunBehavior() {\n      const t = this._objectClass, e = t.IsFamily(), s = t.GetFamilyIndex(), n = this._parameters, i = this._anyParamVariesPerInstance, a = this._results, r = this._func, o = this._behaviorIndex, l = t.GetCurrentSol().GetInstances();\n      for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) {\n        const e3 = n[t2];\n        e3.VariesPerInstance() || (a[t2] = e3.Get(0));\n      }\n      for (let t2 = 0, h = l.length; t2 < h; ++t2) {\n        const h2 = l[t2];\n        if (i) for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) {\n          const s3 = n[e2];\n          s3.VariesPerInstance() && (a[e2] = s3.Get(t2));\n        }\n        const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;\n        r.apply(h2.GetBehaviorInstances()[o + u].GetSdkInstance(), a);\n      }\n    }\n    *_DebugRunBehavior() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._objectClass, e = t.IsFamily(), s = t.GetFamilyIndex(), n = this._parameters, i = this._anyParamVariesPerInstance, a = this._results, r = this._func, o = this._behaviorIndex, l = t.GetCurrentSol().GetInstances();\n        for (let t2 = 0, e2 = n.length; t2 < e2; ++t2) {\n          const e3 = n[t2];\n          e3.VariesPerInstance() || (a[t2] = e3.Get(0));\n        }\n        for (let t2 = 0, h = l.length; t2 < h; ++t2) {\n          const h2 = l[t2];\n          if (i) for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) {\n            const s3 = n[e2];\n            s3.VariesPerInstance() && (a[e2] = s3.Get(t2));\n          }\n          const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;\n          yield* r.apply(h2.GetBehaviorInstances()[o + u].GetSdkInstance(), a);\n        }\n      } else this._RunBehavior();\n    }\n    _RunObject_Async() {\n      const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances(), i = [];\n      for (let a = 0, r = n.length; a < r; ++a) {\n        const r2 = n[a];\n        for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) e[s2] = t[s2].Get(a);\n        i.push(s.apply(r2.GetSdkInstance(), e));\n      }\n      return Promise.all(i);\n    }\n    *_DebugRunObject_Async() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._parameters, e = this._results, s = this._func, n = this._objectClass.GetCurrentSol().GetInstances(), i = [];\n        for (let a = 0, r = n.length; a < r; ++a) {\n          const r2 = n[a];\n          for (let s2 = 0, n2 = t.length; s2 < n2; ++s2) e[s2] = t[s2].Get(a);\n          i.push(yield* s.apply(r2.GetSdkInstance(), e));\n        }\n        return Promise.all(i);\n      }\n      return this._RunObject_Async();\n    }\n    _RunBehavior_Async() {\n      const t = this._objectClass, e = t.IsFamily(), s = t.GetFamilyIndex(), n = this._parameters, i = this._results, a = this._func, r = this._behaviorIndex, o = t.GetCurrentSol().GetInstances(), l = [];\n      for (let t2 = 0, h = o.length; t2 < h; ++t2) {\n        const h2 = o[t2];\n        for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) i[e2] = n[e2].Get(t2);\n        const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;\n        l.push(a.apply(h2.GetBehaviorInstances()[r + u].GetSdkInstance(), i));\n      }\n      return Promise.all(l);\n    }\n    *_DebugRunBehavior_Async() {\n      if ((this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this._DebugReturnsGenerator()) {\n        const t = this._objectClass, e = t.IsFamily(), s = t.GetFamilyIndex(), n = this._parameters, i = this._results, a = this._func, r = this._behaviorIndex, o = t.GetCurrentSol().GetInstances(), l = [];\n        for (let t2 = 0, h = o.length; t2 < h; ++t2) {\n          const h2 = o[t2];\n          for (let e2 = 0, s2 = n.length; e2 < s2; ++e2) i[e2] = n[e2].Get(t2);\n          const u = e ? h2.GetObjectClass().GetFamilyBehaviorOffset(s) : 0;\n          l.push(yield* a.apply(h2.GetBehaviorInstances()[r + u].GetSdkInstance(), i));\n        }\n        return Promise.all(l);\n      }\n      return this._RunBehavior_Async();\n    }\n    async RunUserScript() {\n      try {\n        await this._func();\n      } catch (t) {\n        console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, \"font-size: 1.2em; font-weight: bold;\", t), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), C33.EventScript.HadUserScriptException() || (console.info(\"%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()\", \"font-weight: bold; text-decoration: underline\", \"\", \"font-weight: bold\"), C33.EventScript.SetHadUserScriptException());\n      }\n    }\n    *DebugRunUserScript() {\n      return (this.IsBreakpoint() || this._runtime.DebugBreakNext()) && (yield this), this.RunUserScript();\n    }\n    _SaveToJson() {\n      return this._savedData && this._savedData.size ? { \"ex\": C33.ToSuperJSON(this._savedData) } : null;\n    }\n    _LoadFromJson(t) {\n      if (this._savedData && (this._savedData.clear(), this._savedData = null), !t) return;\n      const e = t[\"ex\"];\n      e && (this._savedData = C33.FromSuperJSON(e));\n    }\n  };\n}\nvar EvalParams2;\n{\n  let GetInst = function(t) {\n    return t instanceof IInstance ? runtime._UnwrapScriptInterface(t) : t.GetInstance();\n  }, GetWorldInfo = function(t) {\n    return GetInst(t).GetWorldInfo();\n  }, GetInst_SDKv2 = function(t) {\n    return runtime._UnwrapScriptInterface(t);\n  }, GetWorldInfo_SDKv2 = function(t) {\n    return GetInst_SDKv2(t).GetWorldInfo();\n  }, GetObjectClass = function(t) {\n    return t instanceof IObjectClass ? runtime._UnwrapScriptInterface(t) : t;\n  }, GetLayer = function(t) {\n    return t instanceof ILayer ? runtime._UnwrapScriptInterface(t) : t;\n  }, CollMemory_Add = function(t, e, n, o) {\n    e.GetUID() < n.GetUID() ? t.Set(e, n, o) : t.Set(n, e, o);\n  }, CollMemory_Remove = function(t, e, n) {\n    e.GetUID() < n.GetUID() ? t.Delete(e, n) : t.Delete(n, e);\n  }, CollMemory_RemoveInstance = function(t, e) {\n    t.DeleteEither(e);\n  }, CollMemory_Get = function(t, e, n) {\n    return e.GetUID() < n.GetUID() ? t.Get(e, n) : t.Get(n, e);\n  }, DoOverlapCondition = function(t, e, n, o) {\n    if (!e) return false;\n    const s = 0 !== n || 0 !== o, i = t.GetWorldInfo(), r = runtime.GetCollisionEngine(), a = runtime.GetCurrentCondition(), l = a.GetEventBlock().IsOrBlock(), c = a.GetObjectClass(), u = a.IsInverted(), S = e.GetCurrentSol(), f = c !== e;\n    let G;\n    rPickType = e, needsCollisionFinish = f && !u, rPickFromElseInstances = false;\n    let d = 0, I = 0, C = false;\n    S.IsSelectAll() ? (tempRect.copy(i.GetBoundingBox()), tempRect.offset(n, o), r.GetCollisionCandidates(i.GetLayer(), e, tempRect, tempCandidates2), G = tempCandidates2) : l ? runtime.IsCurrentConditionFirst() && !S._GetOwnElseInstances().length && S._GetOwnInstances().length ? G = S._GetOwnInstances() : (G = S._GetOwnElseInstances(), rPickFromElseInstances = true) : G = S._GetOwnInstances(), s && (d = i.GetX(), I = i.GetY(), i.OffsetXY(n, o), i.SetBboxChanged());\n    for (const e2 of G) if (r.TestOverlap(t, e2)) {\n      if (C = true, u) break;\n      f && rToPick.add(e2);\n    }\n    return s && (i.SetXY(d, I), i.SetBboxChanged()), C33.clearArray(tempCandidates2), C;\n  }, FinishCollisionConditionPicking = function(t) {\n    const e = runtime.GetCurrentEvent().IsOrBlock(), n = rPickType.GetCurrentSol(), o = n._GetOwnInstances(), s = n._GetOwnElseInstances();\n    n.IsSelectAll() ? (n.SetSetPicked(rToPick), e && (C33.clearArray(s), n.AddElseInstances(rToPick, rPickType.GetInstances()))) : e ? rPickFromElseInstances ? n.TransferElseInstancesToOwn(rToPick) : (n.AddElseInstances(rToPick, o), n.SetSetPicked(rToPick)) : n.SetSetPicked(rToPick), rPickType.ApplySolToContainer();\n  }, FinishCollisionCondition = function(t, e) {\n    needsCollisionFinish && (e && FinishCollisionConditionPicking(t), rToPick.clear(), rPickType = null, needsCollisionFinish = false);\n  }, PickByUID_Normal = function(t, e) {\n    const n = runtime.GetInstanceByUID(e);\n    if (!n) return false;\n    const o = t.GetCurrentSol();\n    if (!o.IsSelectAll() && !o._GetOwnInstances().includes(n)) return false;\n    if (t.IsFamily()) {\n      if (n.GetObjectClass().BelongsToFamily(t)) return o.PickOne(n), t.ApplySolToContainer(), true;\n    } else if (n.GetObjectClass() === t) return o.PickOne(n), t.ApplySolToContainer(), true;\n    return false;\n  }, PickByUID_Inverted = function(t, e) {\n    const n = t.GetCurrentSol();\n    if (n.IsSelectAll()) {\n      n._SetSelectAll(false), n.ClearArrays();\n      const o = t.GetInstances();\n      for (let t2 = 0, s = o.length; t2 < s; ++t2) {\n        const s2 = o[t2];\n        s2.GetUID() === e ? n._PushElseInstance(s2) : n._PushInstance(s2);\n      }\n      return t.ApplySolToContainer(), !!n._GetOwnInstances().length;\n    }\n    {\n      const o = n._GetOwnInstances();\n      let s = 0;\n      for (let t2 = 0, i = o.length; t2 < i; ++t2) {\n        const i2 = o[t2];\n        o[s] = i2, i2.GetUID() === e ? n._PushElseInstance(i2) : ++s;\n      }\n      return C33.truncateArray(o, s), t.ApplySolToContainer(), !!o.length;\n    }\n  };\n  GetInst2 = GetInst, GetWorldInfo2 = GetWorldInfo, GetInst_SDKv22 = GetInst_SDKv2, GetWorldInfo_SDKv22 = GetWorldInfo_SDKv2, GetObjectClass2 = GetObjectClass, GetLayer2 = GetLayer, CollMemory_Add2 = CollMemory_Add, CollMemory_Remove2 = CollMemory_Remove, CollMemory_RemoveInstance2 = CollMemory_RemoveInstance, CollMemory_Get2 = CollMemory_Get, DoOverlapCondition2 = DoOverlapCondition, FinishCollisionConditionPicking2 = FinishCollisionConditionPicking, FinishCollisionCondition2 = FinishCollisionCondition, PickByUID_Normal2 = PickByUID_Normal, PickByUID_Inverted2 = PickByUID_Inverted;\n  const C33 = self.C3, tempColor = new C33.Color(), AnySDK = {}, SDKv1 = {}, SDKv2 = {};\n  let runtime = null;\n  C33.CommonACES_SetRuntime = function(t) {\n    runtime = t;\n  };\n  const IInstance = self.IInstance, IObjectClass = self.IObjectClass, ILayer = self.ILayer;\n  SDKv1.CompareX = function(t, e) {\n    return C33.compare(this.GetWorldInfo().GetX(), t, e);\n  }, SDKv2.CompareX = function(t, e) {\n    return C33.compare(this.x, t, e);\n  }, SDKv1.CompareY = function(t, e) {\n    return C33.compare(this.GetWorldInfo().GetY(), t, e);\n  }, SDKv2.CompareY = function(t, e) {\n    return C33.compare(this.y, t, e);\n  }, SDKv1.IsOnScreen = function() {\n    return this.GetWorldInfo().IsInViewport2();\n  }, SDKv2.IsOnScreen = function() {\n    return this.isOnScreen();\n  }, AnySDK.IsOutsideLayout = function() {\n    const t = GetWorldInfo(this), e = t.GetLayout(), n = t.GetBoundingBox();\n    return n.getRight() < 0 || n.getBottom() < 0 || n.getLeft() > e.GetWidth() || n.getTop() > e.GetHeight();\n  }, AnySDK.PickDistance = function(t, e, n) {\n    const o = GetObjectClass(this).GetCurrentSol(), s = o.GetInstances();\n    if (!s.length) return false;\n    let i = s[0], r = i.GetWorldInfo(), a = i, l = C33.distanceSquared(r.GetX(), r.GetY(), e, n);\n    for (let o2 = 1, c = s.length; o2 < c; ++o2) {\n      i = s[o2], r = i.GetWorldInfo();\n      const c2 = C33.distanceSquared(r.GetX(), r.GetY(), e, n);\n      (0 === t && c2 < l || 1 === t && c2 > l) && (l = c2, a = i);\n    }\n    return o.PickOne(a), true;\n  }, SDKv1.SetX = function(t) {\n    const e = this.GetWorldInfo();\n    e.GetX() !== t && (e.SetX(t), e.SetBboxChanged());\n  }, SDKv2.SetX = function(t) {\n    this.x = +t;\n  }, SDKv1.SetY = function(t) {\n    const e = this.GetWorldInfo();\n    e.GetY() !== t && (e.SetY(t), e.SetBboxChanged());\n  }, SDKv2.SetY = function(t) {\n    this.y = +t;\n  }, SDKv1.SetPos = function(t, e) {\n    const n = this.GetWorldInfo();\n    n.EqualsXY(t, e) || (n.SetXY(t, e), n.SetBboxChanged());\n  }, SDKv2.SetPos = function(t, e) {\n    this.setPosition(t, e);\n  }, AnySDK.SetPosToObject = function(t, e) {\n    if (!(t = GetObjectClass(t))) return;\n    const n = GetInst(this), o = t.GetPairedInstance(n);\n    if (!o) return;\n    const [s, i] = o.GetImagePoint(e), r = n.GetWorldInfo();\n    r.GetX() === s && r.GetY() === i || (r.SetXY(s, i), r.SetBboxChanged());\n  }, AnySDK.MoveForward = function(t) {\n    if (0 === t) return;\n    const e = GetWorldInfo(this);\n    e.OffsetXY(e.GetCosAngle() * t, e.GetSinAngle() * t), e.SetBboxChanged();\n  }, SDKv1.MoveAtAngle = function(t, e) {\n    if (0 === e) return;\n    const n = this.GetWorldInfo();\n    t = C33.toRadians(t), n.OffsetXY(Math.cos(t) * e, Math.sin(t) * e), n.SetBboxChanged();\n  }, SDKv2.MoveAtAngle = function(t, e) {\n    0 !== e && (t = C33.toRadians(t), this.offsetPosition(Math.cos(t) * e, Math.sin(t) * e));\n  }, SDKv1.GetX = function() {\n    return this.GetWorldInfo().GetX();\n  }, SDKv2.GetX = function() {\n    return this.x;\n  }, SDKv1.GetY = function() {\n    return this.GetWorldInfo().GetY();\n  }, SDKv2.GetY = function() {\n    return this.y;\n  }, AnySDK.GetDt = function() {\n    return runtime.GetDt(GetInst(this));\n  }, SDKv1.CompareWidth = function(t, e) {\n    return C33.compare(this.GetWorldInfo().GetWidth(), t, e);\n  }, SDKv2.CompareWidth = function(t, e) {\n    return C33.compare(this.width, t, e);\n  }, SDKv1.CompareHeight = function(t, e) {\n    return C33.compare(this.GetWorldInfo().GetHeight(), t, e);\n  }, SDKv2.CompareHeight = function(t, e) {\n    return C33.compare(this.height, t, e);\n  }, SDKv1.SetWidth = function(t) {\n    const e = this.GetWorldInfo();\n    e.GetWidth() !== t && (e.SetWidth(t), e.SetBboxChanged());\n  }, SDKv2.SetWidth = function(t) {\n    this.width = t;\n  }, SDKv1.SetHeight = function(t) {\n    const e = this.GetWorldInfo();\n    e.GetHeight() !== t && (e.SetHeight(t), e.SetBboxChanged());\n  }, SDKv2.SetHeight = function(t) {\n    this.height = t;\n  }, SDKv1.SetSize = function(t, e) {\n    const n = GetWorldInfo(this);\n    n.GetWidth() === t && n.GetHeight() === e || (n.SetSize(t, e), n.SetBboxChanged());\n  }, SDKv2.SetSize = function(t, e) {\n    this.setSize(t, e);\n  }, SDKv1.GetWidth = function() {\n    return this.GetWorldInfo().GetWidth();\n  }, SDKv2.GetWidth = function() {\n    return this.width;\n  }, SDKv1.GetHeight = function() {\n    return this.GetWorldInfo().GetHeight();\n  }, SDKv2.GetHeight = function() {\n    return this.height;\n  }, AnySDK.GetBboxLeft = function() {\n    return GetWorldInfo(this).GetBoundingBox().getLeft();\n  }, AnySDK.GetBboxTop = function() {\n    return GetWorldInfo(this).GetBoundingBox().getTop();\n  }, AnySDK.GetBboxRight = function() {\n    return GetWorldInfo(this).GetBoundingBox().getRight();\n  }, AnySDK.GetBboxBottom = function() {\n    return GetWorldInfo(this).GetBoundingBox().getBottom();\n  }, AnySDK.GetBboxMidX = function() {\n    const t = GetWorldInfo(this).GetBoundingBox();\n    return (t.getLeft() + t.getRight()) / 2;\n  }, AnySDK.GetBboxMidY = function() {\n    const t = GetWorldInfo(this).GetBoundingBox();\n    return (t.getTop() + t.getBottom()) / 2;\n  }, AnySDK.IsAngleWithin = function(t, e) {\n    return C33.angleDiff(GetWorldInfo(this).GetAngle(), C33.toRadians(e)) <= C33.toRadians(t);\n  }, AnySDK.IsAngleClockwiseFrom = function(t) {\n    return C33.angleClockwise(GetWorldInfo(this).GetAngle(), C33.toRadians(t));\n  }, AnySDK.IsBetweenAngles = function(t, e) {\n    const n = C33.toRadians(t), o = C33.toRadians(e), s = GetWorldInfo(this).GetAngle();\n    return !C33.angleClockwise(o, n) ? !(!C33.angleClockwise(s, n) && C33.angleClockwise(s, o)) : C33.angleClockwise(s, n) && !C33.angleClockwise(s, o);\n  }, SDKv1.SetAngle = function(t) {\n    const e = this.GetWorldInfo(), n = C33.clampAngle(C33.toRadians(t));\n    isNaN(n) || e.GetAngle() === n || (e.SetAngle(n), e.SetBboxChanged());\n  }, SDKv2.SetAngle = function(t) {\n    this.angleDegrees = t;\n  }, AnySDK.RotateClockwise = function(t) {\n    if (isNaN(t) || 0 === t) return;\n    const e = GetWorldInfo(this);\n    e.SetAngle(e.GetAngle() + C33.toRadians(t)), e.SetBboxChanged();\n  }, AnySDK.RotateCounterclockwise = function(t) {\n    if (isNaN(t) || 0 === t) return;\n    const e = GetWorldInfo(this);\n    e.SetAngle(e.GetAngle() - C33.toRadians(t)), e.SetBboxChanged();\n  }, AnySDK.RotateTowardAngle = function(t, e) {\n    const n = GetWorldInfo(this), o = n.GetAngle(), s = C33.angleRotate(o, C33.toRadians(e), C33.toRadians(t));\n    isNaN(s) || o === s || (n.SetAngle(s), n.SetBboxChanged());\n  }, AnySDK.RotateTowardPosition = function(t, e, n) {\n    const o = GetWorldInfo(this), s = o.GetAngle(), i = e - o.GetX(), r = n - o.GetY(), a = Math.atan2(r, i), l = C33.angleRotate(s, a, C33.toRadians(t));\n    isNaN(l) || s === l || (o.SetAngle(l), o.SetBboxChanged());\n  }, AnySDK.SetTowardPosition = function(t, e) {\n    const n = GetWorldInfo(this), o = n.GetAngle(), s = t - n.GetX(), i = e - n.GetY(), r = Math.atan2(i, s);\n    isNaN(r) || o === r || (n.SetAngle(r), n.SetBboxChanged());\n  }, SDKv1.GetAngle = function() {\n    return C33.toDegrees(this.GetWorldInfo().GetAngle());\n  }, SDKv2.GetAngle = function() {\n    return this.angleDegrees;\n  }, AnySDK.CompareOpacity = function(t, e) {\n    return C33.compare(C33.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6), t, e);\n  }, SDKv1.IsVisible = function() {\n    return this.GetWorldInfo().IsVisible();\n  }, SDKv2.IsVisible = function() {\n    return this.isVisible;\n  }, AnySDK.SetVisible = function(t) {\n    const e = GetWorldInfo(this);\n    t = 2 === t ? !e.IsVisible() : 0 !== t, e.IsVisible() !== t && (e.SetVisible(t), runtime.UpdateRender());\n  }, AnySDK.SetOpacity = function(t) {\n    const e = C33.clamp(t / 100, 0, 1), n = GetWorldInfo(this);\n    if (n.GetTransformWithParentOpacity()) {\n      if (n._GetSceneGraphInfo().GetOwnOpacity() === e) return;\n    } else if (n.GetOpacity() === e) return;\n    n.SetOpacity(e), runtime.UpdateRender();\n  }, AnySDK.SetDefaultColor = function(t) {\n    tempColor.setFromRgbValue(t);\n    const e = GetWorldInfo(this);\n    e.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor) || (e.SetUnpremultipliedColor(tempColor), runtime.UpdateRender());\n  }, AnySDK.GetColor = function() {\n    const t = GetWorldInfo(this).GetUnpremultipliedColor();\n    return C33.PackRGBAEx(t.getR(), t.getG(), t.getB(), t.getA());\n  }, AnySDK.GetOpacity = function() {\n    return C33.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6);\n  }, AnySDK.IsOnLayer = function(t) {\n    return !!(t = GetLayer(t)) && GetWorldInfo(this).GetLayer() === t;\n  }, AnySDK.PickTopBottom = function(t) {\n    const e = GetObjectClass(this).GetCurrentSol(), n = e.GetInstances();\n    if (!n.length) return false;\n    let o = n[0];\n    for (let e2 = 1, s = n.length; e2 < s; ++e2) {\n      const s2 = n[e2], i = s2.GetWorldInfo(), r = o.GetWorldInfo(), a = i.GetLayer().GetIndex(), l = r.GetLayer().GetIndex();\n      0 === t ? (a > l || a === l && i.GetZIndex() > r.GetZIndex()) && (o = s2) : (a < l || a === l && i.GetZIndex() < r.GetZIndex()) && (o = s2);\n    }\n    return e.PickOne(o), true;\n  }, SDKv1.CompareZElevation = function(t, e, n) {\n    const o = this.GetWorldInfo(), s = 0 === t ? o.GetZElevation() : o.GetTotalZElevation();\n    return C33.compare(s, e, n);\n  }, SDKv2.CompareZElevation = function(t, e, n) {\n    const o = 0 === t ? this.zElevation : this.totalZElevation;\n    return C33.compare(o, e, n);\n  }, SDKv1.MoveToTop = function() {\n    this.GetWorldInfo().ZOrderMoveToTop();\n  }, SDKv2.MoveToTop = function() {\n    this.moveToTop();\n  }, SDKv1.MoveToBottom = function() {\n    this.GetWorldInfo().ZOrderMoveToBottom();\n  }, SDKv2.MoveToBottom = function() {\n    this.moveToBottom();\n  }, AnySDK.MoveToLayer = function(t) {\n    (t = GetLayer(t)) && GetWorldInfo(this).ZOrderMoveToLayer(t);\n  }, AnySDK.ZMoveToObject = function(t, e) {\n    const n = 0 === t;\n    if (!(e = GetObjectClass(e))) return;\n    const o = GetInst(this), s = e.GetFirstPicked(o);\n    s && o.GetWorldInfo().ZOrderMoveAdjacentToInstance(s, n);\n  }, SDKv1.SetZElevation = function(t) {\n    const e = this.GetWorldInfo();\n    e.GetZElevation() !== t && (e.SetZElevation(t), runtime.UpdateRender());\n  }, SDKv2.SetZElevation = function(t) {\n    this.zElevation = t;\n  }, AnySDK.LayerNumber = function() {\n    return GetWorldInfo(this).GetLayer().GetIndex();\n  }, AnySDK.LayerName = function() {\n    return GetWorldInfo(this).GetLayer().GetName();\n  }, SDKv1.ZIndex = function() {\n    return this.GetWorldInfo().GetZIndex();\n  }, SDKv2.ZIndex = function() {\n    return this.zIndex;\n  }, SDKv1.ZElevation = function() {\n    return this.GetWorldInfo().GetZElevation();\n  }, SDKv2.ZElevation = function() {\n    return this.zElevation;\n  }, SDKv1.TotalZElevation = function() {\n    return this.GetWorldInfo().GetTotalZElevation();\n  }, SDKv2.TotalZElevation = function() {\n    return this.totalZElevation;\n  }, AnySDK.IsEffectEnabled = function(t) {\n    const e = GetInst(this), n = e.GetObjectClass().GetEffectList().GetEffectTypeByName(t);\n    if (!n) return;\n    const o = n.GetIndex();\n    return e.GetWorldInfo().GetInstanceEffectList().IsEffectIndexActive(o);\n  }, AnySDK.SetEffectEnabled = function(t, e) {\n    const n = GetInst(this), o = n.GetObjectClass().GetEffectList().GetEffectTypeByName(e);\n    if (!o) return;\n    const s = o.GetIndex(), i = 1 === t, r = n.GetWorldInfo().GetInstanceEffectList();\n    r.IsEffectIndexActive(s) !== i && (r.SetEffectIndexActive(s, i), r.UpdateActiveEffects(), runtime.UpdateRender());\n  }, AnySDK.SetEffectParam = function(t, e, n) {\n    const o = GetInst(this), s = o.GetObjectClass().GetEffectList().GetEffectTypeByName(t);\n    if (!s) return;\n    e = Math.floor(e);\n    const i = s.GetShaderProgram().GetParameterType(e);\n    if (!i) return;\n    \"color\" === i ? (tempColor.setFromRgbValue(n), n = tempColor) : \"percent\" === i && (n /= 100);\n    const r = s.GetIndex(), a = o.GetWorldInfo().GetInstanceEffectList();\n    a.SetEffectParameter(r, e, n) && a.IsEffectIndexActive(r) && runtime.UpdateRender();\n  };\n  const tempRect = C33.New(C33.Rect), tempCandidates1 = [], tempCandidates2 = [];\n  let needsCollisionFinish = false, rPickType = null, rPickFromElseInstances = false;\n  const rToPick = /* @__PURE__ */ new Set();\n  function* DebugOnCollision(t) {\n    if (!t) return false;\n    const e = this.GetRuntime(), n = e.GetCollisionEngine(), o = e.GetEventSheetManager(), s = o.GetEventStack(), i = o.GetCurrentCondition(), r = i.GetObjectClass(), a = i.GetSavedDataMap(), l = i.GetUnsavedDataMap(), c = s.GetCurrentStackFrame(), u = e.GetTickCount(), S = u - 1, f = c.GetCurrentEvent(), G = s.Push(f);\n    let d = a.get(\"collmemory\");\n    d || (d = C33.New(C33.PairMap), a.set(\"collmemory\", d)), l.get(\"collisionCreatedDestroyCallback\") || (l.set(\"collisionCreatedDestroyCallback\", true), e.Dispatcher().addEventListener(\"instancedestroy\", (t2) => CollMemory_RemoveInstance(d, t2.instance)));\n    const I = r.GetCurrentSol(), C = t.GetCurrentSol(), h = I.GetInstances();\n    let m = null;\n    for (let e2 = 0; e2 < h.length; ++e2) {\n      const s2 = h[e2];\n      C.IsSelectAll() ? (n.GetCollisionCandidates(s2.GetWorldInfo().GetLayer(), t, s2.GetWorldInfo().GetBoundingBox(), tempCandidates1), m = tempCandidates1, n.AddRegisteredCollisionCandidates(s2, t, m)) : m = C.GetInstances();\n      for (let e3 = 0; e3 < m.length; ++e3) {\n        const i2 = m[e3];\n        if (n.TestOverlap(s2, i2) || n.CheckRegisteredCollision(s2, i2)) {\n          const e4 = CollMemory_Get(d, s2, i2);\n          let n2 = false, a2 = -2;\n          \"number\" == typeof e4 && (n2 = true, a2 = e4);\n          const l2 = !n2 || a2 < S;\n          if (CollMemory_Add(d, s2, i2, u), l2) {\n            const e5 = f.GetSolModifiers();\n            o.PushCopySol(e5);\n            const n3 = r.GetCurrentSol(), a3 = t.GetCurrentSol();\n            if (n3._SetSelectAll(false), a3._SetSelectAll(false), r === t) {\n              const t2 = n3._GetOwnInstances();\n              C33.clearArray(t2), t2.push(s2), t2.push(i2), r.ApplySolToContainer();\n            } else {\n              const e6 = n3._GetOwnInstances(), o2 = a3._GetOwnInstances();\n              C33.clearArray(e6), C33.clearArray(o2), e6.push(s2), o2.push(i2), r.ApplySolToContainer(), t.ApplySolToContainer();\n            }\n            yield* f.DebugRetrigger(c, G), o.PopSol(e5);\n          }\n        } else CollMemory_Remove(d, s2, i2);\n      }\n      C33.clearArray(tempCandidates1);\n    }\n    return s.Pop(), false;\n  }\n  AnySDK.OnCollision = function(t) {\n    const e = GetObjectClass(this);\n    t = GetObjectClass(t);\n    const n = e.GetRuntime();\n    if (n.IsDebugging()) return DebugOnCollision.call(e, t);\n    if (!t) return false;\n    const o = n.GetCollisionEngine(), s = n.GetEventSheetManager(), i = s.GetEventStack(), r = s.GetCurrentCondition(), a = r.GetObjectClass(), l = r.GetSavedDataMap(), c = r.GetUnsavedDataMap(), u = i.GetCurrentStackFrame(), S = n.GetTickCount(), f = S - 1, G = u.GetCurrentEvent(), d = i.Push(G);\n    let I = l.get(\"collmemory\");\n    I || (I = C33.New(C33.PairMap), l.set(\"collmemory\", I)), c.get(\"collisionCreatedDestroyCallback\") || (c.set(\"collisionCreatedDestroyCallback\", true), n.Dispatcher().addEventListener(\"instancedestroy\", (t2) => CollMemory_RemoveInstance(I, t2.instance)));\n    const C = a.GetCurrentSol(), h = t.GetCurrentSol(), m = C.GetInstances();\n    let g = null;\n    for (let e2 = 0; e2 < m.length; ++e2) {\n      const n2 = m[e2];\n      h.IsSelectAll() ? (o.GetCollisionCandidates(n2.GetWorldInfo().GetLayer(), t, n2.GetWorldInfo().GetBoundingBox(), tempCandidates1), g = tempCandidates1, o.AddRegisteredCollisionCandidates(n2, t, g)) : g = h.GetInstances();\n      for (let e3 = 0; e3 < g.length; ++e3) {\n        const i2 = g[e3];\n        if (o.TestOverlap(n2, i2) || o.CheckRegisteredCollision(n2, i2)) {\n          const e4 = CollMemory_Get(I, n2, i2);\n          let o2 = false, r2 = -2;\n          \"number\" == typeof e4 && (o2 = true, r2 = e4);\n          const l2 = !o2 || r2 < f;\n          if (CollMemory_Add(I, n2, i2, S), l2) {\n            const e5 = G.GetSolModifiers();\n            s.PushCopySol(e5);\n            const o3 = a.GetCurrentSol(), r3 = t.GetCurrentSol();\n            if (o3._SetSelectAll(false), r3._SetSelectAll(false), a === t) {\n              const t2 = o3._GetOwnInstances();\n              C33.clearArray(t2), t2.push(n2), t2.push(i2), a.ApplySolToContainer();\n            } else {\n              const e6 = o3._GetOwnInstances(), s2 = r3._GetOwnInstances();\n              C33.clearArray(e6), C33.clearArray(s2), e6.push(n2), s2.push(i2), a.ApplySolToContainer(), t.ApplySolToContainer();\n            }\n            G.Retrigger(u, d), s.PopSol(e5);\n          }\n        } else CollMemory_Remove(I, n2, i2);\n      }\n      C33.clearArray(tempCandidates1);\n    }\n    return i.Pop(), false;\n  }, AnySDK.IsOverlapping = function(t) {\n    return t = GetObjectClass(t), DoOverlapCondition(GetInst(this), t, 0, 0);\n  }, AnySDK.IsOverlappingOffset = function(t, e, n) {\n    return t = GetObjectClass(t), DoOverlapCondition(GetInst(this), t, e, n);\n  }, AnySDK.OnHierarchyReady = function() {\n    return true;\n  }, AnySDK.HasParent = function() {\n    return GetWorldInfo(this).HasParent();\n  }, AnySDK.HasChildren = function() {\n    return GetWorldInfo(this).HasChildren();\n  }, AnySDK.PickParent = function(t, e) {\n    const n = GetObjectClass(this);\n    t = GetObjectClass(t);\n    const o = n.GetRuntime(), s = this.GetCurrentSol().GetInstances();\n    if (0 === s.length) return false;\n    const i = t.GetCurrentSol();\n    let r = i.GetInstances();\n    if (i.IsSelectAll()) {\n      const e2 = [...o.instancesPendingCreateForObjectClass(t)];\n      e2.length > 0 && (r = r.concat(e2));\n    }\n    if (0 === r.length) return false;\n    const a = i.IsSelectAll() ? null : new Set(r), l = /* @__PURE__ */ new Set();\n    for (let n2 = 0, o2 = s.length; n2 < o2; ++n2) {\n      const o3 = s[n2];\n      if (1 === e) for (const e2 of o3.parents()) e2.BelongsToObjectClass(t) && (null === a || a.has(e2)) && l.add(e2);\n      else {\n        let n3;\n        if (0 === e) {\n          if (n3 = o3.GetParent(), null === n3) continue;\n        } else n3 = o3.GetTopParent();\n        n3.BelongsToObjectClass(t) && (null === a || a.has(n3)) && l.add(n3);\n      }\n    }\n    return 0 !== l.size && (i.SetSetPicked(l), t.ApplySolToContainer(), true);\n  }, AnySDK.PickChildren = function(t, e) {\n    const n = GetObjectClass(this);\n    t = GetObjectClass(t);\n    const o = n.GetRuntime(), s = n.GetCurrentSol().GetInstances();\n    if (0 === s.length) return false;\n    const i = t.GetCurrentSol();\n    let r = i.GetInstances();\n    if (i.IsSelectAll()) {\n      const e2 = [...o.instancesPendingCreateForObjectClass(t)];\n      e2.length > 0 && (r = r.concat(e2));\n    }\n    if (0 === r.length) return false;\n    const a = i.IsSelectAll() ? null : new Set(r), l = /* @__PURE__ */ new Set();\n    for (let n2 = 0, o2 = s.length; n2 < o2; ++n2) {\n      const o3 = s[n2];\n      2 !== e || o3.HasChildren() || !o3.BelongsToObjectClass(t) || null !== a && !a.has(o3) || l.add(o3);\n      for (const n3 of 0 === e ? o3.children() : o3.allChildren()) 2 === e && n3.HasChildren() || n3.BelongsToObjectClass(t) && (null === a || a.has(n3)) && l.add(n3);\n    }\n    return 0 !== l.size && (i.SetSetPicked(l), t.ApplySolToContainer(), true);\n  }, AnySDK.PickNthChild = function(t, e, n) {\n    const o = GetObjectClass(this);\n    t = GetObjectClass(t);\n    const s = o.GetRuntime(), i = o.GetCurrentSol().GetInstances();\n    if (0 === i.length) return false;\n    const r = t.GetCurrentSol();\n    let a = r.GetInstances();\n    if (r.IsSelectAll()) {\n      const e2 = [...s.instancesPendingCreateForObjectClass(t)];\n      e2.length > 0 && (a = a.concat(e2));\n    }\n    if (0 === a.length) return false;\n    const l = r.IsSelectAll() ? null : new Set(a), c = [];\n    for (let o2 = 0, s2 = i.length; o2 < s2; ++o2) {\n      const s3 = i[o2];\n      if (0 === e) {\n        const e2 = s3.GetChildAt(n);\n        null !== e2 && e2.BelongsToObjectClass(t) && (null === l || l.has(e2)) && c.push(e2);\n      } else if (1 === e) {\n        for (const e2 of s3.children()) if (e2.BelongsToObjectClass(t)) {\n          if (0 === n) {\n            (null === l || l.has(e2)) && c.push(e2);\n            break;\n          }\n          --n;\n        }\n      }\n    }\n    return 0 !== c.length && (r.SetArrayPicked(c), t.ApplySolToContainer(), true);\n  }, AnySDK.CompareChildCount = function(t, e, n) {\n    const o = GetInst(this);\n    switch (t) {\n      case 0:\n      default:\n        return C33.compare(o.GetChildCount(), e, n);\n      case 1:\n        return C33.compare(o.GetAllChildCount(), e, n);\n    }\n  }, AnySDK.AddChild = function(t, e, n, o, s, i, r, a, l, c) {\n    t = GetObjectClass(t);\n    const u = GetInst(this), S = runtime.GetCurrentAction().GetObjectClass();\n    for (const f of t.allCorrespondingInstances(u, S)) {\n      if (!f.GetPlugin().SupportsSceneGraph()) return;\n      u.AddChild(f, { transformX: e, transformY: n, transformWidth: o, transformHeight: s, transformAngle: i, transformOpacity: r, transformZElevation: a, transformVisibility: l, destroyWithParent: c });\n    }\n  }, AnySDK.RemoveChild = function(t) {\n    t = GetObjectClass(t);\n    const e = GetInst(this), n = runtime.GetCurrentAction().GetObjectClass();\n    for (const o of t.allCorrespondingInstances(e, n)) e.RemoveChild(o);\n  }, AnySDK.RemoveFromParent = function() {\n    const t = GetInst(this);\n    if (!t.HasParent()) return;\n    t.GetParent().RemoveChild(t);\n  }, AnySDK.ParentUID = function() {\n    const t = GetInst(this).GetParent();\n    return t ? t.GetUID() : -1;\n  }, AnySDK.ChildCount = function() {\n    return GetInst(this).GetChildCount();\n  }, AnySDK.AllChildCount = function() {\n    return GetInst(this).GetAllChildCount();\n  }, AnySDK.SetMeshSize = function(t, e) {\n    t = Math.floor(t), e = Math.floor(e);\n    const n = GetWorldInfo(this);\n    t < 2 || e < 2 || !isFinite(t) || !isFinite(e) ? (n.ReleaseMesh(), n.SetBboxChanged()) : n.CreateMesh(t, e);\n  }, AnySDK.SetMeshPoint = function(t, e, n, o, s, i, r, a) {\n    const l = GetWorldInfo(this);\n    l.SetMeshPoint(t, e, { mode: 0 === n ? \"absolute\" : \"relative\", x: o, y: s, zElevation: i, u: r, v: a }) && l.SetBboxChanged();\n  }, AnySDK.MeshColumns = function() {\n    const t = GetWorldInfo(this);\n    return t.HasMesh() ? t.GetSourceMesh().GetHSize() : 0;\n  }, AnySDK.MeshRows = function() {\n    const t = GetWorldInfo(this);\n    return t.HasMesh() ? t.GetSourceMesh().GetVSize() : 0;\n  }, AnySDK.SetElementVisible = function(t) {\n    const e = GetWorldInfo(this);\n    t = 2 === t ? !e.IsVisible() : 0 !== t, e.IsVisible() !== t && e.SetVisible(t);\n  }, AnySDK.SetElementCSSStyle = function(t, e) {\n    this instanceof self.IInstance ? this.setElementCSSStyle(t, e) : this.SetElementCSSStyle(t, e);\n  }, AnySDK.SetElementAttribute = function(t, e) {\n    this instanceof self.IInstance ? this.setElementAttribute(t, \"\" + e) : this.SetElementAttribute(t, \"\" + e);\n  }, AnySDK.RemoveElementAttribute = function(t) {\n    this instanceof self.IInstance ? this.removeElementAttribute(t) : this.RemoveElementAttribute(t);\n  }, AnySDK.SetElementFocus = function() {\n    this instanceof self.IInstance ? this.focusElement() : this.FocusElement();\n  }, AnySDK.SetElementBlur = function() {\n    this instanceof self.IInstance ? this.blurElement() : this.BlurElement();\n  }, AnySDK.IsElementFocused = function() {\n    return this instanceof self.IInstance ? this.isElementFocused() : this.IsElementFocused();\n  }, AnySDK.SetElementEnabled = function(t) {\n    this instanceof self.IInstance ? this._setEnabled(0 !== t) : this._SetEnabled(0 !== t);\n  }, AnySDK.IsElementEnabled = function() {\n    return this instanceof self.IInstance ? this._isEnabled() : this._IsEnabled();\n  }, SDKv1.CompareInstanceVar = function(t, e, n) {\n    return C33.compare(this.GetInstance().GetInstanceVariableValue(t), e, n);\n  }, SDKv2.CompareInstanceVar = function(t, e, n) {\n    return C33.compare(GetInst_SDKv2(this).GetInstanceVariableValue(t), e, n);\n  }, SDKv1.IsBoolInstanceVarSet = function(t) {\n    return !!this.GetInstance().GetInstanceVariableValue(t);\n  }, SDKv2.IsBoolInstanceVarSet = function(t) {\n    return !!GetInst_SDKv2(this).GetInstanceVariableValue(t);\n  }, AnySDK.PickInstVarHiLow = function(t, e) {\n    const n = GetObjectClass(this), o = n.GetCurrentSol(), s = o.GetInstances();\n    if (!s.length) return false;\n    const i = n.IsFamily();\n    let r = null, a = 0;\n    for (let o2 = 0, l = s.length; o2 < l; ++o2) {\n      const l2 = s[o2], c = i ? l2.GetObjectClass().GetFamilyInstanceVariableOffset(n.GetFamilyIndex()) : 0, u = l2.GetInstanceVariableValue(c + e);\n      (null === r || 0 === t && u < a || 1 === t && u > a) && (a = u, r = l2);\n    }\n    return o.PickOne(r), true;\n  }, AnySDK.PickByUID = function(t) {\n    const e = GetObjectClass(this);\n    return e.GetRuntime().GetCurrentCondition().IsInverted() ? PickByUID_Inverted(e, t) : PickByUID_Normal(e, t);\n  }, AnySDK.HasTags = function(t) {\n    const e = new Set(C33.splitStringAndNormalize(t)), n = GetInst(this).GetTagsSet();\n    return e.isSubsetOf(n);\n  }, AnySDK.Tags = function() {\n    return GetInst(this).GetTagsString();\n  }, AnySDK.TagsCount = function() {\n    return GetInst(this).GetTagsSet().size;\n  }, AnySDK.TagAt = function(t) {\n    return GetInst(this).GetTagAt(t);\n  }, AnySDK.ChangeTags = function(t, e) {\n    const n = C33.splitStringAndNormalize(e);\n    if (0 === n.length) return;\n    const o = GetInst(this), s = new Set(o.GetTagsSet());\n    if (0 === t) for (const t2 of n) s.add(t2);\n    else if (1 === t) for (const t2 of n) s.delete(t2);\n    o.SetTagsSet(s);\n  }, AnySDK.Destroy = function() {\n    runtime.DestroyInstance(GetInst(this));\n  }, AnySDK.OnCreated = function() {\n    return true;\n  }, AnySDK.OnDestroyed = function() {\n    return true;\n  }, SDKv1.SetInstanceVar = function(t, e) {\n    this.GetInstance().SetInstanceVariableValue(t, e);\n  }, SDKv2.SetInstanceVar = function(t, e) {\n    GetInst_SDKv2(this).SetInstanceVariableValue(t, e);\n  }, SDKv1.AddInstanceVar = function(t, e) {\n    const n = this.GetInstance(), o = n.GetInstanceVariableValue(t);\n    \"number\" == typeof o && \"number\" != typeof e ? e = parseFloat(e) : \"string\" == typeof o && \"string\" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t, o + e);\n  }, SDKv2.AddInstanceVar = function(t, e) {\n    const n = GetInst_SDKv2(this), o = n.GetInstanceVariableValue(t);\n    \"number\" == typeof o && \"number\" != typeof e ? e = parseFloat(e) : \"string\" == typeof o && \"string\" != typeof e && (e = e.toString()), n.SetInstanceVariableValue(t, o + e);\n  }, SDKv1.SubInstanceVar = function(t, e) {\n    const n = this.GetInstance(), o = n.GetInstanceVariableValue(t);\n    \"number\" == typeof o && (\"number\" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t, o - e));\n  }, SDKv2.SubInstanceVar = function(t, e) {\n    const n = GetInst_SDKv2(this), o = n.GetInstanceVariableValue(t);\n    \"number\" == typeof o && (\"number\" != typeof e && (e = parseFloat(e)), n.SetInstanceVariableValue(t, o - e));\n  }, SDKv1.SetBoolInstanceVar = function(t, e) {\n    this.GetInstance().SetInstanceVariableValue(t, e ? 1 : 0);\n  }, SDKv2.SetBoolInstanceVar = function(t, e) {\n    GetInst_SDKv2(this).SetInstanceVariableValue(t, e ? 1 : 0);\n  }, SDKv1.ToggleBoolInstanceVar = function(t) {\n    const e = this.GetInstance();\n    e.SetInstanceVariableValue(t, 0 === e.GetInstanceVariableValue(t) ? 1 : 0);\n  }, SDKv2.ToggleBoolInstanceVar = function(t) {\n    const e = GetInst_SDKv2(this);\n    e.SetInstanceVariableValue(t, 0 === e.GetInstanceVariableValue(t) ? 1 : 0);\n  }, AnySDK.LoadFromJsonString = function(t) {\n    let e;\n    try {\n      e = JSON.parse(t);\n    } catch (t2) {\n      return void console.error(\"Failed to load from JSON string: \", t2);\n    }\n    const n = GetInst(this), o = \"state\";\n    runtime.ClearIntancesNeedingAfterLoad(), n._OnBeforeLoad(o), n.LoadFromJson(e, o), runtime.DoAfterLoad(o, { setFromJson: true });\n  }, AnySDK.AsJSON = function() {\n    return JSON.stringify(GetInst(this).SaveToJson(\"state\"));\n  }, AnySDK.ObjectTypeName = function() {\n    return GetInst(this).GetObjectClass().GetName();\n  }, AnySDK.Count = function() {\n    const t = runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();\n    let e = t.GetInstanceCount();\n    for (const n of runtime.instancesPendingCreateForObjectClass(t)) ++e;\n    return e;\n  }, AnySDK.PickedCount = function() {\n    return runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length;\n  }, SDKv1.GetIID = function() {\n    return this.GetInstance().GetIID();\n  }, SDKv2.GetIID = function() {\n    return GetInst_SDKv2(this).GetIID();\n  }, SDKv1.GetUID = function() {\n    return this.GetInstance().GetUID();\n  }, SDKv2.GetUID = function() {\n    return GetInst_SDKv2(this).GetUID();\n  }, AnySDK.OnInstanceSignal = function(t) {\n    const e = GetInst(this);\n    return t.toLowerCase() === runtime.GetEventSheetManager().GetCurrentInstanceSignalTag(e);\n  }, AnySDK.InstanceSignal = function(t) {\n    const e = GetInst(this);\n    runtime.GetEventSheetManager().InstanceSignal(e, t);\n  }, AnySDK.InstanceWaitForSignal = function(t) {\n    const e = GetObjectClass(this);\n    return runtime.GetEventSheetManager().AddScheduledWait().InitInstanceSignals(e.GetCurrentSol().GetInstances(), t), true;\n  }, AnySDK.TemplateName = function() {\n    return GetInst(this).GetTemplateName();\n  }, C33.AddCommonACEs = function(t, e, n) {\n    const o = t[1], s = t[3], i = t[4], r = t[5], a = t[6], l = t[7], c = t[8], u = t[10], S = t[11], f = t[12], G = t[13], d = t[14], I = t[15], C = t[16], h = e.Cnds, m = e.Acts, g = e.Exps, y = Object.assign({}, AnySDK, n >= 2 ? SDKv2 : SDKv1);\n    s && (h.CompareX = y.CompareX, h.CompareY = y.CompareY, h.IsOnScreen = y.IsOnScreen, h.IsOutsideLayout = y.IsOutsideLayout, h.PickDistance = y.PickDistance, m.SetX = y.SetX, m.SetY = y.SetY, m.SetPos = y.SetPos, m.SetPosToObject = y.SetPosToObject, m.MoveForward = y.MoveForward, m.MoveAtAngle = y.MoveAtAngle, g.X = y.GetX, g.Y = y.GetY, g.dt = y.GetDt), i && (h.CompareWidth = y.CompareWidth, h.CompareHeight = y.CompareHeight, m.SetWidth = y.SetWidth, m.SetHeight = y.SetHeight, m.SetSize = y.SetSize, g.Width = y.GetWidth, g.Height = y.GetHeight, g.BBoxLeft = y.GetBboxLeft, g.BBoxTop = y.GetBboxTop, g.BBoxRight = y.GetBboxRight, g.BBoxBottom = y.GetBboxBottom, g.BBoxMidX = y.GetBboxMidX, g.BBoxMidY = y.GetBboxMidY), r && (h.AngleWithin = y.IsAngleWithin, h.IsClockwiseFrom = y.IsAngleClockwiseFrom, h.IsBetweenAngles = y.IsBetweenAngles, m.SetAngle = y.SetAngle, m.RotateClockwise = y.RotateClockwise, m.RotateCounterclockwise = y.RotateCounterclockwise, m.RotateTowardAngle = y.RotateTowardAngle, m.RotateTowardPosition = y.RotateTowardPosition, m.SetTowardPosition = y.SetTowardPosition, g.Angle = y.GetAngle), a && (h.IsVisible = y.IsVisible, h.CompareOpacity = y.CompareOpacity, m.SetVisible = y.SetVisible, m.SetOpacity = y.SetOpacity, m.SetDefaultColor = y.SetDefaultColor, g.Opacity = y.GetOpacity, g.ColorValue = y.GetColor), l && (h.IsOnLayer = y.IsOnLayer, h.PickTopBottom = y.PickTopBottom, h.CompareZElevation = y.CompareZElevation, m.MoveToTop = y.MoveToTop, m.MoveToBottom = y.MoveToBottom, m.MoveToLayer = y.MoveToLayer, m.ZMoveToObject = y.ZMoveToObject, m.SetZElevation = y.SetZElevation, g.LayerNumber = y.LayerNumber, g.LayerName = y.LayerName, g.ZIndex = y.ZIndex, g.ZElevation = y.ZElevation, g.TotalZElevation = y.TotalZElevation), c && (h.IsEffectEnabled = y.IsEffectEnabled, m.SetEffectEnabled = y.SetEffectEnabled, m.SetEffectParam = y.SetEffectParam), G && (h.OnHierarchyReady = y.OnHierarchyReady, h.HasParent = y.HasParent, h.HasChildren = y.HasChildren, h.PickParent = y.PickParent, h.PickChildren = y.PickChildren, h.PickNthChild = y.PickNthChild, h.CompareChildCount = y.CompareChildCount, m.AddChild = y.AddChild, m.RemoveChild = y.RemoveChild, m.RemoveFromParent = y.RemoveFromParent, g.ParentUID = y.ParentUID, g.ChildCount = y.ChildCount, g.AllChildCount = y.AllChildCount), d && (m.SetMeshSize = y.SetMeshSize, m.SetMeshPoint = y.SetMeshPoint, g.MeshColumns = y.MeshColumns, g.MeshRows = y.MeshRows), u && (h.IsVisible = y.IsVisible, m.SetVisible = y.SetElementVisible, m.SetCSSStyle = y.SetElementCSSStyle, m.SetElemAttribute = y.SetElementAttribute, m.RemoveElemAttribute = y.RemoveElementAttribute), S && (h.IsFocused = y.IsElementFocused, m.SetFocus = y.SetElementFocus, m.SetBlur = y.SetElementBlur), f && (h.IsEnabled = y.IsElementEnabled, m.SetEnabled = y.SetElementEnabled), I && (h.OnCollision = y.OnCollision, h.IsOverlapping = y.IsOverlapping, h.IsOverlappingOffset = y.IsOverlappingOffset, e.FinishCollisionCondition = FinishCollisionCondition), o || (h.CompareInstanceVar = y.CompareInstanceVar, h.IsBoolInstanceVarSet = y.IsBoolInstanceVarSet, h.PickInstVarHiLow = y.PickInstVarHiLow, h.PickByUID = y.PickByUID, h.HasTags = y.HasTags, m.SetInstanceVar = y.SetInstanceVar, m.AddInstanceVar = y.AddInstanceVar, m.SubInstanceVar = y.SubInstanceVar, m.SetBoolInstanceVar = y.SetBoolInstanceVar, m.ToggleBoolInstanceVar = y.ToggleBoolInstanceVar, m.ChangeTags = y.ChangeTags, h.OnCreated = y.OnCreated, h.OnDestroyed = y.OnDestroyed, m.Destroy = y.Destroy, m.LoadFromJsonString || (m.LoadFromJsonString = y.LoadFromJsonString), g.AsJSON || (g.AsJSON = y.AsJSON), g.Count = y.Count, g.PickedCount = y.PickedCount, g.IID = y.GetIID, g.UID = y.GetUID, g.ObjectTypeName = y.ObjectTypeName, g.Tags = y.Tags, g.TagsCount = y.TagsCount, g.TagAt = y.TagAt, h.OnInstanceSignal = y.OnInstanceSignal, m.InstanceSignal = y.InstanceSignal, m.InstanceWaitForSignal = y.InstanceWaitForSignal), C && (g.TemplateName = y.TemplateName);\n  };\n}\nvar GetInst2;\nvar GetWorldInfo2;\nvar GetInst_SDKv22;\nvar GetWorldInfo_SDKv22;\nvar GetObjectClass2;\nvar GetLayer2;\nvar CollMemory_Add2;\nvar CollMemory_Remove2;\nvar CollMemory_RemoveInstance2;\nvar CollMemory_Get2;\nvar DoOverlapCondition2;\nvar FinishCollisionConditionPicking2;\nvar FinishCollisionCondition2;\nvar PickByUID_Normal2;\nvar PickByUID_Inverted2;\n{\n  const C33 = self.C3;\n  C33.ScheduledWait = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._eventSheetManager = t, this._type = \"\", this._time = -1, this._signalTag = \"\", this._isSignalled = false, this._event = null, this._actIndex = 0, this._solModifiers = [], this._dynamicSolModifiers = null, this._sols = /* @__PURE__ */ new Map(), this._pendingInstances = null, this._callingFunctionBlock = null, this._asyncId = -1, this._functionParameters = null, this._functionInnerLocalVars = null, this._shouldRelease = false;\n    }\n    Release() {\n      this._type = \"\", this._time = -1, this._signalTag = \"\", this._event = null, this._callingFunctionBlock = null, this._functionParameters = null, this._functionInnerLocalVars = null, this._asyncId = -1, C33.clearArray(this._solModifiers), this._dynamicSolModifiers && (this._dynamicSolModifiers.clear(), this._dynamicSolModifiers = null);\n      for (const t of this._sols.values()) t.Release();\n      this._sols.clear(), this._pendingInstances = null;\n    }\n    _Init() {\n      const t = this._eventSheetManager, e = t.GetRuntime().GetAllObjectClasses(), s = t.GetCurrentEventStackFrame();\n      this._event = s.GetCurrentEvent(), this._actIndex = s.GetActionIndex() + 1;\n      const i = t.FindFirstFunctionBlockParent(this._event);\n      i && (this._callingFunctionBlock = i, this._functionParameters = i.CaptureFunctionParameters(), this._functionInnerLocalVars = i._GetAllInnerLocalVariables().map((t2) => t2.GetValue()), i.IsAsync() && (this._asyncId = i.PauseCurrentAsyncFunction()));\n      for (const t2 of e) {\n        const e2 = t2.GetCurrentSol();\n        e2.IsSelectAll() && !this._event.HasSolModifier(t2) || (this._solModifiers.push(t2), this._sols.set(t2, C33.New(C33.SolState, e2)));\n      }\n      const n = t.GetDynamicSolModifiersSet();\n      this._dynamicSolModifiers = n.size > 0 ? n : null;\n    }\n    InitTimer(t) {\n      this._type = \"timer\", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetGameTime() + t;\n    }\n    InitWallTimer(t) {\n      this._type = \"walltimer\", this._Init(), this._time = this._eventSheetManager.GetRuntime().GetWallTime() + t;\n    }\n    InitSignal(t) {\n      this._type = \"signal\", this._Init(), this._signalTag = t.toLowerCase();\n    }\n    InitInstanceSignals(t, e) {\n      this._type = \"instance-signals\", this._Init(), this._signalTag = e.toLowerCase(), this._pendingInstances = new Set(t);\n    }\n    InitPromise(t) {\n      this._type = \"promise\", this._Init(), t.then(() => this.SetSignalled()).catch((t2) => {\n        console.warn(\"[C3 runtime] Promise rejected in 'Wait for previous actions to complete': \", t2), this.SetSignalled();\n      });\n    }\n    IsTimer() {\n      return \"timer\" === this._type;\n    }\n    IsWallTimer() {\n      return \"walltimer\" === this._type;\n    }\n    IsSignal() {\n      return \"signal\" === this._type;\n    }\n    IsInstanceSignals() {\n      return \"instance-signals\" === this._type;\n    }\n    IsPromise() {\n      return \"promise\" === this._type;\n    }\n    GetSignalTag() {\n      return this._signalTag;\n    }\n    IsSignalled() {\n      return this._isSignalled;\n    }\n    SetSignalled() {\n      this._isSignalled = true;\n    }\n    SetInstanceSignalled(t) {\n      this._pendingInstances.delete(t), 0 === this._pendingInstances.size && this.SetSignalled();\n    }\n    _ShouldRun() {\n      return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsWallTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetWallTime() : this.IsSignalled();\n    }\n    _RestoreState(t) {\n      t._Restore(this._event, this._actIndex);\n      for (const [t2, e2] of this._sols.entries()) {\n        const s = t2.GetCurrentSol();\n        e2._Restore(s);\n      }\n      this._dynamicSolModifiers && t.SetDynamicSolModifiers([...this._dynamicSolModifiers]);\n      const e = this._callingFunctionBlock;\n      e && (e.SetFunctionParameters(this._functionParameters), e._GetAllInnerLocalVariables().map((t2, e2) => t2.SetValue(this._functionInnerLocalVars[e2])), e.IsAsync() && e.ResumeAsyncFunction(this._asyncId));\n    }\n    _Run(t) {\n      this._RestoreState(t), this._event._ResumeActionsAndSubEvents(t), this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;\n    }\n    async _DebugRun(t) {\n      this._RestoreState(t);\n      for (const e of this._event._DebugResumeActionsAndSubEvents(t)) await this._eventSheetManager.GetRuntime().DebugBreak(e);\n      this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId), this._eventSheetManager.ClearSol(this._solModifiers), this._shouldRelease = true;\n    }\n    ShouldRelease() {\n      return this._shouldRelease;\n    }\n    RemoveInstances(t) {\n      for (const e of this._sols.values()) e.RemoveInstances(t);\n      if (\"instance-signals\" === this._type) {\n        for (const e of t) this._pendingInstances.delete(e);\n        0 === this._pendingInstances.size && this.SetSignalled();\n      }\n    }\n    _SaveToJson() {\n      const t = {}, e = { \"wt\": this._type, \"t\": this._time, \"st\": this._signalTag, \"s\": this._isSignalled, \"ev\": this._event.GetSID(), \"sm\": this._solModifiers.map((t2) => t2.GetSID()), \"dsm\": this._dynamicSolModifiers ? [...this._dynamicSolModifiers].map((t2) => t2.GetSID()) : null, \"sols\": t };\n      this._event._HasActionIndex(this._actIndex) && (e[\"act\"] = this._event.GetActionAt(this._actIndex).GetSID());\n      for (const [e2, s] of this._sols) t[e2.GetSID().toString()] = s._SaveToJson();\n      return \"instance-signals\" === this._type && (e[\"pi\"] = [...this._pendingInstances].map((t2) => t2.GetUID())), e;\n    }\n    static _CreateFromJson(t, e) {\n      const s = t.GetRuntime(), i = t.GetEventBlockBySID(e[\"ev\"]);\n      if (!i) return null;\n      let n = 0;\n      if (e.hasOwnProperty(\"act\")) {\n        const s2 = t.GetActionBySID(e[\"act\"]);\n        if (!s2) return null;\n        n = s2.GetIndex();\n      }\n      const a = C33.New(C33.ScheduledWait, t);\n      a._time = e[\"t\"], e.hasOwnProperty(\"wt\") ? a._type = e[\"wt\"] : a._type = -1 === a._time ? \"signal\" : \"timer\", a._signalTag = e[\"st\"], a._isSignalled = e[\"s\"], a._event = i, a._actIndex = n;\n      for (const t2 of e[\"sm\"]) {\n        const e2 = s.GetObjectClassBySID(t2);\n        e2 && a._solModifiers.push(e2);\n      }\n      if (Array.isArray(e[\"dsm\"])) for (const t2 of e[\"dsm\"]) {\n        const e2 = s.GetObjectClassBySID(t2);\n        e2 && (a._dynamicSolModifiers || (a._dynamicSolModifiers = /* @__PURE__ */ new Set()), a._dynamicSolModifiers.add(e2));\n      }\n      for (const [i2, n2] of Object.entries(e[\"sols\"])) {\n        const e2 = parseInt(i2, 10), l = s.GetObjectClassBySID(e2);\n        if (!l) continue;\n        const o = C33.New(C33.SolState, null);\n        o._LoadFromJson(t, n2), a._sols.set(l, o);\n      }\n      if (\"instance-signals\" === a._type) {\n        a._pendingInstances = /* @__PURE__ */ new Set();\n        for (const t2 of e[\"pi\"]) {\n          const e2 = s.GetInstanceByUID(t2);\n          e2 && a._pendingInstances.add(e2);\n        }\n      }\n      return a;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.SolState = class extends C33.DefendedBase {\n    constructor(s) {\n      super(), this._objectClass = null, this._isSelectAll = true, this._instances = [], s && (this._objectClass = s.GetObjectClass(), this._isSelectAll = s.IsSelectAll(), C33.shallowAssignArray(this._instances, s._GetOwnInstances()));\n    }\n    Release() {\n      this._objectClass = null, C33.clearArray(this._instances);\n    }\n    _Restore(s) {\n      s._SetSelectAll(this._isSelectAll), C33.shallowAssignArray(s._GetOwnInstances(), this._instances);\n    }\n    RemoveInstances(s) {\n      C33.arrayRemoveAllInSet(this._instances, s);\n    }\n    _SaveToJson() {\n      return { \"sa\": this._isSelectAll, \"insts\": this._instances.map((s) => s.GetUID()) };\n    }\n    _LoadFromJson(s, e) {\n      const t = s.GetRuntime();\n      this._isSelectAll = !!e[\"sa\"], C33.clearArray(this._instances);\n      for (const s2 of e[\"insts\"]) {\n        const e2 = t.GetInstanceByUID(s2);\n        e2 && this._instances.push(e2);\n      }\n    }\n  };\n}\n{\n  let GetNextParamMap = function(t, e) {\n    let s = t.get(e);\n    return s || (s = /* @__PURE__ */ new Map(), t.set(e, s)), s;\n  };\n  GetNextParamMap2 = GetNextParamMap;\n  const C33 = self.C3;\n  C33.SDKPluginBase = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._runtime = t.runtime, this._id = t.id, this._name = t.name ?? \"\", this._isSingleGlobal = !!t.isSingleGlobal, this._isWorldType = !!t.isWorld, this._isRotatable = !!t.isRotatable, this._mustPredraw = !!t.mustPredraw, this._hasEffects = !!t.hasEffects, this._supportsSceneGraph = !!t.supportsSceneGraph, this._supportsMesh = !!t.supportsMesh, this._isHTMLElementType = !!t.isHTMLElementType, this._is3d = !!t.is3d, this._sdkVersion = t.sdkVersion, this._singleGlobalObjectClass = null, this._boundACEMethodCache = /* @__PURE__ */ new Map(), this._boundACEMethodCache_1param = /* @__PURE__ */ new Map(), this._boundACEMethodCache_2params = /* @__PURE__ */ new Map(), this._boundACEMethodCache_3params = /* @__PURE__ */ new Map(), this._scriptInterfaceClass = t.scriptInterfaceClass, this._iPlugin = null;\n    }\n    Release() {\n      this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetID() {\n      return this._id;\n    }\n    GetName() {\n      return this._name;\n    }\n    OnCreate() {\n    }\n    GetConstructor() {\n      return this.GetSdkVersion() >= 2 ? this._iPlugin.constructor : this.constructor;\n    }\n    GetSdkVersion() {\n      return this._sdkVersion;\n    }\n    GetScriptInterfaceClass(t = false) {\n      let e = this._scriptInterfaceClass;\n      return t && \"function\" != typeof e && this.GetSdkVersion() >= 2 && (e = globalThis.ISDKPluginBase), e;\n    }\n    IsSingleGlobal() {\n      return this._isSingleGlobal;\n    }\n    IsWorldType() {\n      return this._isWorldType;\n    }\n    IsHTMLElementType() {\n      return this._isHTMLElementType;\n    }\n    Is3D() {\n      return this._is3d;\n    }\n    IsRotatable() {\n      return this._isRotatable;\n    }\n    MustPreDraw() {\n      return this._mustPredraw;\n    }\n    HasEffects() {\n      return this._hasEffects;\n    }\n    SupportsSceneGraph() {\n      return this._supportsSceneGraph;\n    }\n    SupportsMesh() {\n      return this._supportsMesh;\n    }\n    _GetBoundACEMethod(t, e) {\n      if (!e) throw new Error(\"missing 'this' binding\");\n      let s = this._boundACEMethodCache.get(t);\n      return s || (s = t.bind(e), this._boundACEMethodCache.set(t, s), s);\n    }\n    _GetBoundACEMethod_1param(t, e, s) {\n      if (!e) throw new Error(\"missing 'this' binding\");\n      const i = GetNextParamMap(this._boundACEMethodCache_1param, t);\n      let n = i.get(s);\n      return n || (n = t.bind(e, s), i.set(s, n), n);\n    }\n    _GetBoundACEMethod_2params(t, e, s, i) {\n      if (!e) throw new Error(\"missing 'this' binding\");\n      const n = GetNextParamMap(this._boundACEMethodCache_2params, t), r = GetNextParamMap(n, s);\n      let a = r.get(i);\n      return a || (a = t.bind(e, s, i), r.set(i, a), a);\n    }\n    _GetBoundACEMethod_3params(t, e, s, i, n) {\n      if (!e) throw new Error(\"missing 'this' binding\");\n      const r = GetNextParamMap(this._boundACEMethodCache_3params, t), a = GetNextParamMap(r, s), l = GetNextParamMap(a, i);\n      let o = l.get(n);\n      return o || (o = t.bind(e, s, i, n), l.set(n, o), o);\n    }\n    _SetSingleGlobalObjectClass(t) {\n      if (!this.IsSingleGlobal()) throw new Error(\"must be single-global plugin\");\n      this._singleGlobalObjectClass = t;\n    }\n    GetSingleGlobalObjectClass() {\n      if (!this.IsSingleGlobal()) throw new Error(\"must be single-global plugin\");\n      return this._singleGlobalObjectClass;\n    }\n    GetSingleGlobalInstance() {\n      if (!this.IsSingleGlobal()) throw new Error(\"must be single-global plugin\");\n      return this._singleGlobalObjectClass.GetSingleGlobalInstance();\n    }\n    _InitScriptInterface() {\n      const t = this.GetSdkVersion();\n      C33.AddonManager._PushInitObject(this, t);\n      const e = this.GetScriptInterfaceClass(true);\n      if (e) {\n        if (this._iPlugin = new e(), !(this._iPlugin instanceof self.IPlugin)) throw new TypeError(\"plugin class must derive from IPlugin\");\n      } else this._iPlugin = new self.IPlugin();\n      C33.AddonManager._PopInitObject(t);\n    }\n    GetIPlugin() {\n      return this._iPlugin;\n    }\n  };\n}\nvar GetNextParamMap2;\n{\n  const C33 = self.C3;\n  C33.SDKDOMPluginBase = class extends C33.SDKPluginBase {\n    constructor(e, s) {\n      super(e), this._domComponentId = s, this._nextElementId = 0, this._instMap = /* @__PURE__ */ new Map(), this.AddElementMessageHandler(\"elem-focused\", (e2) => e2._OnElemFocused()), this.AddElementMessageHandler(\"elem-blurred\", (e2) => {\n        e2 && e2._OnElemBlurred();\n      });\n    }\n    Release() {\n      super.Release();\n    }\n    _AddElement(e) {\n      const s = this._nextElementId++;\n      return this._instMap.set(s, e), s;\n    }\n    _RemoveElement(e) {\n      this._instMap.delete(e);\n    }\n    AddElementMessageHandler(e, s) {\n      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, (e2) => {\n        const t = this._instMap.get(e2[\"elementId\"]);\n        s(t, e2);\n      });\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.SDKTypeBase = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();\n    }\n    Release() {\n      this._objectClass = null, this._runtime = null, this._plugin = null;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetPlugin() {\n      return this._plugin;\n    }\n    GetImageInfo() {\n      return this._objectClass.GetImageInfo();\n    }\n    OnCreate() {\n    }\n    FinishCondition(e) {\n    }\n    BeforeRunAction(e) {\n    }\n    AfterRunAction(e) {\n    }\n    LoadTextures(e) {\n    }\n    ReleaseTextures() {\n    }\n    OnDynamicTextureLoadComplete() {\n    }\n    PreloadTexturesWithInstances(e) {\n    }\n    LoadTilemapData() {\n    }\n    GetScriptInterfaceClass() {\n      return null;\n    }\n    DispatchScriptEvent(e, t, s) {\n      const n = C33.New(C33.Event, e, t);\n      n.objectClass = this, s && Object.assign(n, s), this.GetObjectClass().DispatchUserScriptEvent(n);\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.SDKInstanceBase = class extends C33.DefendedBase {\n    constructor(e, t) {\n      super(), this._inst = e, this._domComponentId = t, this._wrapperComponentId = null, this._runtime = e.GetRuntime(), this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._tickFunc = null, this._tick2Func = null, this._isTicking = false, this._isTicking2 = false, this._disposables = null, this._wasReleased = false;\n    }\n    Release() {\n      this._wasReleased = true, this._StopTicking(), this._StopTicking2(), this._tickFunc = null, this._tick2Func = null, this._disposables && (this._disposables.Release(), this._disposables = null), this._inst = null, this._runtime = null, this._objectClass = null, this._sdkType = null;\n    }\n    WasReleased() {\n      return this._wasReleased;\n    }\n    GetInstance() {\n      return this._inst;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetPlugin() {\n      return this._sdkType.GetPlugin();\n    }\n    GetSdkType() {\n      return this._sdkType;\n    }\n    GetScriptInterface() {\n      return this._inst.GetInterfaceClass();\n    }\n    Trigger(e) {\n      return this._runtime.Trigger(e, this._inst, null);\n    }\n    DebugTrigger(e) {\n      return this._runtime.DebugTrigger(e, this._inst, null);\n    }\n    TriggerAsync(e) {\n      return this._runtime.TriggerAsync(e, this._inst, null);\n    }\n    FastTrigger(e, t) {\n      return this._runtime.FastTrigger(e, this._inst, t);\n    }\n    DebugFastTrigger(e, t) {\n      return this._runtime.DebugFastTrigger(e, this._inst, t);\n    }\n    ScheduleTriggers(e) {\n      return this._runtime.ScheduleTriggers(e);\n    }\n    AddDOMMessageHandler(e, t) {\n      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, e, t);\n    }\n    AddDOMMessageHandlers(e) {\n      for (const [t, i] of e) this.AddDOMMessageHandler(t, i);\n    }\n    PostToDOM(e, t) {\n      this._runtime.PostComponentMessageToDOM(this._domComponentId, e, t);\n    }\n    PostToDOMAsync(e, t) {\n      return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, e, t);\n    }\n    _PostToDOMMaybeSync(e, t) {\n      if (!this._runtime.IsInWorker()) return window[\"c3_runtimeInterface\"][\"_OnMessageFromRuntime\"]({ \"type\": \"event\", \"component\": this._domComponentId, \"handler\": e, \"data\": t, \"responseId\": null });\n      this.PostToDOM(e, t);\n    }\n    SetWrapperExtensionComponentId(e) {\n      if (!e) throw new Error(\"cannot set empty component id\");\n      this._wrapperComponentId = e;\n    }\n    IsWrapperExtensionAvailable() {\n      if (!this._wrapperComponentId) throw new Error(\"wrapper extension component id not set\");\n      return this._runtime.HasWrapperComponentId(this._wrapperComponentId);\n    }\n    AddWrapperExtensionMessageHandler(e, t) {\n      if (!this._wrapperComponentId) throw new Error(\"wrapper extension component id not set\");\n      this._runtime.AddWrapperExtensionMessageHandler(this._wrapperComponentId, e, t);\n    }\n    AddWrapperExtensionMessageHandlers(e) {\n      for (const [t, i] of e) this.AddWrapperExtensionMessageHandler(t, i);\n    }\n    SendWrapperExtensionMessage(e, t) {\n      if (!this._wrapperComponentId) throw new Error(\"wrapper extension component id not set\");\n      this._runtime.SendWrapperExtensionMessage(this._wrapperComponentId, e, t);\n    }\n    SendWrapperExtensionMessageAsync(e, t) {\n      if (!this._wrapperComponentId) throw new Error(\"wrapper extension component id not set\");\n      return this._runtime.SendWrapperExtensionMessageAsync(this._wrapperComponentId, e, t);\n    }\n    Tick() {\n    }\n    Tick2() {\n    }\n    _StartTicking() {\n      if (!this._isTicking) {\n        if (!this._tickFunc) if (this._runtime.IsDebug()) {\n          const e = globalThis.C3Debugger, t = this.GetPlugin();\n          this._tickFunc = () => {\n            const i = performance.now();\n            this.Tick(), e.AddIndividualPluginTickTime(t, performance.now() - i);\n          };\n        } else this._tickFunc = () => this.Tick();\n        this._runtime.Dispatcher().addEventListener(\"tick\", this._tickFunc), this._isTicking = true;\n      }\n    }\n    _StopTicking() {\n      this._isTicking && (this._runtime.Dispatcher().removeEventListener(\"tick\", this._tickFunc), this._isTicking = false);\n    }\n    IsTicking() {\n      return this._isTicking;\n    }\n    _StartTicking2() {\n      if (!this._isTicking2) {\n        if (!this._tick2Func) if (this._runtime.IsDebug()) {\n          const e = globalThis.C3Debugger, t = this.GetPlugin();\n          this._tick2Func = () => {\n            const i = performance.now();\n            this.Tick2(), e.AddIndividualPluginTickTime(t, performance.now() - i);\n          };\n        } else this._tick2Func = () => this.Tick2();\n        this._runtime.Dispatcher().addEventListener(\"tick2\", this._tick2Func), this._isTicking2 = true;\n      }\n    }\n    _StopTicking2() {\n      this._isTicking2 && (this._runtime.Dispatcher().removeEventListener(\"tick2\", this._tick2Func), this._isTicking2 = false);\n    }\n    IsTicking2() {\n      return this._isTicking2;\n    }\n    GetDebuggerProperties() {\n      return [];\n    }\n    SaveToJson() {\n      return null;\n    }\n    LoadFromJson(e) {\n    }\n    GetPropertyValueByIndex(e) {\n    }\n    SetPropertyValueByIndex(e, t) {\n    }\n    OffsetPropertyValueByIndex(e, t, i) {\n      if (0 === t) return;\n      const n = this.GetPropertyValueByIndex(e);\n      if (\"number\" != typeof n) throw new Error(\"expected number\");\n      this.SetPropertyValueByIndex(e, n + t, i);\n    }\n    SetPropertyColorOffsetValueByIndex(e, t, i, n) {\n    }\n    CallAction(e, ...t) {\n      e.call(this, ...t);\n    }\n    CallExpression(e, ...t) {\n      return e.call(this, ...t);\n    }\n    GetScriptInterfaceClass() {\n      return null;\n    }\n    DispatchScriptEvent(e, t, i) {\n      if (!this._inst.HasScriptInterface()) return;\n      const n = this.GetScriptInterface(), s = C33.New(C33.Event, e, t);\n      s.instance = n, i && Object.assign(s, i), n.dispatchEvent(s);\n    }\n    MustPreDraw() {\n      return false;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.SDKWorldInstanceBase = class extends C33.SDKInstanceBase {\n    constructor(e, t) {\n      super(e, t), this._worldInfo = e.GetWorldInfo(), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;\n    }\n    Release() {\n      if (this._renderercontextlost_handler) {\n        const e = this._runtime.Dispatcher();\n        e.removeEventListener(\"renderercontextlost\", this._renderercontextlost_handler), e.removeEventListener(\"renderercontextrestored\", this._renderercontextrestored_handler), this._renderercontextlost_handler = null, this._renderercontextrestored_handler = null;\n      }\n      this._worldInfo = null, super.Release();\n    }\n    HandleWebGLContextLoss() {\n      this.HandleRendererContextLoss();\n    }\n    OnWebGLContextLost() {\n    }\n    OnWebGLContextRestored() {\n    }\n    HandleRendererContextLoss() {\n      if (this._renderercontextlost_handler) return;\n      this._renderercontextlost_handler = () => this.OnRendererContextLost(), this._renderercontextrestored_handler = () => this.OnRendererContextRestored();\n      const e = this._runtime.Dispatcher();\n      e.addEventListener(\"renderercontextlost\", this._renderercontextlost_handler), e.addEventListener(\"renderercontextrestored\", this._renderercontextrestored_handler);\n    }\n    OnRendererContextLost() {\n      this.OnWebGLContextLost();\n    }\n    OnRendererContextRestored() {\n      this.OnWebGLContextRestored();\n    }\n    GetWorldInfo() {\n      return this._worldInfo;\n    }\n    IsOriginalSizeKnown() {\n      return false;\n    }\n    GetOriginalWidth() {\n      if (!this.IsOriginalSizeKnown()) throw new Error(\"original size not known\");\n      const e = this.GetCurrentImageInfo();\n      if (e) return e.GetWidth();\n    }\n    GetOriginalHeight() {\n      if (!this.IsOriginalSizeKnown()) throw new Error(\"original size not known\");\n      const e = this.GetCurrentImageInfo();\n      if (e) return e.GetHeight();\n    }\n    GetCurrentImageInfo() {\n      return null;\n    }\n    GetCurrentSurfaceSize() {\n      const e = this.GetCurrentImageInfo();\n      if (e) {\n        const t = e.GetTexture();\n        if (t) return [t.GetWidth(), t.GetHeight()];\n      }\n      return [100, 100];\n    }\n    GetCurrentTexRect() {\n      const e = this.GetCurrentImageInfo();\n      return e ? e.GetTexRect() : null;\n    }\n    GetCurrentTexQuad() {\n      const e = this.GetCurrentImageInfo();\n      return e ? e.GetTexQuad() : null;\n    }\n    IsCurrentTexRotated() {\n      const e = this.GetCurrentImageInfo();\n      return !!e && e.IsRotated();\n    }\n    GetImagePoint(e) {\n      const t = this._inst.GetWorldInfo();\n      return [t.GetX(), t.GetY(), t.GetTotalZElevation()];\n    }\n    LoadTilemapData(e, t, r) {\n    }\n    TestPointOverlapTile(e, t) {\n    }\n    RendersToOwnZPlane() {\n      return true;\n    }\n  };\n}\n{\n  const C33 = self.C3, tempRect = C33.New(C33.Rect);\n  C33.SDKDOMInstanceBase = class extends C33.SDKWorldInstanceBase {\n    constructor(t, e) {\n      super(t, e), this._elementId = this.GetPlugin()._AddElement(this), this._isElementShowing = true, this._elemHasFocus = false, this._autoFontSize = false, this._autoFontSizeOffset = -0.2, this._lastRect = C33.New(C33.Rect, 0, 0, -1, -1);\n      const s = this._runtime.GetCanvasManager();\n      this._lastWindowWidth = s.GetLastWidth(), this._lastWindowHeight = s.GetLastHeight(), this._lastHTMLIndex = -1, this._lastHTMLZIndex = -1, this._isPendingUpdateState = false, this._StartTicking();\n    }\n    Release() {\n      this.GetPlugin()._RemoveElement(this._elementId), this.PostToDOMElement(\"destroy\"), this._elementId = -1, super.Release();\n    }\n    _GetElementInDOMMode() {\n      if (this._runtime.IsInWorker()) throw new Error(\"not valid in worker mode\");\n      return this._PostToDOMElementMaybeSync(\"get-element\");\n    }\n    PostToDOMElement(t, e) {\n      e || (e = {}), e[\"elementId\"] = this._elementId, this.PostToDOM(t, e);\n    }\n    _PostToDOMElementMaybeSync(t, e) {\n      return e || (e = {}), e[\"elementId\"] = this._elementId, this._PostToDOMMaybeSync(t, e);\n    }\n    PostToDOMElementAsync(t, e) {\n      return e || (e = {}), e[\"elementId\"] = this._elementId, this.PostToDOMAsync(t, e);\n    }\n    CreateElement(t) {\n      t || (t = {});\n      const e = this.GetWorldInfo();\n      t[\"elementId\"] = this._elementId, t[\"isVisible\"] = e.IsVisible(), t[\"htmlIndex\"] = e.GetLayer().GetHTMLIndex(), t[\"htmlZIndex\"] = e.GetHTMLZIndex(), Object.assign(t, this.GetElementState()), this._isElementShowing = !!t[\"isVisible\"], this._PostToDOMMaybeSync(\"create\", t), this._UpdatePosition(true);\n    }\n    SetElementVisible(t) {\n      t = !!t, this._isElementShowing !== t && (this._isElementShowing = t, this.PostToDOMElement(\"set-visible\", { \"isVisible\": t }));\n    }\n    Tick() {\n      this._UpdatePosition(false);\n    }\n    _ShouldPreserveElement() {\n      const t = this._runtime.GetCanvasManager().GetFullscreenMode();\n      return \"Android\" === C33.Platform.OS && (\"scale-inner\" === t || \"scale-outer\" === t || \"crop\" === t);\n    }\n    _UpdatePosition(t) {\n      if (this.GetInstance().IsDestroyed()) return;\n      const e = this.GetWorldInfo(), s = e.GetLayer(), i = e.GetBoundingBox();\n      let [n, l] = s.LayerToCanvasCss(i.getLeft(), i.getTop()), [o, h] = s.LayerToCanvasCss(i.getRight(), i.getBottom());\n      const a = this._runtime.GetCanvasManager(), d = a.GetCssWidth(), m = a.GetCssHeight();\n      if (!e.IsVisible() || !s.IsVisible()) return void this.SetElementVisible(false);\n      if (!this._ShouldPreserveElement() && (o <= 0 || h <= 0 || n >= d || l >= m)) return void this.SetElementVisible(false);\n      tempRect.set(n, l, o, h);\n      const r = a.GetLastWidth(), _ = a.GetLastHeight(), c = s.GetHTMLIndex(), u = e.GetHTMLZIndex();\n      if (!t && tempRect.equals(this._lastRect) && this._lastWindowWidth === r && this._lastWindowHeight === _ && this._lastHTMLIndex === c && this._lastHTMLZIndex === u) return void this.SetElementVisible(true);\n      this._lastRect.copy(tempRect), this._lastWindowWidth = r, this._lastWindowHeight = _, this._lastHTMLIndex = c, this._lastHTMLZIndex = u, this.SetElementVisible(true);\n      let M = null;\n      this._autoFontSize && (M = s.GetDisplayScale() + this._autoFontSizeOffset), this._PostToDOMElementMaybeSync(\"update-position\", { \"left\": Math.round(this._lastRect.getLeft()), \"top\": Math.round(this._lastRect.getTop()), \"width\": Math.round(this._lastRect.width()), \"height\": Math.round(this._lastRect.height()), \"htmlIndex\": c, \"htmlZIndex\": u, \"fontSize\": M });\n    }\n    FocusElement() {\n      this._PostToDOMElementMaybeSync(\"focus\", { \"focus\": true });\n    }\n    BlurElement() {\n      this._PostToDOMElementMaybeSync(\"focus\", { \"focus\": false });\n    }\n    _OnElemFocused() {\n      this._elemHasFocus = true;\n    }\n    _OnElemBlurred() {\n      this._elemHasFocus = false;\n    }\n    IsElementFocused() {\n      return this._elemHasFocus;\n    }\n    SetElementCSSStyle(t, e) {\n      this.PostToDOMElement(\"set-css-style\", { \"prop\": C33.CSSToCamelCase(t), \"val\": e });\n    }\n    SetElementAttribute(t, e) {\n      this.PostToDOMElement(\"set-attribute\", { \"name\": t, \"val\": e });\n    }\n    RemoveElementAttribute(t) {\n      this.PostToDOMElement(\"remove-attribute\", { \"name\": t });\n    }\n    UpdateElementState() {\n      this._isPendingUpdateState || (this._isPendingUpdateState = true, Promise.resolve().then(() => {\n        this._isPendingUpdateState = false, this.PostToDOMElement(\"update-state\", this.GetElementState());\n      }));\n    }\n    GetElementState() {\n    }\n    GetElementId() {\n      return this._elementId;\n    }\n  };\n}\n{\n  const C33 = self.C3, IBehavior = self.IBehavior;\n  C33.SDKBehaviorBase = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e.runtime, this._id = e.id, this._name = e.name ?? \"\", this._myObjectClasses = C33.New(C33.ArraySet), this._myInstances = C33.New(C33.ArraySet), this._sdkVersion = e.sdkVersion, this._scriptInterfaceClass = e.scriptInterfaceClass, this._iBehavior = null;\n    }\n    Release() {\n      this._myInstances.Release(), this._myObjectClasses.Release(), this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetID() {\n      return this._id;\n    }\n    GetName() {\n      return this._name;\n    }\n    OnCreate() {\n    }\n    GetSdkVersion() {\n      return this._sdkVersion;\n    }\n    GetScriptInterfaceClass(e = false) {\n      let s = this._scriptInterfaceClass;\n      return e && \"function\" != typeof s && this.GetSdkVersion() >= 2 && (s = globalThis.ISDKBehaviorBase), s;\n    }\n    _AddObjectClass(e) {\n      this._myObjectClasses.Add(e);\n    }\n    GetObjectClasses() {\n      return this._myObjectClasses.GetArray();\n    }\n    _AddInstance(e) {\n      this._myInstances.Add(e);\n    }\n    _RemoveInstance(e) {\n      this._myInstances.Delete(e);\n    }\n    GetInstances() {\n      return this._myInstances.GetArray();\n    }\n    _InitScriptInterface() {\n      const e = this.GetSdkVersion();\n      C33.AddonManager._PushInitObject(this, e);\n      const s = this.GetScriptInterfaceClass(true);\n      if (s) {\n        if (this._iBehavior = new s(), !(this._iBehavior instanceof IBehavior)) throw new TypeError(\"behavior class must derive from IBehavior\");\n      } else this._iBehavior = new IBehavior();\n      C33.AddonManager._PopInitObject(e);\n    }\n    GetIBehavior() {\n      return this._iBehavior;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.SDKBehaviorTypeBase = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e.GetRuntime(), this._behaviorType = e, this._objectClass = e.GetObjectClass(), this._behavior = e.GetBehavior(), this._behavior._AddObjectClass(this._objectClass);\n    }\n    Release() {\n      this._runtime = null, this._behaviorType = null, this._objectClass = null, this._behavior = null;\n    }\n    OnCreate() {\n    }\n    GetBehaviorType() {\n      return this._behaviorType;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetBehavior() {\n      return this._behavior;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.SDKBehaviorInstanceBase = class extends C33.DefendedBase {\n    constructor(t, i) {\n      super(), this._behInst = t, this._domComponentId = i, this._inst = t.GetObjectInstance(), this._runtime = t.GetRuntime(), this._behaviorType = t.GetBehaviorType(), this._sdkType = this._behaviorType.GetSdkType(), this._isTicking = false, this._isTicking2 = false, this._isPostTicking = false, this._disposables = null;\n    }\n    Release() {\n      this._StopTicking(), this._StopTicking2(), this._StopPostTicking(), this._disposables && (this._disposables.Release(), this._disposables = null), this._behInst = null, this._inst = null, this._runtime = null, this._behaviorType = null, this._sdkType = null;\n    }\n    GetBehavior() {\n      return this._behaviorType.GetBehavior();\n    }\n    GetBehaviorInstance() {\n      return this._behInst;\n    }\n    GetObjectInstance() {\n      return this._inst;\n    }\n    GetObjectClass() {\n      return this._inst.GetObjectClass();\n    }\n    GetWorldInfo() {\n      return this._inst.GetWorldInfo();\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetBehaviorType() {\n      return this._behaviorType;\n    }\n    GetSdkType() {\n      return this._sdkType;\n    }\n    GetScriptInterface() {\n      return this._behInst.GetScriptInterface();\n    }\n    Trigger(t) {\n      return this._runtime.Trigger(t, this._inst, this._behaviorType);\n    }\n    DebugTrigger(t) {\n      return this._runtime.DebugTrigger(t, this._inst, this._behaviorType);\n    }\n    TriggerAsync(t) {\n      return this._runtime.TriggerAsync(t, this._inst, this._behaviorType);\n    }\n    PostCreate() {\n    }\n    Tick() {\n    }\n    Tick2() {\n    }\n    PostTick() {\n    }\n    _StartTicking() {\n      this._isTicking || (this._runtime._AddBehInstToTick(this), this._isTicking = true);\n    }\n    _StopTicking() {\n      this._isTicking && (this._runtime._RemoveBehInstToTick(this), this._isTicking = false);\n    }\n    IsTicking() {\n      return this._isTicking;\n    }\n    _StartTicking2() {\n      this._isTicking2 || (this._runtime._AddBehInstToTick2(this), this._isTicking2 = true);\n    }\n    _StopTicking2() {\n      this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = false);\n    }\n    IsTicking2() {\n      return this._isTicking2;\n    }\n    _StartPostTicking() {\n      this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), this._isPostTicking = true);\n    }\n    _StopPostTicking() {\n      this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = false);\n    }\n    IsPostTicking() {\n      return this._isPostTicking;\n    }\n    GetDebuggerProperties() {\n      return [];\n    }\n    AddDOMMessageHandler(t, i) {\n      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, t, i);\n    }\n    OnSpriteFrameChanged(t, i) {\n    }\n    SaveToJson() {\n      return null;\n    }\n    LoadFromJson(t) {\n    }\n    GetPropertyValueByIndex(t) {\n    }\n    SetPropertyValueByIndex(t, i) {\n    }\n    OffsetPropertyValueByIndex(t, i) {\n      if (0 === i) return;\n      const e = this.GetPropertyValueByIndex(t);\n      if (\"number\" != typeof e) throw new Error(\"expected number\");\n      this.SetPropertyValueByIndex(t, e + i);\n    }\n    SetPropertyColorOffsetValueByIndex(t, i, e, s) {\n    }\n    CallAction(t, ...i) {\n      t.call(this, ...i);\n    }\n    CallExpression(t, ...i) {\n      return t.call(this, ...i);\n    }\n    GetScriptInterfaceClass() {\n      return null;\n    }\n    DispatchScriptEvent(t, i, e) {\n      if (!this._behInst.HasScriptInterface()) return;\n      const s = this.GetScriptInterface(), n = C33.New(C33.Event, t, i);\n      n.behaviorInstance = s, n.instance = s.instance, e && Object.assign(n, e), s.dispatchEvent(n);\n    }\n  };\n}\n{\n  let ValidateInternalAPIToken = function(t) {\n    if (t !== internalApiToken) throw new Error(\"invalid internal API token\");\n  };\n  ValidateInternalAPIToken2 = ValidateInternalAPIToken;\n  const C33 = self.C3;\n  C33.Plugins = {}, C33.Behaviors = {};\n  const internalApiToken = C33._GetInternalAPIToken();\n  let initObjectStack = [], initObjectStack2 = [], initPropertiesStack = [], originalPushInitObject = null, originalPopInitObject = null, originalGetInitObject = null, originalGetInitObject2 = null;\n  const pluginsByCtor = /* @__PURE__ */ new Map(), behaviorsByCtor = /* @__PURE__ */ new Map();\n  C33.AddonManager = class extends C33.DefendedBase {\n    constructor(t, e) {\n      super(), this._runtime = t, this._allPlugins = [], this._systemPlugin = null, this._allBehaviors = [], this._delayCreateBehaviors = /* @__PURE__ */ new Map(), this._solidBehavior = null, this._jumpthruBehavior = null, this._wrapperComponentIds = new Set(e);\n    }\n    CreatePlugin(t) {\n      const e = t[19], i = this._runtime.GetObjectReference(t[0]);\n      if (!i) throw new Error(\"missing plugin\");\n      C33.AddCommonACEs(t, i, e);\n      const n = e >= 2 ? C33.SDKPluginBase : i, r = C33.New(n, { runtime: this._runtime, isSingleGlobal: t[1], isWorld: t[2], isRotatable: t[5], hasEffects: t[8], mustPredraw: t[9], supportsSceneGraph: t[13], supportsMesh: t[14], isHTMLElementType: t[17], is3d: t[18], sdkVersion: e, id: t[20], name: t[21], scriptInterfaceClass: e >= 2 ? i : null });\n      r.OnCreate(), this._allPlugins.push(r), pluginsByCtor.set(i, r);\n    }\n    CreateSystemPlugin() {\n      this._systemPlugin = C33.New(C33.Plugins.System, { runtime: this._runtime, isSingleGlobal: true }), this._systemPlugin.OnCreate();\n    }\n    CreateBehavior(t) {\n      const e = t[1], i = t[2], n = t[3], r = this._runtime.GetObjectReference(t[0]);\n      if (!r) throw new Error(\"missing behavior\");\n      this._delayCreateBehaviors.set(r, () => {\n        const t2 = e >= 2 ? C33.SDKBehaviorBase : r, s = C33.New(t2, { runtime: this._runtime, id: i, name: n, sdkVersion: e, scriptInterfaceClass: e >= 2 ? r : null });\n        s.OnCreate(), this._allBehaviors.push(s), behaviorsByCtor.set(r, s), !this._solidBehavior && C33.Behaviors.solid && s instanceof C33.Behaviors.solid ? this._solidBehavior = s : !this._jumpthruBehavior && C33.Behaviors.jumpthru && s instanceof C33.Behaviors.jumpthru && (this._jumpthruBehavior = s), s._InitScriptInterface();\n      });\n    }\n    _DelayCreateBehavior(t) {\n      const e = this._delayCreateBehaviors.get(t);\n      e && (e(), this._delayCreateBehaviors.delete(t));\n    }\n    static _PushInitObject(t, e = 1) {\n      if (C33.AddonManager._PushInitObject !== originalPushInitObject) throw new Error(\"invalid method\");\n      1 === e && initObjectStack.push(t), initObjectStack2.push(t);\n    }\n    static _PopInitObject(t = 1) {\n      if (C33.AddonManager._PopInitObject !== originalPopInitObject) throw new Error(\"invalid method\");\n      1 === t && initObjectStack.pop(), initObjectStack2.pop();\n    }\n    static _GetInitObject() {\n      if (C33.AddonManager._GetInitObject !== originalGetInitObject) throw new Error(\"invalid method\");\n      if (0 === initObjectStack.length) throw new Error(\"no init object set\");\n      return initObjectStack.at(-1);\n    }\n    static _GetInitObject2(t) {\n      if (C33.AddonManager._GetInitObject2 !== originalGetInitObject2) throw new Error(\"invalid method\");\n      if (ValidateInternalAPIToken(t), 0 === initObjectStack2.length) throw new Error(\"no init object set\");\n      return initObjectStack2.at(-1);\n    }\n    static _PushInitProperties(t) {\n      initPropertiesStack.push(t);\n    }\n    static _PopInitProperties() {\n      initPropertiesStack.pop();\n    }\n    static _GetInitProperties() {\n      if (0 === initPropertiesStack.length) throw new Error(\"no init properties set\");\n      return initPropertiesStack.at(-1);\n    }\n    _InitAddonScriptInterfaces() {\n      for (const t of this._allPlugins) t._InitScriptInterface();\n    }\n    static GetPluginByConstructorFunction(t) {\n      return pluginsByCtor.get(t) || null;\n    }\n    static GetBehaviorByConstructorFunction(t) {\n      return behaviorsByCtor.get(t) || null;\n    }\n    GetSystemPlugin() {\n      return this._systemPlugin;\n    }\n    GetSolidBehavior() {\n      return this._solidBehavior;\n    }\n    GetJumpthruBehavior() {\n      return this._jumpthruBehavior;\n    }\n    HasWrapperComponentId(t) {\n      return this._wrapperComponentIds.has(t);\n    }\n  }, originalPushInitObject = C33.AddonManager._PushInitObject, originalPopInitObject = C33.AddonManager._PopInitObject, originalGetInitObject = C33.AddonManager._GetInitObject, originalGetInitObject2 = C33.AddonManager._GetInitObject2;\n}\nvar ValidateInternalAPIToken2;\n{\n  const C33 = self.C3, allImageInfos = /* @__PURE__ */ new Set();\n  C33.ImageInfo = class extends C33.DefendedBase {\n    constructor() {\n      super(), this._generation = 0, this._url = \"\", this._size = 0, this._offsetX = 0, this._offsetY = 0, this._width = 0, this._height = 0, this._isRotated = false, this._hasMetaData = false, this._imageAsset = null, this._textureState = \"\", this._rcTex = C33.New(C33.Rect), this._quadTex = C33.New(C33.Quad), this._blobUrl = \"\", this._iImageInfo = new self.IImageInfo(this), allImageInfos.add(this);\n    }\n    Release() {\n      this.ReleaseTexture(), this._imageAsset && 0 === this._imageAsset.GetRefCount() && this._imageAsset.Release(), this._imageAsset = null, allImageInfos.delete(this), this.ReleaseBlobURL();\n    }\n    static OnRendererContextLost() {\n      for (const t of allImageInfos) t._textureState = \"\", t._rcTex.set(0, 0, 0, 0), t._quadTex.setFromRect(t._rcTex);\n    }\n    LoadData(t) {\n      this._url = t[0], this._size = t[1], this._offsetX = t[2], this._offsetY = t[3], this._width = t[4], this._height = t[5], this._isRotated = t[6], this._hasMetaData = true;\n    }\n    LoadDynamicAsset(t, e, s) {\n      if (s = !!s, this._imageAsset) throw new Error(\"already loaded asset\");\n      this._url = e;\n      const i = { isTiled: s };\n      return C33.IsAbsoluteURL(e) && (i.loadPolicy = \"remote\"), this.LoadAsset(t, i), this._imageAsset.Load();\n    }\n    LoadDynamicBlobAsset(t, e) {\n      if (this._imageAsset) throw new Error(\"already loaded asset\");\n      this._url = \"\", this._size = e.size, this._imageAsset = C33.New(C33.ImageAsset, t.GetAssetManager(), { blob: e, size: this._size, loadPolicy: \"local\" });\n    }\n    ReplaceWith(t) {\n      if (t === this) throw new Error(\"cannot replace with self\");\n      this._generation++, this.ReleaseTexture(), this._url = t._url, this._size = t._size, this._offsetX = t._offsetX, this._offsetY = t._offsetY, this._width = t._width, this._height = t._height, this._isRotated = t._isRotated, this._hasMetaData = t._hasMetaData, this._imageAsset = t._imageAsset, this._textureState = t._textureState, this._rcTex = t._rcTex, this._quadTex = t._quadTex, this.ReleaseBlobURL();\n    }\n    GetURL() {\n      return this._url;\n    }\n    GetSize() {\n      return this._size;\n    }\n    GetOffsetX() {\n      return this._offsetX;\n    }\n    GetOffsetY() {\n      return this._offsetY;\n    }\n    IsRotated() {\n      return this._isRotated;\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    GetSheetWidth() {\n      return this._imageAsset.GetWidth();\n    }\n    GetSheetHeight() {\n      return this._imageAsset.GetHeight();\n    }\n    LoadAsset(t, e) {\n      if (this._imageAsset) throw new Error(\"already got asset\");\n      e = Object.assign({}, e, { url: this.GetURL(), size: this.GetSize() }), this._imageAsset = t.LoadImage(e);\n    }\n    IsLoaded() {\n      return this._imageAsset && this._imageAsset.IsLoaded();\n    }\n    async LoadStaticTexture(t, e) {\n      if (!this._imageAsset) throw new Error(\"no asset\");\n      if (this._textureState) throw new Error(\"already loaded texture\");\n      const s = this._generation;\n      this._textureState = \"loading\";\n      const i = await this._imageAsset.LoadStaticTexture(t, e);\n      if (this._generation !== s) return null;\n      if (!i) return this._textureState = \"\", null;\n      this._textureState = \"loaded\", this._hasMetaData || (this._width = i.GetWidth(), this._height = i.GetHeight(), this._hasMetaData = true);\n      const h = this._isRotated ? this._height : this._width, a = this._isRotated ? this._width : this._height;\n      return this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + h, this._offsetY + a), this._rcTex.divide(i.GetWidth(), i.GetHeight()), this._quadTex.setFromRect(this._rcTex), this._isRotated && this._quadTex.rotatePointsAnticlockwise(), i;\n    }\n    ReleaseTexture() {\n      this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(), this._textureState = \"\", this._rcTex.set(0, 0, 0, 0), this._quadTex.setFromRect(this._rcTex));\n    }\n    GetTexture() {\n      return this._imageAsset && \"loaded\" === this._textureState ? this._imageAsset.GetTexture() : null;\n    }\n    GetTexRect() {\n      return this._rcTex;\n    }\n    GetTexQuad() {\n      return this._quadTex;\n    }\n    GetIImageInfo() {\n      return this._iImageInfo;\n    }\n    GetImageAsset() {\n      return this._imageAsset;\n    }\n    async ExtractImageToCanvas(t) {\n      t || (t = await this._imageAsset.LoadToDrawable());\n      const e = C33.CreateCanvas(this._width, this._height), s = e.getContext(\"2d\");\n      return this._isRotated ? (s.rotate(Math.PI / -2), s.translate(-this._height, 0), s.drawImage(t, this._offsetX, this._offsetY, this._height, this._width, 0, 0, this._height, this._width)) : s.drawImage(t, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height), e;\n    }\n    async ExtractImageToBlobURL(t) {\n      if (this._blobUrl) return this._blobUrl;\n      const e = await this.ExtractImageToCanvas(t), s = await C33.CanvasToBlob(e);\n      return this._blobUrl = URL.createObjectURL(s), this._blobUrl;\n    }\n    ReleaseBlobURL() {\n      this._blobUrl && (URL.revokeObjectURL(this._blobUrl), this._blobUrl = \"\");\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.AnimationInfo = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._name = e[0], this._speed = e[1], this._isLooping = !!e[2], this._repeatCount = e[3], this._repeatTo = e[4], this._isPingPong = !!e[5], this._sid = e[6], this._frames = e[7].map((e2) => C33.New(C33.AnimationFrameInfo, e2)), this._iAnimation = new self.IAnimation(this);\n    }\n    static CreateDynamic(e, t) {\n      const r = C33.New(C33.AnimationInfo, [t, 0, false, 0, 0, false, Math.floor(1e15 * Math.random()), []]);\n      return r._frames.push(C33.AnimationFrameInfo.CreateDynamic(e)), r;\n    }\n    Release() {\n      for (const e of this._frames) e.Release();\n      C33.clearArray(this._frames);\n    }\n    LoadAllAssets(e) {\n      for (const t of this._frames) t.GetImageInfo().LoadAsset(e);\n    }\n    LoadAllTextures(e, t) {\n      return Promise.all(this._frames.map((r) => r.GetImageInfo().LoadStaticTexture(e, t)));\n    }\n    ReleaseAllTextures() {\n      for (const e of this._frames) e.GetImageInfo().ReleaseTexture();\n    }\n    GetName() {\n      return this._name;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    GetFrameCount() {\n      return this._frames.length;\n    }\n    GetFrames() {\n      return this._frames;\n    }\n    GetFrameAt(e) {\n      if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError(\"invalid frame\");\n      return this._frames[e];\n    }\n    InsertFrameAt(e, t) {\n      (t = Math.floor(t)) < 0 ? this._frames.unshift(e) : t >= this._frames.length ? this._frames.push(e) : this._frames.splice(t, 0, e);\n    }\n    RemoveFrameAt(e) {\n      if ((e = Math.floor(e)) < 0 || e >= this._frames.length) throw new RangeError(\"invalid frame\");\n      this._frames[e].Release(), this._frames.splice(e, 1);\n    }\n    GetFrameIndexByTag(e) {\n      for (let t = 0, r = this._frames.length; t < r; ++t) if (C33.equalsNoCase(this._frames[t].GetTag(), e)) return t;\n      return -1;\n    }\n    FrameTagOrIndexToIndex(e) {\n      if (\"string\" == typeof e) {\n        const t = this.GetFrameIndexByTag(e);\n        if (-1 === t) throw new Error(`cannot find animation frame with tag ${e}`);\n        return t;\n      }\n      return e;\n    }\n    GetSpeed() {\n      return this._speed;\n    }\n    IsLooping() {\n      return this._isLooping;\n    }\n    GetRepeatCount() {\n      return this._repeatCount;\n    }\n    GetRepeatTo() {\n      return this._repeatTo;\n    }\n    IsPingPong() {\n      return this._isPingPong;\n    }\n    GetIAnimation() {\n      return this._iAnimation;\n    }\n  };\n}\n{\n  const C33 = self.C3, EMPTY_IMAGE_BLOB = (() => {\n    const t = atob(\"iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC\"), i = new Uint8Array(t.length);\n    for (let e = 0, n = t.length; e < n; ++e) i[e] = t.charCodeAt(e);\n    return new Blob([i], { type: \"image/png\" });\n  })();\n  C33.AnimationFrameInfo = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._imageInfo = C33.New(C33.ImageInfo), this._imageInfo.LoadData(t), this._duration = t[7], this._origin = C33.New(C33.Vector2, t[8], t[9]), this._imagePoints = t[10].map((t2) => C33.New(C33.ImagePoint, this, t2)), this._imagePointsByName = /* @__PURE__ */ new Map();\n      for (const t2 of this._imagePoints) this._imagePointsByName.set(t2.GetName().toLowerCase(), t2);\n      this._collisionPoly = null;\n      const i = t[11];\n      i.length >= 6 && (this._collisionPoly = C33.New(C33.CollisionPoly, i)), this._tag = t[12] ? t[12] : \"\", this._iAnimationFrame = new self.IAnimationFrame(this);\n    }\n    static CreateDynamic(t) {\n      const i = C33.New(C33.AnimationFrameInfo, [\"\", 0, 0, 0, 100, 100, false, 1, 0, 0, [], [], \"\"]);\n      return i._imageInfo.LoadDynamicBlobAsset(t, EMPTY_IMAGE_BLOB), i;\n    }\n    Release() {\n      this._collisionPoly && (this._collisionPoly.Release(), this._collisionPoly = null), this._imageInfo.Release(), this._imageInfo = null;\n    }\n    GetImageInfo() {\n      return this._imageInfo;\n    }\n    GetDuration() {\n      return this._duration;\n    }\n    GetOriginX() {\n      return this._origin.getX();\n    }\n    GetOriginY() {\n      return this._origin.getY();\n    }\n    GetCollisionPoly() {\n      return this._collisionPoly;\n    }\n    GetImagePointByName(t) {\n      return this._imagePointsByName.get(t.toLowerCase()) || null;\n    }\n    GetImagePointByIndex(t) {\n      return (t = Math.floor(t)) < 0 || t >= this._imagePoints.length ? null : this._imagePoints[t];\n    }\n    GetImagePointCount() {\n      return this._imagePoints.length;\n    }\n    GetTag() {\n      return this._tag;\n    }\n    GetIAnimationFrame() {\n      return this._iAnimationFrame;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.ImagePoint = class extends C33.DefendedBase {\n    constructor(e, t) {\n      super(), this._afi = e, this._name = t[0], this._pos = C33.New(C33.Vector2, t[1], t[2]);\n    }\n    Release() {\n    }\n    GetName() {\n      return this._name;\n    }\n    GetX() {\n      return this._pos.getX();\n    }\n    GetY() {\n      return this._pos.getY();\n    }\n    GetVec2() {\n      return this._pos;\n    }\n  };\n}\n{\n  const C33 = globalThis.C3, C3Debugger = globalThis.C3Debugger, IObjectClass = globalThis.IObjectClass, IObjectType = globalThis.IObjectType, IFamily = globalThis.IFamily, assert = globalThis.assert;\n  C33.ObjectClass = class extends C33.DefendedBase {\n    constructor(t, e, s) {\n      super();\n      const i = t.GetObjectReference(s[1]);\n      this._runtime = t, this._plugin = C33.AddonManager.GetPluginByConstructorFunction(i), this._sdkType = null, this._instSdkCtor = i.Instance, this._index = e, this._sid = s[11], this._name = s[0], this._jsPropName = this._runtime.GetJsPropName(s[14]), this._isGlobal = !!s[9], this._isFamily = !!s[2], this._isOnLoaderLayout = !!s[10], this._instVars = s[3].map((e2) => ({ sid: e2[0], type: e2[1], name: e2[2], jsPropName: t.GetJsPropName(e2[3]) })), this._behaviorsCount = s[4], this._effectsCount = s[5], this._isWorldType = this._plugin.IsWorldType(), this._dispatcher = C33.New(C33.Event.Dispatcher), this._effectList = null;\n      const [n, a] = t.GetCollisionEngine().GetCollisionCellSize();\n      if (this._collisionGrid = C33.New(C33.SparseGrid, n, a), this._anyCollisionCellChanged = true, this._familyMembers = null, this._familyMembersSet = null, this._familyIndex = -1, this._families = null, this._familiesSet = null, this._familyInstVarMap = null, this._familyBehaviorMap = null, this._familyEffectMap = null, this._isInContainer = false, this._container = null, this._behaviorTypes = s[8].map((t2) => C33.BehaviorType.Create(this, t2)), this._behaviorTypesIncludingInherited = [], this._behaviorsByName = /* @__PURE__ */ new Map(), this._behaviorNameToIndex = /* @__PURE__ */ new Map(), this._usedBehaviorCtors = /* @__PURE__ */ new Set(), this._customActionMap = /* @__PURE__ */ new Map(), this._solStack = C33.New(C33.SolStack, this), this._defaultInstanceData = null, this._defaultLayerIndex = 0, this._isContained = false, this._container = null, this._imageInfo = null, this._animations = null, this._animationsByName = null, this._animationsBySid = null, this._textureRefCount = 0, this._savedData = /* @__PURE__ */ new Map(), this._unsavedData = /* @__PURE__ */ new Map(), this._instances = [], this._worldInfosByLayer = /* @__PURE__ */ new Map(), this._iidsStale = true, this._plugin.HasEffects() && (this._effectList = C33.New(C33.EffectList, this, s[12])), s[6] && (this._imageInfo = C33.New(C33.ImageInfo), this._imageInfo.LoadData(s[6])), s[7]) {\n        this._animations = s[7].map((t2) => C33.New(C33.AnimationInfo, t2)), this._animationsByName = /* @__PURE__ */ new Map(), this._animationsBySid = /* @__PURE__ */ new Map();\n        for (const t2 of this._animations) this._animationsByName.set(t2.GetName().toLowerCase(), t2), this._animationsBySid.set(t2.GetSID(), t2);\n      }\n      this._isFamily ? (this._familyMembers = [], this._familyMembersSet = /* @__PURE__ */ new Set(), this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = /* @__PURE__ */ new Set(), this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []);\n      const r = this._plugin.GetSdkVersion();\n      if (r < 2 && (this._sdkType = C33.New(i.Type, this, s[15]), !(this._sdkType instanceof C33.SDKTypeBase))) throw new Error(\"v1 sdk type must derive from SDKTypeBase\");\n      let o;\n      if (this._iObjectClass = null, this._instanceUserScriptClass = null, this._userScriptDispatcher = C33.New(C33.Event.Dispatcher), C33.AddonManager._PushInitObject(this, r), r >= 2 ? (o = i.Type, o || (o = globalThis.ISDKObjectTypeBase)) : o = this._sdkType.GetScriptInterfaceClass(), o && !this._isFamily) {\n        if (this._iObjectClass = new o(r < 2 ? this : null), r < 2 && !(this._iObjectClass instanceof IObjectType)) throw new TypeError(\"script interface class must derive from IObjectType\");\n        if (r >= 2 && !(this._iObjectClass instanceof globalThis.ISDKObjectTypeBase)) throw new TypeError(\"script interface class must derive from ISDKObjectTypeBase\");\n      } else {\n        const t2 = this._isFamily ? IFamily : IObjectType;\n        this._iObjectClass = new t2();\n      }\n      if (C33.AddonManager._PopInitObject(r), s[13]) {\n        const t2 = s[13];\n        if (t2) {\n          const e2 = t2[0], s2 = t2[1], i2 = t2[2];\n          this._sdkType.LoadTilemapData(e2, s2, i2);\n        }\n      }\n      this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate(), this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(s)), this._loadInstancesJson = null;\n    }\n    static Create(t, e, s) {\n      return C33.New(C33.ObjectClass, t, e, s);\n    }\n    Release() {\n      if (this._dispatcher.Release(), this._dispatcher = null, this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null), this._animations) {\n        for (const t of this._animations) t.Release();\n        C33.clearArray(this._animations), this._animationsByName.clear(), this._animationsBySid.clear();\n      }\n      this._loadInstancesJson = null, this._solStack.Release(), this._solStack = null, this._savedData.clear(), this._unsavedData.clear(), this._container = null, this._runtime = null;\n    }\n    _LoadFamily(t) {\n      for (let e = 1, s = t.length; e < s; ++e) {\n        const s2 = this._runtime.GetObjectClassByIndex(t[e]);\n        this._familyMembers.push(s2), this._familyMembersSet.add(s2), s2._families.push(this), s2._familiesSet.add(this);\n      }\n    }\n    _SetContainer(t) {\n      this._isInContainer = true, this._container = t;\n    }\n    IsInContainer() {\n      return this._isInContainer;\n    }\n    GetContainer() {\n      return this._container;\n    }\n    _OnAfterCreate() {\n      let t = 0;\n      if (!this._isFamily) for (const e of this._families) for (const s of e.GetBehaviorTypes()) {\n        const e2 = s.GetName().toLowerCase();\n        this._behaviorsByName.set(e2, s), this._behaviorNameToIndex.set(e2, t), this._behaviorTypesIncludingInherited.push(s), ++t;\n      }\n      for (const e of this.GetBehaviorTypes()) {\n        const s = e.GetName().toLowerCase();\n        this._behaviorsByName.set(s, e), this._behaviorNameToIndex.set(s, t), this._behaviorTypesIncludingInherited.push(e), ++t;\n      }\n      for (const t2 of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(t2.GetBehavior().constructor);\n      if (!this._isFamily && this._families.length) {\n        const t2 = this._runtime.GetFamilyCount();\n        C33.extendArray(this._familyInstVarMap, t2, 0), C33.extendArray(this._familyBehaviorMap, t2, 0), C33.extendArray(this._familyEffectMap, t2, 0);\n        const e = [];\n        let s = 0, i = 0, n = 0;\n        for (const t3 of this._families) {\n          const a = t3.GetFamilyIndex();\n          this._familyInstVarMap[a] = s, s += t3.GetInstanceVariablesCount(), this._familyBehaviorMap[a] = i, i += t3.GetBehaviorTypesCount(), this._familyEffectMap[a] = n, n += t3.GetEffectTypesCount();\n          const r = t3.GetEffectList();\n          if (r && this._effectList) for (const t4 of r.GetAllEffectTypes()) e.push(t4.Clone(this._effectList));\n        }\n        this._effectList && this._effectList.PrependEffectTypes(e);\n      }\n    }\n    _CreateSingleGlobalInstance(t) {\n      const e = C33.IsFiniteNumber(t[17]) ? t[17] : this._runtime._GetNewUID(), s = C33.New(C33.Instance, { runtime: this._runtime, objectType: this, uid: e });\n      s._CreateSdkInstance(t[16], []), this._runtime._MapInstanceByUID(e, s), this._instances.push(s);\n    }\n    GetSdkType() {\n      return this._sdkType;\n    }\n    IsOnLoaderLayout() {\n      return this._isOnLoaderLayout;\n    }\n    Dispatcher() {\n      return this._dispatcher;\n    }\n    OnCreate() {\n      this._isFamily || (this._sdkType ? this._sdkType.OnCreate() : this._iObjectClass._onCreate());\n    }\n    HasLoadedTextures() {\n      return this._textureRefCount > 0;\n    }\n    async LoadTextures(t) {\n      this._isFamily || (this._textureRefCount++, 1 === this._textureRefCount && (this._sdkType ? await this._sdkType.LoadTextures(t) : await this._iObjectClass._loadTextures(this._runtime.GetCanvasManager().GetIRenderer())));\n    }\n    ReleaseTextures() {\n      if (!this._isFamily) {\n        if (this._textureRefCount--, this._textureRefCount < 0) throw new Error(\"released textures too many times\");\n        0 === this._textureRefCount && (this._sdkType ? this._sdkType.ReleaseTextures() : this._iObjectClass._releaseTextures(this._runtime.GetCanvasManager().GetIRenderer()));\n      }\n    }\n    OnDynamicTextureLoadComplete() {\n      if (this._isFamily) throw new Error(\"not applicable to family\");\n      this._sdkType ? this._sdkType.OnDynamicTextureLoadComplete() : this._iObjectClass._onDynamicTextureLoadComplete();\n    }\n    async PreloadTexturesWithInstances(t) {\n      this._isFamily || (this._sdkType ? await this._sdkType.PreloadTexturesWithInstances(t) : await this._iObjectClass._preloadTexturesWithInstances(this._runtime.GetCanvasManager().GetIRenderer()));\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetPlugin() {\n      return this._plugin;\n    }\n    GetInstanceSdkCtor() {\n      return this._instSdkCtor;\n    }\n    GetName() {\n      return this._name;\n    }\n    GetJsPropName() {\n      return this._jsPropName;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    IsFamily() {\n      return this._isFamily;\n    }\n    IsGlobal() {\n      return this._isGlobal;\n    }\n    IsWorldType() {\n      return this._isWorldType;\n    }\n    GetFamilyIndex() {\n      return this._familyIndex;\n    }\n    GetBehaviorTypes() {\n      return this._behaviorTypes;\n    }\n    GetBehaviorTypesCount() {\n      return this._behaviorsCount;\n    }\n    UsesBehaviorByCtor(t) {\n      return t && this._usedBehaviorCtors.has(t);\n    }\n    GetInstanceVariablesCount() {\n      return this._instVars.length;\n    }\n    GetInstanceVariableSIDs() {\n      return this._instVars.map((t) => t.sid);\n    }\n    GetInstanceVariableIndexBySID(t) {\n      return this._instVars.findIndex((e) => e.sid === t);\n    }\n    GetInstanceVariableIndexByName(t) {\n      return this._instVars.findIndex((e) => e.name === t);\n    }\n    _GetAllInstanceVariableNames() {\n      return this._instVars.map((t) => t.name);\n    }\n    _GetAllInstanceVariableJsPropNames() {\n      return this._instVars.map((t) => t.jsPropName);\n    }\n    GetInstanceVariableType(t) {\n      if ((t = Math.floor(t)) < 0 || t >= this._instVars.length) throw new RangeError(\"invalid instance variable index\");\n      return this._instVars[t].type;\n    }\n    GetInstanceVariableName(t) {\n      if ((t = Math.floor(t)) < 0 || t >= this._instVars.length) throw new RangeError(\"invalid instance variable index\");\n      return this._instVars[t].name;\n    }\n    GetEffectTypesCount() {\n      return this._effectsCount;\n    }\n    GetBehaviorTypesIncludingInherited() {\n      return this._behaviorTypesIncludingInherited;\n    }\n    GetBehaviorTypeByName(t) {\n      return this._behaviorsByName.get(t.toLowerCase()) || null;\n    }\n    GetBehaviorIndexByName(t) {\n      const e = this._behaviorNameToIndex.get(t.toLowerCase());\n      return void 0 === e ? -1 : e;\n    }\n    GetEffectList() {\n      return this._effectList;\n    }\n    HasEffects() {\n      return this._plugin.HasEffects();\n    }\n    UsesEffects() {\n      return this._effectList && this._effectList.HasAnyEffectType();\n    }\n    GetSolStack() {\n      return this._solStack;\n    }\n    GetCurrentSol() {\n      return this._solStack.GetCurrentSol();\n    }\n    GetImageInfo() {\n      return this._imageInfo;\n    }\n    SetDefaultInstanceData(t) {\n      this._defaultInstanceData = t;\n    }\n    GetDefaultInstanceData() {\n      return this._defaultInstanceData;\n    }\n    _SetDefaultLayerIndex(t) {\n      this._defaultLayerIndex = t;\n    }\n    GetDefaultLayerIndex() {\n      return this._defaultLayerIndex;\n    }\n    GetAnimations() {\n      return this._animations;\n    }\n    GetAnimationCount() {\n      return this._animations.length;\n    }\n    GetFamilies() {\n      return this._families;\n    }\n    BelongsToFamily(t) {\n      return this._familiesSet.has(t);\n    }\n    GetFamilyMembers() {\n      return this._familyMembers;\n    }\n    FamilyHasMember(t) {\n      return this._familyMembersSet.has(t);\n    }\n    GetFamilyBehaviorOffset(t) {\n      return this._familyBehaviorMap[t];\n    }\n    GetFamilyInstanceVariableOffset(t) {\n      return this._familyInstVarMap[t];\n    }\n    AddCustomAction(t) {\n      this._customActionMap.set(t.GetACEName().toLowerCase(), t);\n    }\n    HasOwnCustomActionByName(t) {\n      return !!this.GetOwnCustomActionByName(t);\n    }\n    GetOwnCustomActionByName(t) {\n      const e = this._customActionMap.get(t.toLowerCase());\n      return e && e.IsEnabled() ? e : null;\n    }\n    GetAllAnimations() {\n      return this._animations;\n    }\n    GetAnimationByName(t) {\n      if (!this._animations) throw new Error(\"no animations\");\n      return this._animationsByName.get(t.toLowerCase()) || null;\n    }\n    GetAnimationBySID(t) {\n      if (!this._animations) throw new Error(\"no animations\");\n      return this._animationsBySid.get(t) || null;\n    }\n    AddAnimation(t) {\n      if (this.GetAnimationByName(t)) throw new Error(`animation name '${t}' already exists`);\n      const e = C33.AnimationInfo.CreateDynamic(this.GetRuntime(), t);\n      return this._animations.push(e), this._animationsByName.set(e.GetName().toLowerCase(), e), this._animationsBySid.set(e.GetSID(), e), e;\n    }\n    RemoveAnimation(t) {\n      const e = this.GetAnimationByName(t);\n      if (!e) throw new Error(`animation name '${t}' does not exist`);\n      if (1 === this._animations.length) throw new Error(\"cannot remove last animation\");\n      const s = this._animations.indexOf(e);\n      this._animations.splice(s, 1), this._animationsByName.delete(e.GetName().toLowerCase()), this._animationsBySid.delete(e.GetSID()), e.Release();\n    }\n    GetFirstAnimation() {\n      if (!this._animations) throw new Error(\"no animations\");\n      return this._animations[0];\n    }\n    GetFirstAnimationFrame() {\n      return this.GetFirstAnimation().GetFrameAt(0);\n    }\n    GetDefaultInstanceSize() {\n      if (this._animations) {\n        const t = this.GetFirstAnimationFrame().GetImageInfo();\n        return [t.GetWidth(), t.GetHeight()];\n      }\n      return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100];\n    }\n    GetSingleGlobalInstance() {\n      if (!this._plugin.IsSingleGlobal()) throw new Error(\"not a single-global plugin\");\n      return this._instances[0];\n    }\n    GetInstances() {\n      return this._instances;\n    }\n    *instances() {\n      yield* this._instances;\n    }\n    *instancesIncludingPendingCreate() {\n      yield* this._instances, yield* this._runtime.instancesPendingCreateForObjectClass(this);\n    }\n    GetInstanceCount() {\n      return this._instances.length;\n    }\n    _AddInstance(t) {\n      this._instances.push(t);\n    }\n    _SetIIDsStale() {\n      this._iidsStale = true;\n    }\n    _UpdateIIDs() {\n      if (!this._iidsStale || this._isFamily) return;\n      const t = this._instances;\n      let e = 0;\n      for (let s2 = t.length; e < s2; ++e) t[e]._SetIID(e);\n      const s = this._runtime._GetInstancesPendingCreate();\n      for (const t2 of s) t2.GetObjectClass() === this && t2._SetIID(e++);\n      this._iidsStale = false;\n    }\n    GetInstanceByIID(t) {\n      const e = this._instances;\n      if (t < e.length) return e[t];\n      t -= e.length;\n      const s = this._runtime._GetInstancesPendingCreate();\n      for (const e2 of s) if (e2.GetObjectClass() === this) {\n        if (0 === t) return e2;\n        --t;\n      }\n      return null;\n    }\n    GetFirstPicked(t) {\n      if (t && t.IsInContainer() && t.GetObjectClass() !== this) {\n        for (const e2 of t.siblings()) if (e2.GetObjectClass() === this) return e2;\n      }\n      const e = this.GetCurrentSol().GetInstances();\n      return e.length ? e[0] : null;\n    }\n    GetPairedInstance(t) {\n      const e = this.GetCurrentSol().GetInstances();\n      return e.length > 0 ? e[t.GetIID() % e.length] : null;\n    }\n    *allCorrespondingInstances(t, e) {\n      const s = this.GetCurrentSol().GetInstances(), i = s.length, n = e.GetCurrentSol(), a = e.GetCurrentSol().GetInstances(), r = a.length;\n      let o = t.GetIID();\n      !e.IsFamily() && n.IsSelectAll() || (o = a.indexOf(t));\n      const h = Math.ceil(i / r), l = i % r;\n      let _ = 0, c = 0;\n      0 === l || o < l ? (_ = o * h, c = h) : (_ = l * h + (o - l) * (h - 1), c = h - 1);\n      for (let t2 = _, e2 = _ + c; t2 < e2; ++t2) yield s[t2];\n    }\n    FinishCondition(t) {\n      this._sdkType?.FinishCondition(t);\n    }\n    ApplySolToContainer() {\n      if (!this._isInContainer || this._isFamily) return;\n      this._UpdateIIDs();\n      const t = this.GetCurrentSol(), e = t._GetOwnInstances(), s = t.IsSelectAll(), i = this._runtime.GetCurrentEventStackFrame(), n = i && i.GetCurrentEvent() && i.GetCurrentEvent().IsOrBlock();\n      for (const i2 of this._container.objectTypes()) {\n        if (i2 === this) continue;\n        i2._UpdateIIDs();\n        const a = i2.GetCurrentSol();\n        if (a._SetSelectAll(s), !s) {\n          const s2 = a._GetOwnInstances();\n          C33.clearArray(s2);\n          for (const t2 of e) s2.push(i2.GetInstanceByIID(t2.GetIID()));\n          if (n) {\n            const e2 = t._GetOwnElseInstances(), s3 = a._GetOwnElseInstances();\n            C33.clearArray(s3);\n            for (const t2 of e2) s3.push(i2.GetInstanceByIID(t2.GetIID()));\n          }\n        }\n      }\n    }\n    _TruncateContainerSols(t, e) {\n      for (const s of this.GetContainer().objectTypes()) {\n        const i = s.GetCurrentSol();\n        t ? C33.truncateArray(i._GetOwnElseInstances(), e) : C33.truncateArray(i._GetOwnInstances(), e);\n      }\n    }\n    _GetCollisionCellGrid() {\n      return this._collisionGrid;\n    }\n    _SetAnyCollisionCellChanged(t) {\n      this._anyCollisionCellChanged = !!t;\n    }\n    _UpdateAllCollisionCells() {\n      if (this._anyCollisionCellChanged && this._isWorldType) {\n        for (const t of this._instances) t.GetWorldInfo()._UpdateCollisionCell();\n        for (const t of this._runtime._GetInstancesPendingCreate()) t.GetObjectClass() === this && t.GetWorldInfo()._UpdateCollisionCell();\n        this._anyCollisionCellChanged = false;\n      }\n    }\n    _OnWorldInstanceLayerChanged(t, e, s) {\n      if (e) {\n        const s2 = this._worldInfosByLayer.get(e);\n        s2 && (s2.delete(t), 0 === s2.size && this._worldInfosByLayer.delete(e));\n      }\n      if (s) {\n        let e2 = this._worldInfosByLayer.get(s);\n        e2 || (e2 = /* @__PURE__ */ new Set(), this._worldInfosByLayer.set(s, e2)), e2.add(t);\n      }\n    }\n    *layersHasInstancesOn() {\n      if (this.IsFamily()) {\n        const t = /* @__PURE__ */ new Set();\n        for (const e of this._familyMembers) for (const s of e.layersHasInstancesOn()) t.add(s);\n        yield* t.values();\n      } else for (const t of this._worldInfosByLayer.keys()) t.WasReleased() || (yield t);\n    }\n    GetSavedDataMap() {\n      return this._savedData || (this._savedData = /* @__PURE__ */ new Map()), this._savedData;\n    }\n    GetUnsavedDataMap() {\n      return this._unsavedData || (this._unsavedData = /* @__PURE__ */ new Map()), this._unsavedData;\n    }\n    HasSolidBehavior() {\n      return this.UsesBehaviorByCtor(C33.Behaviors.solid);\n    }\n    HasJumpthruBehavior() {\n      return this.UsesBehaviorByCtor(C33.Behaviors.jumpthru);\n    }\n    HasNoSaveBehavior() {\n      return this.UsesBehaviorByCtor(C33.Behaviors.NoSave);\n    }\n    HasPersistBehavior() {\n      return this.UsesBehaviorByCtor(C33.Behaviors.Persist);\n    }\n    _SaveToJson() {\n      const t = { \"instances\": this._instances.map((t2) => t2.SaveToJson()) };\n      return this._savedData && this._savedData.size && (t[\"ex\"] = C33.ToSuperJSON(this._savedData)), t;\n    }\n    _LoadFromJson(t, e) {\n      this._savedData && (this._savedData.clear(), this._savedData = null);\n      const s = t[\"ex\"];\n      s && (this._savedData = C33.FromSuperJSON(s));\n      const i = this._instances, n = t[\"instances\"];\n      for (let t2 = 0, e2 = Math.min(i.length, n.length); t2 < e2; ++t2) i[t2].LoadFromJson(n[t2]);\n      for (let t2 = n.length, e2 = i.length; t2 < e2; ++t2) this._runtime.DestroyInstance(i[t2]);\n      for (let t2 = i.length, s2 = n.length; t2 < s2; ++t2) {\n        const s3 = n[t2];\n        let i2 = null;\n        if (this.IsWorldType() && (i2 = this._runtime.GetMainRunningLayout().GetLayerBySID(s3[\"w\"][\"l\"]), !i2)) continue;\n        const a = this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, i2, false, 0, 0, true);\n        a.LoadFromJson(s3), e && e.add(a);\n      }\n      this._loadInstancesJson = n, this._SetIIDsStale();\n    }\n    _GetLoadInstancesJson() {\n      return this._loadInstancesJson;\n    }\n    _ClearLoadInstancesJson() {\n      this._loadInstancesJson = null;\n    }\n    _SetupSceneGraphConnectionsOnChangeOfLayout() {\n      for (let t = 0, e = this._instances; t < e; ++t) this._instances[t]._SetupSceneGraphConnectionsOnChangeOfLayout();\n    }\n    GetIObjectClass() {\n      return this._iObjectClass;\n    }\n    UserScriptDispatcher() {\n      return this._userScriptDispatcher;\n    }\n    _GetUserScriptInstanceClass() {\n      return this._instanceUserScriptClass;\n    }\n    _SetUserScriptInstanceClass(t) {\n      this._instanceUserScriptClass = t;\n    }\n    DispatchUserScriptEvent(t) {\n      const e = this._runtime, s = e.IsDebug() && !e.GetEventSheetManager().IsInEventEngine();\n      s && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(t), s && C3Debugger.AddScriptTime();\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.Container = class extends C33.DefendedBase {\n    constructor(e, t) {\n      super(), this._runtime = e, this._objectTypes = t;\n      for (const e2 of this._objectTypes) e2._SetContainer(this);\n    }\n    Release() {\n      this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetObjectTypes() {\n      return this._objectTypes;\n    }\n    objectTypes() {\n      return this._objectTypes;\n    }\n    HasAnyWorldType() {\n      return this._objectTypes.some((e) => e.IsWorldType());\n    }\n  };\n}\n{\n  const C33 = self.C3, C3Debugger = self.C3Debugger, IInstance = self.IInstance, originalAddonManager = C33.AddonManager, EMPTY_ARRAY = [];\n  let nextPuid = 0;\n  const savedDataMaps = /* @__PURE__ */ new WeakMap(), unsavedDataMaps = /* @__PURE__ */ new WeakMap(), FLAG_DESTROYED = 1, FLAG_TILEMAP = 2, FLAG_MUST_PREDRAW = 4, FLAG_SOLID_ENABLED = 8, FLAG_JUMPTHRU_ENABLED = 16, FLAG_MUST_MITIGATE_Z_FIGHTING = 32, FLAG_IS_DRAWING_WITH_EFFECTS = 64;\n  C33.Instance = class extends C33.DefendedBase {\n    constructor(t) {\n      if (C33.AddonManager !== originalAddonManager) throw new Error(\"invalid addon manager\");\n      super(), this._runtime = t.runtime, this._objectType = t.objectType, this._worldInfo = null, this._sdkInst = null, this._iScriptInterface = null, this._iid = 0, this._uid = t.uid, this._puid = nextPuid++, this._flags = 0, this._tagsSet = null;\n      const e = C33.splitStringAndNormalize(t.tags);\n      e.length > 0 && (this._tagsSet = new Set(e)), this._instVarValues = EMPTY_ARRAY, this._behaviorInstances = EMPTY_ARRAY;\n      const s = this._objectType.GetBehaviorTypesIncludingInherited();\n      s.length > 0 && (this._behaviorInstances = s.map((t2, e2) => C33.New(C33.BehaviorInstance, { runtime: this._runtime, behaviorType: t2, instance: this, index: e2 }))), this._siblings = this._objectType.IsInContainer() ? [] : null, this._timeScale = -1, this._dispatcher = null;\n      const n = this.GetPlugin();\n      if (n.MustPreDraw() && (this._flags |= 4), n.IsWorldType()) if (this._worldInfo = C33.New(C33.WorldInfo, this, t.layer), t.worldData) this._worldInfo.Init(t.worldData);\n      else {\n        this._worldInfo.InitNoData();\n        const [t2, e2] = this._objectType.GetDefaultInstanceSize();\n        this._worldInfo.SetSize(t2, e2), this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters();\n      }\n      t.instVarData ? this._LoadInstanceVariableData(t.instVarData) : this._LoadDefaultInstanceVariables();\n    }\n    Release() {\n      if (this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), this._behaviorInstances.length > 0) {\n        for (const t2 of this._behaviorInstances) t2.Release();\n        C33.clearArray(this._behaviorInstances);\n      }\n      this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null);\n      const t = savedDataMaps.get(this);\n      t && (t.clear(), savedDataMaps.delete(this));\n      const e = unsavedDataMaps.get(this);\n      e && (e.clear(), unsavedDataMaps.delete(this)), this._siblings && C33.clearArray(this._siblings), this._dispatcher && (this._dispatcher.Release(), this._dispatcher = null), this._tagsSet && this._tagsSet.clear(), this._tagsSet = null, this._runtime = null, this._objectType = null, this._instVarValues.length > 0 && C33.clearArray(this._instVarValues), this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null);\n    }\n    _LoadInstanceVariableData(t) {\n      t.length > 0 && (this._instVarValues = [], C33.shallowAssignArray(this._instVarValues, t));\n    }\n    _LoadDefaultInstanceVariables() {\n      const t = this._objectType.GetInstanceVariablesCount();\n      if (0 === t) return;\n      this._instVarValues = [];\n      const e = [0, 0, \"\"];\n      for (let s = 0; s < t; ++s) this._instVarValues.push(e[this._objectType.GetInstanceVariableType(s)]);\n    }\n    _CreateSdkInstance(t, e) {\n      if (this._sdkInst) throw new Error(\"already got sdk instance\");\n      for (let t2 = 0, s = this._behaviorInstances.length; t2 < s; ++t2) {\n        this._behaviorInstances[t2]._CreateSdkInstance(e ? e[t2] : null);\n      }\n      if (this.GetPlugin().GetSdkVersion() < 2) {\n        if (this._sdkInst = C33.New(this._objectType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof C33.SDKInstanceBase)) throw new Error(\"sdk type must derive from SDKInstanceBase\");\n        !this.GetPlugin().IsWorldType() && this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();\n      } else {\n        const e2 = this.GetPlugin().GetScriptInterfaceClass();\n        this._InitUserScriptInterface(e2.Instance, t);\n      }\n    }\n    GetSdkInstance() {\n      return this._sdkInst ?? this._iScriptInterface;\n    }\n    GetWorldInfo() {\n      return this._worldInfo;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetTimeScale() {\n      return this._timeScale;\n    }\n    GetActiveTimeScale() {\n      const t = this._timeScale;\n      return -1 === t ? this.GetRuntime().GetTimeScale() : t;\n    }\n    SetTimeScale(t) {\n      ((t = +t) < 0 || !isFinite(t)) && (t = 0), this._timeScale = t, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, true);\n    }\n    RestoreTimeScale() {\n      this._timeScale = -1, this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, false);\n    }\n    GetInstanceGameTime() {\n      return this._runtime._GetInstanceGameTime(this);\n    }\n    Dispatcher() {\n      return this._dispatcher || (this._dispatcher = C33.New(C33.Event.Dispatcher)), this._dispatcher;\n    }\n    Draw(t) {\n      this._sdkInst ? this._sdkInst.Draw(t) : this._iScriptInterface._draw(this._runtime.GetCanvasManager().GetIRenderer());\n    }\n    OnCreate(t) {\n      this._sdkInst.OnCreate(t);\n    }\n    _SetHasTilemap() {\n      this._flags |= 2;\n    }\n    HasTilemap() {\n      return !!(2 & this._flags);\n    }\n    _MarkDestroyed() {\n      this._flags |= 1;\n    }\n    IsDestroyed() {\n      return !!(1 & this._flags);\n    }\n    MustPreDraw() {\n      return !!(4 & this._flags) || this._sdkInst.MustPreDraw();\n    }\n    SetMustMitigateZFighting() {\n      this._flags |= 32;\n    }\n    MustMitigateZFighting() {\n      return !!(32 & this._flags);\n    }\n    _IsSolidEnabled() {\n      return !!(8 & this._flags);\n    }\n    _SetSolidEnabled(t) {\n      t ? this._flags |= 8 : this._flags &= -9;\n    }\n    _IsJumpthruEnabled() {\n      return !!(16 & this._flags);\n    }\n    _SetJumpthruEnabled(t) {\n      t ? this._flags |= 16 : this._flags &= -17;\n    }\n    _IsDrawingWithEffects() {\n      return !!(64 & this._flags);\n    }\n    _SetIsDrawingWithEffects(t) {\n      t ? this._flags |= 64 : this._flags &= -65;\n    }\n    SetFlag(t, e) {\n      t <<= 16, e ? this._flags |= t : this._flags &= ~t;\n    }\n    GetFlag(t) {\n      return !!(this._flags & t << 16);\n    }\n    GetCurrentImageInfo() {\n      return this._sdkInst.GetCurrentImageInfo();\n    }\n    GetCurrentSurfaceSize() {\n      return this._sdkInst.GetCurrentSurfaceSize();\n    }\n    GetCurrentTexRect() {\n      return this._sdkInst.GetCurrentTexRect();\n    }\n    GetCurrentTexQuad() {\n      return this._sdkInst.GetCurrentTexQuad();\n    }\n    IsCurrentTexRotated() {\n      return this._sdkInst.IsCurrentTexRotated();\n    }\n    GetImagePoint(t) {\n      return this._sdkInst.GetImagePoint(t);\n    }\n    GetObjectClass() {\n      return this._objectType;\n    }\n    RendersToOwnZPlane() {\n      return this._sdkInst.RendersToOwnZPlane();\n    }\n    BelongsToObjectClass(t) {\n      return t.IsFamily() ? t.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === t;\n    }\n    CollectInstancesToPick(t, e, s) {\n      const n = (e2, s2) => {\n        const n2 = s2 || e2.GetObjectClass(), i = t.get(n2);\n        i ? i.add(e2) : t.set(n2, /* @__PURE__ */ new Set([e2]));\n      };\n      if (n(this, e), this.IsInContainer()) for (const t2 of this.siblings()) n(t2);\n      if (s) for (const t2 of this.allChildren()) n(t2);\n    }\n    VerifySupportsSceneGraph() {\n      if (!this.GetPlugin().SupportsSceneGraph()) throw new Error(\"object does not support scene graph\");\n    }\n    HasParent() {\n      return null !== this.GetParent();\n    }\n    GetParent() {\n      const t = this.GetWorldInfo();\n      if (!t) return null;\n      const e = t.GetParent();\n      return e ? e.GetInstance() : null;\n    }\n    GetTopParent() {\n      const t = this.GetWorldInfo();\n      if (!t) return null;\n      const e = t.GetTopParent();\n      return e ? e.GetInstance() : null;\n    }\n    *parents() {\n      const t = this.GetWorldInfo();\n      if (t) for (const e of t.parents()) yield e.GetInstance();\n    }\n    HasChild(t) {\n      if (!t) return false;\n      for (const e of this.children()) if (e === t) return true;\n      return false;\n    }\n    HasChildren() {\n      const t = this.GetWorldInfo();\n      return !!t && t.HasChildren();\n    }\n    GetChildrenOfObjectClass(t) {\n      const e = this.GetWorldInfo();\n      if (!e) return [];\n      const s = t.GetName();\n      return e.GetChildren().map((t2) => t2.GetInstance()).filter((t2) => t2.GetObjectClass().GetName() === s);\n    }\n    GetChildren() {\n      const t = this.GetWorldInfo();\n      return t ? t.GetChildren().map((t2) => t2.GetInstance()) : [];\n    }\n    *children() {\n      const t = this.GetWorldInfo();\n      if (t) for (const e of t.children()) yield e.GetInstance();\n    }\n    *allChildren() {\n      const t = this.GetWorldInfo();\n      if (t) for (const e of t.allChildren()) yield e.GetInstance();\n    }\n    GetChildCount() {\n      const t = this.GetWorldInfo();\n      return t ? t.GetChildCount() : 0;\n    }\n    GetParentCount() {\n      return [...this.parents()].length;\n    }\n    GetAllChildCount() {\n      const t = this.GetWorldInfo();\n      return t ? t.GetAllChildCount() : 0;\n    }\n    GetChildAt(t) {\n      const e = this.GetWorldInfo();\n      if (!e) return null;\n      const s = e.GetChildAt(t);\n      return s ? s.GetInstance() : null;\n    }\n    GetIndexInParent() {\n      const t = this.GetWorldInfo();\n      if (!t) return NaN;\n      const e = t.GetParent();\n      return e ? e.GetChildIndex(t) : NaN;\n    }\n    HasChildWithUID(t) {\n      for (const e of this.GetWorldInfo().GetChildren()) if (e.GetInstance().GetUID() === t) return true;\n      return false;\n    }\n    AddChild(t, e) {\n      this.VerifySupportsSceneGraph(), t.VerifySupportsSceneGraph(), this.GetWorldInfo().AddChild(t.GetWorldInfo(), e || {});\n    }\n    RemoveChild(t) {\n      const e = this.GetWorldInfo();\n      e && e.RemoveChild(t.GetWorldInfo());\n    }\n    GetDestroyWithParent() {\n      const t = this.GetWorldInfo();\n      return !!t && t.GetDestroyWithParent();\n    }\n    SetupInitialSceneGraphConnections() {\n      const t = this.GetWorldInfo();\n      if (!t) return;\n      const e = t.GetSceneGraphChildrenExportData();\n      if (e) for (const t2 of e) {\n        const e2 = this._runtime.GetInstanceByUID(t2[2]);\n        if (e2) {\n          const s = t2[3];\n          this.AddChild(e2, { transformX: !!(1 & s), transformY: !!(s >> 1 & 1), transformWidth: !!(s >> 2 & 1), transformHeight: !!(s >> 3 & 1), transformAngle: !!(s >> 4 & 1), destroyWithParent: !!(s >> 5 & 1), transformZElevation: !!(s >> 6 & 1), transformOpacity: !!(s >> 7 & 1), transformVisibility: !!(s >> 8 & 1) });\n        }\n      }\n    }\n    SetupPersistedSceneGraphConnections(t, e) {\n      const s = t.get(this);\n      if (s) for (const t2 of s[\"sceneGraphJson\"][\"children\"]) {\n        const s2 = e.get(t2[\"index\"]);\n        if (!s2) continue;\n        const n = t2[\"flags\"];\n        this.AddChild(s2, { transformX: !!(1 & n), transformY: !!(n >> 1 & 1), transformWidth: !!(n >> 2 & 1), transformHeight: !!(n >> 3 & 1), transformAngle: !!(n >> 4 & 1), destroyWithParent: !!(n >> 5 & 1), transformZElevation: !!(n >> 6 & 1), transformOpacity: !!(n >> 7 & 1), transformVisibility: !!(n >> 8 & 1) });\n      }\n    }\n    GetTemplateName() {\n      const t = this._runtime.GetTemplateManager();\n      return t ? t.GetInstanceTemplateName(this) : \"\";\n    }\n    IsInContainer() {\n      return null !== this._siblings;\n    }\n    _ClearSiblings() {\n      C33.clearArray(this._siblings);\n    }\n    _AddSibling(t) {\n      this._siblings.push(t);\n    }\n    GetSiblings() {\n      return this._siblings;\n    }\n    HasSibling(t) {\n      return !!this.GetSibling(t);\n    }\n    GetSibling(t) {\n      const e = this.siblings();\n      if (null === e || 0 === e.length) return false;\n      for (const s of e) if (s.GetObjectClass() === t) return s;\n      return null;\n    }\n    siblings() {\n      return this._siblings;\n    }\n    SetSiblingsSinglePicked() {\n      for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol().SetSinglePicked(t);\n    }\n    _PushSiblingsToSolInstances() {\n      for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._PushInstance(t);\n    }\n    _SetSiblingsToSolInstancesIndex(t) {\n      for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnInstances()[t] = e;\n    }\n    _PushSiblingsToSolElseInstances() {\n      for (const t of this.siblings()) t.GetObjectClass().GetCurrentSol()._PushElseInstance(t);\n    }\n    _SetSiblingsToSolElseInstancesIndex(t) {\n      for (const e of this.siblings()) e.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[t] = e;\n    }\n    GetPlugin() {\n      return this._objectType.GetPlugin();\n    }\n    _SetIID(t) {\n      this._iid = t;\n    }\n    GetIID() {\n      return this._objectType._UpdateIIDs(), this._iid;\n    }\n    GetUID() {\n      return this._uid;\n    }\n    SetUID(t) {\n      this._uid = t;\n    }\n    GetPUID() {\n      return this._puid;\n    }\n    _SetTagsSetFromJson(t) {\n      t ? this.SetTagsSet(new Set(t)) : this._tagsSet = null;\n    }\n    SetTagsSet(t) {\n      if (0 === t.size) this._tagsSet = null;\n      else {\n        this._tagsSet ? this._tagsSet.clear() : this._tagsSet = /* @__PURE__ */ new Set();\n        for (const e of t) this._tagsSet.add(e);\n      }\n    }\n    GetTagsSet() {\n      return this._tagsSet ?? /* @__PURE__ */ new Set();\n    }\n    GetTagsString() {\n      return Array.from(this.GetTagsSet()).join(\" \");\n    }\n    GetTagAt(t) {\n      t = Math.floor(t);\n      for (const e of this.GetTagsSet()) {\n        if (0 === t) return e;\n        --t;\n      }\n      return \"\";\n    }\n    GetBehaviorInstances() {\n      return this._behaviorInstances;\n    }\n    GetBehaviorInstanceFromCtor(t) {\n      if (!t) return null;\n      for (const e of this._behaviorInstances) if (e.GetBehavior() instanceof t) return e;\n      return null;\n    }\n    GetBehaviorSdkInstanceFromCtor(t) {\n      if (!t) return null;\n      const e = this.GetBehaviorInstanceFromCtor(t);\n      return e ? e.GetSdkInstance() : null;\n    }\n    GetBehaviorIndexBySID(t) {\n      const e = this._behaviorInstances;\n      for (let s = 0, n = e.length; s < n; ++s) if (e[s].GetBehaviorType().GetSID() === t) return s;\n      return -1;\n    }\n    GetAllInstanceVariableValues() {\n      return this._instVarValues;\n    }\n    _GetAllInstanceVariableNames() {\n      return this._objectType._GetAllInstanceVariableNames();\n    }\n    GetInstanceVariableCount() {\n      return this._instVarValues.length;\n    }\n    GetInstanceVariableValue(t) {\n      t |= 0;\n      const e = this._instVarValues;\n      if (t < 0 || t >= e.length) throw new RangeError(\"invalid instance variable\");\n      return e[t];\n    }\n    _GetInstanceVariableValueUnchecked(t) {\n      return this._instVarValues[t];\n    }\n    _GetInstanceVariableTypedValue(t) {\n      const e = this._instVarValues[t];\n      return 0 === this._objectType.GetInstanceVariableType(t) ? !!e : e;\n    }\n    SetInstanceVariableValue(t, e) {\n      t |= 0;\n      const s = this._instVarValues;\n      if (t < 0 || t >= s.length) throw new RangeError(\"invalid instance variable\");\n      switch (this._objectType.GetInstanceVariableType(t)) {\n        case 0:\n          s[t] = e ? 1 : 0;\n          break;\n        case 1:\n          s[t] = \"number\" == typeof e ? e : parseFloat(e);\n          break;\n        case 2:\n          s[t] = \"string\" == typeof e ? e : e.toString();\n          break;\n        default:\n          throw new Error(\"unknown instance variable type\");\n      }\n    }\n    SetInstanceVariableOffset(t, e) {\n      if (0 === e) return;\n      t |= 0;\n      const s = this._instVarValues;\n      if (t < 0 || t >= s.length) throw new RangeError(\"invalid instance variable\");\n      const n = s[t];\n      if (\"number\" != typeof n) throw \"boolean\" == typeof n ? new Error(\"can not set offset of boolean variable\") : \"string\" == typeof n ? new Error(\"can not set offset of string variable\") : new Error(\"unknown instance variable type\");\n      s[t] += \"number\" == typeof e ? e : parseFloat(e);\n    }\n    GetSavedDataMap() {\n      let t = savedDataMaps.get(this);\n      return t || (t = /* @__PURE__ */ new Map(), savedDataMaps.set(this, t), t);\n    }\n    GetUnsavedDataMap() {\n      let t = unsavedDataMaps.get(this);\n      return t || (t = /* @__PURE__ */ new Map(), unsavedDataMaps.set(this, t), t);\n    }\n    _HasAnyCreateDestroyHandler(t) {\n      const e = this.GetObjectClass();\n      if (e.UserScriptDispatcher().HasAnyHandlerFor(t)) return true;\n      for (const s of e.GetFamilies()) if (s.UserScriptDispatcher().HasAnyHandlerFor(t)) return true;\n      return !!this._runtime.UserScriptDispatcher().HasAnyHandlerFor(t);\n    }\n    _TriggerOnCreatedOnSelfAndRelated(t = void 0) {\n      const e = t ?? /* @__PURE__ */ new Set();\n      if (e.has(this)) return;\n      e.add(this);\n      const s = this.GetWorldInfo();\n      if (s && s.HasChildren()) {\n        for (const t2 of this.allChildren()) if (e.add(t2), t2.IsInContainer()) for (const s2 of t2.siblings()) e.add(s2);\n      }\n      if (this.IsInContainer()) for (const t2 of this.siblings()) t2._TriggerOnCreatedOnSelfAndRelated(e);\n      if (!t) {\n        for (const t2 of e.values()) t2._TriggerOnCreated();\n        this._OnHierarchyReady();\n      }\n    }\n    _OnCreatedCommon() {\n      this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();\n      for (const t of this._behaviorInstances) t.PostCreate();\n    }\n    _OnCreatedForLoadingSavegame() {\n      this._OnCreatedCommon();\n    }\n    _TriggerOnCreated() {\n      if (this._OnCreatedCommon(), this._HasAnyCreateDestroyHandler(\"instancecreate\")) {\n        const t = this.GetObjectClass(), e = new C33.Event(\"instancecreate\");\n        e.instance = this.GetInterfaceClass(), t.DispatchUserScriptEvent(e);\n        for (const s of t.GetFamilies()) s.DispatchUserScriptEvent(e);\n        this._runtime.DispatchUserScriptEvent(e);\n      }\n      this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnCreated, this, null);\n    }\n    _OnHierarchyReady() {\n      if (this.GetPlugin().SupportsSceneGraph()) {\n        if (this.DispatchUserScriptEvent(new C33.Event(\"hierarchyready\")), this._HasAnyCreateDestroyHandler(\"hierarchyready\")) {\n          const t = this.GetObjectClass(), e = new C33.Event(\"hierarchyready\");\n          e.instance = this.GetInterfaceClass(), t.DispatchUserScriptEvent(e);\n          for (const s of t.GetFamilies()) s.DispatchUserScriptEvent(e);\n          this._runtime.DispatchUserScriptEvent(e);\n        }\n        this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnHierarchyReady, this, null);\n      }\n    }\n    _TriggerOnDestroyed() {\n      this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnDestroyed, this, null);\n    }\n    _FireDestroyedScriptEvents(t) {\n      if (this._iScriptInterface) {\n        const e2 = new C33.Event(\"destroy\");\n        e2.isEndingLayout = t, this.DispatchUserScriptEvent(e2);\n      }\n      if (!this._HasAnyCreateDestroyHandler(\"instancedestroy\")) return;\n      const e = this.GetObjectClass(), s = new C33.Event(\"instancedestroy\");\n      s.instance = this.GetInterfaceClass(), s.isEndingLayout = t, e.DispatchUserScriptEvent(s);\n      for (const t2 of e.GetFamilies()) t2.DispatchUserScriptEvent(s);\n      this._runtime.DispatchUserScriptEvent(s);\n    }\n    _GetDebuggerProperties() {\n      return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();\n    }\n    SaveToJson(t = \"full\", e = null) {\n      const s = {};\n      \"full\" === t ? s[\"uid\"] = this.GetUID() : s[\"c3\"] = true;\n      const n = this.GetTagsSet();\n      if (n.size > 0 && (s[\"tags\"] = Array.from(n)), \"visual-state\" !== t) {\n        const e2 = savedDataMaps.get(this);\n        if (e2 && e2.size && (s[\"ex\"] = C33.ToSuperJSON(e2)), -1 !== this.GetTimeScale() && (s[\"mts\"] = this.GetTimeScale()), this._objectType.GetInstanceVariablesCount() > 0) {\n          const t2 = {}, e3 = this._objectType.GetInstanceVariableSIDs();\n          for (let s2 = 0, n2 = this._instVarValues.length; s2 < n2; ++s2) t2[e3[s2].toString()] = this._instVarValues[s2];\n          s[\"ivs\"] = t2;\n        }\n        if (this._behaviorInstances.length) {\n          const e3 = {};\n          for (const s2 of this._behaviorInstances) {\n            const n2 = s2.SaveToJson(t);\n            n2 && (e3[s2.GetBehaviorType().GetSID().toString()] = n2);\n          }\n          s[\"behs\"] = e3;\n        }\n      }\n      this._worldInfo && (s[\"w\"] = this._worldInfo._SaveToJson(t, e));\n      const i = this._sdkInst ? this._sdkInst.SaveToJson() : this._iScriptInterface._saveToJson();\n      return i && (s[\"data\"] = i), s;\n    }\n    _OnBeforeLoad(t = \"full\", e = null) {\n      this._worldInfo && this._worldInfo._OnBeforeLoad(t);\n    }\n    _OnAfterLoad(t, e = \"full\", s = null) {\n      this._worldInfo && this._worldInfo._OnAfterLoad(t, e, s);\n    }\n    _OnAfterLoad2(t, e = \"full\", s = null) {\n      this._worldInfo && this._worldInfo._OnAfterLoad2(t, e, s);\n    }\n    _SetupSceneGraphConnectionsOnChangeOfLayout() {\n      this.GetPlugin().IsWorldType() && this._worldInfo._SetupSceneGraphConnectionsOnChangeOfLayout();\n    }\n    LoadFromJson(t, e = \"full\", s = null) {\n      if (\"full\" === e) this._uid = t[\"uid\"];\n      else if (!t[\"c3\"]) return;\n      if (this._SetTagsSetFromJson(t[\"tags\"]), \"visual-state\" !== e) {\n        let e2 = savedDataMaps.get(this);\n        e2 && (e2.clear(), savedDataMaps.delete(this));\n        const s2 = t[\"ex\"];\n        s2 && (e2 = C33.FromSuperJSON(s2), savedDataMaps.set(this, e2)), this._timeScale = t.hasOwnProperty(\"mts\") ? t[\"mts\"] : -1;\n        const n2 = t[\"ivs\"];\n        if (n2) for (const [t2, e3] of Object.entries(n2)) {\n          const s3 = parseInt(t2, 10), n3 = this._objectType.GetInstanceVariableIndexBySID(s3);\n          if (n3 < 0 || n3 >= this._instVarValues.length) continue;\n          let i = e3;\n          null === i && (i = NaN), this._instVarValues[n3] = i;\n        }\n      }\n      if (this.GetPlugin().IsWorldType()) {\n        const n2 = t[\"w\"];\n        if (n2) {\n          const t2 = n2[\"l\"];\n          if (this._worldInfo.GetLayer().GetSID() !== t2) {\n            const s2 = this._worldInfo.GetLayer(), n3 = s2.GetLayout().GetLayerBySID(t2);\n            n3 ? (this._worldInfo._SetLayer(n3), s2._RemoveInstance(this, true), n3._AddInstance(this, true), n3.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged()) : \"full\" === e && this._runtime.DestroyInstance(this);\n          }\n          this._worldInfo._LoadFromJson(n2, e, s);\n        }\n      }\n      if (\"visual-state\" !== e) {\n        const s2 = t[\"behs\"];\n        if (s2) for (const [t2, n2] of Object.entries(s2)) {\n          const s3 = parseInt(t2, 10), i = this.GetBehaviorIndexBySID(s3);\n          i < 0 || i >= this._behaviorInstances.length || this._behaviorInstances[i].LoadFromJson(n2, e);\n        }\n      }\n      const n = t[\"data\"];\n      n && (this._sdkInst ? this._sdkInst.LoadFromJson(n, e) : this._iScriptInterface._loadFromJson(n));\n    }\n    MoveToLayerWithSID(t) {\n      if (this._worldInfo.GetLayer().GetSID() === t) return;\n      const e = this._worldInfo.GetLayer(), s = e.GetLayout().GetLayerBySID(t);\n      s && (this._worldInfo._SetLayer(s), e._RemoveInstance(this, true), s._AddInstance(this, true), s.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged());\n    }\n    GetInterfaceClass() {\n      return this._iScriptInterface || this._InitUserScriptInterface();\n    }\n    HasScriptInterface() {\n      return !!this._iScriptInterface;\n    }\n    _InitUserScriptInterface(t, e) {\n      const s = this._worldInfo ? t ? self.ISDKWorldInstanceBase : self.IWorldInstance : t ? self.ISDKInstanceBase : self.IInstance, n = t || this._sdkInst.GetScriptInterfaceClass(), i = this._objectType._GetUserScriptInstanceClass(), r = i || n || s, a = this.GetPlugin().GetSdkVersion();\n      if (C33.AddonManager._PushInitObject(this, a), C33.AddonManager._PushInitProperties(e), this._iScriptInterface = new r(), C33.AddonManager._PopInitProperties(), C33.AddonManager._PopInitObject(a), n && !(this._iScriptInterface instanceof s)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s.name}'`);\n      if (i) {\n        const t2 = n || s;\n        if (!(this._iScriptInterface instanceof t2)) throw new TypeError(`setInstanceClass(): class '${i.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);\n      }\n      return this._iScriptInterface;\n    }\n    _GetInstVarsScriptDescriptor(t) {\n      if (0 === this._instVarValues.length) return;\n      const e = {}, s = this._objectType._GetAllInstanceVariableJsPropNames();\n      for (let t2 = 0, n2 = s.length; t2 < n2; ++t2) e[s[t2]] = { configurable: false, enumerable: true, get: C33.Instance.prototype._GetInstanceVariableTypedValue.bind(this, t2), set: C33.Instance.prototype.SetInstanceVariableValue.bind(this, t2) };\n      const n = Object.create(Object.prototype, e);\n      t.instVars = { value: n, writable: false };\n    }\n    _GetBehaviorsScriptDescriptor(t) {\n      const e = this._behaviorInstances;\n      if (0 === e.length) return;\n      const s = {};\n      for (const t2 of e) s[t2.GetBehaviorType().GetJsPropName()] = { value: t2.GetScriptInterface(), writable: false };\n      const n = Object.create(Object.prototype, s);\n      t.behaviors = { value: n, writable: false };\n    }\n    DispatchUserScriptEvent(t) {\n      if (!this.HasScriptInterface()) return;\n      const e = this.GetInterfaceClass();\n      t.instance = e;\n      const s = this._runtime, n = s.IsDebug() && !s.GetEventSheetManager().IsInEventEngine();\n      n && C3Debugger.StartMeasuringScriptTime(), e.dispatchEvent(t), n && C3Debugger.AddScriptTime();\n    }\n  };\n}\n{\n  const C33 = self.C3, updatedInstances = /* @__PURE__ */ new Map();\n  C33.SceneGraphInfo = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._owner = t, this._parent = null, this._children = [], this._startWidth = t.GetWidth(), this._startHeight = t.GetHeight(), this._startScaleX = 1, this._startScaleY = 1, this._parentStartAngle = 0, this._ownOpacity = 1, this._startOpacity = t.GetOpacity(), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, this._on_instance_create = (e) => {\n        if (e.instance !== this._parent.GetInstance()) return;\n        t.GetRuntime().Dispatcher().removeEventListener(\"instancecreate\", this._on_instance_create);\n        const n = this._parent.GetInstance().GetSdkInstance();\n        this._originalSizeKnown = !!n.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? n.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? n.GetOriginalHeight() : NaN;\n      };\n    }\n    Release() {\n      this._parent = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._indexInParent = NaN, this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN, C33.clearArray(this._children);\n    }\n    SetParent(t) {\n      if (this._ownOpacity = this._owner.GetOpacity(), this._startOpacity = this._ownOpacity, this._parent = t, this._parentStartAngle = t ? t.GetAngle() : 0, this._parent) {\n        const t2 = this._owner.GetRuntime();\n        if (this._parent.GetInstance().GetPlugin().GetSdkVersion() < 2) {\n          const e = this._parent.GetInstance().GetSdkInstance();\n          e ? (this._originalSizeKnown = !!e.IsOriginalSizeKnown(), this._originalWidth = this._originalSizeKnown ? e.GetOriginalWidth() : NaN, this._originalHeight = this._originalSizeKnown ? e.GetOriginalHeight() : NaN) : this._parent.GetInstance().IsDestroyed() || t2.Dispatcher().addEventListener(\"instancecreate\", this._on_instance_create);\n        } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;\n      } else this._originalSizeKnown = false, this._originalWidth = NaN, this._originalHeight = NaN;\n    }\n    GetParent() {\n      return this._parent;\n    }\n    HasChildren() {\n      return this._children.length > 0;\n    }\n    GetChildren() {\n      return this._children;\n    }\n    _MaybeSortChildren() {\n      this.HasChildren() && 1 !== this._children.length && (this._tmpSceneGraphChildrenIndexes ? this._children.sort((t, e) => {\n        const n = this._tmpSceneGraphChildrenIndexes.get(t.GetInstance()), s = this._tmpSceneGraphChildrenIndexes.get(e.GetInstance());\n        return C33.IsFiniteNumber(n) && C33.IsFiniteNumber(s) ? n - s : 0;\n      }) : this._children.sort((t, e) => {\n        const n = t._GetSceneGraphInfo()._GetIndexInParent(), s = e._GetSceneGraphInfo()._GetIndexInParent();\n        return C33.IsFiniteNumber(n) && C33.IsFiniteNumber(s) ? n - s : 0;\n      }));\n    }\n    _GetIndexInParent() {\n      return this._indexInParent;\n    }\n    GetStartScaleX() {\n      return this._startScaleX;\n    }\n    SetStartScaleX(t) {\n      this._startScaleX = t;\n    }\n    GetStartScaleY() {\n      return this._startScaleY;\n    }\n    SetStartScaleY(t) {\n      this._startScaleY = t;\n    }\n    GetStartOpacity() {\n      return this._startOpacity;\n    }\n    GetOwnOpacity() {\n      return this._ownOpacity;\n    }\n    SetOwnOpacity(t) {\n      this._ownOpacity = t;\n    }\n    _GetStartWidth() {\n      return 0 === this._startWidth ? Number.EPSILON : this._startWidth;\n    }\n    _GetStartHeight() {\n      return 0 === this._startHeight ? Number.EPSILON : this._startHeight;\n    }\n    GetParentScaleX() {\n      if (this._owner.GetTransformWithParentWidth()) {\n        const t = this._parent;\n        let e = t.GetWidth(), n = t._GetSceneGraphInfo()._GetStartWidth();\n        return 0 === e && (e = Number.EPSILON), n === Number.EPSILON && e === Number.EPSILON ? 1 : n === Number.EPSILON && e !== Number.EPSILON && this._originalSizeKnown ? 1 + e / this._originalWidth : e / n;\n      }\n      return 1;\n    }\n    GetParentScaleY() {\n      if (this._owner.GetTransformWithParentHeight()) {\n        const t = this._parent;\n        let e = t.GetHeight(), n = t._GetSceneGraphInfo()._GetStartHeight();\n        return 0 === e && (e = Number.EPSILON), n === Number.EPSILON && e === Number.EPSILON ? 1 : n === Number.EPSILON && e !== Number.EPSILON && this._originalSizeKnown ? 1 + e / this._originalHeight : e / n;\n      }\n      return 1;\n    }\n    GetParentStartAngle() {\n      return 0;\n    }\n    _SaveToJsonProperties() {\n      return { \"sw\": this._startWidth, \"sh\": this._startHeight, \"sx\": this._startScaleX, \"sy\": this._startScaleY, \"psa\": this._parentStartAngle, \"oo\": this._ownOpacity, \"so\": this._startOpacity, \"pi\": this._owner.GetInstance().GetIndexInParent() };\n    }\n    _SaveToJson(t, e = null) {\n      const n = this._SaveToJsonProperties();\n      return e && e[\"selfOnly\"] ? Object.assign(n, { \"p\": null, \"c\": [] }) : Object.assign(n, { \"p\": this._GetParentJson(t), \"c\": this._GetChildrenJson(t) });\n    }\n    _GetFlagsString(t) {\n      let e = \"\";\n      return t.GetTransformWithParentX() && (e += \"x\"), t.GetTransformWithParentY() && (e += \"y\"), t.GetTransformWithParentWidth() && (e += \"w\"), t.GetTransformWithParentHeight() && (e += \"h\"), t.GetTransformWithParentAngle() && (e += \"a\"), t.GetTransformWithParentZElevation() && (e += \"z\"), t.GetDestroyWithParent() && (e += \"d\"), t.GetTransformWithParentOpacity() && (e += \"o\"), t.GetTransformWithParentVisibility() && (e += \"v\"), e;\n    }\n    _GetParentJson(t) {\n      return this._parent ? !this._parent.GetInstance() || this._parent.GetInstance().IsDestroyed() ? null : this._GetInstanceJson(this._parent, this._owner, t) : null;\n    }\n    _GetChildrenJson(t) {\n      return this._children.map((e) => this._GetInstanceJson(e, e, t)).filter((t2) => t2);\n    }\n    _GetInstanceJson(t, e, n) {\n      const s = t.GetInstance();\n      if (s && s.IsDestroyed()) return null;\n      const i = {};\n      return i[\"uid\"] = s.GetUID(), i[\"f\"] = this._GetFlagsString(e), i[\"offsets\"] = e._SaveSceneGraphPropertiesToJson(), i[\"data\"] = C33.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(s), i[\"oci\"] = s.GetObjectClass().GetIndex(), \"state\" === n ? (i[\"inst\"] = s.SaveToJson(\"full\", { \"selfOnly\": true }), i[\"instIndex\"] = NaN) : (i[\"instIndex\"] = s.GetObjectClass().GetInstances().indexOf(s), i[\"inst\"] = null), i;\n    }\n    _LoadFromJson(t) {\n      this._startWidth = t[\"sw\"], this._startHeight = t[\"sh\"], this._startScaleX = t[\"sx\"], this._startScaleY = t[\"sy\"], this._parentStartAngle = t[\"psa\"], this._ownOpacity = t[\"oo\"], this._startOpacity = t[\"so\"], this._indexInParent = C33.IsFiniteNumber(t[\"pi\"]) ? t[\"pi\"] : NaN;\n    }\n    _SetTmpSceneGraphChildren(t, e, n, s) {\n      if (!t && !e) {\n        if (s?.setFromJson) {\n          if (this._tmpSceneGraphChildren) for (const t2 of this._tmpSceneGraphChildren) t2.IsDestroyed() || t2.HasParent() || t2.GetRuntime().DestroyInstance(t2);\n        } else if (this._tmpSceneGraphChildren) {\n          for (const t2 of this._tmpSceneGraphChildren) if (n[\"c\"] && n[\"c\"].length) {\n            if (!n[\"c\"].some((e2) => e2[\"uid\"] === t2.GetUID())) continue;\n            t2.IsDestroyed() || t2.HasParent() || t2.GetRuntime().DestroyInstance(t2);\n          }\n        }\n      }\n      this._tmpSceneGraphChildren = t, this._tmpSceneGraphChildrenIndexes = e;\n    }\n    _GetInstanceByUID(t) {\n      const e = this._owner.GetRuntime();\n      return updatedInstances.has(t) ? updatedInstances.get(t) : e.GetInstanceByUID(t);\n    }\n    _OnAfterLoad(t, e) {\n      const n = this._owner, s = n.GetRuntime(), i = e?.processedWorldInfo ?? /* @__PURE__ */ new Set();\n      if (t[\"p\"] && !this._parent) {\n        const a2 = t[\"p\"][\"uid\"], r2 = this._GetInstanceByUID(a2);\n        if (r2) {\n          const a3 = r2.GetWorldInfo();\n          if (r2.HasChild(n.GetInstance())) this._parent = a3;\n          else {\n            r2.HasChildWithUID(n.GetInstance().GetUID()) ? (s.DestroyInstance(n.GetInstance()), s._RemoveInstanceFromUIDMap(n.GetInstance().GetUID()), updatedInstances.delete(n.GetInstance().GetUID())) : r2.AddChild(n.GetInstance(), this._GetFlagsObj(t[\"p\"][\"f\"])), i.has(n) || (n._LoadSceneGraphPropertiesFromJson(t[\"p\"][\"offsets\"]), this._LoadInstancePropertiesFromJson(r2, t[\"p\"], e), this._UpdateUIDInstanceMap(r2, r2.GetUID(), n.GetRuntime(), e)), i.add(n);\n            r2.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren();\n          }\n        } else if (C33.IsFiniteNumber(t[\"p\"][\"oci\"])) {\n          const i2 = s.CreateInstance(s.GetObjectClassByIndex(t[\"p\"][\"oci\"]), n.GetLayer(), 0, 0, true);\n          if (i2) {\n            const a3 = this._GetInstanceData(t[\"p\"], s);\n            a3 && i2.LoadFromJson(a3);\n            const r3 = i2.GetWorldInfo(), h = !!e?.setFromJson;\n            r3.GetLayer().SortAndAddInstancesByZIndex(i2, false, h), i2.AddChild(n.GetInstance(), this._GetFlagsObj(t[\"p\"][\"f\"])), updatedInstances.set(i2.GetUID(), i2), this._UpdateUIDInstanceMap(i2, i2.GetUID(), s, e);\n            i2.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren();\n          }\n        }\n      }\n      const a = [];\n      for (const e2 of t[\"c\"]) {\n        const t2 = e2[\"uid\"], n2 = this._GetInstanceByUID(t2);\n        n2 && a.push(n2);\n      }\n      let r = 0;\n      for (const h of t[\"c\"]) {\n        const c = h[\"uid\"], o = this._GetInstanceByUID(c);\n        if (o) {\n          if (this._tmpSceneGraphChildren) {\n            if (this._tmpSceneGraphChildren.includes(o)) {\n              const s3 = o;\n              if (s3.GetObjectClass() !== o.GetObjectClass()) {\n                r++;\n                continue;\n              }\n              if (s3.IsDestroyed()) {\n                r++;\n                continue;\n              }\n              const h2 = t[\"c\"][r];\n              if (!e?.setFromJson && this._HasAllChildrenOfType(s3, a, n)) {\n                if (n.GetInstance().GetChildAt(r)) {\n                  const a2 = s3.GetObjectClass().GetIndex(), c2 = h2[\"oci\"], o2 = n.GetInstance().GetChildAt(r).GetObjectClass().GetIndex();\n                  if (a2 !== c2 || c2 !== o2) {\n                    this._RefreshAllChildren(t[\"c\"], n, i, e);\n                    break;\n                  }\n                  this._UpdateInstance(r, h2, n, i, e);\n                } else this._UpdateInstance(r, h2, n, i, e);\n                r++;\n                continue;\n              }\n              if (s3.HasParent() && s3.GetParent() !== n.GetInstance()) {\n                const t2 = this._CreateNewChildInstance(h2, e);\n                this._AddAndSetChildInstance(t2, h2, i, e), r++;\n                continue;\n              }\n              this._AddAndSetChildInstance(s3.GetWorldInfo(), h2, i, e, true), r++;\n              continue;\n            }\n            if (this._tmpSceneGraphChildren[r]) {\n              const s3 = this._tmpSceneGraphChildren[r];\n              if (s3.GetObjectClass() !== o.GetObjectClass()) {\n                r++;\n                continue;\n              }\n              if (s3.IsDestroyed()) {\n                r++;\n                continue;\n              }\n              const h2 = t[\"c\"][r];\n              if (!e?.setFromJson && this._HasAllChildrenOfType(s3, a, n)) {\n                if (n.GetInstance().GetChildAt(r)) {\n                  const a2 = s3.GetObjectClass().GetIndex(), c2 = h2[\"oci\"], o2 = n.GetInstance().GetChildAt(r).GetObjectClass().GetIndex();\n                  if (a2 !== c2 || c2 !== o2) {\n                    this._RefreshAllChildren(t[\"c\"], n, i, e);\n                    break;\n                  }\n                  this._UpdateInstance(r, h2, n, i, e);\n                } else this._UpdateInstance(r, h2, n, i, e);\n                r++;\n                continue;\n              }\n              if (s3.HasParent() && s3.GetParent() !== n.GetInstance()) {\n                const t2 = this._CreateNewChildInstance(h2, e);\n                this._AddAndSetChildInstance(t2, h2, i, e), r++;\n                continue;\n              }\n              this._AddAndSetChildInstance(s3.GetWorldInfo(), h2, i, e, true), r++;\n              continue;\n            }\n          }\n          const s2 = o.GetObjectClass();\n          if (this._GetInstancesOfObjectClassCount(a, s2) === n.GetInstance().GetChildrenOfObjectClass(s2).length) {\n            for (const t2 of n.GetInstance().GetChildren()) {\n              if (t2.GetObjectClass() !== s2) continue;\n              const n2 = t2.GetWorldInfo();\n              if (n2 && !i.has(n2)) {\n                i.add(n2), n2._LoadSceneGraphPropertiesFromJson(h[\"offsets\"]), this._LoadInstancePropertiesFromJson(t2, h, e);\n                break;\n              }\n            }\n            r++;\n            continue;\n          }\n          if (o.HasParent() && o.GetParent() !== n.GetInstance()) {\n            const t2 = this._CreateNewChildInstance(h, e);\n            this._AddAndSetChildInstance(t2, h, i, e), r++;\n            continue;\n          }\n          this._AddAndSetChildInstance(o.GetWorldInfo(), h, i, e);\n        } else if (this._tmpSceneGraphChildren && this._tmpSceneGraphChildren[r]) {\n          const c2 = this._tmpSceneGraphChildren[r], o2 = s.GetObjectClassByIndex(this._GetObjectClassIndex(h));\n          if (c2.GetObjectClass() !== o2) {\n            r++;\n            continue;\n          }\n          if (c2.IsDestroyed()) {\n            r++;\n            continue;\n          }\n          const d = t[\"c\"][r];\n          if (!e?.setFromJson && this._HasAllChildrenOfType(c2, a, n)) {\n            if (n.GetInstance().GetChildAt(r)) {\n              const s2 = c2.GetObjectClass().GetIndex(), a2 = d[\"oci\"], h2 = n.GetInstance().GetChildAt(r).GetObjectClass().GetIndex();\n              if (s2 !== a2 || a2 !== h2) {\n                this._RefreshAllChildren(t[\"c\"], n, i, e);\n                break;\n              }\n              this._UpdateInstance(r, d, n, i, e);\n            } else this._UpdateInstance(r, d, n, i, e);\n            r++;\n            continue;\n          }\n          if (c2.HasParent() && c2.GetParent() !== n.GetInstance()) {\n            const t2 = this._CreateNewChildInstance(d, e);\n            this._AddAndSetChildInstance(t2, d, i, e), r++;\n            continue;\n          }\n          this._AddAndSetChildInstance(c2.GetWorldInfo(), d, i, e);\n        } else {\n          const t2 = this._CreateNewChildInstance(h, e);\n          this._AddAndSetChildInstance(t2, h, i, e);\n        }\n        r++;\n      }\n    }\n    _RefreshAllChildren(t, e, n, s) {\n      const i = e.GetRuntime();\n      for (const t2 of e.GetInstance().children()) t2 && !t2.IsDestroyed() && (i.DestroyInstance(t2), i._RemoveInstanceFromUIDMap(t2.GetUID()), updatedInstances.delete(t2.GetUID()));\n      this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren = []), this._tmpSceneGraphChildrenIndexes && (this._tmpSceneGraphChildrenIndexes = /* @__PURE__ */ new WeakMap());\n      Object.assign({}, s, { \"assignZIndex\": false });\n      for (const e2 of t) {\n        const t2 = this._CreateNewChildInstance(e2, s);\n        this._AddAndSetChildInstance(t2, e2, n, s), this._tmpSceneGraphChildren.push(t2.GetInstance()), this._tmpSceneGraphChildrenIndexes.set(t2.GetInstance(), this._tmpSceneGraphChildren.length - 1);\n      }\n      e._GetSceneGraphInfo()._MaybeSortChildren();\n    }\n    _HasAllChildrenOfType(t, e, n) {\n      const s = t.GetObjectClass();\n      return this._GetInstancesOfObjectClassCount(e, s) === n.GetInstance().GetChildrenOfObjectClass(s).length;\n    }\n    _UpdateInstance(t, e, n, s, i) {\n      const a = n.GetInstance().GetChildAt(t);\n      if (!a) return;\n      const r = a.GetWorldInfo();\n      r && (s.has(r) || (r._LoadSceneGraphPropertiesFromJson(e[\"offsets\"]), this._LoadInstancePropertiesFromJson(a, e, i)), s.add(r));\n    }\n    _GetFlagsObj(t) {\n      const e = {};\n      return e.transformX = t.includes(\"x\"), e.transformY = t.includes(\"y\"), e.transformWidth = t.includes(\"w\"), e.transformHeight = t.includes(\"h\"), e.transformAngle = t.includes(\"a\"), e.transformZElevation = t.includes(\"z\"), e.destroyWithParent = t.includes(\"d\"), e.transformOpacity = t.includes(\"o\"), e.transformVisibility = t.includes(\"v\"), e;\n    }\n    _GetObjectClassIndex(t) {\n      return C33.IsFiniteNumber(t[\"oci\"]) ? t[\"oci\"] : t[1];\n    }\n    _CreateNewChildInstance(t, e) {\n      if (!C33.IsFiniteNumber(t[\"oci\"])) return;\n      const n = this._owner, s = n.GetRuntime();\n      let i;\n      const a = !e.hasOwnProperty(\"createHierarchy\") || e[\"createHierarchy\"];\n      if (i = t[\"data\"] ? s.CreateInstanceFromData(t[\"data\"], n.GetLayer(), false, 0, 0, false, a) : s.CreateInstance(s.GetObjectClassByIndex(t[\"oci\"]), n.GetLayer(), 0, 0, a), !i) return;\n      const r = this._GetInstanceData(t, s);\n      r && i.LoadFromJson(r);\n      const h = i.GetWorldInfo(), c = !!e?.setFromJson;\n      return h.GetLayer().SortAndAddInstancesByZIndex(i, true, c), h;\n    }\n    _UpdateUIDInstanceMap(t, e, n, s) {\n      if (this._GetInstanceByUID(e) && !s?.setFromJson) {\n        const s2 = this._GetInstanceByUID(e);\n        s2 !== t && n.DestroyInstance(s2);\n      }\n      n._RemoveInstanceFromUIDMap(e), n._MapInstanceByUID(e, t);\n    }\n    _AddAndSetChildInstance(t, e, n, s, i = true) {\n      const a = this._owner, r = a.AddChild(t, this._GetFlagsObj(e[\"f\"]));\n      r && i ? (n.has(t) || (t._LoadSceneGraphPropertiesFromJson(e[\"offsets\"]), this._LoadInstancePropertiesFromJson(t.GetInstance(), e, s)), n.add(t)) : r && (updatedInstances.set(t.GetInstance().GetUID(), t.GetInstance()), this._UpdateUIDInstanceMap(t.GetInstance(), e[\"uid\"], a.GetRuntime(), s)), this._MaybeSortChildren();\n    }\n    _LoadInstancePropertiesFromJson(t, e, n) {\n      let s = this._GetInstanceData(e, this._owner.GetRuntime());\n      if (!s) return;\n      const i = !n.hasOwnProperty(\"clearChildren\") || n[\"clearChildren\"], a = !n.hasOwnProperty(\"assignZIndex\") || n[\"assignZIndex\"], r = t.GetRuntime();\n      if (updatedInstances.set(t.GetUID(), t), s = JSON.parse(JSON.stringify(s)), i && t.GetUID() !== s[\"uid\"]) {\n        for (const e2 of t.children()) e2 && !e2.IsDestroyed() && (r.DestroyInstance(e2), r._RemoveInstanceFromUIDMap(e2.GetUID()), updatedInstances.delete(e2.GetUID()));\n        if (s[\"w\"]?.[\"sgi\"] && s[\"w\"][\"sgi\"][\"c\"]?.length) for (const e2 of s[\"w\"][\"sgi\"][\"c\"]) {\n          const s2 = Object.assign({}, n, { \"clearChildren\": false, \"createHierarchy\": false }), i2 = this._CreateNewChildInstance(e2, s2);\n          updatedInstances.set(i2.GetInstance().GetUID(), i2.GetInstance()), t.AddChild(i2.GetInstance(), this._GetFlagsObj(e2[\"f\"])), i2._LoadSceneGraphPropertiesFromJson(e2[\"offsets\"]), this._LoadInstancePropertiesFromJson(i2.GetInstance(), e2, s2);\n        }\n      }\n      const h = s[\"w\"]?.[\"zi\"], c = s[\"w\"]?.[\"l\"];\n      s[\"w\"] = null, t.LoadFromJson(s), n?.setFromJson || (C33.IsFiniteNumber(h) && a && t.GetWorldInfo()._SetZIndex(h), C33.IsFiniteNumber(c) && t.MoveToLayerWithSID(c)), this._UpdateUIDInstanceMap(t, s[\"uid\"], r, n);\n    }\n    _GetInstancesOfObjectClassCount(t, e) {\n      return t.filter((t2) => t2.GetObjectClass().GetName() === e.GetName()).length;\n    }\n    _GetInstanceData(t, e) {\n      if (C33.IsFiniteNumber(t[\"instIndex\"])) {\n        const n = e.GetObjectClassByIndex(t[\"oci\"])._GetLoadInstancesJson();\n        return n ? n[t[\"instIndex\"]] : null;\n      }\n      return C33.IsString(t[\"inst\"]) ? JSON.parse(t[\"inst\"]) : t[\"inst\"] ? t[\"inst\"] : void 0;\n    }\n    static GetSceneGraphInstanceDataFromInstance(t) {\n      let e = t.GetWorldInfo().GetLayer().GetInitialInstanceData(t.GetUID());\n      if (!e) return null;\n      e = JSON.parse(JSON.stringify(e));\n      const n = [];\n      for (const e2 of [...t.GetChildren()]) {\n        const t2 = e2.GetWorldInfo();\n        n.push([t2.GetLayout().GetSID(), t2.GetLayer().GetIndex(), e2.GetUID(), C33.SceneGraphInfo._GetFlagsNumber(t2), e2.GetObjectClass().IsInContainer() ? 1 : 0, t2.GetZIndex(), C33.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(e2)]);\n      }\n      return C33.IsArray(e[0][14]) ? e[0][14][1] = n : (e[0][14] = [], e[0][14][0] = C33.SceneGraphInfo._GetDefaultFlagsNumber(), e[0][14][1] = n, e[0][14][2] = t.GetWorldInfo().GetZIndex()), e;\n    }\n    static _GetFlagsNumber(t) {\n      let e = 0;\n      return e |= Number(t.GetTransformWithParentVisibility()) << 8, e |= Number(t.GetTransformWithParentOpacity()) << 7, e |= Number(t.GetTransformWithParentZElevation()) << 6, e |= Number(t.GetDestroyWithParent()) << 5, e |= Number(t.GetTransformWithParentAngle()) << 4, e |= Number(t.GetTransformWithParentHeight()) << 3, e |= Number(t.GetTransformWithParentWidth()) << 2, e |= Number(t.GetTransformWithParentY()) << 1, e |= Number(t.GetTransformWithParentX()) | 0, e;\n    }\n    static _GetDefaultFlagsNumber(t) {\n      let e = 0;\n      return e |= 256, e |= 128, e |= 64, e |= 32, e |= 16, e |= 8, e |= 4, e |= 2, e |= 1, 511;\n    }\n    static ClearUpdatedInstances() {\n      updatedInstances.clear();\n    }\n  };\n}\n{\n  const C33 = self.C3, glMatrix = self.glMatrix, vec3 = glMatrix.vec3, vec4 = glMatrix.vec4, tempRect = C33.New(C33.Rect), tempQuad = C33.New(C33.Quad), bboxChangeEvent = C33.New(C33.Event, \"bboxchange\", false), tempColor = C33.New(C33.Color, 0, 0, 0, 0), tempCollisionPoly = C33.New(C33.CollisionPoly), DEFAULT_COLOR = C33.New(C33.Color, 1, 1, 1, 1), DEFAULT_RENDER_CELLS = C33.New(C33.Rect, 0, 0, -1, -1), DEFAULT_COLLISION_CELLS = C33.New(C33.Rect, 0, 0, -1, -1), VALID_SET_MESH_POINT_MODES = /* @__PURE__ */ new Set([\"absolute\", \"relative\"]), EMPTY_ARRAY = [];\n  let enableUpdateRendererStateGroup = true;\n  const FLAG_IS_VISIBLE = 1, FLAG_BBOX_CHANGED = 2, FLAG_ENABLE_BBOX_CHANGED_EVENT = 4, FLAG_COLLISION_ENABLED = 8, FLAG_COLLISION_CELL_CHANGED = 16, FLAG_SOLID_FILTER_INCLUSIVE = 32, FLAG_HAS_ANY_ACTIVE_EFFECT = 64, FLAG_IS_ROTATABLE = 128, FLAG_DESTROYED = 256, FLAG_DESTROY_WITH_PARENT = 512, FLAG_TRANSFORM_WITH_PARENT_X = 1024, FLAG_TRANSFORM_WITH_PARENT_Y = 2048, FLAG_TRANSFORM_WITH_PARENT_W = 4096, FLAG_TRANSFORM_WITH_PARENT_H = 8192, FLAG_TRANSFORM_WITH_PARENT_A = 16384, FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 32768, FLAG_TRANSFORM_WITH_PARENT_OPACITY = 1 << 22, FLAG_TRANSFORM_WITH_PARENT_VISIBILITY = 1 << 23, MASK_ALL_SCENE_GRAPH_FLAGS = 12647936, FLAG_MESH_CHANGED = 65536, FLAG_PHYSICS_BODY_CHANGED = 1 << 17, FLAG_SIN_COS_ANGLE_CHANGED = 1 << 18, FLAG_USE_POINTS_SHADER_PROGRAM = 1 << 19, FLAG_DRAW_BACK_FACE_ONLY = 1 << 20, FLAG_DRAW_NON_BACK_FACES_ONLY = 1 << 21, FLAG_BLEND_MODE_BIT_OFFSET = 26, FLAG_BLEND_MODE_MASK = 31 << 26, sceneGraphExportDataMap = /* @__PURE__ */ new WeakMap(), sceneGraphZIndexMap = /* @__PURE__ */ new WeakMap();\n  C33.WorldInfo = class extends C33.DefendedBase {\n    constructor(t, e) {\n      super(), this._inst = t, this._objectClass = t.GetObjectClass(), this._runtime = t.GetRuntime(), this._layer = e, this._objectClass._OnWorldInstanceLayerChanged(this, null, e), this._zIndex = -1, this._htmlZIndex = -1, this._flags = 196635, this._objectClass.GetPlugin().IsRotatable() && (this._flags |= 128), this._x = NaN, this._y = NaN, this._zElevation = NaN, this._w = NaN, this._h = NaN, this._depth = NaN, this._a = NaN, this._sinA = NaN, this._cosA = NaN, this._ox = NaN, this._oy = NaN, this._boundingBox = C33.New(C33.Rect), this._boundingQuad = C33.New(C33.Quad), this._collisionCells = DEFAULT_COLLISION_CELLS, this._renderCells = DEFAULT_RENDER_CELLS, this._sourceCollisionPoly = null, this._transformedPolyInfo = null, this._solidFilterTags = null, this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR, this._stateGroup = null, this._instanceEffectList = null, this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = C33.New(C33.InstanceEffectList, this._inst, this)), this._sceneGraphInfo = null, this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null, this._tmpHierarchyPosition = -1, this._meshInfo = null;\n    }\n    _MarkDestroyed() {\n      this._flags |= 256;\n    }\n    Release() {\n      if (this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, null), this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null), this._sourceCollisionPoly = null, this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null), this._solidFilterTags && (this._solidFilterTags.clear(), this._solidFilterTags = null), this.ReleaseMesh(), this._instanceEffectList && this._instanceEffectList.Release(), this.HasParent() && this.GetParent().RemoveChild(this), this.HasChildren()) {\n        const t = [...this.GetChildren()];\n        for (const e of t) this.RemoveChild(e);\n      }\n      this._ReleaseSceneGraphInfo(), this._ReleaseTmpSceneGraphInfo(), sceneGraphExportDataMap.delete(this), sceneGraphZIndexMap.delete(this), this._inst = null, this._objectClass = null, this._runtime = null, this._layer = null;\n    }\n    Init(t) {\n      if (enableUpdateRendererStateGroup = false, this.SetXY(t[0], t[1]), this.SetZElevation(t[2]), this.SetSize(t[3], t[4]), this._depth = 0, this.IsRotatable() ? this.SetAngle(t[6]) : this._a = 0, tempColor.setFromJSON(t[7]), this._SetColor(tempColor), this.SetOriginX(t[8]), this.SetOriginY(t[9]), this.SetBlendMode(t[10]), this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(t[12]), t[14] && sceneGraphExportDataMap.set(this, { childrenData: t[14][1], zIndexData: t[14][2] }), t[15]) {\n        const e = t[15];\n        this.CreateMesh(e[0], e[1]);\n        const s = this.GetSourceMesh(), i = e[2];\n        for (let t2 = 0, e2 = i.length; t2 < e2; ++t2) {\n          const e3 = i[t2];\n          for (let i2 = 0, n = e3.length; i2 < n; ++i2) {\n            const n2 = e3[i2], r = s.GetMeshPointAt(i2, t2);\n            r.SetX(n2[0]), r.SetY(n2[1]), r.SetZElevation(n2[2]), r.SetU(n2[3]), r.SetV(n2[4]);\n          }\n        }\n      }\n      if (t[16]) {\n        const e = t[16][0], s = t[16][1], i = !!s, n = !i, r = this._runtime.GetTemplateManager();\n        i && r && r.MapInstanceToTemplateName(this.GetInstance(), s), n && r && r.MapInstanceToTemplateName(this.GetInstance(), e);\n      }\n      enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup();\n    }\n    InitNoData() {\n      this._x = 0, this._y = 0, this._zElevation = 0, this._w = 0, this._h = 0, this._depth = 0, this._a = 0, this._sinA = 0, this._cosA = 1, this._ox = 0, this._oy = 0, this._UpdateRendererStateGroup();\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetInstance() {\n      return this._inst;\n    }\n    _GetParentOffsetAngle() {\n      return this.GetTransformWithParentAngle() ? this._MaybeReflectAngleForMirrorFlip(this.GetParent()._GetAngleNoReflect() - this._sceneGraphInfo.GetParentStartAngle()) : 0;\n    }\n    SetX(t) {\n      if (t = +t, this.GetTransformWithParentX()) {\n        const e = this._sceneGraphInfo, s = t - this.GetX(), i = -this._GetParentOffsetAngle();\n        0 === i ? this._x += s / e.GetParentScaleX() : (this._x += Math.cos(i) * s / e.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(i) * s / e.GetParentScaleY()));\n      } else this._x = t;\n    }\n    OffsetX(t, e = false) {\n      t = +t, e ? this._x += t : this.GetTransformWithParentX() ? this.SetX(this.GetX() + t) : this._x += t;\n    }\n    GetX() {\n      if (this.GetTransformWithParentX()) {\n        let t = this._x;\n        const e = this._sceneGraphInfo, s = this.GetParent(), i = this._GetParentOffsetAngle();\n        return 0 === i ? t *= e.GetParentScaleX() : (t = t * e.GetParentScaleX() * Math.cos(i), this.GetTransformWithParentY() && (t -= this._y * e.GetParentScaleY() * Math.sin(i))), s.GetX() + t;\n      }\n      return this._x;\n    }\n    SetY(t) {\n      if (t = +t, this.GetTransformWithParentY()) {\n        const e = this._sceneGraphInfo, s = t - this.GetY(), i = -this._GetParentOffsetAngle();\n        0 === i ? this._y += s / e.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(i) * s / e.GetParentScaleX()), this._y += Math.cos(i) * s / e.GetParentScaleY());\n      } else this._y = t;\n    }\n    OffsetY(t, e = false) {\n      t = +t, e ? this._y += t : this.GetTransformWithParentY() ? this.SetY(this.GetY() + t) : this._y += t;\n    }\n    GetY() {\n      if (this.GetTransformWithParentY()) {\n        let t = this._y;\n        const e = this._sceneGraphInfo, s = this.GetParent(), i = this._GetParentOffsetAngle();\n        return 0 === i ? t *= e.GetParentScaleY() : (t = t * e.GetParentScaleY() * Math.cos(i), this.GetTransformWithParentX() && (t += this._x * e.GetParentScaleX() * Math.sin(i))), s.GetY() + t;\n      }\n      return this._y;\n    }\n    SetXY(t, e) {\n      if (t = +t, e = +e, this.GetTransformWithParentXOrY()) {\n        const s = this.GetTransformWithParentX(), i = this.GetTransformWithParentY(), n = this._sceneGraphInfo, r = t - this.GetX(), h = e - this.GetY(), a = -this._GetParentOffsetAngle();\n        if (0 === a) s ? this._x += r / n.GetParentScaleX() : this._x = t, i ? this._y += h / n.GetParentScaleY() : this._y = e;\n        else {\n          const o = Math.sin(a), l = Math.cos(a);\n          s ? this._x += i ? (l * r - o * h) / n.GetParentScaleX() : l * r / n.GetParentScaleX() : this._x = t, i ? this._y += s ? (o * r + l * h) / n.GetParentScaleY() : l * h / n.GetParentScaleY() : this._y = e;\n        }\n      } else this._x = t, this._y = e;\n    }\n    GetXY() {\n      return [this.GetX(), this.GetY()];\n    }\n    OffsetXY(t, e) {\n      t = +t, e = +e, this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + t, this.GetY() + e) : (this._x += t, this._y += e);\n    }\n    EqualsXY(t, e) {\n      return this.GetX() === t && this.GetY() === e;\n    }\n    SetZElevation(t) {\n      if (t = +t, this.GetTransformWithParentZElevation() && (t -= this.GetParent().GetZElevation()), this._zElevation === t) return;\n      this._zElevation = t, this._UpdateZElevation();\n      const e = this.GetLayer();\n      0 !== this._zElevation && e._SetAnyInstanceZElevated(), e.SetZIndicesChanged(this);\n    }\n    _UpdateZElevation() {\n      if (this._UpdateRendererStateGroup(), this.HasChildren()) {\n        const t = this.GetChildren();\n        for (let e = 0, s = t.length; e < s; e++) {\n          const s2 = t[e];\n          s2.GetTransformWithParentZElevation() && s2._UpdateZElevation();\n        }\n      }\n    }\n    OffsetZElevation(t) {\n      this.SetZElevation(this.GetZElevation() + t);\n    }\n    GetZElevation() {\n      return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation;\n    }\n    GetTotalZElevation() {\n      return this.GetLayer().GetZElevation() + this.GetZElevation();\n    }\n    IsOriginalSizeKnown() {\n      return this.GetInstance().GetPlugin().GetSdkVersion() < 2 && this.GetInstance().GetSdkInstance().IsOriginalSizeKnown();\n    }\n    SetWidth(t) {\n      if (t = +t, this.GetTransformWithParentWidth()) {\n        const e = this.GetWidth();\n        0 === e ? this._w = Number.EPSILON : this._w *= t / e;\n      } else this._w = t;\n      this._MarkSinCosAngleChanged();\n    }\n    OffsetWidth(t, e) {\n      t = +t, e ? this._w += t : this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + t) : this._w += t, this._MarkSinCosAngleChanged();\n    }\n    GetWidth() {\n      if (this.GetTransformWithParentWidth()) {\n        const t = this.GetParent(), e = t.GetWidth();\n        return t._GetSceneGraphInfo()._GetStartWidth() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartWidth() + e) * this._w : e * this._w;\n      }\n      return this._w;\n    }\n    SetHeight(t) {\n      if (t = +t, this.GetTransformWithParentHeight()) {\n        const e = this.GetHeight();\n        0 === e ? this._h = Number.EPSILON : this._h *= t / e;\n      } else this._h = t;\n      this._MarkSinCosAngleChanged();\n    }\n    OffsetHeight(t, e) {\n      t = +t, e ? this._h += t : this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + t) : this._h += t, this._MarkSinCosAngleChanged();\n    }\n    GetHeight() {\n      if (this.GetTransformWithParentHeight()) {\n        const t = this.GetParent(), e = t.GetHeight();\n        return t._GetSceneGraphInfo()._GetStartHeight() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartHeight() + e) * this._h : e * this._h;\n      }\n      return this._h;\n    }\n    SetSize(t, e) {\n      if (t = +t, e = +e, this.GetTransformWithParentWidth()) {\n        const e2 = this.GetWidth();\n        0 === e2 ? this._w = Number.EPSILON : this._w *= t / e2;\n      } else this._w = t;\n      if (this.GetTransformWithParentHeight()) {\n        const t2 = this.GetHeight();\n        0 === t2 ? this._h = Number.EPSILON : this._h *= e / t2;\n      } else this._h = e;\n      this._MarkSinCosAngleChanged();\n    }\n    GetSize() {\n      return [this.GetWidth(), this.GetHeight()];\n    }\n    GetDepth() {\n      return this._depth;\n    }\n    SetDepth(t) {\n      if (t < 0) throw new RangeError(\"invalid depth\");\n      this._depth = t;\n    }\n    GetSceneGraphScale() {\n      if (this.HasParent()) {\n        const t = this._sceneGraphInfo;\n        return Math.min(t.GetParentScaleX(), t.GetParentScaleY());\n      }\n      return 1;\n    }\n    IsRotatable() {\n      return !!(128 & this._flags);\n    }\n    SetAngle(t) {\n      t = +t, this.IsRotatable() && (this.GetTransformWithParentAngle() && (t -= this.GetParent().GetAngle()), t = C33.clampAngle(t), this._a !== t && (this._a = t, this._MarkSinCosAngleChanged()));\n    }\n    OffsetAngle(t) {\n      0 !== (t = +t) && this.IsRotatable() && (this._a = C33.clampAngle(this._a + t), this._MarkSinCosAngleChanged());\n    }\n    _MarkSinCosAngleChanged() {\n      if (this._flags |= 262144, this.HasChildren()) {\n        const t = this.GetChildren();\n        for (let e = 0, s = t.length; e < s; e++) t[e]._MarkSinCosAngleChanged();\n      }\n    }\n    GetAngle() {\n      return this.GetTransformWithParentAngle() && this.IsRotatable() ? this._MaybeReflectAngleForMirrorFlip(C33.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a)) : this._a;\n    }\n    _GetAngleNoReflect() {\n      return this.GetTransformWithParentAngle() && this.IsRotatable() ? C33.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a) : this._a;\n    }\n    _MaybeReflectAngleForMirrorFlip(t) {\n      return this.GetTransformWithParentWidth() && this.GetTopParent().GetWidth() < 0 && (t = C33.clampAngle(C33.angleReflect(t, this.GetTopParent().GetAngle() + Math.PI))), this.GetTransformWithParentHeight() && this.GetTopParent().GetHeight() < 0 && (t = C33.angleReflect(t, this.GetTopParent().GetAngle())), t;\n    }\n    _NeedsReflectAngleForMirrorOrFlip() {\n      const t = this.GetParent();\n      return !!(this.GetTransformWithParentWidth() && t.GetWidth() < 0) || !!(this.GetTransformWithParentHeight() && t.GetHeight() < 0);\n    }\n    _NeedsReflectAngleForMirrorAndFlip() {\n      const t = this.GetParent();\n      return !!(this.GetTransformWithParentWidth() && t.GetWidth() < 0 && this.GetTransformWithParentHeight() && t.GetHeight() < 0);\n    }\n    _MaybeUpdateSinCosAngle() {\n      const t = this._flags;\n      if (!(262144 & t)) return;\n      const e = this.GetAngle();\n      this._sinA = Math.sin(e), this._cosA = Math.cos(e), this._flags = -262145 & t;\n    }\n    GetSinAngle() {\n      return this._MaybeUpdateSinCosAngle(), this._sinA;\n    }\n    GetCosAngle() {\n      return this._MaybeUpdateSinCosAngle(), this._cosA;\n    }\n    SetOriginX(t) {\n      this._ox = +t;\n    }\n    OffsetOriginX(t) {\n      this._ox += +t;\n    }\n    GetOriginX() {\n      return this._ox;\n    }\n    SetOriginY(t) {\n      this._oy = +t;\n    }\n    OffsetOriginY(t) {\n      this._oy += +t;\n    }\n    GetOriginY() {\n      return this._oy;\n    }\n    _SetColor(t) {\n      this._color.equals(t) || (this._color === DEFAULT_COLOR ? (this._color = C33.New(C33.Color, t), this._colorPremultiplied = C33.New(C33.Color, t), this._colorPremultiplied.premultiply()) : t.equalsRgba(1, 1, 1, 1) ? (this._color = DEFAULT_COLOR, this._colorPremultiplied = DEFAULT_COLOR) : (this._color.set(t), this._colorPremultiplied.set(t), this._colorPremultiplied.premultiply()), this._UpdateRendererStateGroup());\n    }\n    SetOpacity(t) {\n      if (t = C33.clamp(+t, 0, 1), this.GetTransformWithParentOpacity()) {\n        if (this._GetSceneGraphInfo().GetOwnOpacity() === t) return;\n        this._GetSceneGraphInfo().SetOwnOpacity(t), t = this.GetOpacity();\n      } else if (this._color.a === t) return;\n      this._SetColorWithOpacity(t);\n    }\n    _SetOpacityOfChildren() {\n      if (!this.HasChildren()) return;\n      const t = this.GetChildren();\n      for (let e = 0, s = t.length; e < s; e++) {\n        const s2 = t[e];\n        s2._SetColorWithOpacity(s2.GetOpacity());\n      }\n    }\n    _SetColorWithOpacity(t) {\n      tempColor.copyRgb(this._color), tempColor.a = t, this._SetColor(tempColor), this._SetOpacityOfChildren();\n    }\n    OffsetOpacity(t) {\n      this.GetTransformWithParentOpacity() ? this.SetOpacity(this._GetSceneGraphInfo().GetOwnOpacity() + t) : this.SetOpacity(this.GetOpacity() + t);\n    }\n    GetOpacity() {\n      return this.GetTransformWithParentOpacity() ? this.GetParent().GetOpacity() * this._GetSceneGraphInfo().GetOwnOpacity() : this._color.a;\n    }\n    SetUnpremultipliedColor(t) {\n      this._color.equalsIgnoringAlpha(t) || (tempColor.copyRgb(t), tempColor.a = this.GetOpacity(), this._SetColor(tempColor));\n    }\n    SetUnpremultipliedColorRGB(t, e, s) {\n      tempColor.setRgb(t, e, s), this.SetUnpremultipliedColor(tempColor);\n    }\n    OffsetUnpremultipliedColorRGB(t, e, s) {\n      0 === t && 0 === e && 0 === s || (tempColor.copyRgb(this._color), tempColor.r += t, tempColor.g += e, tempColor.b += s, this.SetUnpremultipliedColor(tempColor));\n    }\n    GetUnpremultipliedColor() {\n      return this._color;\n    }\n    GetPremultipliedColor() {\n      return this._colorPremultiplied;\n    }\n    GetDestroyWithParent() {\n      return !!(512 & this._flags);\n    }\n    SetDestroyWithParent(t) {\n      this._SetFlag(512, t);\n    }\n    GetTransformWithParentX() {\n      return !!(1024 & this._flags);\n    }\n    SetTransformWithParentX(t) {\n      this._SetFlag(1024, t);\n    }\n    GetTransformWithParentY() {\n      return !!(2048 & this._flags);\n    }\n    GetTransformWithParentXOrY() {\n      return !!(3072 & this._flags);\n    }\n    SetTransformWithParentY(t) {\n      this._SetFlag(2048, t);\n    }\n    GetTransformWithParentWidth() {\n      return !!(4096 & this._flags);\n    }\n    SetTransformWithParentWidth(t) {\n      this._SetFlag(4096, t);\n    }\n    GetTransformWithParentHeight() {\n      return !!(8192 & this._flags);\n    }\n    SetTransformWithParentHeight(t) {\n      this._SetFlag(8192, t);\n    }\n    GetTransformWithParentAngle() {\n      return !!(16384 & this._flags);\n    }\n    SetTransformWithParentAngle(t) {\n      this._SetFlag(16384, t);\n    }\n    GetTransformWithParentZElevation() {\n      return !!(32768 & this._flags);\n    }\n    SetTransformWithParentZElevation(t) {\n      this._SetFlag(32768, t);\n    }\n    GetTransformWithParentOpacity() {\n      return !!(4194304 & this._flags);\n    }\n    SetTransformWithParentOpacity(t) {\n      this._SetFlag(4194304, t);\n    }\n    GetTransformWithParentVisibility() {\n      return !!(8388608 & this._flags);\n    }\n    SetTransformWithParentVisibility(t) {\n      this._SetFlag(8388608, t);\n    }\n    _ClearAllSceneGraphFlags() {\n      this._flags &= -12647937;\n    }\n    AddChild(t, e) {\n      if (t === this) return false;\n      if (t.HasParent()) return false;\n      if (this._HasChildRecursive(t)) return false;\n      if (this._HasAnyParent(t)) return false;\n      const s = t.GetX(), i = t.GetY(), n = t.GetWidth(), r = t.GetHeight(), h = t.GetAngle(), a = t.GetZElevation(), o = t.GetOpacity();\n      t._SetParent(this), t.SetTransformWithParentX(e.transformX), t.SetTransformWithParentY(e.transformY), t.SetTransformWithParentWidth(e.transformWidth), t.SetTransformWithParentHeight(e.transformHeight), t.SetTransformWithParentAngle(e.transformAngle), t.SetTransformWithParentZElevation(e.transformZElevation), t.SetTransformWithParentOpacity(e.transformOpacity), t.SetTransformWithParentVisibility(e.transformVisibility), t.SetDestroyWithParent(e.destroyWithParent);\n      const l = s - this.GetX(), _ = i - this.GetY(), G = -this.GetAngle(), c = Math.cos(G), d = Math.sin(G);\n      if (e.transformX && (e.transformAngle ? t._x = l * c - _ * d : t._x = l, e.transformWidth)) {\n        const e2 = this.GetWidth() / this._sceneGraphInfo._GetStartWidth();\n        0 !== e2 && (t._x /= e2);\n      }\n      if (e.transformY && (e.transformAngle ? t._y = l * d + _ * c : t._y = _, e.transformHeight)) {\n        const e2 = this.GetHeight() / this._sceneGraphInfo._GetStartHeight();\n        0 !== e2 && (t._y /= e2);\n      }\n      if (e.transformWidth) {\n        const e2 = this.GetWidth();\n        0 === e2 || e2 === Number.EPSILON ? (t._w = 1, t._sceneGraphInfo.SetStartScaleX(1)) : (t._w = n / this.GetWidth(), t._sceneGraphInfo.SetStartScaleX(t._w));\n      }\n      if (e.transformHeight) {\n        const e2 = this.GetHeight();\n        0 === e2 || e2 === Number.EPSILON ? (t._h = 1, t._sceneGraphInfo.SetStartScaleY(1)) : (t._h = r / this.GetHeight(), t._sceneGraphInfo.SetStartScaleY(t._h));\n      }\n      return e.transformAngle && (t._a = h - this.GetAngle()), e.transformZElevation && (t._zElevation = a - this.GetZElevation()), e.transformOpacity && t._sceneGraphInfo.SetOwnOpacity(o), e.transformVisibility && t.SetVisible(this.IsVisible()), this._AddChildToSceneGraphInfo(t), this.SetBboxChanged(), this._SetOpacityOfChildren(), true;\n    }\n    RemoveChild(t) {\n      if (t.GetParent() !== this) return;\n      const e = t.GetX(), s = t.GetY(), i = t.GetWidth(), n = t.GetHeight(), r = t.GetAngle(), h = t.GetZElevation(), a = t.GetOpacity();\n      t._SetParent(null), t._ClearAllSceneGraphFlags(), t.SetXY(e, s), t.SetSize(i, n), t.SetAngle(r), t.SetZElevation(h), t.SetOpacity(a), this._RemoveChildFromSceneGraphInfo(t), this.SetBboxChanged();\n    }\n    GetTmpHierarchyPosition() {\n      return this._tmpHierarchyPosition;\n    }\n    _ResetAllSceneGraphState() {\n      this._BuildTmpSceneGraphData();\n      const t = [...this.children()];\n      for (const e2 of t) this.RemoveChild(e2);\n      const e = this.GetParent();\n      e && e.RemoveChild(this), this._ClearAllSceneGraphFlags();\n    }\n    _BuildTmpSceneGraphData() {\n      if (this._SetTmpHierarchyPosition(), !this._tmpSceneGraphChildren) {\n        const t2 = [...this.children()];\n        t2.length && (this._tmpSceneGraphChildren = [], this._tmpSceneGraphChildrenIndexes = /* @__PURE__ */ new WeakMap());\n        let e = 0;\n        for (const s of t2) {\n          const t3 = s.GetInstance();\n          this._tmpSceneGraphChildren.push(t3), this._tmpSceneGraphChildrenIndexes.set(t3, e), e++;\n        }\n      }\n      const t = this.GetParent();\n      t && t._BuildTmpSceneGraphData();\n    }\n    _SetTmpHierarchyPosition() {\n      if (-1 !== this._tmpHierarchyPosition) return;\n      const t = [...this.parents()];\n      this._tmpHierarchyPosition = t.length;\n      for (const e2 of t) e2._SetTmpHierarchyPosition();\n      const e = [...this.children()];\n      for (const t2 of e) t2._SetTmpHierarchyPosition();\n    }\n    _ReleaseTmpSceneGraphInfo() {\n      this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren.length = 0), this._tmpSceneGraphChildren = null, this._tmpSceneGraphChildrenIndexes = null;\n      const t = this.GetParent();\n      t && t._ReleaseTmpSceneGraphInfo(), this._tmpHierarchyPosition = -1;\n    }\n    HasParent() {\n      return null !== this.GetParent();\n    }\n    GetParent() {\n      const t = this._sceneGraphInfo;\n      return null !== t ? t.GetParent() : null;\n    }\n    GetTopParent() {\n      let t = this;\n      for (; t.HasParent(); ) t = t.GetParent();\n      return t;\n    }\n    *parents() {\n      let t = this.GetParent();\n      for (; t; ) yield t, t = t.GetParent();\n    }\n    HasChild(t) {\n      return this.GetChildren().includes(t);\n    }\n    HasChildren() {\n      const t = this._sceneGraphInfo;\n      return null !== t && t.HasChildren();\n    }\n    GetChildren() {\n      const t = this._sceneGraphInfo;\n      return null !== t ? t.GetChildren() : EMPTY_ARRAY;\n    }\n    children() {\n      return this.GetChildren();\n    }\n    *allChildren() {\n      for (const t of this.children()) yield t, yield* t.allChildren();\n    }\n    GetChildCount() {\n      return this.GetChildren().length;\n    }\n    GetAllChildCount() {\n      return [...this.allChildren()].length;\n    }\n    GetChildAt(t) {\n      const e = this.GetChildren();\n      return (t = Math.floor(+t)) < 0 || t >= e.length ? null : e[t];\n    }\n    GetChildIndex(t) {\n      if (!t) return NaN;\n      const e = this.GetChildren();\n      if (!e) return NaN;\n      for (let s = 0; s < e.length; s++) if (t === e[s]) return s;\n      return NaN;\n    }\n    _CreateSceneGraphInfo(t) {\n      this._sceneGraphInfo || (this._sceneGraphInfo = C33.New(C33.SceneGraphInfo, this)), t && this._sceneGraphInfo.SetParent(t);\n    }\n    _GetSceneGraphInfo() {\n      return this._sceneGraphInfo;\n    }\n    _ReleaseSceneGraphInfo() {\n      this._sceneGraphInfo && (this._sceneGraphInfo.Release(), this._sceneGraphInfo = null);\n    }\n    _SetParent(t) {\n      t ? (t._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(t)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo());\n    }\n    _HasAnyParent(t) {\n      if (!this.HasParent()) return false;\n      const e = this.GetParent();\n      return e === t || e._HasAnyParent(t);\n    }\n    _HasChildRecursive(t) {\n      if (this.HasChild(t)) return true;\n      for (const e of this.GetChildren()) if (e._HasChildRecursive(t)) return true;\n      return false;\n    }\n    _AddChildToSceneGraphInfo(t) {\n      this._sceneGraphInfo.GetChildren().push(t);\n    }\n    _RemoveChildFromSceneGraphInfo(t) {\n      const e = this._sceneGraphInfo.GetChildren(), s = e.indexOf(t);\n      -1 !== s && e.splice(s, 1), 0 !== e.length || this.HasParent() || this._ReleaseSceneGraphInfo(), t.HasChildren() || t._ReleaseSceneGraphInfo();\n    }\n    GetSceneGraphChildrenExportData() {\n      const t = sceneGraphExportDataMap.get(this);\n      return t ? t.childrenData : null;\n    }\n    GetSceneGraphZIndexExportData() {\n      const t = sceneGraphExportDataMap.get(this);\n      return t ? t.zIndexData : NaN;\n    }\n    GetSceneGraphZIndex() {\n      const t = sceneGraphZIndexMap.get(this);\n      return C33.IsFiniteNumber(t) ? t : NaN;\n    }\n    SetSceneGraphZIndex(t) {\n      sceneGraphZIndexMap.set(this, t);\n    }\n    SetUsePointsShaderProgram() {\n      this._SetFlag(524288, true), this._UpdateRendererStateGroup();\n    }\n    _UpdateRendererStateGroup() {\n      if (!enableUpdateRendererStateGroup) return;\n      const t = this._runtime.GetRenderer();\n      let e;\n      this._stateGroup && t.ReleaseStateGroup(this._stateGroup), e = 524288 & this._flags ? t.GetPointsRenderingProgram() || \"<point>\" : t.GetTextureFillShaderProgram() || \"<default>\", this._stateGroup = t.AcquireStateGroup(e, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation());\n    }\n    GetRendererStateGroup() {\n      return this._stateGroup;\n    }\n    HasDefaultColor() {\n      return this._color === DEFAULT_COLOR;\n    }\n    SetBlendMode(t) {\n      if ((t |= 0) < 0 || t > 31) throw new RangeError(\"invalid blend mode\");\n      this.GetBlendMode() !== t && (this._flags = -2080374785 & this._flags | t << 26, this._UpdateRendererStateGroup());\n    }\n    GetBlendMode() {\n      return (2080374784 & this._flags) >> 26;\n    }\n    _SetLayer(t, e) {\n      const s = e && this._layer !== t;\n      s && this._RemoveFromRenderCells(), this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, t), this._layer = t, s && this._UpdateRenderCell(), 0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated();\n    }\n    GetLayer() {\n      return this._layer;\n    }\n    GetLayout() {\n      return this.GetLayer().GetLayout();\n    }\n    _SetZIndex(t) {\n      this._zIndex = 0 | t;\n    }\n    GetZIndex() {\n      return this._layer._UpdateZIndices(), this._zIndex;\n    }\n    _SetHTMLZIndex(t) {\n      this._htmlZIndex = 0 | t;\n    }\n    GetHTMLZIndex() {\n      return this._layer._UpdateHTMLZIndices(), this._htmlZIndex;\n    }\n    _GetLastCachedZIndex() {\n      return this._zIndex;\n    }\n    _SetFlag(t, e) {\n      e ? this._flags |= t : this._flags &= ~t;\n    }\n    IsVisible() {\n      return !!(1 & this._flags);\n    }\n    SetVisible(t) {\n      if (this._SetFlag(1, t), this.HasChildren()) for (const e of this.GetChildren()) e.GetTransformWithParentVisibility() && e.SetVisible(t);\n    }\n    IsCollisionEnabled() {\n      return !!(8 & this._flags);\n    }\n    SetCollisionEnabled(t) {\n      t = !!t, this.IsCollisionEnabled() !== t && (this._SetFlag(8, t), t ? this.SetBboxChanged() : this._RemoveFromCollisionCells());\n    }\n    SetSolidCollisionFilter(t, e) {\n      if (this._SetFlag(32, t), this._solidFilterTags && this._solidFilterTags.clear(), e.trim()) {\n        this._solidFilterTags || (this._solidFilterTags = /* @__PURE__ */ new Set());\n        for (const t2 of e.split(\" \")) t2 && this._solidFilterTags.add(t2.toLowerCase());\n      } else this._solidFilterTags = null;\n    }\n    IsSolidCollisionAllowed(t) {\n      const e = !!(32 & this._flags), s = this._solidFilterTags;\n      if (!t || !s) return !e;\n      for (const i of s) if (t.has(i)) return e;\n      return !e;\n    }\n    SetBboxChanged() {\n      if (this._flags |= 65554, this._objectClass._SetAnyCollisionCellChanged(true), this._runtime.UpdateRender(), this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags &= -3, this._UpdateRenderCell()), 4 & this._flags && this._inst.Dispatcher().dispatchEvent(bboxChangeEvent), null !== this._sceneGraphInfo) {\n        const t = this._sceneGraphInfo.GetChildren();\n        for (let e = 0, s = t.length; e < s; ++e) t[e].SetBboxChanged();\n      }\n    }\n    CalculateBbox(t, e, s) {\n      const i = this.GetX(), n = this.GetY(), r = this.GetWidth(), h = this.GetHeight(), a = this.GetAngle();\n      t.setWH(i - this._ox * r, n - this._oy * h, r, h), s && this.HasMesh() && this._ExpandBboxForMesh(t), 0 === a ? e.setFromRect(t) : (t.offset(-i, -n), e.setFromRotatedRectPrecalc(t, this.GetSinAngle(), this.GetCosAngle()), e.offset(i, n), e.getBoundingBox(t)), t.normalize();\n    }\n    _UpdateBbox() {\n      const t = this._flags;\n      2 & t && (this.CalculateBbox(this._boundingBox, this._boundingQuad, true), this._flags = -3 & t);\n    }\n    GetBoundingBox() {\n      return this._UpdateBbox(), this._boundingBox;\n    }\n    GetBoundingQuad() {\n      return this._UpdateBbox(), this._boundingQuad;\n    }\n    PixelRoundQuad(t) {\n      const e = this.GetX(), s = this.GetY(), i = Math.round(e) - e, n = Math.round(s) - s;\n      return 0 === i && 0 === n ? t : (tempQuad.copy(t), tempQuad.offset(i, n), tempQuad);\n    }\n    OverwriteBoundingBox(t) {\n      this._boundingBox.copy(t), this._boundingQuad.setFromRect(this._boundingBox), this._flags &= -3, this._UpdateCollisionCell(), this._UpdateRenderCell();\n    }\n    SetBboxChangeEventEnabled(t) {\n      this._SetFlag(4, t);\n    }\n    IsBboxChangeEventEnabled() {\n      return !!(4 & this._flags);\n    }\n    IsInViewport(t, e, s) {\n      return e && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || s ? t.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated();\n    }\n    _IsInViewport_ZElevated() {\n      const t = this.GetLayer(), e = this.GetTotalZElevation();\n      return !(e >= t.Get2DCameraZ()) && (t.GetViewportForZ(e, tempRect), tempRect.intersectsRect(this.GetBoundingBox()));\n    }\n    IsInViewport3D(t) {\n      const e = this.GetBoundingBox(), s = e.getLeft(), i = e.getRight(), n = e.getTop(), r = e.getBottom(), h = this.GetTotalZElevation(), a = h + this.GetDepth();\n      return t.ContainsAABB(s, n, h, i, r, a);\n    }\n    IsInViewport2() {\n      const t = this.GetLayer();\n      if (t.Has3DCamera()) return this.IsInViewport3D(t._GetViewFrustum());\n      {\n        const e = t.GetLayout();\n        return this.IsInViewport(t.GetViewport(), e.HasVanishingPointOutsideViewport(), e.IsOrthographicProjection());\n      }\n    }\n    _SetDrawBackFaceOnly(t) {\n      this._SetFlag(1048576, t);\n    }\n    _SetDrawNonBackFacesOnly(t) {\n      this._SetFlag(2097152, t);\n    }\n    IsDrawBackFaceOnly() {\n      return !!(1048576 & this._flags);\n    }\n    IsDrawNonBackFacesOnly() {\n      return !!(2097152 & this._flags);\n    }\n    SetSourceCollisionPoly(t) {\n      this._sourceCollisionPoly = t, this._DiscardTransformedCollisionPoly(), this.HasMesh() && (this._meshInfo.meshPoly = null);\n    }\n    GetSourceCollisionPoly() {\n      return this._sourceCollisionPoly;\n    }\n    HasOwnCollisionPoly() {\n      return null !== this._sourceCollisionPoly || this.HasMesh();\n    }\n    GetTransformedCollisionPoly() {\n      return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle());\n    }\n    GetCustomTransformedCollisionPoly(t, e, s) {\n      let i = 0, n = 1;\n      return 0 !== s && (i = Math.sin(s), n = Math.cos(s)), this._GetCustomTransformedCollisionPolyPrecalc(t, e, s, i, n);\n    }\n    _GetCustomTransformedCollisionPolyPrecalc(t, e, s, i, n) {\n      let r = this._transformedPolyInfo;\n      null === r && (r = { poly: C33.New(C33.CollisionPoly), width: NaN, height: NaN, angle: NaN }, this._transformedPolyInfo = r);\n      const h = r.poly;\n      if (r.width === t && r.height === e && r.angle === s) return h;\n      const a = this._sourceCollisionPoly;\n      if (this.HasMesh()) {\n        const s2 = this.GetOriginX(), r2 = this.GetOriginY(), o = this.GetSourceMesh();\n        let l = this._meshInfo.meshPoly;\n        l || (a ? (tempCollisionPoly.copy(a), tempCollisionPoly.offset(s2, r2)) : tempCollisionPoly.setDefaultPoints(), l = o.InsertPolyMeshVertices(tempCollisionPoly), this._meshInfo.meshPoly = l), o.TransformCollisionPoly(l, h), h.offset(-s2, -r2), h.transformPrecalc(t, e, i, n);\n      } else a ? (h.copy(a), h.transformPrecalc(t, e, i, n)) : h.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());\n      return r.width = t, r.height = e, r.angle = s, h;\n    }\n    _DiscardTransformedCollisionPoly() {\n      this.SetPhysicsBodyChanged(true);\n      const t = this._transformedPolyInfo;\n      null !== t && (t.width = NaN);\n    }\n    CreateMesh(t, e) {\n      if (t = Math.floor(t), e = Math.floor(e), !this.GetInstance().GetPlugin().SupportsMesh()) throw new Error(\"object does not support mesh\");\n      this.ReleaseMesh(), this._meshInfo = { sourceMesh: C33.New(C33.Gfx.Mesh, t, e), transformedMesh: C33.New(C33.Gfx.Mesh, t, e), meshPoly: null };\n    }\n    HasMesh() {\n      return null !== this._meshInfo;\n    }\n    GetSourceMesh() {\n      if (!this.HasMesh()) throw new Error(\"no mesh\");\n      return this._meshInfo.sourceMesh;\n    }\n    GetTransformedMesh() {\n      if (!this.HasMesh()) throw new Error(\"no mesh\");\n      return this._meshInfo.transformedMesh;\n    }\n    SetMeshChanged(t) {\n      this._SetFlag(65536, t);\n    }\n    IsMeshChanged() {\n      return !!(65536 & this._flags);\n    }\n    SetPhysicsBodyChanged(t) {\n      this._SetFlag(131072, t);\n    }\n    IsPhysicsBodyChanged() {\n      return !!(131072 & this._flags);\n    }\n    _ExpandBboxForMesh(t) {\n      const e = this._meshInfo.sourceMesh, s = Math.min(e.GetMinX(), 0), i = Math.min(e.GetMinY(), 0), n = Math.max(e.GetMaxX(), 1), r = Math.max(e.GetMaxY(), 1), h = t.width(), a = t.height();\n      t.offsetLeft(s * h), t.offsetTop(i * a), t.offsetRight((n - 1) * h), t.offsetBottom((r - 1) * a), this._depth = e.GetMaxZ();\n    }\n    ReleaseMesh() {\n      this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly());\n    }\n    SetMeshPoint(t, e, s) {\n      t = Math.floor(t), e = Math.floor(e);\n      const i = s.mode || \"absolute\";\n      if (!VALID_SET_MESH_POINT_MODES.has(i)) throw new Error(\"invalid mode\");\n      const n = \"relative\" === i;\n      let r = s.x, h = s.y;\n      const a = s.zElevation;\n      let o = \"number\" == typeof s.u ? s.u : n ? 0 : -1, l = \"number\" == typeof s.v ? s.v : n ? 0 : -1;\n      if (!this.HasMesh()) return false;\n      const _ = this.GetSourceMesh(), G = _.GetMeshPointAt(t, e);\n      if (null === G) return false;\n      let c = false;\n      return \"number\" == typeof a && G.GetZElevation() !== a && (G.SetZElevation(a), c = true), n && (r += t / (_.GetHSize() - 1), h += e / (_.GetVSize() - 1)), -1 !== o || n ? (n && (o += t / (_.GetHSize() - 1)), o = C33.clamp(o, 0, 1)) : o = G.GetU(), -1 !== l || n ? (n && (l += e / (_.GetVSize() - 1)), l = C33.clamp(l, 0, 1)) : l = G.GetV(), G.GetX() === r && G.GetY() === h && G.GetU() === o && G.GetV() === l ? c : (G.SetX(r), G.SetY(h), G.SetU(o), G.SetV(l), this._DiscardTransformedCollisionPoly(), true);\n    }\n    HasTilemap() {\n      return this._inst.HasTilemap();\n    }\n    ContainsPoint(t, e) {\n      return !!this.GetBoundingBox().containsPoint(t, e) && (!!this.GetBoundingQuad().containsPoint(t, e) && (this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(t, e) : !this.HasOwnCollisionPoly() || this.GetTransformedCollisionPoly().containsPoint(t - this.GetX(), e - this.GetY())));\n    }\n    _IsCollisionCellChanged() {\n      return !!(16 & this._flags);\n    }\n    _UpdateCollisionCell() {\n      if (!this._IsCollisionCellChanged() || !this.IsCollisionEnabled() || 256 & this._flags) return;\n      const t = this.GetBoundingBox(), e = this._objectClass._GetCollisionCellGrid(), s = this._collisionCells;\n      if (tempRect.set(e.XToCell(t.getLeft()), e.YToCell(t.getTop()), e.XToCell(t.getRight()), e.YToCell(t.getBottom())), s.equals(tempRect)) return;\n      const i = this._inst;\n      s === DEFAULT_COLLISION_CELLS ? (e.Update(i, null, tempRect), this._collisionCells = C33.New(C33.Rect, tempRect)) : (e.Update(i, s, tempRect), s.copy(tempRect)), this._flags &= -17;\n    }\n    _SetCollisionCellChanged() {\n      this._flags |= 16;\n    }\n    _RemoveFromCollisionCells() {\n      const t = this._collisionCells;\n      t !== DEFAULT_COLLISION_CELLS && (this._objectClass._GetCollisionCellGrid().Update(this._inst, t, null), this._collisionCells = DEFAULT_COLLISION_CELLS);\n    }\n    _UpdateRenderCell() {\n      const t = this.GetLayer();\n      if (!t.UsesRenderCells() || 256 & this._flags) return;\n      const e = t.GetRenderGrid(), s = this.GetBoundingBox(), i = this._renderCells;\n      if (tempRect.set(e.XToCell(s.getLeft()), e.YToCell(s.getTop()), e.XToCell(s.getRight()), e.YToCell(s.getBottom())), i.equals(tempRect)) return;\n      const n = this._inst;\n      i === DEFAULT_RENDER_CELLS ? (e.Update(n, null, tempRect), this._renderCells = C33.New(C33.Rect, tempRect)) : (e.Update(n, i, tempRect), i.copy(tempRect)), t.SetRenderListStale();\n    }\n    _RemoveFromRenderCells() {\n      const t = this._renderCells;\n      t !== DEFAULT_RENDER_CELLS && (this.GetLayer().GetRenderGrid().Update(this._inst, t, null), this._renderCells = DEFAULT_RENDER_CELLS);\n    }\n    GetRenderCellRange() {\n      return this._renderCells;\n    }\n    ZOrderMoveToTop() {\n      const t = this._inst, e = this._layer, s = e._GetInstances();\n      s.length && s.at(-1) === t || (e._RemoveInstance(t, false), e._AddInstance(t, false), this._runtime.UpdateRender());\n    }\n    ZOrderMoveToBottom() {\n      const t = this._inst, e = this._layer, s = e._GetInstances();\n      s.length && s[0] === t || (e._RemoveInstance(t, false), e._PrependInstance(t, false), this._runtime.UpdateRender());\n    }\n    ZOrderMoveToLayer(t) {\n      const e = this._inst, s = this._layer;\n      if (s.GetLayout() !== t.GetLayout()) throw new Error(\"layer from different layout\");\n      t !== s && (s._RemoveInstance(e, true), this._SetLayer(t), t._AddInstance(e, true), this._runtime.UpdateRender());\n    }\n    ZOrderMoveAdjacentToInstance(t, e) {\n      const s = this._inst;\n      let i = false;\n      const n = this._layer;\n      if (t.GetUID() === s.GetUID()) return;\n      const r = t.GetWorldInfo();\n      if (!r) throw new Error(\"expected world instance\");\n      const h = r.GetLayer();\n      n.GetIndex() !== h.GetIndex() && (n._RemoveInstance(s, true), this._SetLayer(h), h._AddInstance(s, true), i = true);\n      const a = h.MoveInstanceAdjacent(s, t, !!e);\n      (i || a) && this._runtime.UpdateRender();\n    }\n    GetInstanceEffectList() {\n      return this._instanceEffectList;\n    }\n    _SetHasAnyActiveEffect(t) {\n      this._SetFlag(64, t);\n    }\n    HasAnyActiveEffect() {\n      return !!(64 & this._flags);\n    }\n    _SaveToJson(t, e = null) {\n      const s = { \"x\": this.GetX(), \"y\": this.GetY(), \"w\": this.GetWidth(), \"h\": this.GetHeight(), \"l\": this.GetLayer().GetSID(), \"zi\": this.GetZIndex() };\n      0 !== this.GetZElevation() && (s[\"ze\"] = this.GetZElevation()), 0 !== this.GetAngle() && (s[\"a\"] = this._GetAngleNoReflect()), this.HasDefaultColor() || (s[\"c\"] = this._color.toJSON()), 0.5 !== this.GetOriginX() && (s[\"oX\"] = this.GetOriginX()), 0.5 !== this.GetOriginY() && (s[\"oY\"] = this.GetOriginY()), 0 !== this.GetBlendMode() && (s[\"bm\"] = this.GetBlendMode()), this.IsVisible() || (s[\"v\"] = this.IsVisible()), this.IsCollisionEnabled() || (s[\"ce\"] = this.IsCollisionEnabled()), this.IsBboxChangeEventEnabled() && (s[\"be\"] = this.IsBboxChangeEventEnabled()), this._instanceEffectList && (s[\"fx\"] = this._instanceEffectList._SaveToJson());\n      const i = !!(32 & this._flags);\n      return i && (s[\"sfi\"] = i), this._solidFilterTags && (s[\"sft\"] = [...this._solidFilterTags].join(\" \")), this._sceneGraphInfo && \"visual-state\" !== t && (s[\"sgi\"] = this._sceneGraphInfo._SaveToJson(t, e), sceneGraphExportDataMap.has(this) && (s[\"sgcd\"] = sceneGraphExportDataMap.get(this).childrenData, s[\"sgzid\"] = sceneGraphExportDataMap.get(this).zIndexData)), this.HasMesh() && (s[\"mesh\"] = this.GetSourceMesh().SaveToJson()), s;\n    }\n    _SaveSceneGraphPropertiesToJson() {\n      return { \"x\": this._x, \"y\": this._y, \"z\": this._zElevation, \"w\": this._w, \"h\": this._h, \"a\": this._a, \"sgi\": this._GetSceneGraphInfo() ? this._GetSceneGraphInfo()._SaveToJsonProperties() : null };\n    }\n    _LoadSceneGraphPropertiesFromJson(t) {\n      t && (this._x = t[\"x\"], this._y = t[\"y\"], this._zElevation = t[\"z\"], this._w = t[\"w\"], this._h = t[\"h\"], this._a = t[\"a\"], t[\"sgi\"] && this._GetSceneGraphInfo() && this._GetSceneGraphInfo()._LoadFromJson(t[\"sgi\"]), this._MarkSinCosAngleChanged(), this.SetBboxChanged());\n    }\n    _SetupSceneGraphConnectionsOnChangeOfLayout() {\n      this._ReleaseTmpSceneGraphInfo(), this._ResetAllSceneGraphState(), this._CreateSceneGraphInfo(null), this._sceneGraphInfo && this._sceneGraphInfo._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes);\n    }\n    _OnBeforeLoad(t) {\n      \"visual-state\" !== t && this._ResetAllSceneGraphState();\n    }\n    _OnAfterLoad(t, e = \"full\", s = null) {\n      if (t.hasOwnProperty(\"sgi\") && \"visual-state\" !== e) {\n        if (256 & this._flags) return;\n        this._sceneGraphInfo._OnAfterLoad(t[\"sgi\"], s);\n      }\n    }\n    _OnAfterLoad2(t, e = \"full\", s = null) {\n      if (\"visual-state\" !== e) if (256 & this._flags) this._ReleaseTmpSceneGraphInfo();\n      else {\n        if (t.hasOwnProperty(\"sgi\")) this._sceneGraphInfo._SetTmpSceneGraphChildren(null, null, t[\"sgi\"], s);\n        else if (s?.setFromJson && this._tmpSceneGraphChildren) for (const t2 of this._tmpSceneGraphChildren) t2.IsDestroyed() || this._runtime.DestroyInstance(t2);\n        this._ReleaseTmpSceneGraphInfo(), this.SetBboxChanged();\n      }\n    }\n    _LoadFromJson(t, e, s = null) {\n      if (enableUpdateRendererStateGroup = false, this.SetX(t[\"x\"]), this.SetY(t[\"y\"]), this.SetWidth(t[\"w\"]), this.SetHeight(t[\"h\"]), this._SetZIndex(t[\"zi\"]), this.SetZElevation(t.hasOwnProperty(\"ze\") ? t[\"ze\"] : 0), this.SetAngle(t.hasOwnProperty(\"a\") ? t[\"a\"] : 0), t.hasOwnProperty(\"c\") ? tempColor.setFromJSON(t[\"c\"]) : t.hasOwnProperty(\"o\") ? (tempColor.copyRgb(this._color), tempColor.a = t[\"o\"]) : tempColor.setRgba(1, 1, 1, 1), this._SetColor(tempColor), this.SetOriginX(t.hasOwnProperty(\"oX\") ? t[\"oX\"] : 0.5), this.SetOriginY(t.hasOwnProperty(\"oY\") ? t[\"oY\"] : 0.5), this.SetBlendMode(t.hasOwnProperty(\"bm\") ? t[\"bm\"] : 0), this.SetVisible(!t.hasOwnProperty(\"v\") || t[\"v\"]), this.SetCollisionEnabled(!t.hasOwnProperty(\"ce\") || t[\"ce\"]), this.SetBboxChangeEventEnabled(!!t.hasOwnProperty(\"be\") && t[\"be\"]), this.SetSolidCollisionFilter(!!t.hasOwnProperty(\"sfi\") && t[\"sfi\"], t.hasOwnProperty(\"sft\") ? t[\"sft\"] : \"\"), this._instanceEffectList && t.hasOwnProperty(\"fx\") && this._instanceEffectList._LoadFromJson(t[\"fx\"]), t.hasOwnProperty(\"sgi\") && \"visual-state\" !== e) {\n        this._CreateSceneGraphInfo(null);\n        const e2 = this._sceneGraphInfo, s2 = t[\"sgi\"];\n        e2._LoadFromJson(s2), e2._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes), this._SetSceneGraphExportData(t[\"sgcd\"], t[\"sgzid\"]);\n      }\n      if (t.hasOwnProperty(\"mesh\")) {\n        const e2 = t[\"mesh\"];\n        this.CreateMesh(e2[\"cols\"], e2[\"rows\"]), this.GetSourceMesh().LoadFromJson(e2);\n      } else this.ReleaseMesh();\n      this.SetBboxChanged(), enableUpdateRendererStateGroup = true, this._UpdateRendererStateGroup(), \"visual-state\" !== e && this._runtime.AddInstanceNeedingAfterLoad(this.GetInstance(), t);\n    }\n    _SetSceneGraphExportData(t, e) {\n      t && C33.IsFiniteNumber(e) && sceneGraphExportDataMap.set(this, { childrenData: t, zIndexData: e });\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.BehaviorType = class extends C33.DefendedBase {\n    constructor(e, t) {\n      super();\n      const s = e.GetRuntime(), i = s.GetObjectReference(t[1]);\n      s.GetAddonManager()._DelayCreateBehavior(i), this._runtime = s, this._objectClass = e, this._behavior = C33.AddonManager.GetBehaviorByConstructorFunction(i), this._sdkType = null, this._iBehaviorType = null, this._instSdkCtor = i.Instance, this._sid = t[2], this._name = t[0], this._jsPropName = this._runtime.GetJsPropName(t[3]);\n      const r = this._behavior.GetSdkVersion();\n      if (r < 2 && (this._sdkType = C33.New(i.Type, this), !(this._sdkType instanceof C33.SDKBehaviorTypeBase))) throw new Error(\"v1 sdk type must derive from SDKBehaviorBase\");\n      if (C33.AddonManager._PushInitObject(this, r), r >= 2) {\n        const e2 = i.Type ?? globalThis.ISDKBehaviorTypeBase;\n        if (this._iBehaviorType = new e2(), !(this._iBehaviorType instanceof globalThis.ISDKBehaviorTypeBase)) throw new Error(\"script interface class must derive from ISDKBehaviorTypeBase\");\n      } else this._iBehaviorType = new globalThis.IBehaviorType();\n      C33.AddonManager._PopInitObject(r), this.OnCreate();\n    }\n    static Create(e, t) {\n      return C33.New(C33.BehaviorType, e, t);\n    }\n    Release() {\n      this._runtime = null, this._behavior = null, this._sdkType && (this._sdkType.Release(), this._sdkType = null), this._instSdkCtor = null;\n    }\n    GetSdkType() {\n      return this._sdkType;\n    }\n    OnCreate() {\n      this._sdkType ? this._sdkType.OnCreate() : this._iBehaviorType && this._iBehaviorType._onCreate();\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetObjectClass() {\n      return this._objectClass;\n    }\n    GetBehavior() {\n      return this._behavior;\n    }\n    GetInstanceSdkCtor() {\n      return this._instSdkCtor;\n    }\n    GetName() {\n      return this._name;\n    }\n    GetSID() {\n      return this._sid;\n    }\n    GetIBehaviorType() {\n      return this._iBehaviorType;\n    }\n    GetJsPropName() {\n      return this._jsPropName;\n    }\n  };\n}\n{\n  const C33 = self.C3, IBehaviorInstance = self.IBehaviorInstance;\n  C33.BehaviorInstance = class extends C33.DefendedBase {\n    constructor(t) {\n      super(), this._runtime = t.runtime, this._behaviorType = t.behaviorType, this._behavior = this._behaviorType.GetBehavior(), this._inst = t.instance, this._index = t.index, this._sdkInst = null, this._iScriptInterface = null, this._behavior._AddInstance(this._inst);\n    }\n    Release() {\n      this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null), this._behavior._RemoveInstance(this._inst), this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null), this._runtime = null, this._behaviorType = null, this._behavior = null, this._inst = null;\n    }\n    _CreateSdkInstance(t) {\n      if (this._sdkInst) throw new Error(\"already got sdk instance\");\n      if (this.GetBehavior().GetSdkVersion() < 2) {\n        if (this._sdkInst = C33.New(this._behaviorType.GetInstanceSdkCtor(), this, t), !(this._sdkInst instanceof C33.SDKBehaviorInstanceBase)) throw new Error(\"v1 sdk type must derive from SDKBehaviorInstanceBase\");\n      } else {\n        const e = this.GetBehavior().GetScriptInterfaceClass();\n        this._InitScriptInterface(e.Instance, t);\n      }\n    }\n    GetSdkInstance() {\n      return this._sdkInst ?? this._iScriptInterface;\n    }\n    GetObjectInstance() {\n      return this._inst;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetBehaviorType() {\n      return this._behaviorType;\n    }\n    GetBehavior() {\n      return this._behavior;\n    }\n    _GetIndex() {\n      return this._index;\n    }\n    PostCreate() {\n      this._sdkInst ? this._sdkInst.PostCreate() : this._iScriptInterface._postCreate();\n    }\n    OnSpriteFrameChanged(t, e) {\n      this._sdkInst && this._sdkInst.OnSpriteFrameChanged(t, e);\n    }\n    _GetDebuggerProperties() {\n      return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties();\n    }\n    SaveToJson(t = \"full\") {\n      return this._sdkInst ? this._sdkInst.SaveToJson(t) : this._iScriptInterface._saveToJson(t);\n    }\n    LoadFromJson(t, e = \"full\") {\n      if (this._sdkInst) return this._sdkInst.LoadFromJson(t, e);\n      this._iScriptInterface._loadFromJson(t, e);\n    }\n    static SortByTickSequence(t, e, s) {\n      const n = globalThis.ISDKBehaviorInstanceBase;\n      let i, r;\n      i = e instanceof n ? t._UnwrapScriptInterface(e) : e.GetBehaviorInstance(), r = s instanceof n ? t._UnwrapScriptInterface(s) : s.GetBehaviorInstance();\n      const a = i.GetObjectInstance(), h = r.GetObjectInstance(), c = a.GetObjectClass().GetIndex(), o = h.GetObjectClass().GetIndex();\n      if (c !== o) return c - o;\n      const I = a.GetPUID(), _ = h.GetPUID();\n      return I !== _ ? I - _ : i._GetIndex() - r._GetIndex();\n    }\n    _InitScriptInterface(t, e) {\n      const s = IBehaviorInstance, n = t ?? this._sdkInst.GetScriptInterfaceClass(), i = n || s, r = this.GetBehavior().GetSdkVersion();\n      if (C33.AddonManager._PushInitObject(this, r), C33.AddonManager._PushInitProperties(e), this._iScriptInterface = new i(), C33.AddonManager._PopInitProperties(), C33.AddonManager._PopInitObject(r), n && !(this._iScriptInterface instanceof s)) throw new TypeError(`script interface class '${n.name}' does not extend the right base class '${s.name}'`);\n      return this._iScriptInterface;\n    }\n    GetScriptInterface() {\n      return this._iScriptInterface || this._InitScriptInterface();\n    }\n    HasScriptInterface() {\n      return !!this._iScriptInterface;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.EffectList = class extends C33.DefendedBase {\n    constructor(e, t) {\n      super(), this._owner = e, this._allEffectTypes = [], this._activeEffectTypes = [], this._effectTypesByName = /* @__PURE__ */ new Map(), this._effectParams = [], this._effectParamBuffers = [], this._allInstanceEffectLists = /* @__PURE__ */ new Set(), this._preservesOpaqueness = true;\n      for (const e2 of t) {\n        const t2 = C33.New(C33.EffectType, this, e2, this._allEffectTypes.length);\n        this._allEffectTypes.push(t2), this._effectTypesByName.set(t2.GetName().toLowerCase(), t2), e2.length >= 3 && this._effectParams.push(this._LoadSingleEffectParameters(t2, e2[2]));\n      }\n      this.GetRuntime()._AddEffectList(this);\n    }\n    Release() {\n      this.GetRuntime()._RemoveEffectList(this);\n      for (const e of this._effectParamBuffers) e.Release();\n      C33.clearArray(this._effectParamBuffers), C33.clearArray(this._allEffectTypes), C33.clearArray(this._activeEffectTypes), this._effectTypesByName.clear(), C33.clearArray(this._effectParams), this._owner = null;\n    }\n    _AddInstanceEffectList(e) {\n      this._allInstanceEffectLists.add(e);\n    }\n    _RemoveInstanceEffectList(e) {\n      this._allInstanceEffectLists.delete(e);\n    }\n    _InitRenderer(e) {\n      e.IsWebGPU() && (this._effectParamBuffers = this._allEffectTypes.map((e2) => {\n        const t = e2.GetShaderProgram();\n        return t.GetCustomParametersByteSize() > 0 ? C33.New(C33.Gfx.WebGPUEffectCustomParamsBuffer, t) : null;\n      }), this._UpdateAllEffectParamBuffers());\n      for (const t of this._allInstanceEffectLists) t._InitRenderer(e);\n    }\n    PrependEffectTypes(e) {\n      if (e.length) {\n        this._allEffectTypes = e.concat(this._allEffectTypes);\n        for (const t of e) this._effectTypesByName.set(t.GetName().toLowerCase(), t);\n        for (let e2 = 0, t = this._allEffectTypes.length; e2 < t; ++e2) this._allEffectTypes[e2]._SetIndex(e2);\n      }\n    }\n    _LoadSingleEffectParameters(e, t) {\n      e.SetActive(t[0]);\n      const s = t.slice(1);\n      for (let e2 = 0, t2 = s.length; e2 < t2; ++e2) {\n        const t3 = s[e2];\n        if (Array.isArray(t3)) {\n          const f = C33.New(C33.Color);\n          f.setFromJSON(t3), s[e2] = f;\n        }\n      }\n      return s;\n    }\n    GetOwner() {\n      return this._owner;\n    }\n    GetRuntime() {\n      return this._owner.GetRuntime();\n    }\n    UpdateActiveEffects() {\n      C33.clearArray(this._activeEffectTypes);\n      let e = true;\n      for (const t of this._allEffectTypes) t.IsActive() && (this._activeEffectTypes.push(t), t.GetShaderProgram().PreservesOpaqueness() || (e = false));\n      this._preservesOpaqueness = e;\n    }\n    GetAllEffectTypes() {\n      return this._allEffectTypes;\n    }\n    HasAnyEffectType() {\n      return this._allEffectTypes.length > 0;\n    }\n    GetEffectTypeByName(e) {\n      return this._effectTypesByName.get(e.toLowerCase()) || null;\n    }\n    GetEffectTypeByIndex(e) {\n      if ((e = Math.floor(+e)) < 0 || e >= this._allEffectTypes.length) throw new RangeError(\"invalid effect type index\");\n      return this._allEffectTypes[e];\n    }\n    IsEffectIndexActive(e) {\n      return this.GetEffectTypeByIndex(e).IsActive();\n    }\n    SetEffectIndexActive(e, t) {\n      this.GetEffectTypeByIndex(e).SetActive(t);\n    }\n    GetActiveEffectTypes() {\n      return this._activeEffectTypes;\n    }\n    HasAnyActiveEffect() {\n      return this._activeEffectTypes.length > 0;\n    }\n    PreservesOpaqueness() {\n      return this._preservesOpaqueness;\n    }\n    GetEffectParametersForIndex(e) {\n      return this._effectParams[e];\n    }\n    _GetEffectChainShaderParametersForIndex(e) {\n      return e < this._effectParamBuffers.length ? this._effectParamBuffers[e] : this._effectParams[e];\n    }\n    GetEffectParameter(e, t) {\n      if (e < 0 || e >= this._effectParams.length) return null;\n      const s = this._effectParams[e];\n      return t < 0 || t >= s.length ? null : s[t];\n    }\n    SetEffectParameter(e, t, s) {\n      if (e < 0 || e >= this._effectParams.length) return false;\n      const f = this._effectParams[e];\n      if (t < 0 || t >= f.length) return false;\n      const r = f[t];\n      if (r instanceof C33.Color) {\n        if (r.equalsIgnoringAlpha(s)) return false;\n        r.copyRgb(s);\n      } else {\n        if (r === s) return false;\n        f[t] = s;\n      }\n      return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t, s), true;\n    }\n    _UpdateAllEffectParamBuffers() {\n      const e = this._effectParams, t = this._effectParamBuffers;\n      for (let s = 0, f = Math.min(e.length, t.length); s < f; ++s) {\n        const f2 = t[s], r = e[s];\n        for (let e2 = 0, t2 = r.length; e2 < t2; ++e2) f2.SetParameterValue(e2, r[e2]);\n      }\n    }\n    static SaveFxParamToJson(e) {\n      return e && e instanceof C33.Color ? { \"t\": \"color\", \"v\": e.toJSON() } : e;\n    }\n    static LoadFxParamFromJson(e) {\n      if (null === e) return NaN;\n      if (\"object\" == typeof e) {\n        if (\"color\" === e[\"t\"]) {\n          const t = C33.New(C33.Color);\n          return t.setFromJSON(e[\"v\"]), t;\n        }\n        throw new Error(\"invalid effect parameter type\");\n      }\n      return e;\n    }\n    static SaveFxParamsToJson(e) {\n      return e.map(C33.EffectList.SaveFxParamToJson);\n    }\n    static LoadFxParamsFromJson(e) {\n      return e.map(C33.EffectList.LoadFxParamFromJson);\n    }\n    SaveToJson() {\n      return this._allEffectTypes.map((e) => ({ \"name\": e.GetName(), \"active\": e.IsActive(), \"params\": C33.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));\n    }\n    LoadFromJson(e) {\n      for (const t of e) {\n        const e2 = this.GetEffectTypeByName(t[\"name\"]);\n        e2 && (e2.SetActive(t[\"active\"]), this._effectParams[e2.GetIndex()] = C33.EffectList.LoadFxParamsFromJson(t[\"params\"]));\n      }\n      this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.EffectType = class extends C33.DefendedBase {\n    constructor(e, t, r) {\n      super(), this._effectList = e, this._id = t[0], this._name = t[1], this._index = r, this._shaderProgram = null, this._isActive = true;\n    }\n    Release() {\n      this._effectList = null, this._shaderProgram = null;\n    }\n    Clone(e) {\n      const t = C33.New(C33.EffectType, e, [this._id, this._name], -1);\n      return t._shaderProgram = this._shaderProgram, t._isActive = this._isActive, t;\n    }\n    _InitRenderer(e) {\n      const t = e.GetShaderProgramByName(this._id);\n      if (!t) throw new Error(\"failed to find shader program '\" + this._id + \"'\");\n      this._shaderProgram = t;\n    }\n    GetEffectList() {\n      return this._effectList;\n    }\n    GetName() {\n      return this._name;\n    }\n    _SetIndex(e) {\n      this._index = e;\n    }\n    GetIndex() {\n      return this._index;\n    }\n    GetOwner() {\n      return this._effectList.GetOwner();\n    }\n    GetRuntime() {\n      return this._effectList.GetRuntime();\n    }\n    SetActive(e) {\n      this._isActive = !!e;\n    }\n    IsActive() {\n      return this._isActive;\n    }\n    GetShaderProgram() {\n      return this._shaderProgram;\n    }\n    GetDefaultParameterValues() {\n      const e = [];\n      for (let t = 0, r = this._shaderProgram.GetParameterCount(); t < r; ++t) {\n        const r2 = this._shaderProgram.GetParameterType(t);\n        if (\"float\" === r2 || \"percent\" === r2) e.push(0);\n        else {\n          if (\"color\" !== r2) throw new TypeError(\"unknown effect parameter type\");\n          e.push(C33.New(C33.Color, 1, 1, 1, 1));\n        }\n      }\n      return e;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.InstanceEffectList = class extends C33.DefendedBase {\n    constructor(e, t) {\n      super(), this._inst = e, this._wi = t, this._effectList = e.GetObjectClass().GetEffectList(), this._needsRebuildSteps = true, this._wasDefaultColor = true, this._was3D = false, this._wasRotatedOrNegativeSize = false, this._wasTexRotated = false, this._wasMustPreDraw = false, this._effectChain = C33.New(C33.Gfx.EffectChain, e.GetRuntime().GetCanvasManager().GetEffectChainManager(), { drawContent: (e2, t2) => {\n        const s = t2.GetContentObject(), f = s.GetWorldInfo();\n        e2.SetColor(f.GetPremultipliedColor()), e2.SetCurrentZ(f.GetTotalZElevation()), s.Draw(e2), e2.SetCurrentZ(0);\n      }, getSourceTextureInfo: (e2) => {\n        const t2 = e2.GetCurrentTexRect(), [s, f] = e2.GetCurrentSurfaceSize();\n        return { srcTexRect: t2, srcWidth: s, srcHeight: f };\n      }, getShaderParameters: (e2) => this._GetEffectChainShaderParametersForIndex(e2) }), this._activeEffectFlags = [], this._activeEffectTypes = [], this._preservesOpaqueness = true, this._effectParams = [], this._effectParamBuffers = [], this._InitRenderer(e.GetRuntime().GetRenderer());\n      for (let e2 = 0, t2 = this._effectList.GetAllEffectTypes().length; e2 < t2; ++e2) this._activeEffectFlags.push(true);\n      this.UpdateActiveEffects(), this._effectList._AddInstanceEffectList(this);\n    }\n    Release() {\n      this._effectList._RemoveInstanceEffectList(this);\n      for (const e of this._effectParamBuffers) e && e.Release();\n      C33.clearArray(this._effectParamBuffers), this._effectChain.Release(), this._effectChain = null, C33.clearArray(this._activeEffectFlags), C33.clearArray(this._activeEffectTypes), C33.clearArray(this._effectParams), this._inst = null, this._effectList = null;\n    }\n    _InitRenderer(e) {\n      e.IsWebGPU() && (this._effectParamBuffers = this._effectList.GetAllEffectTypes().map((e2) => {\n        const t = e2.GetShaderProgram();\n        return t.GetCustomParametersByteSize() > 0 ? C33.New(C33.Gfx.WebGPUEffectCustomParamsBuffer, t) : null;\n      }));\n    }\n    _LoadEffectParameters(e) {\n      let t = 0;\n      for (const s of e) this._effectParams.push(this._LoadSingleEffectParameters(t, s)), ++t;\n      this._UpdateAllEffectParamBuffers(), this.UpdateActiveEffects();\n    }\n    _LoadSingleEffectParameters(e, t) {\n      this._activeEffectFlags[e] = t[0];\n      const s = t.slice(1);\n      for (let e2 = 0, t2 = s.length; e2 < t2; ++e2) {\n        const t3 = s[e2];\n        if (Array.isArray(t3)) {\n          const f = C33.New(C33.Color);\n          f.setFromJSON(t3), s[e2] = f;\n        }\n      }\n      return s;\n    }\n    LoadDefaultEffectParameters() {\n      for (const e of this._effectList.GetAllEffectTypes()) this._effectParams.push(e.GetDefaultParameterValues());\n      this._UpdateAllEffectParamBuffers();\n    }\n    GetOwner() {\n      return this._owner;\n    }\n    GetEffectList() {\n      return this._effectList;\n    }\n    GetEffectChain() {\n      return this._MaybeRebuildEffectChainSteps(), this._effectChain;\n    }\n    GetRuntime() {\n      return this._inst.GetRuntime();\n    }\n    UpdateActiveEffects() {\n      C33.clearArray(this._activeEffectTypes);\n      const e = this._wi, t = this._effectList.GetAllEffectTypes(), s = this._activeEffectTypes, f = this._activeEffectFlags;\n      let a = true;\n      for (let e2 = 0, r = t.length; e2 < r; ++e2) if (f[e2]) {\n        const f2 = t[e2];\n        s.push(f2), f2.GetShaderProgram().PreservesOpaqueness() || (a = false);\n      }\n      this._preservesOpaqueness = a, e._SetHasAnyActiveEffect(!!s.length), this._needsRebuildSteps = true;\n    }\n    _MaybeRebuildEffectChainSteps() {\n      const e = this._inst, t = this._wi, s = t.HasDefaultColor(), f = e.GetPlugin().Is3D(), a = 0 !== t.GetAngle() || 0 !== t.GetLayer().GetAngle() || t.GetWidth() < 0 || t.GetHeight() < 0, r = e.IsCurrentTexRotated(), i = e.MustPreDraw();\n      (this._needsRebuildSteps || s !== this._wasDefaultColor || f !== this._was3D || a !== this._wasRotatedOrNegativeSize || r !== this._wasTexRotated || i !== this._wasMustPreDraw || this._effectChain.NeedsRebuild()) && (this._effectChain.BuildSteps(this._activeEffectTypes.map((e2) => e2.GetShaderProgram()), { indexMap: this._activeEffectTypes.map((e2) => e2.GetIndex()), forcePreDraw: !s || i, is3D: f, isSourceTextureRotated: r, isRotatedOrNegativeSizeInstance: a }), this._needsRebuildSteps = false, this._wasDefaultColor = s, this._was3D = f, this._wasRotatedOrNegativeSize = a, this._wasTexRotated = r, this._wasMustPreDraw = i);\n    }\n    GetActiveEffectTypes() {\n      return this._activeEffectTypes;\n    }\n    GetEffectParametersForIndex(e) {\n      return this._effectParams[e];\n    }\n    _GetEffectChainShaderParametersForIndex(e) {\n      return e < this._effectParamBuffers.length ? this._effectParamBuffers[e] : this._effectParams[e];\n    }\n    GetEffectParameter(e, t) {\n      if (e < 0 || e >= this._effectParams.length) return null;\n      const s = this._effectParams[e];\n      return t < 0 || t >= s.length ? null : s[t];\n    }\n    SetEffectParameter(e, t, s) {\n      if (e < 0 || e >= this._effectParams.length) return false;\n      const f = this._effectParams[e];\n      if (t < 0 || t >= f.length) return false;\n      const a = f[t];\n      if (a instanceof C33.Color) {\n        if (a.equalsIgnoringAlpha(s)) return false;\n        a.copyRgb(s);\n      } else {\n        if (a === s) return false;\n        f[t] = s;\n      }\n      return e < this._effectParamBuffers.length && this._effectParamBuffers[e].SetParameterValue(t, s), true;\n    }\n    _UpdateAllEffectParamBuffers() {\n      const e = this._effectParams, t = this._effectParamBuffers;\n      for (let s = 0, f = t.length; s < f; ++s) {\n        const f2 = t[s], a = e[s];\n        for (let e2 = 0, t2 = a.length; e2 < t2; ++e2) f2.SetParameterValue(e2, a[e2]);\n      }\n    }\n    PreservesOpaqueness() {\n      return this._preservesOpaqueness;\n    }\n    HasAnyActiveBackgroundBlendingEffect() {\n      return this._activeEffectTypes.some((e) => e.GetShaderProgram().BlendsBackground());\n    }\n    IsEffectIndexActive(e) {\n      return this._activeEffectFlags[e];\n    }\n    SetEffectIndexActive(e, t) {\n      this._activeEffectFlags[e] = !!t;\n    }\n    GetAllEffectTypes() {\n      return this._effectList.GetAllEffectTypes();\n    }\n    _SaveToJson() {\n      return this._effectList.GetAllEffectTypes().map((e) => ({ \"name\": e.GetName(), \"active\": this._activeEffectFlags[e.GetIndex()], \"params\": C33.EffectList.SaveFxParamsToJson(this._effectParams[e.GetIndex()]) }));\n    }\n    _LoadFromJson(e) {\n      for (const t of e) {\n        const e2 = this._effectList.GetEffectTypeByName(t[\"name\"]);\n        e2 && (this._activeEffectFlags[e2.GetIndex()] = t[\"active\"], this._effectParams[e2.GetIndex()] = C33.EffectList.LoadFxParamsFromJson(t[\"params\"]));\n      }\n      this.UpdateActiveEffects(), this._UpdateAllEffectParamBuffers();\n    }\n  };\n}\n{\n  const C33 = self.C3, tempCandidates = [], tileCollRectCandidates = [], tempJumpthruRet = [], tempPolyA = C33.New(C33.CollisionPoly), tempPolyB = C33.New(C33.CollisionPoly), tempQuad = C33.New(C33.Quad), tempRect = C33.New(C33.Rect), tempRect2 = C33.New(C33.Rect);\n  let tempPolyC = null, tempRect3 = null, tempQuadB = null;\n  C33.CollisionEngine = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e, this._collisionCellWidth = 0, this._collisionCellHeight = 0, this._registeredCollisions = [], this._collisionCheckCount = 0, this._collisionCheckSec = 0, this._polyCheckCount = 0, this._polyCheckSec = 0, this._iCollisionEngine = new self.ICollisionEngine(this);\n    }\n    Release() {\n      this._runtime = null;\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetICollisionEngine() {\n      return this._iCollisionEngine;\n    }\n    _Update1sStats() {\n      this._collisionCheckSec = this._collisionCheckCount, this._collisionCheckCount = 0, this._polyCheckSec = this._polyCheckCount, this._polyCheckCount = 0;\n    }\n    Get1secCollisionChecks() {\n      return this._collisionCheckSec;\n    }\n    Get1secPolyChecks() {\n      return this._polyCheckSec;\n    }\n    RegisterCollision(e, t) {\n      const s = e.GetWorldInfo(), n = t.GetWorldInfo();\n      s && n && s.IsCollisionEnabled() && n.IsCollisionEnabled() && this._registeredCollisions.push([e, t]);\n    }\n    AddRegisteredCollisionCandidates(e, t, s) {\n      for (const [n, l] of this._registeredCollisions) {\n        let o = null;\n        if (e === n) o = l;\n        else {\n          if (e !== l) continue;\n          o = n;\n        }\n        o.BelongsToObjectClass(t) && (s.includes(o) || s.push(o));\n      }\n    }\n    CheckRegisteredCollision(e, t) {\n      if (!this._registeredCollisions.length) return false;\n      for (const [s, n] of this._registeredCollisions) if (e === s && t === n || e === n && t === s) return true;\n      return false;\n    }\n    ClearRegisteredCollisions() {\n      C33.clearArray(this._registeredCollisions);\n    }\n    TestOverlap(e, t) {\n      if (!e || !t || e === t) return false;\n      const s = e.GetWorldInfo(), n = t.GetWorldInfo();\n      if (!s.IsCollisionEnabled() || !n.IsCollisionEnabled()) return false;\n      this._collisionCheckCount++;\n      const l = s.GetLayer(), o = n.GetLayer();\n      return l.IsTransformCompatibleWith(o) ? this._TestOverlap_SameLayers(s, n) : this._TestOverlap_DifferentLayers(s, n);\n    }\n    _TestOverlap_SameLayers(e, t) {\n      if (!e.GetBoundingBox().intersectsRect(t.GetBoundingBox())) return false;\n      if (this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(t.GetBoundingQuad())) return false;\n      if (e.HasTilemap() && t.HasTilemap()) return false;\n      if (e.HasTilemap()) return this.TestTilemapOverlap(e, t);\n      if (t.HasTilemap()) return this.TestTilemapOverlap(t, e);\n      if (!e.HasOwnCollisionPoly() && !t.HasOwnCollisionPoly()) return true;\n      const s = e.GetTransformedCollisionPoly(), n = t.GetTransformedCollisionPoly();\n      return s.intersectsPoly(n, t.GetX() - e.GetX(), t.GetY() - e.GetY());\n    }\n    _TestOverlap_DifferentLayers(e, t) {\n      const s = e.HasTilemap(), n = t.HasTilemap();\n      if (s && !n) return this.TestTilemapOverlapDifferentLayers(e, t);\n      if (n && !s) return this.TestTilemapOverlapDifferentLayers(t, e);\n      if (n || s) return false;\n      {\n        const s2 = e.GetLayer(), n2 = t.GetLayer();\n        tempPolyA.copy(e.GetTransformedCollisionPoly()), tempPolyB.copy(t.GetTransformedCollisionPoly());\n        const l = tempPolyA.pointsArr();\n        for (let t2 = 0, n3 = l.length; t2 < n3; t2 += 2) {\n          const n4 = t2 + 1, o2 = l[t2], i = l[n4], [r, a] = s2.LayerToCanvasCss(o2 + e.GetX(), i + e.GetY());\n          l[t2] = r, l[n4] = a;\n        }\n        const o = tempPolyB.pointsArr();\n        for (let e2 = 0, s3 = o.length; e2 < s3; e2 += 2) {\n          const s4 = e2 + 1, l2 = o[e2], i = o[s4], [r, a] = n2.LayerToCanvasCss(l2 + t.GetX(), i + t.GetY());\n          o[e2] = r, o[s4] = a;\n        }\n        return tempPolyA.setBboxChanged(), tempPolyB.setBboxChanged(), this._polyCheckCount++, tempPolyA.intersectsPoly(tempPolyB, 0, 0);\n      }\n    }\n    TestTilemapOverlapDifferentLayers(e, t) {\n      const s = e.GetLayer(), n = t.GetLayer();\n      tempPolyC || (tempPolyC = C33.New(C33.CollisionPoly)), tempRect3 || (tempRect3 = C33.New(C33.Rect)), tempQuadB || (tempQuadB = C33.New(C33.Quad));\n      const l = t.GetX(), o = t.GetY(), [i, r] = n.LayerToCanvasCss(l, o), [a, c] = s.CanvasCssToLayer(i, r), C = a - l, d = c - o;\n      if (tempRect3.copy(t.GetBoundingBox()), tempRect3.offset(C, d), !e.GetBoundingBox().intersectsRect(tempRect3)) return false;\n      if (tempQuadB.copy(t.GetBoundingQuad()), tempQuadB.offset(C, d), this._polyCheckCount++, !e.GetBoundingQuad().intersectsQuad(tempQuadB)) return false;\n      tempPolyC.copy(t.GetTransformedCollisionPoly());\n      const u = tempPolyC.pointsArr();\n      for (let e2 = 0, t2 = u.length; e2 < t2; e2 += 2) {\n        const t3 = e2 + 1;\n        u[e2] += C, u[t3] += d;\n      }\n      return tempPolyC.setBboxChanged(), this.TestTilemapOverlap(e, t, a, c, tempPolyC, tempRect3, tempQuadB);\n    }\n    TestTilemapOverlap(e, t, s, n, l, o, i) {\n      const r = void 0 !== o ? o : t.GetBoundingBox(), a = e.GetX(), c = e.GetY(), C = e.GetInstance().GetSdkInstance(), d = void 0 !== s ? s : t.GetX(), u = void 0 !== n ? n : t.GetY(), h = t.HasOwnCollisionPoly(), p = void 0 !== i ? i : t.GetBoundingQuad(), f = tileCollRectCandidates;\n      C.GetCollisionRectCandidates(r, f);\n      for (let e2 = 0, s2 = f.length; e2 < s2; ++e2) {\n        const s3 = f[e2], n2 = s3.GetRect();\n        if (this._collisionCheckCount++, r.intersectsRectOffset(n2, a, c) && (tempQuad.setFromRect(n2), tempQuad.offset(a, c), tempQuad.intersectsQuad(p))) if (h) {\n          const e3 = void 0 !== l ? l : t.GetTransformedCollisionPoly();\n          let o2 = d, i2 = u;\n          void 0 !== l && (o2 = t.GetX(), i2 = t.GetY());\n          const r2 = s3.GetPoly();\n          if (r2) {\n            if (this._polyCheckCount++, r2.intersectsPoly(e3, o2 - (a + n2.getLeft()), i2 - (c + n2.getTop()))) return C33.clearArray(f), true;\n          } else if (tempPolyA.setFromQuad(tempQuad, 0, 0), tempPolyA.intersectsPoly(e3, o2, i2)) return C33.clearArray(f), true;\n        } else {\n          const e3 = s3.GetPoly();\n          if (!e3) return C33.clearArray(f), true;\n          if (tempPolyA.setFromQuad(p, 0, 0), e3.intersectsPoly(tempPolyA, -(a + n2.getLeft()), -(c + n2.getTop()))) return C33.clearArray(f), true;\n        }\n      }\n      return C33.clearArray(f), false;\n    }\n    TestAndSelectCanvasPointOverlap(e, t, s) {\n      const n = e.GetCurrentSol(), l = this._runtime.GetCurrentEvent();\n      if (!l) throw new Error(\"cannot call outside event\");\n      const o = l.IsOrBlock(), i = new C33.LayerStateCache();\n      if (n.IsSelectAll()) {\n        s || (n._SetSelectAll(false), C33.clearArray(n._GetOwnInstances())), o && C33.clearArray(n._GetOwnElseInstances());\n        for (const l2 of e.GetInstances()) {\n          const e2 = l2.GetWorldInfo(), r = e2.GetLayer();\n          let a = false;\n          if (i.IsInteractive(r) && e2.IsInViewport2() && (a = t.some(([t2, s2]) => {\n            const [n2, l3] = i.CanvasCssToLayer(r, t2, s2, e2.GetTotalZElevation());\n            return e2.ContainsPoint(n2, l3);\n          })), a) {\n            if (s) return false;\n            n._PushInstance(l2);\n          } else o && n._PushElseInstance(l2);\n        }\n      } else {\n        let e2, r = false;\n        o && !l.IsFirstConditionOfType(this._runtime.GetCurrentCondition()) ? this._runtime.IsCurrentConditionFirst() && !n._GetOwnElseInstances().length && n._GetOwnInstances().length ? e2 = n._GetOwnInstances() : (e2 = n._GetOwnElseInstances(), r = true) : e2 = n._GetOwnInstances();\n        let a = 0;\n        for (let l2 = 0, c = e2.length; l2 < c; ++l2) {\n          const c2 = e2[l2], C = c2.GetWorldInfo(), d = C.GetLayer();\n          let u = false;\n          if (i.IsInteractive(d) && C.IsInViewport2() && (u = t.some(([e3, t2]) => {\n            const [s2, n2] = i.CanvasCssToLayer(d, e3, t2, C.GetTotalZElevation());\n            return C.ContainsPoint(s2, n2);\n          })), u) {\n            if (s) return false;\n            r ? n._PushInstance(c2) : e2[a++] = c2;\n          } else r ? e2[a++] = c2 : o && n._PushElseInstance(c2);\n        }\n        s || (e2.length = a);\n      }\n      return e.ApplySolToContainer(), i.Release(), !!s || n.HasAnyInstances();\n    }\n    _ObjectClassCanUseCollisionCells(e, t) {\n      if (!e) return true;\n      for (const s of t.layersHasInstancesOn()) if (!e.IsTransformCompatibleWith(s)) return false;\n      return true;\n    }\n    GetCollisionCandidates(e, t, s, n) {\n      if (t.IsFamily()) for (const l of t.GetFamilyMembers()) this._ObjectClassCanUseCollisionCells(e, l) ? (l._UpdateAllCollisionCells(), l._GetCollisionCellGrid().QueryRange(s, n)) : C33.appendArray(n, l.GetInstances());\n      else this._ObjectClassCanUseCollisionCells(e, t) ? (t._UpdateAllCollisionCells(), t._GetCollisionCellGrid().QueryRange(s, n)) : C33.appendArray(n, t.GetInstances());\n    }\n    GetObjectClassesCollisionCandidates(e, t, s, n) {\n      for (const l of t) this.GetCollisionCandidates(e, l, s, n);\n    }\n    GetSolidCollisionCandidates(e, t, s) {\n      const n = this._runtime.GetSolidBehavior();\n      n && this.GetObjectClassesCollisionCandidates(e, n.GetObjectClasses(), t, s);\n    }\n    GetJumpthruCollisionCandidates(e, t, s) {\n      const n = this._runtime.GetJumpthruBehavior();\n      n && this.GetObjectClassesCollisionCandidates(e, n.GetObjectClasses(), t, s);\n    }\n    IsSolidCollisionAllowed(e, t) {\n      return e._IsSolidEnabled() && (!t || t.GetWorldInfo().IsSolidCollisionAllowed(e.GetSavedDataMap().get(\"solidTags\")));\n    }\n    TestOverlapSolid(e) {\n      const t = e.GetWorldInfo();\n      this.GetSolidCollisionCandidates(t.GetLayer(), t.GetBoundingBox(), tempCandidates);\n      for (const t2 of tempCandidates) if (this.IsSolidCollisionAllowed(t2, e) && this.TestOverlap(e, t2)) return C33.clearArray(tempCandidates), t2;\n      return C33.clearArray(tempCandidates), null;\n    }\n    TestRectOverlapSolid(e, t) {\n      this.GetSolidCollisionCandidates(null, e, tempCandidates);\n      for (const s of tempCandidates) if (this.IsSolidCollisionAllowed(s, t) && this.TestRectOverlap(e, s)) return C33.clearArray(tempCandidates), s;\n      return C33.clearArray(tempCandidates), null;\n    }\n    TestOverlapJumpthru(e, t) {\n      let s = null;\n      t && (s = tempJumpthruRet, C33.clearArray(s));\n      const n = e.GetWorldInfo();\n      this.GetJumpthruCollisionCandidates(n.GetLayer(), n.GetBoundingBox(), tempCandidates);\n      for (const n2 of tempCandidates) if (n2._IsJumpthruEnabled() && this.TestOverlap(e, n2)) {\n        if (!t) return C33.clearArray(tempCandidates), n2;\n        s.push(n2);\n      }\n      return C33.clearArray(tempCandidates), s;\n    }\n    PushOut(e, t, s, n, l) {\n      n = n || 50;\n      const o = e.GetWorldInfo(), i = o.GetX(), r = o.GetY();\n      for (let a = 0; a < n; ++a) if (o.SetXY(i + t * a, r + s * a), o.SetBboxChanged(), !this.TestOverlap(e, l)) return true;\n      return o.SetXY(i, r), o.SetBboxChanged(), false;\n    }\n    PushOutSolid(e, t, s, n, l, o) {\n      n = n || 50;\n      const i = e.GetWorldInfo(), r = i.GetX(), a = i.GetY();\n      let c = null, C = null;\n      for (let d = 0; d < n; ++d) if (i.SetXY(r + t * d, a + s * d), i.SetBboxChanged(), !this.TestOverlap(e, c)) {\n        if (c = this.TestOverlapSolid(e), c) C = c;\n        else if (l && (c = o ? this.TestOverlap(e, o) ? o : null : this.TestOverlapJumpthru(e), c && (C = c)), !c) return C && this.PushInFractional(e, t, s, C, 16, true), true;\n      }\n      return i.SetXY(r, a), i.SetBboxChanged(), false;\n    }\n    PushOutSolidAxis(e, t, s, n) {\n      n = n || 50;\n      const l = e.GetWorldInfo(), o = l.GetX(), i = l.GetY();\n      let r = null, a = null;\n      for (let c = 0; c < n; ++c) for (let n2 = 0; n2 < 2; ++n2) {\n        const C = 2 * n2 - 1;\n        if (l.SetXY(o + t * c * C, i + s * c * C), l.SetBboxChanged(), !this.TestOverlap(e, r)) {\n          if (r = this.TestOverlapSolid(e), !r) return a && this.PushInFractional(e, t * C, s * C, a, 16, true), true;\n          a = r;\n        }\n      }\n      return l.SetXY(o, i), l.SetBboxChanged(), false;\n    }\n    PushInFractional(e, t, s, n, l, o) {\n      let i = 2, r = false, a = false;\n      const c = e.GetWorldInfo();\n      let C = c.GetX(), d = c.GetY();\n      for (; i <= l; ) {\n        const l2 = 1 / i;\n        i *= 2, c.OffsetXY(t * l2 * (r ? 1 : -1), s * l2 * (r ? 1 : -1)), c.SetBboxChanged(), this.TestOverlap(e, n) || o && this.TestOverlapSolid(e) ? (r = true, a = true) : (r = false, a = false, C = c.GetX(), d = c.GetY());\n      }\n      a && (c.SetXY(C, d), c.SetBboxChanged());\n    }\n    PushOutSolidNearest(e, t = 100) {\n      let s = 0;\n      const n = e.GetWorldInfo(), l = n.GetX(), o = n.GetY();\n      let i = 0, r = this.TestOverlapSolid(e);\n      if (!r) return true;\n      for (; s <= t; ) {\n        let t2 = 0, a = 0;\n        switch (i) {\n          case 0:\n            t2 = 0, a = -1, s++;\n            break;\n          case 1:\n            t2 = 1, a = -1;\n            break;\n          case 2:\n            t2 = 1, a = 0;\n            break;\n          case 3:\n            t2 = 1, a = 1;\n            break;\n          case 4:\n            t2 = 0, a = 1;\n            break;\n          case 5:\n            t2 = -1, a = 1;\n            break;\n          case 6:\n            t2 = -1, a = 0;\n            break;\n          case 7:\n            t2 = -1, a = -1;\n        }\n        if (i = (i + 1) % 8, n.SetXY(Math.floor(l + t2 * s), Math.floor(o + a * s)), n.SetBboxChanged(), !this.TestOverlap(e, r) && (r = this.TestOverlapSolid(e), !r)) return true;\n      }\n      return n.SetXY(l, o), n.SetBboxChanged(), false;\n    }\n    CalculateBounceAngle(e, t, s, n) {\n      const l = e.GetWorldInfo(), o = l.GetX(), i = l.GetY(), r = Math.max(10, C33.distanceTo(t, s, o, i)), a = C33.angleTo(t, s, o, i), c = n || this.TestOverlapSolid(e);\n      if (!c) return C33.clampAngle(a + Math.PI);\n      let C = c, d = 0, u = 0;\n      const h = C33.toRadians(5);\n      let p;\n      for (p = 1; p < 36; ++p) {\n        const o2 = a - p * h;\n        if (l.SetXY(t + Math.cos(o2) * r, s + Math.sin(o2) * r), l.SetBboxChanged(), !this.TestOverlap(e, C) && (C = n ? null : this.TestOverlapSolid(e), !C)) {\n          d = o2;\n          break;\n        }\n      }\n      for (36 === p && (d = C33.clampAngle(a + Math.PI)), C = c, p = 1; p < 36; ++p) {\n        const o2 = a + p * h;\n        if (l.SetXY(t + Math.cos(o2) * r, s + Math.sin(o2) * r), l.SetBboxChanged(), !this.TestOverlap(e, C) && (C = n ? null : this.TestOverlapSolid(e), !C)) {\n          u = o2;\n          break;\n        }\n      }\n      if (36 === p && (u = C33.clampAngle(a + Math.PI)), l.SetXY(o, i), l.SetBboxChanged(), u === d) return u;\n      const f = C33.angleDiff(u, d) / 2;\n      let G;\n      G = C33.angleClockwise(u, d) ? C33.clampAngle(d + f + Math.PI) : C33.clampAngle(u + f);\n      const m = Math.cos(a), y = Math.sin(a), g = Math.cos(G), T = Math.sin(G), _ = m * g + y * T, I = m - 2 * _ * g, S = y - 2 * _ * T;\n      return C33.angleTo(0, 0, I, S);\n    }\n    TestSegmentOverlap(e, t, s, n, l) {\n      if (!l) return false;\n      const o = l.GetWorldInfo();\n      if (!o.IsCollisionEnabled()) return false;\n      if (this._collisionCheckCount++, tempRect.set(Math.min(e, s), Math.min(t, n), Math.max(e, s), Math.max(t, n)), !o.GetBoundingBox().intersectsRect(tempRect)) return false;\n      if (l.HasTilemap()) return this._TestSegmentOverlapTilemap(e, t, s, n, l, o);\n      if (this._polyCheckCount++, !o.GetBoundingQuad().intersectsSegment(e, t, s, n)) return false;\n      if (!o.HasOwnCollisionPoly()) return true;\n      return o.GetTransformedCollisionPoly().intersectsSegment(o.GetX(), o.GetY(), e, t, s, n);\n    }\n    _TestSegmentOverlapTilemap(e, t, s, n, l, o) {\n      const i = o.GetX(), r = o.GetY(), a = l.GetSdkInstance(), c = tileCollRectCandidates;\n      tempRect2.set(e, t, s, n), tempRect2.normalize(), a.GetCollisionRectCandidates(tempRect2, c);\n      for (let l2 = 0, o2 = c.length; l2 < o2; ++l2) {\n        const o3 = c[l2], a2 = o3.GetRect();\n        if (this._collisionCheckCount++, tempRect.intersectsRectOffset(a2, i, r) && (tempQuad.setFromRect(a2), tempQuad.offset(i, r), tempQuad.intersectsSegment(e, t, s, n))) {\n          const l3 = o3.GetPoly();\n          if (!l3) return C33.clearArray(c), true;\n          if (this._polyCheckCount++, l3.intersectsSegment(i + a2.getLeft(), r + a2.getTop(), e, t, s, n)) return C33.clearArray(c), true;\n        }\n      }\n      return C33.clearArray(c), false;\n    }\n    TestRectOverlap(e, t) {\n      if (!t) return false;\n      const s = t.GetWorldInfo();\n      if (!s.IsCollisionEnabled()) return false;\n      if (this._collisionCheckCount++, !s.GetBoundingBox().intersectsRect(e)) return false;\n      if (t.HasTilemap()) return this._TestRectOverlapTilemap(e, t, s);\n      if (this._polyCheckCount++, tempQuad.setFromRect(e), !s.GetBoundingQuad().intersectsQuad(tempQuad)) return false;\n      if (!s.HasOwnCollisionPoly()) return true;\n      const n = tempPolyA;\n      n.setFromRect(e, s.GetX(), s.GetY());\n      const l = s.GetTransformedCollisionPoly();\n      return n.intersectsPoly(l, 0, 0);\n    }\n    _TestRectOverlapTilemap(e, t, s) {\n      const n = s.GetX(), l = s.GetY(), o = t.GetSdkInstance(), i = tileCollRectCandidates;\n      o.GetCollisionRectCandidates(e, i);\n      for (let t2 = 0, s2 = i.length; t2 < s2; ++t2) {\n        const s3 = i[t2], o2 = s3.GetRect();\n        if (this._collisionCheckCount++, e.intersectsRectOffset(o2, n, l)) {\n          const t3 = s3.GetPoly();\n          if (!t3) return C33.clearArray(i), true;\n          if (this._polyCheckCount++, tempPolyA.setFromRect(e, 0, 0), t3.intersectsPoly(tempPolyA, -(n + o2.getLeft()), -(l + o2.getTop()))) return C33.clearArray(i), true;\n        }\n      }\n      return C33.clearArray(i), false;\n    }\n    TestRayIntersectsInstance(e, t) {\n      if (!e) return;\n      const s = e.GetWorldInfo();\n      s.IsCollisionEnabled() && (this._collisionCheckCount++, s.GetBoundingBox().intersectsRect(t.rect) && (e.HasTilemap() ? this._TestRayIntersectsTilemap(e, s, t) : (this._polyCheckCount++, s.HasOwnCollisionPoly() ? t.TestInstancePoly(e, s.GetX(), s.GetY(), s.GetTransformedCollisionPoly()) : t.TestInstanceQuad(e, s.GetBoundingQuad()))));\n    }\n    _TestRayIntersectsTilemap(e, t, s) {\n      const n = t.GetX(), l = t.GetY(), o = tileCollRectCandidates;\n      e.GetSdkInstance().GetCollisionRectCandidates(s.rect, o);\n      for (let i = 0, r = o.length; i < r; i++) {\n        const r2 = o[i], a = r2.GetRect();\n        if (this._collisionCheckCount++, s.rect.intersectsRectOffset(a, n, l)) {\n          const o2 = r2.GetPoly();\n          this._polyCheckCount++, o2 ? s.TestInstancePoly(e, n + a.getLeft(), l + a.getTop(), o2) : s.TestInstanceRect(e, t.GetX(), t.GetY(), a);\n        }\n      }\n      C33.clearArray(o);\n    }\n    SetCollisionCellSize(e, t) {\n      if (e === this._collisionCellWidth && t === this._collisionCellHeight) return;\n      this._collisionCellWidth = e, this._collisionCellHeight = t;\n      const s = this._runtime.GetAllObjectClasses();\n      for (const n of s) if (n.IsWorldType()) {\n        for (const e2 of n.instancesIncludingPendingCreate()) e2.GetWorldInfo()._RemoveFromCollisionCells();\n        n._GetCollisionCellGrid().SetCellSize(e, t), n._SetAnyCollisionCellChanged();\n        for (const e2 of n.instancesIncludingPendingCreate()) {\n          const t2 = e2.GetWorldInfo();\n          t2._SetCollisionCellChanged(), t2._UpdateCollisionCell();\n        }\n      }\n    }\n    GetCollisionCellSize() {\n      return [this._collisionCellWidth, this._collisionCellHeight];\n    }\n    _InitCollisionCellSize(e, t) {\n      this._collisionCellWidth = e, this._collisionCellHeight = t;\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.SparseGrid = class extends C33.DefendedBase {\n    constructor(t, e) {\n      super(), this._cellWidth = t, this._cellHeight = e, this._cells = C33.New(C33.PairMap);\n    }\n    Release() {\n      this._cells.Release(), this._cells = null;\n    }\n    SetCellSize(t, e) {\n      if (!this._cells.IsEmpty()) throw new Error(\"grid not empty\");\n      this._cellWidth = t, this._cellHeight = e;\n    }\n    GetCell(t, e, l) {\n      let i = this._cells.Get(t, e);\n      return i || (l ? (i = C33.New(C33.GridCell, this, t, e), this._cells.Set(t, e, i), i) : null);\n    }\n    XToCell(t) {\n      const e = Math.floor(t / this._cellWidth);\n      return isFinite(e) ? e : 0;\n    }\n    YToCell(t) {\n      const e = Math.floor(t / this._cellHeight);\n      return isFinite(e) ? e : 0;\n    }\n    Update(t, e, l) {\n      if (e) for (let i = e.getLeft(), s = e.getRight(); i <= s; ++i) for (let s2 = e.getTop(), o = e.getBottom(); s2 <= o; ++s2) {\n        if (l && l.containsPoint(i, s2)) continue;\n        const e2 = this.GetCell(i, s2, false);\n        e2 && (e2.Remove(t), e2.IsEmpty() && this._cells.Delete(i, s2));\n      }\n      if (l) for (let i = l.getLeft(), s = l.getRight(); i <= s; ++i) for (let s2 = l.getTop(), o = l.getBottom(); s2 <= o; ++s2) e && e.containsPoint(i, s2) || this.GetCell(i, s2, true).Insert(t);\n    }\n    QueryRange(t, e) {\n      let l = this.XToCell(t.getLeft());\n      const i = this.YToCell(t.getTop()), s = this.XToCell(t.getRight()), o = this.YToCell(t.getBottom());\n      if (isFinite(s) && isFinite(o)) for (; l <= s; ++l) for (let t2 = i; t2 <= o; ++t2) {\n        const i2 = this.GetCell(l, t2, false);\n        i2 && i2.Dump(e);\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.GridCell = class extends C33.DefendedBase {\n    constructor(s, e, t) {\n      super(), this._grid = s, this._x = e, this._y = t, this._instances = C33.New(C33.ArraySet);\n    }\n    Release() {\n      this._instances.Release(), this._instances = null, this._grid = null;\n    }\n    IsEmpty() {\n      return this._instances.IsEmpty();\n    }\n    Insert(s) {\n      this._instances.Add(s);\n    }\n    Remove(s) {\n      this._instances.Delete(s);\n    }\n    Dump(s) {\n      C33.appendArray(s, this._instances.GetArray());\n    }\n  };\n}\n{\n  const C33 = self.C3, PADDING = 1e-6, NO_HIT = 2;\n  C33.Ray = class {\n    constructor() {\n      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.dx = 0, this.dy = 0, this.rect = new C33.Rect(), this.hitFraction = 2, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0;\n    }\n    DidCollide() {\n      return this.hitFraction < 1.000001;\n    }\n    Reset() {\n      this.hitFraction = 2;\n    }\n    Set(t, i, s, h) {\n      return this.x1 = t, this.y1 = i, this.x2 = s, this.y2 = h, this.dx = s - t, this.dy = h - i, this.rect.set(t, i, s, h), this.rect.normalize(), this.hitFraction = 2, this.hitUid = null, this.hitNormal = 0, this.hitNormalDx = 0, this.hitNormalDy = 0, this.hitX = 0, this.hitY = 0, this.distance = 0, this.normalX = 1, this.normalY = 0, this.reflectionX = 1, this.reflectionY = 0, this;\n    }\n    Complete() {\n      if (false === this.DidCollide()) return;\n      const t = this.dx * this.hitFraction, i = this.dy * this.hitFraction, s = C33.hypot2DFast(t, i), h = t / s, e = i / s;\n      this.distance = s - PADDING, this.hitX = this.x1 + h * this.distance, this.hitY = this.y1 + e * this.distance, this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2, this.normalX = Math.cos(this.hitNormal), this.normalY = Math.sin(this.hitNormal);\n      const n = h * this.normalX + e * this.normalY;\n      if (this.reflectionX = h - 2 * this.normalX * n, this.reflectionY = e - 2 * this.normalY * n, n > 0) {\n        const t2 = Math.PI;\n        this.hitNormal = C33.clampAngle(this.hitNormal + t2), this.normalX = -this.normalX, this.normalY = -this.normalY;\n      }\n    }\n    TestInstanceSegment(t, i, s, h, e) {\n      const n = C33.rayIntersect(this.x1, this.y1, this.x2, this.y2, i, s, h, e);\n      n >= 0 && n < this.hitFraction && (this.hitFraction = n, this.hitUid = t.GetUID(), this.hitNormalDx = i - h, this.hitNormalDy = s - e);\n    }\n    TestInstanceRect(t, i, s, h) {\n      const e = i + h.getLeft(), n = i + h.getRight(), a = s + h.getTop(), o = s + h.getBottom();\n      this.TestInstanceSegment(t, e, a, n, a), this.TestInstanceSegment(t, n, a, n, o), this.TestInstanceSegment(t, n, o, e, o), this.TestInstanceSegment(t, e, o, e, a);\n    }\n    TestInstanceQuad(t, i) {\n      const s = i.getTlx(), h = i.getTly(), e = i.getTrx(), n = i.getTry(), a = i.getBrx(), o = i.getBry(), r = i.getBlx(), l = i.getBly();\n      this.TestInstanceSegment(t, s, h, e, n), this.TestInstanceSegment(t, e, n, a, o), this.TestInstanceSegment(t, a, o, r, l), this.TestInstanceSegment(t, r, l, s, h);\n    }\n    TestInstancePoly(t, i, s, h) {\n      const e = h.pointsArr();\n      for (let h2 = 0, n = e.length; h2 < n; h2 += 2) {\n        const a = (h2 + 2) % n, o = e[h2] + i, r = e[h2 + 1] + s, l = e[a] + i, c = e[a + 1] + s;\n        this.TestInstanceSegment(t, o, r, l, c);\n      }\n    }\n  };\n}\n{\n  const C33 = self.C3;\n  C33.LayerStateCache = class {\n    constructor() {\n      this._layerCache = /* @__PURE__ */ new Map();\n    }\n    Release() {\n      for (const e of this._layerCache.values()) e.layerPts.Clear();\n      this._layerCache.clear();\n    }\n    _GetLayerCache(e) {\n      let a = this._layerCache.get(e);\n      return void 0 === a && (a = { isInteractive: null, layerPts: new C33.PairMap() }, this._layerCache.set(e, a)), a;\n    }\n    IsInteractive(e) {\n      const a = this._GetLayerCache(e);\n      return null === a.isInteractive && (a.isInteractive = e.IsSelfAndParentsInteractive()), a.isInteractive;\n    }\n    CanvasCssToLayer(e, a, t, s) {\n      if (0 !== s) return e.CanvasCssToLayer(a, t, s);\n      const r = this._GetLayerCache(e);\n      let n = r.layerPts.Get(a, t);\n      return void 0 === n && (n = e.CanvasCssToLayer(a, t, s), r.layerPts.Set(a, t, n)), n;\n    }\n  };\n}\n{\n  const C33 = self.C3, VALID_FULLSCREEN_MODES = /* @__PURE__ */ new Set([\"off\", \"crop\", \"scale-inner\", \"scale-outer\", \"letterbox-scale\", \"letterbox-integer-scale\"]), VALID_FULLSCREEN_SCALING_QUALITIES = /* @__PURE__ */ new Set([\"high\", \"low\"]), glMatrix = self.glMatrix, mat4 = glMatrix.mat4, vec3 = glMatrix.vec3, tempProjection = mat4.create(), PERCENTTEXT_WIDTH = 300, PERCENTTEXT_HEIGHT = 200, PROGRESSBAR_WIDTH = 120, PROGRESSBAR_HEIGHT = 8, tempQuad = C33.New(C33.Quad), tempRect = C33.New(C33.Rect), SPLASH_MIN_DISPLAY_TIME = 3e3, SPLASH_AFTER_FADEOUT_WAIT_TIME = 200, SPLASH_FADE_DURATION = 300;\n  C33.CanvasManager = class extends C33.DefendedBase {\n    constructor(e) {\n      super(), this._runtime = e, this._canvasLayers = [], this._isWebGPUEnabled = false, this._webglRenderer = null, this._webgpuRenderer = null, this._iRenderer = null, this._gpuPreference = \"high-performance\", this._isLimitedToWebGL1 = false, this._multitexturingMode = \"auto\", this._windowInnerWidth = 0, this._windowInnerHeight = 0, this._cssDisplayMode = \"\", this._canvasCssWidth = 0, this._canvasCssHeight = 0, this._canvasDeviceWidth = 0, this._canvasDeviceHeight = 0, this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0, this._zAxisScale = \"normalized\", this._initFieldOfView = 0, this._zNear = 1, this._zFar = 1e4, this._enableMipmaps = true, this._textureAnisotropy = 0, this._drawWidth = 0, this._drawHeight = 0, this._fullscreenMode = \"letterbox-scale\", this._documentFullscreenMode = \"letterbox-scale\", this._deviceTransformOffX = 0, this._deviceTransformOffY = 0, this._defaultProjectionMatrix = mat4.create(), this._wantFullscreenScalingQuality = \"high\", this._fullscreenScalingQuality = this._wantFullscreenScalingQuality, this._isDocumentFullscreen = false, this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets = /* @__PURE__ */ new Set(), this._shaderData = self[\"C3_Shaders\"], this._effectChainManager = C33.New(C33.Gfx.EffectChainManager, { getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()], getRenderTarget: () => this.GetEffectCompositorRenderTarget(), releaseRenderTarget: (e2) => this.ReleaseEffectCompositorRenderTarget(e2), getTime: () => this.GetRuntime().GetGameTime(), redraw: () => this.GetRuntime().UpdateRender() }), this._gpuTimeStartFrame = 0, this._gpuTimeEndFrame = 0, this._gpuLastUtilisation = NaN, this._gpuFrameTimingsBuffer = null, this._layersGpuProfile = /* @__PURE__ */ new Map(), this._gpuCurUtilisation = NaN, this._webgpuFrameTimings = /* @__PURE__ */ new Map(), this._snapshotFormat = \"\", this._snapshotQuality = 1, this._snapshotArea = C33.New(C33.Rect), this._snapshotUrl = \"\", this._snapshotPromise = null, this._snapshotResolve = null, this._isPastingToDrawingCanvas = 0, this._loaderStartTime = 0, this._rafId = -1, this._loadingProgress = 0, this._loadingprogress_handler = (e2) => this._loadingProgress = e2.progress, this._percentText = null, this._splashTextures = { logo: null, powered: null, website: null }, this._splashFrameNumber = 0, this._splashFadeInFinishTime = 0, this._splashFadeOutStartTime = 0, this._splashState = \"fade-in\", this._splashDoneResolve = null, this._splashDonePromise = new Promise((e2) => this._splashDoneResolve = e2);\n    }\n    _SetGPUPowerPreference(e) {\n      this._gpuPreference = e;\n    }\n    _SetWebGPUEnabled(e) {\n      this._isWebGPUEnabled = !!e;\n    }\n    _SetZAxisScale(e) {\n      this._zAxisScale = e;\n    }\n    GetZAxisScale() {\n      return this._zAxisScale;\n    }\n    _SetInitFieldOfView(e) {\n      this._initFieldOfView = e;\n    }\n    _SetZDistances(e, t) {\n      this._zNear = e, this._zFar = t;\n    }\n    _SetLimitedToWebGL1(e) {\n      this._isLimitedToWebGL1 = !!e;\n    }\n    _SetMultitexturingMode(e) {\n      this._multitexturingMode = e;\n    }\n    async CreateCanvas(e) {\n      let t = e[\"canvas\"];\n      this._canvasLayers.push({ canvas: t, ctx: null }), this._runtime.AddDOMComponentMessageHandler(\"runtime\", \"window-resize\", (e2) => this._OnWindowResize(e2)), this._runtime.AddDOMComponentMessageHandler(\"runtime\", \"fullscreenchange\", (e2) => this._OnFullscreenChange(e2)), this._runtime.AddDOMComponentMessageHandler(\"runtime\", \"fullscreenerror\", (e2) => this._OnFullscreenError(e2)), t.addEventListener(\"webglcontextlost\", (e2) => this._OnWebGLContextLost(e2)), t.addEventListener(\"webglcontextrestored\", (e2) => this._OnWebGLContextRestored(e2)), this._isDocumentFullscreen = !!e[\"isFullscreen\"], this._cssDisplayMode = e[\"cssDisplayMode\"];\n      const s = navigator[\"gpu\"] && this._isWebGPUEnabled;\n      let i = false;\n      if (s) try {\n        await this._InitWebGPUContext(true);\n      } catch (e2) {\n        this._MaybeLogRendererError(\"WebGPU\", e2), this._webgpuRenderer = null;\n      }\n      if (!this.GetRenderer()) try {\n        await this._InitWebGLContext(true);\n      } catch (e2) {\n        this._MaybeLogRendererError(\"WebGL\", e2), this._webglRenderer = null;\n      }\n      if (this.GetRenderer() || (i = true), !this.GetRenderer() && s) try {\n        await this._InitWebGPUContext(false);\n      } catch (e2) {\n        this._MaybeLogRendererError(\"WebGPU\", e2), this._webgpuRenderer = null;\n      }\n      if (!this.GetRenderer()) try {\n        await this._InitWebGLContext(false);\n      } catch (e2) {\n        this._MaybeLogRendererError(\"WebGL\", e2), this._webglRenderer = null;\n      }\n      const r = this.GetRenderer();\n      if (!r) throw new Error(\"failed to acquire a renderer - check WebGL or WebGPU is supported\");\n      r.SetHasMajorPerformanceCaveat(i), this._webgpuRenderer && (this._webgpuRenderer.ondevicelost = () => this._OnWebGPUDeviceLost(), this._webgpuRenderer.ondevicerestored = () => this._OnWebGPUDeviceRestored()), \"normalized\" === this._zAxisScale ? r.SetZAxisScaleNormalized() : (r.SetZAxisScaleRegular(), r.SetFovY(this._initFieldOfView)), this.SetSize(e[\"windowInnerWidth\"], e[\"windowInnerHeight\"], true), await this._InitRenderer();\n    }\n    _MaybeLogRendererError(e, t) {\n      t && \"string\" == typeof t.message && t.message.startsWith(\"renderer-unavailable\") || console.error(`Error creating ${e} renderer: `, t);\n    }\n    async _InitWebGPUContext(e) {\n      const t = { nearZ: this._zNear, farZ: this._zFar };\n      let s = true;\n      \"no\" === this._multitexturingMode ? s = false : \"auto\" === this._multitexturingMode && (s = C33.Platform.IsDesktop);\n      const i = { powerPreference: this._gpuPreference, depth: this._runtime.Uses3DFeatures(), failIfMajorPerformanceCaveat: e, usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(), canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(), canSampleDepth: this._runtime.UsesAnyDepthSampling(), isMultiTexturingAllowed: s };\n      this._webgpuRenderer = C33.New(C33.Gfx.WebGPURenderer, t), await this._webgpuRenderer.Create(this._canvasLayers[0].canvas, i);\n    }\n    async _InitWebGLContext(e) {\n      const t = { alpha: true, powerPreference: this._gpuPreference, enableGpuProfiling: \"xbox-uwp-webview2\" !== this._runtime.GetExportType(), depth: this._runtime.Uses3DFeatures(), canSampleDepth: this._runtime.UsesAnyDepthSampling(), failIfMajorPerformanceCaveat: e, nearZ: this._zNear, farZ: this._zFar };\n      this._isLimitedToWebGL1 && (t.maxWebGLVersion = 1), this._webglRenderer = C33.New(C33.Gfx.WebGLRenderer, this._canvasLayers[0].canvas, t), await this._webglRenderer.InitState();\n    }\n    async _InitWebGPU() {\n      if (this._shaderData) {\n        const e = [];\n        for (const [t, s] of Object.entries(this._shaderData)) {\n          s.src = s.wgsl;\n          const i = C33.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource(this._webgpuRenderer.IsColorDataF16());\n          e.push(this._webgpuRenderer.CreateShaderProgram(Object.assign({ vertexSrc: i, name: t }, s)));\n        }\n        await Promise.all(e);\n      }\n    }\n    async _InitWebGL() {\n      if (this._shaderData) {\n        const e = [];\n        for (const [t, s] of Object.entries(this._shaderData)) {\n          let i;\n          if (s.glslWebGL2 && this._webglRenderer.GetWebGLVersionNumber() >= 2) s.src = s.glslWebGL2, i = C33.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2();\n          else {\n            if (!s.glsl) throw new Error(`shader '${t}' does not support WebGL 1`);\n            s.src = s.glsl, i = C33.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();\n          }\n          e.push(this._webglRenderer.CreateShaderProgram(Object.assign({ vertexSrc: i, name: t }, s)));\n        }\n        await Promise.all(e), this._webglRenderer.ResetLastProgram(), this._webglRenderer.SetTextureFillMode();\n      }\n      this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = C33.New(C33.Gfx.WebGLQueryResultBuffer, this._webglRenderer));\n    }\n    async _InitRenderer() {\n      this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();\n      const e = this.GetRenderer();\n      e.SetMipmapsEnabled(this._enableMipmaps), e.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);\n      for (const t of this._runtime._GetAllEffectLists()) {\n        for (const s of t.GetAllEffectTypes()) s._InitRenderer(e);\n        t._InitRenderer(e), t.UpdateActiveEffects();\n      }\n      this._iRenderer = new self.IRenderer(this._runtime, e);\n    }\n    Release() {\n      this._runtime = null, this._webglRenderer = null, this._canvasLayers.length = 0;\n    }\n    IsInWorker() {\n      return this._runtime.IsInWorker();\n    }\n    _OnWindowResize(e) {\n      const t = this._runtime;\n      if (t.IsExportToVideo()) return;\n      const s = e[\"devicePixelRatio\"];\n      this.IsInWorker() && (self.devicePixelRatio = s), t._SetDevicePixelRatio(s), this._isDocumentFullscreen = !!e[\"isFullscreen\"], this._cssDisplayMode = e[\"cssDisplayMode\"], this.SetSize(e[\"innerWidth\"], e[\"innerHeight\"]), t.UpdateRender();\n      const i = new C33.Event(\"window-resize\");\n      i.data = e, t.Dispatcher().dispatchEventAndWaitAsyncSequential(i);\n      const r = new C33.Event(\"resize\");\n      r.cssWidth = this.GetCssWidth(), r.cssHeight = this.GetCssHeight(), r.deviceWidth = this.GetDeviceWidth(), r.deviceHeight = this.GetDeviceHeight(), t.DispatchUserScriptEvent(r), this._runtime.GetCurrentLayout()?.BoundScrolling(), t.IsDebug() && (t.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && t.Render();\n    }\n    _OnFullscreenChange(e) {\n      this._isDocumentFullscreen = !!e[\"isFullscreen\"], this.SetSize(e[\"innerWidth\"], e[\"innerHeight\"], true), this._runtime.UpdateRender();\n    }\n    _OnFullscreenError(e) {\n      this._isDocumentFullscreen = !!e[\"isFullscreen\"], this.SetSize(e[\"innerWidth\"], e[\"innerHeight\"], true), this._runtime.UpdateRender();\n    }\n    SetSize(e, t, s = false) {\n      if (e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0) throw new Error(\"invalid size\");\n      if (this._windowInnerWidth === e && this._windowInnerHeight === t && !s) return;\n      this._windowInnerWidth = e, this._windowInnerHeight = t;\n      const i = this.GetCurrentFullscreenMode();\n      \"letterbox-scale\" === i ? this._CalculateLetterboxScale(e, t) : \"letterbox-integer-scale\" === i ? this._CalculateLetterboxIntegerScale(e, t) : \"off\" === i ? this._CalculateFixedSizeCanvas(e, t) : this._CalculateFullsizeCanvas(e, t), this._UpdateFullscreenScalingQuality(i);\n      for (const { canvas: e2 } of this._canvasLayers) e2.width = this._canvasDeviceWidth, e2.height = this._canvasDeviceHeight;\n      this._runtime.PostComponentMessageToDOM(\"canvas\", \"update-size\", { \"marginLeft\": this._canvasCssOffsetX, \"marginTop\": this._canvasCssOffsetY, \"styleWidth\": this._canvasCssWidth, \"styleHeight\": this._canvasCssHeight, \"displayScale\": this.GetDisplayScale() });\n      const r = this.GetRenderer();\n      r.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, true);\n      for (const e2 of this._availableAdditionalRenderTargets) r.DeleteRenderTarget(e2);\n      C33.clearArray(this._availableAdditionalRenderTargets), this.UpdateDefaultProjectionMatrix();\n      const a = this._runtime.GetLayoutManager();\n      a.SetAllLayerProjectionChanged(), a.SetAllLayerMVChanged();\n    }\n    UpdateDefaultProjectionMatrix() {\n      this.GetRenderer().CalculatePerspectiveMatrix(this._defaultProjectionMatrix, this.GetDrawWidth() / this.GetDrawHeight());\n    }\n    GetDefaultProjectionMatrix() {\n      return this._defaultProjectionMatrix;\n    }\n    _CalculateLetterboxScale(e, t) {\n      const s = this._runtime.GetDevicePixelRatio(), i = this._runtime.GetOriginalViewportWidth(), r = this._runtime.GetOriginalViewportHeight(), a = i / r;\n      if (e / t > a) {\n        const s2 = t * a;\n        this._canvasCssWidth = Math.round(s2), this._canvasCssHeight = t, this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = 0;\n      } else {\n        const s2 = e / a;\n        this._canvasCssWidth = e, this._canvasCssHeight = Math.round(s2), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2);\n      }\n      this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._runtime.SetViewportSize(i, r);\n    }\n    _CalculateLetterboxIntegerScale(e, t) {\n      const s = this._runtime.GetDevicePixelRatio();\n      1 !== s && (e += 1, t += 1);\n      const i = this._runtime.GetOriginalViewportWidth(), r = this._runtime.GetOriginalViewportHeight(), a = i / r;\n      let n;\n      if (e / t > a) {\n        n = t * a * s / i;\n      } else {\n        n = e / a * s / r;\n      }\n      n > 1 ? n = Math.floor(n) : n < 1 && (n = 1 / Math.ceil(1 / n)), this._canvasDeviceWidth = Math.round(i * n), this._canvasDeviceHeight = Math.round(r * n), this._canvasCssWidth = this._canvasDeviceWidth / s, this._canvasCssHeight = this._canvasDeviceHeight / s, this._canvasCssOffsetX = Math.max(Math.floor((e - this._canvasCssWidth) / 2), 0), this._canvasCssOffsetY = Math.max(Math.floor((t - this._canvasCssHeight) / 2), 0), this._runtime.SetViewportSize(i, r);\n    }\n    _CalculateFullsizeCanvas(e, t) {\n      const s = this._runtime.GetDevicePixelRatio();\n      this._canvasCssWidth = e, this._canvasCssHeight = t, this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0;\n      const i = this.GetDisplayScale();\n      this._runtime.SetViewportSize(this._canvasCssWidth / i, this._canvasCssHeight / i);\n    }\n    _CalculateFixedSizeCanvas(e, t) {\n      const s = this._runtime.GetDevicePixelRatio();\n      this._canvasCssWidth = this._runtime.GetViewportWidth(), this._canvasCssHeight = this._runtime.GetViewportHeight(), this._canvasDeviceWidth = Math.round(this._canvasCssWidth * s), this._canvasDeviceHeight = Math.round(this._canvasCssHeight * s), this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((e - this._canvasCssWidth) / 2), this._canvasCssOffsetY = Math.floor((t - this._canvasCssHeight) / 2)) : (this._canvasCssOffsetX = 0, this._canvasCssOffsetY = 0), this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight());\n    }\n    _UpdateFullscreenScalingQuality(e) {\n      if (\"high\" === this._wantFullscreenScalingQuality) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = \"high\";\n      else {\n        let t, s;\n        if (\"off\" === this.GetCurrentFullscreenMode() ? (t = this._runtime.GetViewportWidth(), s = this._runtime.GetViewportHeight()) : (t = this._runtime.GetOriginalViewportWidth(), s = this._runtime.GetOriginalViewportHeight()), this._canvasDeviceWidth < t || this._canvasDeviceHeight < s) this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = \"high\";\n        else if (this._drawWidth = t, this._drawHeight = s, this._fullscreenScalingQuality = \"low\", \"scale-inner\" === e) {\n          const e2 = t / s, i = this._windowInnerWidth / this._windowInnerHeight;\n          i < e2 ? this._drawWidth = this._drawHeight * i : i > e2 && (this._drawHeight = this._drawWidth / i);\n        } else if (\"scale-outer\" === e) {\n          const e2 = t / s, i = this._windowInnerWidth / this._windowInnerHeight;\n          i > e2 ? this._drawWidth = this._drawHeight * i : i < e2 && (this._drawHeight = this._drawWidth / i);\n        }\n      }\n    }\n    GetRuntime() {\n      return this._runtime;\n    }\n    GetMainCanvas() {\n      return this._canvasLayers[0].canvas;\n    }\n    GetEffectChainManager() {\n      return this._effectChainManager;\n    }\n    IsDocumentFullscreen() {\n      return this._isDocumentFullscreen;\n    }\n    GetCssDisplayMode() {\n      return this._cssDisplayMode;\n    }\n    SetFullscreenMode(e) {\n      if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error(\"invalid fullscreen mode\");\n      this._fullscreenMode = e;\n      const t = this._runtime.GetLayoutManager();\n      t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();\n    }\n    GetFullscreenMode() {\n      return this._fullscreenMode;\n    }\n    SetDocumentFullscreenMode(e) {\n      if (!VALID_FULLSCREEN_MODES.has(e)) throw new Error(\"invalid fullscreen mode\");\n      this._documentFullscreenMode = e;\n      const t = this._runtime.GetLayoutManager();\n      t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();\n    }\n    GetDocumentFullscreenMode() {\n      return this._documentFullscreenMode;\n    }\n    GetCurrentFullscreenMode() {\n      return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode();\n    }\n    SetFullscreenScalingQuality(e) {\n      if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(e)) throw new Error(\"invalid fullscreen scaling quality\");\n      this._wantFullscreenScalingQuality = e, this._runtime.GetLayoutManager().SetAllLayerProjectionChanged();\n    }\n    GetSetFullscreenScalingQuality() {\n      return this._wantFullscreenScalingQuality;\n    }\n    GetCurrentFullscreenScalingQuality() {\n      return this._fullscreenScalingQuality;\n    }\n    static _FullscreenModeNumberToString(e) {\n      switch (e) {\n        case 0:\n          return \"off\";\n        case 1:\n          return \"crop\";\n        case 2:\n          return \"scale-inner\";\n        case 3:\n          return \"scale-outer\";\n        case 4:\n          return \"letterbox-scale\";\n        case 5:\n          return \"letterbox-integer-scale\";\n        default:\n          throw new Error(\"invalid fullscreen mode\");\n      }\n    }\n    GetLastWidth() {\n      return this._windowInnerWidth;\n    }\n    GetLastHeight() {\n      return this._windowInnerHeight;\n    }\n    GetDrawWidth() {\n      return this._drawWidth;\n    }\n    GetDrawHeight() {\n      return this._drawHeight;\n    }\n    SetMipmapsEnabled(e) {\n      this._enableMipmaps = !!e;\n    }\n    _SetTextureAnisotropy(e) {\n      this._textureAnisotropy = e;\n    }\n    GetTextureAnisotropy() {\n      return this._textureAnisotropy;\n    }\n    IsRendererContextLost() {\n      return this.GetRenderer().IsContextLost();\n    }\n    _OnWebGLContextLost(e) {\n      console.log(\"[Construct] WebGL context lost\"), e.preventDefault(), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._webglRenderer.OnContextLost(), this._runtime._OnRendererContextLost();\n    }\n    _OnWebGPUDeviceLost() {\n      console.log(\"[Construct] WebGPU device lost\"), this._availableAdditionalRenderTargets = [], this._usedAdditionalRenderTargets.clear(), this._effectChainManager.OnContextLost(), this._runtime._OnRendererContextLost();\n    }\n    async _OnWebGLContextRestored(e) {\n      await this._webglRenderer.OnContextRestored(), await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log(\"[Construct] WebGL context restored\");\n    }\n    async _OnWebGPUDeviceRestored() {\n      await this._InitRenderer(), await this._runtime._OnRendererContextRestored(), console.log(\"[Construct] WebGPU device restored\");\n    }\n    GetWebGLRenderer() {\n      return this._webglRenderer;\n    }\n    GetWebGPURenderer() {\n      return this._webgpuRenderer;\n    }\n    GetRenderer() {\n      return this._webgpuRenderer || this._webglRenderer;\n    }\n    GetIRenderer() {\n      return this._iRenderer;\n    }\n    GetRendererString() {\n      let e = \"\";\n      return e = this._runtime.GetWebGPURenderer() ? \"webgpu\" : \"webgl\" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber(), this._runtime.GetRenderer().HasMajorPerformanceCaveat() && (e += \"-software\"), e;\n    }\n    GetRendererDetailString() {\n      return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();\n    }\n    GetRenderScale() {\n      return \"low\" === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale();\n    }\n    GetDisplayScale() {\n      const e = this.GetCurrentFullscreenMode();\n      if (\"off\" === e || \"crop\" === e) return 1;\n      const t = this._runtime.GetOriginalViewportWidth(), s = this._runtime.GetOriginalViewportHeight(), i = t / s, r = this._canvasDeviceWidth / this._canvasDeviceHeight;\n      return \"scale-inner\" !== e && r > i || \"scale-inner\" === e && r < i ? this._canvasCssHeight / s : this._canvasCssWidth / t;\n    }\n    GetEffectLayerScaleParam() {\n      return \"low\" === this.GetCurrentFullscreenScalingQuality() ? 1 : this.GetDisplayScale();\n    }\n    GetEffectDevicePixelRatioParam() {\n      return \"low\" === this.GetCurrentFullscreenScalingQuality() ? 1 : this._runtime.GetDevicePixelRatio();\n    }\n    SetDeviceTransformOffset(e, t) {\n      this._deviceTransformOffX = e, this._deviceTransformOffY = t;\n    }\n    SetDeviceTransform(e, t, s, i = true) {\n      t = t || this._drawWidth, s = s || this._drawHeight;\n      const r = t / 2 + this._deviceTransformOffX, a = s / 2 + this._deviceTransformOffY;\n      if (i) {\n        let i2 = this.GetDefaultProjectionMatrix();\n        t === this._drawWidth && s === this._drawHeight || (e.CalculatePerspectiveMatrix(tempProjection, t / s), i2 = tempProjection), e.SetProjectionMatrix(i2);\n      }\n      const n = e.CalculateLookAtModelView2(r, a, e.GetDefaultCameraZ(s), r, a, 0, s);\n      e.SetModelViewMatrix(n);\n    }\n    SetCssTransform(e, t = true) {\n      const s = this.GetCssWidth(), i = this.GetCssHeight(), r = s / 2, a = i / 2;\n      t && e.SetProjectionMatrix(this.GetDefaultProjectionMatrix());\n      const n = e.CalculateLookAtModelView2(r, a, e.GetDefaultCameraZ(i), r, a, 0, i);\n      e.SetModelViewMatrix(n);\n    }\n    GetDeviceWidth() {\n      return this._canvasDeviceWidth;\n    }\n    GetDeviceHeight() {\n      return this._canvasDeviceHeight;\n    }\n    GetCssWidth() {\n      return this._canvasCssWidth;\n    }\n    GetCssHeight() {\n      return this._canvasCssHeight;\n    }\n    GetCanvasClientX() {\n      return this._canvasCssOffsetX;\n    }\n    GetCanvasClientY() {\n      return this._canvasCssOffsetY;\n    }\n    GetHTMLLayerCount() {\n      return this._canvasLayers.length;\n    }\n    _CanUseImageBitmapRenderingContext() {\n      return \"undefined\" != typeof OffscreenCanvas && this.GetMainCanvas() instanceof OffscreenCanvas && (\"Chromium\" !== C33.Platform.BrowserEngine || C33.Platform.BrowserVersionNumber >= 124);\n    }\n    async SetHTMLLayerCount(e, t = false) {\n      if (e < 1) throw new Error(\"invalid HTML layer count\");\n      if (this._canvasLayers.length === e) return;\n      const s = { \"count\": e, \"layersDomState\": this._runtime.GetLayoutManager().GetMainRunningLayout()._GetRootLayers().filter((e2) => e2.IsHTMLElementsLayer()).map((e2) => e2._GetHTMLLayerDOMState()), \"immediate\": t, \"marginLeft\": this._canvasCssOffsetX, \"marginTop\": this._canvasCssOffsetY, \"styleWidth\": this._canvasCssWidth, \"styleHeight\": this._canvasCssHeight };\n      let i;\n      if (i = this.IsInWorker() ? await this._runtime.PostComponentMessageToDOMAsync(\"canvas\", \"set-html-layer-count\", s) : self[\"c3_runtimeInterface\"][\"_OnSetHTMLLayerCount\"](s), e < this._canvasLayers.length) this._canvasLayers.length = e;\n      else for (const e2 of i[\"addedCanvases\"]) {\n        e2.width = this._canvasDeviceWidth, e2.height = this._canvasDeviceHeight;\n        const t2 = this._CanUseImageBitmapRenderingContext() ? \"bitmaprenderer\" : \"2d\", s2 = e2.getContext(t2);\n        if (!s2) throw new Error(`failed to acquire '${t2}' canvas context`);\n        this._canvasLayers.push({ canvas: e2, ctx: s2 });\n      }\n      this._runtime.UpdateRender();\n    }\n    BlitMainCanvasToHTMLLayerCanvas(e) {\n      if (e >= this._canvasLayers.length) return;\n      const t = this.GetMainCanvas(), s = this._canvasLayers[e].ctx;\n      this._CanUseImageBitmapRenderingContext() ? s[\"transferFromImageBitmap\"](t[\"transferToImageBitmap\"]()) : (s.globalCompositeOperation = \"copy\", s.drawImage(t, 0, 0));\n    }\n    GetAdditionalRenderTarget(e) {\n      e.depth = this._runtime.Uses3DFeatures();\n      const t = this._availableAdditionalRenderTargets, s = t.findIndex((t2) => t2.IsCompatibleWithOptions(e));\n      let i;\n      return -1 !== s ? (i = t[s], t.splice(s, 1)) : i = this.GetRenderer().CreateRenderTarget(e), this._usedAdditionalRenderTargets.add(i), i;\n    }\n    ReleaseAdditionalRenderTarget(e) {\n      if (!this._usedAdditionalRenderTargets.has(e)) throw new Error(\"render target not in use\");\n      this._usedAdditionalRenderTargets.delete(e), this._availableAdditionalRenderTargets.push(e);\n    }\n    GetEffectCompositorRenderTarget() {\n      const e = { sampling: this._runtime.GetSampling() };\n      return \"low\" === this.GetCurrentFullscreenScalingQuality() && (e.width = this.GetDrawWidth(), e.height = this.GetDrawHeight()), this.GetAdditionalRenderTarget(e);\n    }\n    ReleaseEffectCompositorRenderTarget(e) {\n      this.ReleaseAdditionalRenderTarget(e);\n    }\n    *activeLayersGpuProfiles() {\n      for (const e of this._runtime.GetLayoutManager().runningLayouts()) for (const t of e.GetLayers()) {\n        const e2 = this._layersGpuProfile.get(t);\n        e2 && (yield e2);\n      }\n    }\n    GetLayerTimingsBuffer(e) {\n      if (!this.GetRenderer().SupportsGPUProfiling()) return null;\n      let t = this._layersGpuProfile.get(e);\n      return t || (t = { layer: e, name: e.GetName(), timingsBuffer: C33.New(C33.Gfx.WebGLQueryResultBuffer, this._webglRenderer), curUtilisation: 0, lastTotalUtilisation: 0, lastSelfUtilisation: 0 }, this._layersGpuProfile.set(e, t)), t.timingsBuffer;\n    }\n    _Update1sFrameRange() {\n      const e = this.GetRenderer();\n      if (e.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {\n        this._gpuTimeEndFrame = e.GetFrameNumber(), this._gpuCurUtilisation = NaN;\n        for (const e2 of this.activeLayersGpuProfiles()) e2.curUtilisation = NaN;\n      }\n    }\n    _UpdateTick() {\n      this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL(), this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU();\n    }\n    _UpdateTick_WebGL() {\n      if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), !isNaN(this._gpuCurUtilisation))) {\n        if (this._runtime.IsDebug()) {\n          for (const e of this.activeLayersGpuProfiles()) if (e.curUtilisation = e.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), isNaN(e.curUtilisation)) return;\n        }\n        if (this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1), this._runtime.IsDebug()) {\n          const e = /* @__PURE__ */ new Map();\n          for (const t2 of this.activeLayersGpuProfiles()) t2.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), t2.lastTotalUtilisation = Math.min(t2.curUtilisation, 1), e.set(t2.layer, t2.lastTotalUtilisation);\n          for (const t2 of this.activeLayersGpuProfiles()) {\n            const s2 = t2.layer, i = (e.get(s2) || 0) - s2.GetSubLayers().reduce((t3, s3) => t3 + (e.get(s3) || 0), 0);\n            t2.lastSelfUtilisation = C33.clamp(i, 0, 1);\n          }\n          const t = this._runtime.GetMainRunningLayout(), s = this._gpuLastUtilisation - t._GetRootLayers().reduce((t2, s2) => t2 + (e.get(s2) || 0), 0);\n          self.C3Debugger.UpdateGPUProfile(C33.clamp(s, 0, 1), this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()]);\n        }\n        this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;\n      }\n    }\n    GetGPUFrameTimingsBuffer() {\n      return this._gpuFrameTimingsBuffer;\n    }\n    _UpdateTick_WebGPU() {\n      if (0 === this._gpuTimeEndFrame) return;\n      for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {\n        const t2 = this._webgpuFrameTimings.get(e2);\n        if (t2 && !t2.HasResult()) return;\n      }\n      const e = this._runtime.GetMainRunningLayout(), t = C33.MakeFilledArray(e.GetLayerCount() + 1, 0);\n      let s = 0;\n      for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) {\n        const i = this._webgpuFrameTimings.get(e2);\n        if (!i) continue;\n        const r = i.GetResult();\n        let a = BigInt(0), n = BigInt(0);\n        const h = BigInt(0);\n        for (let e3 = 0, s2 = Math.min(t.length, r.length / 2); e3 < s2; ++e3) {\n          const s3 = r[2 * e3], i2 = r[2 * e3 + 1];\n          s3 !== h && (a === h || s3 < a) && (a = s3), i2 > n && (n = i2);\n          const o = Number(i2 - s3) / 1e9;\n          t[e3] += o;\n        }\n        s += Number(n - a) / 1e9;\n      }\n      if (this._gpuLastUtilisation = C33.clamp(s, 0, 1), this._runtime.IsDebug()) {\n        const s2 = e.GetLayers(), i = /* @__PURE__ */ new Map();\n        for (let e2 = 0, r2 = Math.min(s2.length, t.length - 1); e2 < r2; ++e2) {\n          const r3 = t[e2 + 1];\n          i.set(s2[e2], r3);\n        }\n        const r = [], a = /* @__PURE__ */ new Map();\n        for (const [e2, t2] of i) {\n          const s3 = [...e2.selfAndAllSubLayers()].reduce((e3, t3) => e3 + (i.get(t3) || 0), 0);\n          a.set(e2, s3), r.push({ name: e2.GetName(), lastSelfUtilisation: C33.clamp(t2, 0, 1), lastTotalUtilisation: C33.clamp(s3, 0, 1) });\n        }\n        const n = this._gpuLastUtilisation - e._GetRootLayers().reduce((e2, t2) => e2 + (a.get(t2) || 0), 0);\n        self.C3Debugger.UpdateGPUProfile(C33.clamp(n, 0, 1), this._gpuLastUtilisation, r);\n      }\n      for (let e2 = this._gpuTimeStartFrame; e2 < this._gpuTimeEndFrame; ++e2) this._webgpuFrameTimings.delete(e2);\n      this._gpuTimeStartFrame = this._gpuTimeEndFrame, this._gpuTimeEndFrame = 0;\n    }\n    _AddWebGPUFrameTiming(e) {\n      this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), e);\n    }\n    GetGPUUtilisation() {\n      return this._gpuLastUtilisation;\n    }\n    SnapshotCanvas(e, t, s, i, r, a) {\n      return this._snapshotFormat = e, this._snapshotQuality = t, this._snapshotArea.setWH(s, i, r, a), this._snapshotPromise || (this._snapshotPromise = new Promise((e2) => {\n        this._snapshotResolve = e2;\n      })), this._snapshotPromise;\n    }\n    _MaybeTakeSnapshot() {\n      if (!this._snapshotFormat) return;\n      let e = this.GetMainCanvas();\n      const t = this._snapshotArea, s = C33.clamp(Math.floor(t.getLeft()), 0, e.width), i = C33.clamp(Math.floor(t.getTop()), 0, e.height);\n      let r = t.width();\n      r = 0 === r ? e.width - s : C33.clamp(Math.floor(r), 0, e.width - s);\n      let a = t.height();\n      if (a = 0 === a ? e.height - i : C33.clamp(Math.floor(a), 0, e.height - i), (0 !== s || 0 !== i || r !== e.width || a !== e.height) && r > 0 && a > 0) {\n        const t2 = C33.CreateCanvas(r, a);\n        t2.getContext(\"2d\").drawImage(e, s, i, r, a, 0, 0, r, a), e = t2;\n      }\n      C33.CanvasToBlob(e, this._snapshotFormat, this._snapshotQuality).then((e2) => {\n        this._snapshotUrl && URL.revokeObjectURL(this._snapshotUrl), this._snapshotUrl = URL.createObjectURL(e2), this._snapshotPromise = null, this._snapshotResolve(e2);\n      }), this._snapshotFormat = \"\", this._snapshotQuality = 1;\n    }\n    GetCanvasSnapshotUrl() {\n      return this._snapshotUrl;\n    }\n    SetIsPastingToDrawingCanvas(e) {\n      e ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--;\n    }\n    IsPastingToDrawingCanvas() {\n      return this._isPastingToDrawingCanvas > 0;\n    }\n    InitLoadingScreen(e) {\n      const t = this.GetRenderer();\n      if (2 === e) this._percentText = C33.New(C33.Gfx.RendererText, this.GetRenderer()), this._percentText.SetFontName(\"Arial\"), this._percentText.SetFontSize(16), this._percentText.SetHorizontalAlignment(\"center\"), this._percentText.SetVerticalAlignment(\"center\"), this._percentText.SetSize(300, 200);\n      else if (0 === e) {\n        const e2 = this._runtime.GetLoadingLogoAsset();\n        e2 && e2.LoadStaticTexture(t).catch((e3) => console.warn(\"[C3 runtime] Failed to create texture for loading logo: \", e3));\n      } else 4 === e && (this._LoadSvgSplashImage(\"splash-images/splash-logo.svg\").then((e2) => {\n        \"done\" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.logo = e2;\n      }).catch((e2) => console.warn(\"Failed to load splash image: \", e2)), this._LoadBitmapSplashImage(\"splash-images/splash-poweredby-512.png\").then((e2) => {\n        \"done\" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.powered = e2;\n      }).catch((e2) => console.warn(\"Failed to load splash image: \", e2)), this._LoadBitmapSplashImage(\"splash-images/splash-website-512.png\").then((e2) => {\n        \"done\" === this._splashState ? t.DeleteTexture(e2) : this._splashTextures.website = e2;\n      }).catch((e2) => console.warn(\"Failed to load splash image: \", e2)));\n    }\n    async _LoadSvgSplashImage(e) {\n      e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();\n      const t = await C33.FetchBlob(e), s = await this._runtime.RasterSvgImage(t, 2048, 2048);\n      return await this.GetRenderer().CreateStaticTextureAsync(s, { mipMapQuality: \"high\" });\n    }\n    async _LoadBitmapSplashImage(e) {\n      e = new URL(e, this._runtime.GetRuntimeBaseURL()).toString();\n      const t = await C33.FetchBlob(e);\n      return await this.GetRenderer().CreateStaticTextureAsync(t, { mipMapQuality: \"high\" });\n    }\n    HideCordovaSplashScreen() {\n      this._runtime.PostComponentMessageToDOM(\"runtime\", \"hide-cordova-splash\");\n    }\n    StartLoadingScreen() {\n      this._loaderStartTime = Date.now(), this._runtime.Dispatcher().addEventListener(\"loadingprogress\", this._loadingprogress_handler), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());\n      3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen();\n    }\n    async EndLoadingScreen() {\n      const e = this.GetRenderer();\n      this._loadingProgress = 1;\n      const t = this._runtime.GetLoaderStyle();\n      4 === t && await this._splashDonePromise, this._splashDoneResolve = null, this._splashDonePromise = null, -1 !== this._rafId && (cancelAnimationFrame(this._rafId), this._rafId = -1), this._runtime.Dispatcher().removeEventListener(\"loadingprogress\", this._loadingprogress_handler), this._loadingprogress_handler = null, this._percentText && (this._percentText.Release(), this._percentText = null), this._runtime.ReleaseLoadingLogoAsset(), e.Start(), this._splashTextures.logo && (e.DeleteTexture(this._splashTextures.logo), this._splashTextures.logo = null), this._splashTextures.powered && (e.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered = null), this._splashTextures.website && (e.DeleteTexture(this._splashTextures.website), this._splashTextures.website = null), e.ClearRgba(0, 0, 0, 0), e.Finish(), this._splashState = \"done\", this._gpuTimeStartFrame = e.GetFrameNumber(), 3 === t && this.HideCordovaSplashScreen();\n    }\n    _DrawLoadingScreen() {\n      if (-1 === this._rafId) return;\n      const e = this.GetRenderer();\n      e.Start(), this._rafId = -1;\n      const t = this._runtime.GetAssetManager().HasHadErrorLoading(), s = this._runtime.GetLoaderStyle();\n      if (3 !== s && (this.SetCssTransform(e), e.ClearRgba(0, 0, 0, 0), e.ResetColor(), e.SetTextureFillMode(), e.SetTexture(null)), 0 === s) this._DrawProgressBarAndLogoLoadingScreen(t);\n      else if (1 === s) this._DrawProgressBarLoadingScreen(t, 120, 0);\n      else if (2 === s) this._DrawPercentTextLoadingScreen(t);\n      else if (3 === s) C33.noop();\n      else {\n        if (4 !== s) throw new Error(\"invalid loader style\");\n        this._DrawSplashLoadingScreen(t);\n      }\n      e.Finish(), this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());\n    }\n    _DrawPercentTextLoadingScreen(e) {\n      e ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(0.6, 0.6, 0.6), this._percentText.SetText(Math.round(100 * this._loadingProgress) + \"%\");\n      const t = this._canvasCssWidth / 2, s = this._canvasCssHeight / 2;\n      tempQuad.setRect(t - 150, s - 100, t + 150, s + 100);\n      const i = this.GetRenderer();\n      i.SetTexture(this._percentText.GetTexture()), i.Quad3(tempQuad, this._percentText.GetTexRect());\n    }\n    _DrawProgressBarLoadingScreen(e, t, s) {\n      const i = this.GetRenderer();\n      i.SetColorFillMode(), e ? i.SetColorRgba(1, 0, 0, 1) : i.SetColorRgba(0.118, 0.565, 1, 1);\n      const r = this._canvasCssWidth / 2, a = this._canvasCssHeight / 2, n = t / 2;\n      tempRect.setWH(r - n, a - 4 + s, Math.floor(t * this._loadingProgress), 8), i.Rect(tempRect), tempRect.setWH(r - n, a - 4 + s, t, 8), tempRect.offset(-0.5, -0.5), tempRect.inflate(0.5, 0.5), i.SetColorRgba(0, 0, 0, 1), i.LineRect2(tempRect), tempRect.inflate(1, 1), i.SetColorRgba(1, 1, 1, 1), i.LineRect2(tempRect);\n    }\n    _DrawProgressBarAndLogoLoadingScreen(e) {\n      const t = this.GetRenderer(), s = this._runtime.GetLoadingLogoAsset();\n      if (!s) return void this._DrawProgressBarLoadingScreen(e, 120, 0);\n      const i = s.GetTexture();\n      if (!i) return void this._DrawProgressBarLoadingScreen(e, 120, 0);\n      const r = i.GetWidth(), a = i.GetHeight(), n = this._canvasCssWidth / 2, h = this._canvasCssHeight / 2, o = r / 2, l = a / 2;\n      tempQuad.setRect(n - o, h - l, n + o, h + l), t.SetTexture(i), t.Quad(tempQuad), this._DrawProgressBarLoadingScreen(e, r, l + 16);\n    }\n    _DrawSplashLoadingScreen(e) {\n      const t = this.GetRenderer(), s = this._splashTextures.logo, i = this._splashTextures.powered, r = this._splashTextures.website, a = Date.now();\n      0 === this._splashFrameNumber && (this._loaderStartTime = a);\n      const n = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova(), h = n ? 0 : 200, o = n ? 0 : 3e3;\n      let l = 1;\n      \"fade-in\" === this._splashState ? l = Math.min((a - this._loaderStartTime) / 300, 1) : \"fade-out\" === this._splashState && (l = Math.max(1 - (a - this._splashFadeOutStartTime) / 300, 0)), t.SetColorFillMode(), t.SetColorRgba(0.231 * l, 0.251 * l, 0.271 * l, l), tempRect.set(0, 0, this._canvasCssWidth, this._canvasCssHeight), t.Rect(tempRect);\n      const c = Math.ceil(this._canvasCssWidth), _ = Math.ceil(this._canvasCssHeight);\n      let d, u;\n      this._canvasCssHeight > 256 ? (t.SetColorRgba(0.302 * l, 0.334 * l, 0.365 * l, l), d = c, u = Math.max(5e-3 * _, 2), tempRect.setWH(0, 0.8 * _ - u / 2, d, u), t.Rect(tempRect), e ? t.SetColorRgba(l, 0, 0, l) : t.SetColorRgba(0.161 * l, 0.953 * l, 0.816 * l, l), d = c * this._loadingProgress, tempRect.setWH(0.5 * c - d / 2, 0.8 * _ - u / 2, d, u), t.Rect(tempRect), t.SetColorRgba(l, l, l, l), t.SetTextureFillMode(), i && (d = 1.5 * C33.clamp(0.22 * _, 105, 0.6 * c), u = d / 8, tempRect.setWH(0.5 * c - d / 2, 0.2 * _ - u / 2, d, u), t.SetTexture(i), t.Rect(tempRect)), s && (d = Math.min(0.395 * _, 0.95 * c), u = d, tempRect.setWH(0.5 * c - d / 2, 0.485 * _ - u / 2, d, u), t.SetTexture(s), t.Rect(tempRect)), r && (d = 1.5 * C33.clamp(0.22 * _, 105, 0.6 * c), u = d / 8, tempRect.setWH(0.5 * c - d / 2, 0.868 * _ - u / 2, d, u), t.SetTexture(r), t.Rect(tempRect))) : (t.SetColorRgba(0.302 * l, 0.334 * l, 0.365 * l, l), d = c, u = Math.max(5e-3 * _, 2), tempRect.setWH(0, 0.85 * _ - u / 2, d, u), t.Rect(tempRect), e ? t.SetColorRgba(l, 0, 0, l) : t.SetColorRgba(0.161 * l, 0.953 * l, 0.816 * l, l), d = c * this._loadingProgress, tempRect.setWH(0.5 * c - d / 2, 0.85 * _ - u / 2, d, u), t.Rect(tempRect), t.SetColorRgba(l, l, l, l), t.SetTextureFillMode(), s && (d = 0.55 * _, u = d, tempRect.setWH(0.5 * c - d / 2, 0.45 * _ - u / 2, d, u), t.SetTexture(s), t.Rect(tempRect))), this._splashFrameNumber++, \"fade-in\" === this._splashState && a - this._loaderStartTime >= 300 && this._splashFrameNumber >= 2 && (this._splashState = \"wait\", this._splashFadeInFinishTime = a), \"wait\" === this._splashState && a - this._splashFadeInFinishTime >= o && this._loadingProgress >= 1 && (this._splashState = \"fade-out\", this._splashFadeOutStartTime = a), (\"fade-out\" === this._splashState && a - this._splashFadeOutStartTime >= 300 + h || n && this._loadingProgress >= 1 && a - this._loaderStartTime < 500) && this._splashDoneResolve();\n    }\n  };\n}\n{\n  const C33 = self.C3, C3Debugger = self.C3Debugger, assert = self.assert, ISDKBehaviorInstanceBase = self.ISDKBehaviorInstanceBase, DEFAULT_RUNTIME_OPTS = { \"messagePort\": null, \"runtimeBaseUrl\": \"\", \"headless\": false, \"hasDom\": true, \"isInWorker\": false, \"useAudio\": true, \"exportType\": \"\" };\n  let ife = true;\n  C33.Runtime = class extends C33.DefendedBase {\n    constructor(e) {\n      e = Object.assign({}, DEFAULT_RUNTIME_OPTS, e), super(), this._messagePort = e[\"messagePort\"], this._runtimeBaseUrl = e[\"runtimeBaseUrl\"], this._previewUrl = e[\"previewUrl\"], this._isHeadless = !!e[\"headless\"], this._hasDom = !!e[\"hasDom\"], this._isInWorker = !!e[\"isInWorker\"], ife = e[\"ife\"], this._useAudio = !!e[\"useAudio\"], this._exportType = e[\"exportType\"], this._isNWjs = e[\"isNWjs\"], this._isiOSCordova = !!e[\"isiOSCordova\"], this._isiOSWebView = !!e[\"isiOSWebView\"], this._isWindowsWebView2 = !!e[\"isWindowsWebView2\"], this._isAnyWebView2Wrapper = !!e[\"isAnyWebView2Wrapper\"], this._isFBInstantAvailable = !!e[\"isFBInstantAvailable\"], this._isDebug = !(\"preview\" !== this._exportType || !e[\"isDebug\"]), this._breakpointsEnabled = this._isDebug, this._isDebugging = this._isDebug, this._debuggingDisabled = 0, this._additionalLoadPromises = [], this._additionalCreatePromises = [], this._isUsingCreatePromises = false, this._projectName = \"\", this._projectVersion = \"\", this._projectUniqueId = \"\", this._appId = \"\", this._exportTimestamp = 0, this._originalViewportWidth = 0, this._originalViewportHeight = 0, this._devicePixelRatio = self.devicePixelRatio, this._parallaxXorigin = 0, this._parallaxYorigin = 0, this._viewportWidth = 0, this._viewportHeight = 0, this._loaderStyle = 0, this._usesLoaderLayout = false, this._isLoading = true, this._usesAnyBackgroundBlending = false, this._usesAnyCrossSampling = false, this._usesAnyDepthSampling = false, this._loadingLogoAsset = null, this._assetManager = C33.New(C33.AssetManager, this, e), this._layoutManager = C33.New(C33.LayoutManager, this), this._eventSheetManager = C33.New(C33.EventSheetManager, this), this._addonManager = C33.New(C33.AddonManager, this, e[\"wrapperComponentIds\"]), this._collisionEngine = C33.New(C33.CollisionEngine, this), this._timelineManager = C33.New(C33.TimelineManager, this), this._transitionManager = C33.New(C33.TransitionManager, this), this._templateManager = C33.New(C33.TemplateManager, this), this._flowchartManager = C33.New(C33.FlowchartManager, this), this._textIconManager = C33.New(C33.TextIconManager, { getIconSetMeta: (e2) => this._GetTextIconSetMeta(e2), getIconSetContent: (e2) => this._GetTextIconSetContent(e2) }), this._iconChangeHandlers = /* @__PURE__ */ new Map(), this._allObjectClasses = [], this._objectClassesByName = /* @__PURE__ */ new Map(), this._objectClassesBySid = /* @__PURE__ */ new Map(), this._familyCount = 0, this._allContainers = [], this._allEffectLists = /* @__PURE__ */ new Set(), this._currentLayoutStack = [], this._instancesPendingCreate = [], this._instancesPendingDestroy = /* @__PURE__ */ new Map(), this._hasPendingInstances = false, this._isFlushingPendingInstances = false, this._objectCount = 0, this._nextUid = 0, this._instancesByUid = /* @__PURE__ */ new Map(), this._instancesPendingRelease = /* @__PURE__ */ new Set(), this._instancesPendingReleaseAffectedObjectClasses = /* @__PURE__ */ new Set(), this._objectReferenceTable = [], this._jsPropNameTable = [], this._canvasManager = null, this._uses3dFeatures = false, this._framerateMode = \"vsync\", this._sampling = \"trilinear\", this._isPixelRoundingEnabled = false, this._needRender = true, this._pauseOnBlur = false, this._isPausedOnBlur = false, this._exportToVideo = null, this._tickCallbacks = { normal: (e2) => {\n        this._rafId = -1, this._ruafId = -1, this.Tick(e2);\n      }, tickOnly: (e2) => {\n        this._ruafId = -1, this.Tick(e2, false, \"skip-render\");\n      }, renderOnly: () => {\n        this._rafId = -1, this.Render();\n      } }, this._rafId = -1, this._ruafId = -1, this._tickCount = 0, this._tickCountNoSave = 0, this._hasStarted = false, this._isInTick = false, this._hasStartedTicking = false, this._isLayoutFirstTick = true, this._isAutoSuspendEnabled = true, this._isPageVisibilitySuspended = false, this._suspendCount = 0, this._scheduleTriggersThrottle = new C33.PromiseThrottle(1), this._randomNumberCallback = () => Math.random(), this._startTime = 0, this._lastTickTime = 0, this._dtRaw = 0, this._dt1 = 0, this._dt = 0, this._timeScale = 1, this._maxDt = 1 / 30, this._minDt = 0, this._gameTime = C33.New(C33.KahanSum), this._gameTimeRaw = C33.New(C33.KahanSum), this._wallTime = C33.New(C33.KahanSum), this._instanceTimes = /* @__PURE__ */ new Map(), this._fpsFrameCount = -1, this._fpsLastTime = 0, this._fps = 0, this._tpsTickCount = -1, this._tps = 0, this._mainThreadTimeCounter = 0, this._mainThreadTime = 0, this._isLoadingState = false, this._saveToSlotName = \"\", this._saveToJsonString = false, this._loadFromSlotName = \"\", this._loadFromJson = null, this._lastSaveJson = \"\", this._projectStorage = null, this._savegamesStorage = null, this._dispatcher = C33.New(C33.Event.Dispatcher), this._domEventHandlers = /* @__PURE__ */ new Map(), this._pendingResponsePromises = /* @__PURE__ */ new Map(), this._nextDomResponseId = 0, this._didRequestDeviceOrientationEvent = false, this._didRequestDeviceMotionEvent = false, this._isReadyToHandleEvents = false, this._waitingToHandleEvents = [], this._eventObjects = { \"pretick\": C33.New(C33.Event, \"pretick\", false), \"tick\": C33.New(C33.Event, \"tick\", false), \"tick2\": C33.New(C33.Event, \"tick2\", false), \"instancecreate\": C33.New(C33.Event, \"instancecreate\", false), \"instancedestroy\": C33.New(C33.Event, \"instancedestroy\", false), \"beforelayoutchange\": C33.New(C33.Event, \"beforelayoutchange\", false), \"layoutchange\": C33.New(C33.Event, \"layoutchange\", false) }, this._eventObjects[\"instancecreate\"].instance = null, this._eventObjects[\"instancedestroy\"].instance = null, this._userScriptDispatcher = C33.New(C33.Event.Dispatcher), this._userScriptEventObjects = null;\n      const t = (e2, t2) => C33.BehaviorInstance.SortByTickSequence(this, e2, t2);\n      this._behInstsToTick = C33.New(C33.RedBlackSet, t), this._behInstsToPostTick = C33.New(C33.RedBlackSet, t), this._behInstsToTick2 = C33.New(C33.RedBlackSet, t), this._jobScheduler = C33.New(C33.JobSchedulerRuntime, this, e[\"jobScheduler\"]), e[\"canvas\"] && (this._canvasManager = C33.New(C33.CanvasManager, this)), this._messagePort.onmessage = (e2) => this[\"_OnMessageFromDOM\"](e2.data), this.AddDOMComponentMessageHandler(\"runtime\", \"visibilitychange\", (e2) => this._OnVisibilityChange(e2)), this.AddDOMComponentMessageHandler(\"runtime\", \"wrapper-extension-message\", (e2) => this._OnWrapperExtensionMessage(e2)), this.AddDOMComponentMessageHandler(\"runtime\", \"get-remote-preview-status-info\", () => this._GetRemotePreviewStatusInfo()), this.AddDOMComponentMessageHandler(\"runtime\", \"js-invoke-function\", (e2) => this._InvokeFunctionFromJS(e2)), this.AddDOMComponentMessageHandler(\"runtime\", \"go-to-last-error-script\", self[\"goToLastErrorScript\"]), this.AddDOMComponentMessageHandler(\"runtime\", \"offline-audio-render-completed\", (e2) => this._OnOfflineAudioRenderCompleted(e2)), this._dispatcher.addEventListener(\"window-blur\", (e2) => this._OnWindowBlur(e2)), this._dispatcher.addEventListener(\"window-focus\", () => this._OnWindowFocus()), this._timelineManager.AddRuntimeListeners(), this._templateManager.AddRuntimeListeners(), this._iRuntime = null, this._interfaceMap = /* @__PURE__ */ new WeakMap(), this._commonScriptInterfaces = { keyboard: null, mouse: null, touch: null, timelineController: null }, this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), this._instancesNeedingAfterLoadArray = [];\n    }\n    static Create(e) {\n      return C33.New(C33.Runtime, e);\n    }\n    Release() {\n      C33.clearArray(this._allObjectClasses), this._objectClassesByName.clear(), this._objectClassesBySid.clear(), this._layoutManager.Release(), this._layoutManager = null, this._eventSheetManager.Release(), this._eventSheetManager = null, this._addonManager.Release(), this._addonManager = null, this._assetManager.Release(), this._assetManager = null, this._collisionEngine.Release(), this._collisionEngine = null, this._timelineManager.Release(), this._timelineManager = null, this._transitionManager.Release(), this._transitionManager = null, this._templateManager.Release(), this._templateManager = null, this._flowchartManager.Release(), this._flowchartManager = null, this._textIconManager.Release(), this._textIconManager = null, this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null), this._dispatcher.Release(), this._dispatcher = null, this._tickEvent = null;\n    }\n    \"_OnMessageFromDOM\"(e) {\n      const t = e[\"type\"];\n      if (\"event\" === t) this._OnEventFromDOM(e);\n      else {\n        if (\"result\" !== t) throw new Error(`unknown message '${t}'`);\n        this._OnResultFromDOM(e);\n      }\n    }\n    _OnEventFromDOM(e) {\n      if (!this._isReadyToHandleEvents) return void this._waitingToHandleEvents.push(e);\n      const t = e[\"component\"], s = e[\"handler\"], i = e[\"data\"], n = e[\"dispatchOpts\"], a = !(!n || !n[\"dispatchRuntimeEvent\"]), r = !(!n || !n[\"dispatchUserScriptEvent\"]), o = e[\"responseId\"];\n      if (\"runtime\" === t) {\n        if (a) {\n          const e2 = new C33.Event(s);\n          e2.data = i, this._dispatcher.dispatchEventAndWaitAsyncSequential(e2);\n        }\n        if (r) {\n          const e2 = new C33.Event(s, true);\n          for (const [t2, s2] of Object.entries(i)) e2[t2] = s2;\n          this.DispatchUserScriptEvent(e2);\n        }\n      }\n      const h = this._domEventHandlers.get(t);\n      if (!h) return void (a || r || console.warn(`[Runtime] No DOM event handlers for component '${t}'`));\n      const l = h.get(s);\n      if (!l) return void (a || r || console.warn(`[Runtime] No DOM handler '${s}' for component '${t}'`));\n      let c = null;\n      try {\n        c = l(i);\n      } catch (e2) {\n        return console.error(`Exception in '${t}' handler '${s}':`, e2), void (null !== o && this._PostResultToDOM(o, false, \"\" + e2));\n      }\n      null !== o && (c && c.then ? c.then((e2) => this._PostResultToDOM(o, true, e2)).catch((e2) => {\n        console.error(`Rejection from '${t}' handler '${s}':`, e2), this._PostResultToDOM(o, false, \"\" + e2);\n      }) : this._PostResultToDOM(o, true, c));\n    }\n    _PostResultToDOM(e, t, s) {\n      this._messagePort.postMessage({ \"type\": \"result\", \"responseId\": e, \"isOk\": t, \"result\": s });\n    }\n    _OnResultFromDOM(e) {\n      const t = e[\"responseId\"], s = e[\"isOk\"], i = e[\"result\"], n = this._pendingResponsePromises.get(t);\n      s ? n.resolve(i) : n.reject(i), this._pendingResponsePromises.delete(t);\n    }\n    AddDOMComponentMessageHandler(e, t, s) {\n      let i = this._domEventHandlers.get(e);\n      if (i || (i = /* @__PURE__ */ new Map(), this._domEventHandlers.set(e, i)), i.has(t)) throw new Error(`[Runtime] Component '${e}' already has handler '${t}'`);\n      i.set(t, s);\n    }\n    PostComponentMessageToDOM(e, t, s, i) {\n      this._messagePort.postMessage({ \"type\": \"event\", \"component\": e, \"handler\": t, \"data\": s, \"responseId\": null }, i);\n    }\n    PostComponentMessageToDOMAsync(e, t, s, i) {\n      const n = this._nextDomResponseId++, a = new Promise((e2, t2) => {\n        this._pendingResponsePromises.set(n, { resolve: e2, reject: t2 });\n      });\n      return this._messagePort.postMessage({ \"type\": \"event\", \"component\": e, \"handler\": t, \"data\": s, \"responseId\": n }, i), a;\n    }\n    SendWrapperExtensionMessage(e, t, s, i = -1) {\n      this.PostComponentMessageToDOM(\"runtime\", \"send-wrapper-extension-message\", { \"componentId\": e, \"messageId\": t, \"params\": s, \"asyncId\": i });\n    }\n    SendWrapperExtensionMessageAsync(e, t, s) {\n      const i = this._nextDomResponseId++, n = new Promise((e2, t2) => {\n        this._pendingResponsePromises.set(i, { resolve: e2, reject: t2 });\n      });\n      return this.SendWrapperExtensionMessage(e, t, s, i), n;\n    }\n    _OnWrapperExtensionMessage(e) {\n      if (-1 !== e[\"asyncId\"]) {\n        const t = e[\"asyncId\"];\n        this._pendingResponsePromises.get(t).resolve(e[\"params\"]), this._pendingResponsePromises.delete(t);\n      } else this._OnEventFromDOM({ \"component\": \"wrapper-extension:\" + e[\"componentId\"], \"handler\": e[\"messageId\"], \"data\": e[\"params\"], \"responseId\": null });\n    }\n    AddWrapperExtensionMessageHandler(e, t, s) {\n      this.AddDOMComponentMessageHandler(\"wrapper-extension:\" + e, t, s);\n    }\n    HasWrapperComponentId(e) {\n      return this._addonManager.HasWrapperComponentId(e);\n    }\n    PostToDebugger(e) {\n      if (!this.IsDebug()) throw new Error(\"not in debug mode\");\n      this.PostComponentMessageToDOM(\"runtime\", \"post-to-debugger\", e);\n    }\n    async Init(e) {\n      C33.CommonACES_SetRuntime(this), this.IsDebug() ? await C3Debugger.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);\n      const t = await this._assetManager.FetchJson(\"data.json\");\n      if (await this._LoadDataJson(t), await this._InitialiseCanvas(e), this.IsPreview() || console.info(\"%cMade with Construct, the game and animation creation tool. Visit: https://www.construct.net\", \"font-weight: bold\"), this.GetWebGLRenderer()) {\n        const e2 = this.GetWebGLRenderer();\n        console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? \"worker\" : \"DOM\"}, rendering with WebGL ${e2.GetWebGLVersionNumber()} [${e2.GetUnmaskedRenderer()}]`);\n      } else this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? \"worker\" : \"DOM\"}, rendering with WebGPU [${this.GetWebGPURenderer().GetAdapterInfoString()}]`);\n      this.GetRenderer().HasMajorPerformanceCaveat() && console.warn(\"[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.\"), this._isReadyToHandleEvents = true;\n      for (const e2 of this._waitingToHandleEvents) this._OnEventFromDOM(e2);\n      C33.clearArray(this._waitingToHandleEvents), this._canvasManager && this._canvasManager.StartLoadingScreen();\n      for (const t2 of e[\"runOnStartupFunctions\"]) this._additionalLoadPromises.push(this._RunOnStartupFunction(t2));\n      if (await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]), C33.clearArray(this._additionalLoadPromises), !this._assetManager.HasHadErrorLoading()) return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new C33.Event(\"beforeruntimestart\")), await this.Start(), this._messagePort.postMessage({ \"type\": \"runtime-ready\" }), this;\n      this._canvasManager && this._canvasManager.HideCordovaSplashScreen();\n    }\n    async _RunOnStartupFunction(e) {\n      try {\n        await e(this._iRuntime);\n      } catch (e2) {\n        console.error(\"[C3 runtime] Error in runOnStartup function: \", e2);\n      }\n    }\n    async _LoadDataJson(e) {\n      const t = e[\"project\"];\n      this._projectName = t[0], this._projectVersion = t[16], this._projectUniqueId = t[31], this._appId = t[38], this._exportTimestamp = t[36];\n      const s = t[39] || \"loading-logo.png\";\n      this._isPixelRoundingEnabled = !!t[9], this._originalViewportWidth = this._viewportWidth = t[10], this._originalViewportHeight = this._viewportHeight = t[11], this._collisionEngine._InitCollisionCellSize(this._originalViewportWidth, this._originalViewportHeight), this._parallaxXorigin = this._originalViewportWidth / 2, this._parallaxYorigin = this._originalViewportHeight / 2, this._framerateMode = t[37], this._uses3dFeatures = !!t[40], this._sampling = t[14], this._usesAnyBackgroundBlending = t[15], this._usesAnyCrossSampling = t[42], this._usesAnyDepthSampling = t[17], this._usesLoaderLayout = !!t[18], this._loaderStyle = t[19], this._nextUid = t[21], this._pauseOnBlur = t[22];\n      const i = this._assetManager;\n      if (i._SetFileStructure(t[45]), i._SetAudioFiles(t[7], t[25]), i._SetMediaSubfolder(t[8]), i._SetFontsSubfolder(t[32]), i._SetIconsSubfolder(t[28]), i._SetWebFonts(t[29]), 0 === this._loaderStyle) {\n        let e2 = \"\";\n        e2 = \"flat\" === i.GetFileStructure() ? i.GetIconsSubfolder() + s : s, e2 && (this._loadingLogoAsset = i.LoadImage({ url: e2 }));\n      }\n      this._canvasManager && (this._canvasManager.SetFullscreenMode(C33.CanvasManager._FullscreenModeNumberToString(t[12])), this._canvasManager.SetFullscreenScalingQuality(t[23] ? \"high\" : \"low\"), this._canvasManager.SetMipmapsEnabled(0 !== t[24]), this._canvasManager._SetGPUPowerPreference(t[34]), this._canvasManager._SetTextureAnisotropy(t[41]), this._canvasManager._SetWebGPUEnabled(t[13]), this._canvasManager._SetZAxisScale(t[30]), this._canvasManager._SetZDistances(t[46], t[47]), this._canvasManager._SetInitFieldOfView(t[26]), this._canvasManager._SetLimitedToWebGL1(t[48]), this._canvasManager._SetMultitexturingMode(t[50]));\n      const n = t[43];\n      n && await this._LoadExportToVideoData(n), this._InitScriptInterfaces(), this._addonManager.CreateSystemPlugin(), this._objectReferenceTable = self.C3_GetObjectRefTable();\n      const a = t[2];\n      for (const e2 of a[1]) this._addonManager.CreateBehavior(e2);\n      for (const e2 of a[0]) this._addonManager.CreatePlugin(e2);\n      this._objectReferenceTable = self.C3_GetObjectRefTable(), this._LoadJsPropNameTable(), this._addonManager._InitAddonScriptInterfaces();\n      for (const e2 of t[3]) {\n        const t2 = C33.ObjectClass.Create(this, this._allObjectClasses.length, e2);\n        this._allObjectClasses.push(t2), this._objectClassesByName.set(t2.GetName().toLowerCase(), t2), this._objectClassesBySid.set(t2.GetSID(), t2);\n      }\n      for (const e2 of t[4]) {\n        this._allObjectClasses[e2[0]]._LoadFamily(e2);\n      }\n      for (const e2 of t[27]) {\n        const t2 = e2.map((e3) => this._allObjectClasses[e3]);\n        this._allContainers.push(C33.New(C33.Container, this, t2));\n      }\n      this._InitObjectsScriptInterface();\n      for (const e2 of this._allObjectClasses) e2._OnAfterCreate();\n      for (const e2 of t[5]) this._layoutManager.Create(e2);\n      const r = t[1];\n      if (r) {\n        const e2 = this._layoutManager.GetLayoutByName(r);\n        e2 && this._layoutManager.SetFirstLayout(e2);\n      }\n      for (const e2 of t[35]) this._transitionManager.Create(e2);\n      for (const e2 of t[33]) this._timelineManager.Create(e2);\n      for (const e2 of t[44]) this._templateManager.Create(e2);\n      this._templateManager.HasTemplates() || (this._templateManager.Release(), this._templateManager = null);\n      for (const e2 of t[49]) this._flowchartManager.Create(e2);\n      this._flowchartManager.HasFlowcharts() || (this._flowchartManager.Release(), this._flowchartManager = null);\n      for (const e2 of t[6]) this._eventSheetManager.Create(e2);\n      this._eventSheetManager._PostInit(), this._InitGlobalVariableScriptInterface(), C33.clearArray(this._objectReferenceTable), this.FlushPendingInstances();\n      let o = \"any\";\n      const h = t[20];\n      1 === h ? o = \"portrait\" : 2 === h && (o = \"landscape\"), this.PostComponentMessageToDOM(\"runtime\", \"set-target-orientation\", { \"targetOrientation\": o });\n    }\n    async _LoadExportToVideoData(e) {\n      const t = e[\"format\"];\n      \"image-sequence\" === t ? this._exportToVideo = new self.C3ExportToImageSequence(this, e) : \"image-sequence-gif\" === t ? this._exportToVideo = new self.C3ExportToGIF(this, e) : \"webm\" === t ? this._exportToVideo = new self.C3ExportToWebMVideo(this, e) : \"mp4\" === t && (this._exportToVideo = new self.C3ExportToMP4Video(this, e)), this._framerateMode = \"unlimited-frame\", this._canvasManager.SetFullscreenMode(\"off\"), this._devicePixelRatio = 1, self.devicePixelRatio = 1, await this.PostComponentMessageToDOMAsync(\"runtime\", \"set-exporting-to-video\", { \"message\": this._exportToVideo.GetExportingMessageForPercent(0), \"duration\": this._exportToVideo.GetDuration() });\n    }\n    GetLoaderStyle() {\n      return this._loaderStyle;\n    }\n    IsExportToVideo() {\n      return null !== this._exportToVideo;\n    }\n    GetExportVideoDuration() {\n      return this._exportToVideo.GetDuration();\n    }\n    GetExportVideoFramerate() {\n      return this._exportToVideo.GetFramerate();\n    }\n    _InitExportToVideo() {\n      return this._exportToVideo.Init({ width: this._canvasManager.GetDeviceWidth(), height: this._canvasManager.GetDeviceHeight() });\n    }\n    _ExportToVideoAddFrame() {\n      const e = this._tickCount / this.GetExportVideoFramerate();\n      return this._exportToVideo.AddFrame(this._canvasManager.GetMainCanvas(), e);\n    }\n    _ExportToVideoAddKeyframe() {\n      this._exportToVideo && this._exportToVideo.AddKeyframe();\n    }\n    _OnOfflineAudioRenderCompleted(e) {\n      this._exportToVideo.OnOfflineAudioRenderCompleted(e);\n    }\n    _ExportToVideoFinish() {\n      return this._exportToVideo.Finish();\n    }\n    IsFBInstantAvailable() {\n      return this._isFBInstantAvailable;\n    }\n    IsLoading() {\n      return this._isLoading;\n    }\n    AddLoadPromise(e) {\n      this._additionalLoadPromises.push(e);\n    }\n    SetUsingCreatePromises(e) {\n      this._isUsingCreatePromises = !!e;\n    }\n    AddCreatePromise(e) {\n      this._isUsingCreatePromises && this._additionalCreatePromises.push(e);\n    }\n    GetCreatePromises() {\n      return this._additionalCreatePromises;\n    }\n    _GetNextFamilyIndex() {\n      return this._familyCount++;\n    }\n    GetFamilyCount() {\n      return this._familyCount;\n    }\n    _AddEffectList(e) {\n      this._allEffectLists.add(e);\n    }\n    _RemoveEffectList(e) {\n      this._allEffectLists.delete(e);\n    }\n    _GetAllEffectLists() {\n      return this._allEffectLists;\n    }\n    async _InitialiseCanvas(e) {\n      this._canvasManager && (await this._canvasManager.CreateCanvas(e), this._canvasManager.InitLoadingScreen(this._loaderStyle));\n    }\n    async Start() {\n      this._hasStarted = true, this._startTime = Date.now();\n      let e = null;\n      const t = new Promise((t2) => e = t2);\n      if (this._usesLoaderLayout) {\n        for (const e2 of this._allObjectClasses) e2.IsFamily() || e2.IsOnLoaderLayout() || !e2.IsWorldType() || e2.OnCreate();\n        (async () => {\n          await this._assetManager.WaitForAllToLoad(), await t, this._isLoading = false, this._OnLoadFinished();\n        })();\n      } else this._isLoading = false;\n      this._assetManager.SetInitialLoadFinished(), this.IsDebug() && C3Debugger.RuntimeInit(ife);\n      for (const e2 of this._layoutManager.GetAllLayouts()) e2._CreateGlobalNonWorlds();\n      this.IsExportToVideo() && await this._InitExportToVideo();\n      const s = this._layoutManager.GetFirstLayout();\n      await s._Load(null, this.GetRenderer()), await s._StartRunning(true), this._fpsLastTime = performance.now(), e(), this._usesLoaderLayout || this._OnLoadFinished();\n      (await this.PostComponentMessageToDOMAsync(\"runtime\", \"before-start-ticking\"))[\"isSuspended\"] && !this.IsExportToVideo() ? (this._suspendCount++, this._isPageVisibilitySuspended = true) : this.Tick();\n    }\n    _OnLoadFinished() {\n      this.Trigger(C33.Plugins.System.Cnds.OnLoadFinished, null, null), this.PostComponentMessageToDOM(\"runtime\", \"register-sw\");\n    }\n    GetObjectReference(e) {\n      e = Math.floor(e);\n      const t = this._objectReferenceTable;\n      if (e < 0 || e >= t.length) throw new Error(\"invalid object reference\");\n      return t[e];\n    }\n    _LoadJsPropNameTable() {\n      for (const e of self.C3_JsPropNameTable) {\n        const t = C33.first(Object.keys(e));\n        this._jsPropNameTable.push(t);\n      }\n    }\n    GetJsPropName(e) {\n      e = Math.floor(e);\n      const t = this._jsPropNameTable;\n      if (e < 0 || e >= t.length) throw new Error(\"invalid prop reference\");\n      return t[e];\n    }\n    HasDOM() {\n      return this._hasDom;\n    }\n    IsHeadless() {\n      return this._isHeadless;\n    }\n    IsInWorker() {\n      return this._isInWorker;\n    }\n    GetRuntimeBaseURL() {\n      return this._runtimeBaseUrl;\n    }\n    GetPreviewURL() {\n      return this._previewUrl;\n    }\n    GetEventSheetManager() {\n      return this._eventSheetManager;\n    }\n    GetEventStack() {\n      return this._eventSheetManager.GetEventStack();\n    }\n    GetCurrentEventStackFrame() {\n      return this._eventSheetManager.GetCurrentEventStackFrame();\n    }\n    GetCurrentEvent() {\n      return this._eventSheetManager.GetCurrentEvent();\n    }\n    GetCurrentCondition() {\n      return this._eventSheetManager.GetCurrentCondition();\n    }\n    IsCurrentConditionFirst() {\n      return 0 === this.GetCurrentEventStackFrame().GetConditionIndex();\n    }\n    GetCurrentAction() {\n      return this._eventSheetManager.GetCurrentAction();\n    }\n    GetAddonManager() {\n      return this._addonManager;\n    }\n    GetSystemPlugin() {\n      return this._addonManager.GetSystemPlugin();\n    }\n    GetObjectClassByIndex(e) {\n      if ((e = Math.floor(e)) < 0 || e >= this._allObjectClasses.length) throw new RangeError(\"invalid index\");\n      return this._allObjectClasses[e];\n    }\n    GetObjectClassByName(e) {\n      return this._objectClassesByName.get(e.toLowerCase()) || null;\n    }\n    GetObjectClassBySID(e) {\n      return this._objectClassesBySid.get(e) || null;\n    }\n    GetSingleGlobalObjectClassByCtor(e) {\n      const t = C33.AddonManager.GetPluginByConstructorFunction(e);\n      return t ? t.GetSingleGlobalObjectClass() : null;\n    }\n    GetAllObjectClasses() {\n      return this._allObjectClasses;\n    }\n    *allInstances() {\n      for (const e of this._allObjectClasses) e.IsFamily() || (yield* e.instances());\n    }\n    Dispatcher() {\n      return this._dispatcher;\n    }\n    UserScriptDispatcher() {\n      return this._userScriptDispatcher;\n    }\n    DispatchUserScriptEvent(e) {\n      e.runtime = this.GetIRuntime();\n      const t = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();\n      t && C3Debugger.StartMeasuringScriptTime(), this._userScriptDispatcher.dispatchEvent(e), t && C3Debugger.AddScriptTime();\n    }\n    DispatchUserScriptEventAsyncWait(e) {\n      return e.runtime = this.GetIRuntime(), this._userScriptDispatcher.dispatchEventAndWaitAsync(e);\n    }\n    GetOriginalViewportWidth() {\n      return this._originalViewportWidth;\n    }\n    GetOriginalViewportHeight() {\n      return this._originalViewportHeight;\n    }\n    SetOriginalViewportSize(e, t) {\n      if (this._originalViewportWidth === e && this._originalViewportHeight === t) return;\n      this._originalViewportWidth = e, this._originalViewportHeight = t;\n      const s = this.GetLayoutManager();\n      s.SetAllLayerProjectionChanged(), s.SetAllLayerMVChanged();\n    }\n    GetViewportWidth() {\n      return this._viewportWidth;\n    }\n    GetViewportHeight() {\n      return this._viewportHeight;\n    }\n    SetViewportSize(e, t) {\n      if (this._viewportWidth === e && this._viewportHeight === t) return;\n      this._viewportWidth = e, this._viewportHeight = t;\n      const s = this.GetLayoutManager();\n      s.SetAllLayerProjectionChanged(), s.SetAllLayerMVChanged();\n    }\n    _SetDevicePixelRatio(e) {\n      this.IsExportToVideo() || (this._devicePixelRatio = e);\n    }\n    GetDevicePixelRatio() {\n      return this._devicePixelRatio;\n    }\n    GetParallaxXOrigin() {\n      return this._parallaxXorigin;\n    }\n    GetParallaxYOrigin() {\n      return this._parallaxYorigin;\n    }\n    GetCanvasManager() {\n      return this._canvasManager;\n    }\n    GetDrawWidth() {\n      return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth;\n    }\n    GetDrawHeight() {\n      return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight;\n    }\n    GetRenderScale() {\n      return this._canvasManager ? this._canvasManager.GetRenderScale() : 1;\n    }\n    GetDisplayScale() {\n      return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1;\n    }\n    GetEffectLayerScaleParam() {\n      return this._canvasManager ? this._canvasManager.GetEffectLayerScaleParam() : 1;\n    }\n    GetEffectDevicePixelRatioParam() {\n      return this._canvasManager ? this._canvasManager.GetEffectDevicePixelRatioParam() : 1;\n    }\n    GetCanvasClientX() {\n      return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0;\n    }\n    GetCanvasClientY() {\n      return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0;\n    }\n    GetCanvasCssWidth() {\n      return this._canvasManager ? this._canvasManager.GetCssWidth() : 0;\n    }\n    GetCanvasCssHeight() {\n      return this._canvasManager ? this._canvasManager.GetCssHeight() : 0;\n    }\n    GetFullscreenMode() {\n      return this._canvasManager ? this._canvasManager.GetFullscreenMode() : \"off\";\n    }\n    GetAdditionalRenderTarget(e) {\n      return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(e) : null;\n    }\n    ReleaseAdditionalRenderTarget(e) {\n      this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(e);\n    }\n    UsesAnyBackgroundBlending() {\n      return this._usesAnyBackgroundBlending;\n    }\n    UsesAnyCrossSampling() {\n      return this._usesAnyCrossSampling;\n    }\n    UsesAnyDepthSampling() {\n      return this._usesAnyDepthSampling;\n    }\n    GetGPUUtilisation() {\n      return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN;\n    }\n    IsLinearSampling() {\n      return \"nearest\" !== this.GetSampling();\n    }\n    GetFramerateMode() {\n      return this._framerateMode;\n    }\n    _SetFramerateMode(e) {\n      this._framerateMode !== e && (this._framerateMode = e, -1 === this._rafId && -1 === this._ruafId || (this._CancelAnimationFrame(), this._RequestAnimationFrame()));\n    }\n    GetSampling() {\n      return this._sampling;\n    }\n    UsesLoaderLayout() {\n      return this._usesLoaderLayout;\n    }\n    GetLoadingLogoAsset() {\n      return this._loadingLogoAsset;\n    }\n    ReleaseLoadingLogoAsset() {\n      this._loadingLogoAsset && (this._loadingLogoAsset.ReleaseTexture(), this._loadingLogoAsset.Release(), this._loadingLogoAsset = null);\n    }\n    GetLayoutManager() {\n      return this._layoutManager;\n    }\n    GetMainRunningLayout() {\n      return this._layoutManager.GetMainRunningLayout();\n    }\n    GetTimelineManager() {\n      return this._timelineManager;\n    }\n    GetTransitionManager() {\n      return this._transitionManager;\n    }\n    GetTemplateManager() {\n      return this._templateManager;\n    }\n    GetFlowchartManager() {\n      return this._flowchartManager;\n    }\n    GetAssetManager() {\n      return this._assetManager;\n    }\n    LoadImage(e) {\n      return this._assetManager.LoadImage(e);\n    }\n    CreateInstance(e, t, s, i, n, a) {\n      if (a && this._templateManager) {\n        if (e instanceof C33.ObjectClass && e.IsFamily()) {\n          const r2 = e.GetFamilyMembers(), o = Math.floor(this.Random() * r2.length);\n          return this.CreateInstance(r2[o], t, s, i, n, a);\n        }\n        const r = this._templateManager.GetTemplateData(e, a);\n        if (r) {\n          const e2 = this.CreateInstanceFromData(r, t, false, s, i, false, n, void 0, n);\n          return this._templateManager.MapInstanceToTemplateName(e2, a), e2;\n        }\n      }\n      return this.CreateInstanceFromData(e, t, false, s, i, false, n, void 0, n);\n    }\n    CreateInstanceFromData(e, t, s, i, n, a, r, o, h) {\n      let l = null, c = null;\n      if (e instanceof C33.ObjectClass) {\n        if (c = e, c.IsFamily()) {\n          const e2 = c.GetFamilyMembers();\n          c = e2[Math.floor(this.Random() * e2.length)];\n        }\n        l = c.GetDefaultInstanceData();\n      } else l = e, c = this.GetObjectClassByIndex(l[1]);\n      const d = c.GetPlugin().IsWorldType();\n      if (this._isLoading && d && !c.IsOnLoaderLayout()) return null;\n      const _ = t;\n      let u;\n      d || (t = null), u = s && !a && l && !this._instancesByUid.has(l[2]) ? l[2] : this._nextUid++;\n      const g = l ? l[0] : null, m = C33.New(C33.Instance, { runtime: this, objectType: c, layer: t, worldData: g, instVarData: l ? l[3] : null, uid: u, tags: l ? l[6] : null });\n      this._instancesByUid.set(u, m);\n      let p = null;\n      if (d && (p = m.GetWorldInfo(), void 0 !== i && void 0 !== n && (p.SetX(i), p.SetY(n)), c._SetAnyCollisionCellChanged(true)), t && (h || t._AddInstance(m, true), t.GetLayout().MaybeLoadTexturesFor(c)), this._objectCount++, c.IsInContainer() && !s && !a) {\n        const e2 = /* @__PURE__ */ new Set();\n        for (const t2 of c.GetContainer().objectTypes()) {\n          if (t2 === c) continue;\n          const s2 = this._MaybeGetChildInstanceForObjectTypeData(t2, p, e2);\n          if (s2) {\n            const e3 = this.CreateInstanceFromData(s2, _, false, p ? p.GetX() : i, p ? p.GetY() : n, true, false, void 0, h);\n            m._AddSibling(e3);\n          } else {\n            const e3 = this.CreateInstanceFromData(t2, _, false, p ? p.GetX() : i, p ? p.GetY() : n, true, false, void 0, h);\n            m._AddSibling(e3);\n          }\n        }\n        for (const e3 of m.siblings()) {\n          e3._AddSibling(m);\n          for (const t2 of m.siblings()) e3 !== t2 && e3._AddSibling(t2);\n        }\n      }\n      if (d && !s && r && this._CreateChildInstancesFromData(m, g, p, t, i, n, h), c.IsInContainer() && !s && !a && r) for (const e2 of m.siblings()) {\n        const s2 = e2.GetWorldInfo();\n        if (!s2) continue;\n        const i2 = e2.GetPlugin(), n2 = e2.GetObjectClass().GetDefaultInstanceData()[0];\n        i2.IsWorldType() ? this._CreateChildInstancesFromData(e2, n2, s2, t, s2.GetX(), s2.GetY(), h) : this._CreateChildInstancesFromData(e2, n2, s2, t, void 0, void 0, h);\n      }\n      if (!a && r) {\n        void 0 === i && (i = g[0]), void 0 === n && (n = g[1]);\n        const e2 = p.GetTopParent(), t2 = i - p.GetX() + e2.GetX(), s2 = n - p.GetY() + e2.GetY();\n        e2.SetXY(t2, s2);\n      }\n      c._SetIIDsStale();\n      const f = l ? C33.cloneArray(l[5]) : null, C = l ? l[4].map((e2) => C33.cloneArray(e2)) : null, S = d && g && g[13];\n      if (S && m._SetHasTilemap(), m._CreateSdkInstance(f, C), S) {\n        const e2 = g[13];\n        m.GetSdkInstance().LoadTilemapData(e2[2], e2[0], e2[1]);\n      }\n      this._instancesPendingCreate.push(m), this._hasPendingInstances = true, this.IsDebug() && C3Debugger.InstanceCreated(m);\n      const I = this._eventObjects[\"instancecreate\"];\n      return I.instance = m, this._dispatcher.dispatchEvent(I), m;\n    }\n    _GetInstanceData(e) {\n      const t = e[0], s = e[1], i = e[2], n = e[6];\n      if (n) return n;\n      return this._layoutManager.GetLayoutBySID(t).GetLayer(s).GetInitialInstanceData(i);\n    }\n    _MaybeGetChildInstanceForObjectTypeData(e, t, s) {\n      const i = t?.GetSceneGraphChildrenExportData() ?? [];\n      for (const t2 of i) {\n        const i2 = this._GetInstanceData(t2), n = !!t2[4], a = this.GetObjectClassByIndex(i2[1]);\n        if (!s.has(i2) && (e === a && n)) return s.add(i2), i2;\n      }\n    }\n    _CreateChildInstancesFromData(e, t, s, i, n, a, r) {\n      const o = s.GetSceneGraphZIndexExportData(), h = s.GetSceneGraphChildrenExportData();\n      if (e.GetWorldInfo().SetSceneGraphZIndex(o), !h) return;\n      void 0 === n && (n = t[0]), void 0 === a && (a = t[1]);\n      const l = /* @__PURE__ */ new Set(), c = t[0], d = t[1];\n      for (const t2 of h) {\n        const s2 = t2[0], o2 = t2[1], h2 = t2[2], _ = t2[3], u = !!t2[4], g = t2[5], m = t2[6];\n        let p;\n        if (m) p = m;\n        else {\n          p = this._layoutManager.GetLayoutBySID(s2).GetLayer(o2).GetInitialInstanceData(h2);\n        }\n        const f = this.GetObjectClassByIndex(p[1]), C = e.HasSibling(f), S = l.has(f);\n        if (C && !S && u) {\n          const t3 = e.GetSibling(f);\n          t3.GetWorldInfo().Init(p[0]);\n          const s3 = n + p[0][0] - c, i2 = a + p[0][1] - d;\n          t3.GetWorldInfo().SetXY(s3, i2), t3.GetWorldInfo().SetSceneGraphZIndex(g), e.AddChild(t3, { transformX: !!(1 & _), transformY: !!(_ >> 1 & 1), transformWidth: !!(_ >> 2 & 1), transformHeight: !!(_ >> 3 & 1), transformAngle: !!(_ >> 4 & 1), destroyWithParent: !!(_ >> 5 & 1), transformZElevation: !!(_ >> 6 & 1), transformOpacity: !!(_ >> 7 & 1), transformVisibility: !!(_ >> 8 & 1) }), l.add(f);\n        } else {\n          const t3 = n + p[0][0] - c, s3 = a + p[0][1] - d, o3 = this.CreateInstanceFromData(p, i, false, t3, s3, false, true, e, r);\n          o3.GetWorldInfo().SetSceneGraphZIndex(g), e.AddChild(o3, { transformX: !!(1 & _), transformY: !!(_ >> 1 & 1), transformWidth: !!(_ >> 2 & 1), transformHeight: !!(_ >> 3 & 1), transformAngle: !!(_ >> 4 & 1), destroyWithParent: !!(_ >> 5 & 1), transformZElevation: !!(_ >> 6 & 1), transformOpacity: !!(_ >> 7 & 1), transformVisibility: !!(_ >> 8 & 1) });\n        }\n      }\n    }\n    DestroyInstance(e) {\n      if (this._instancesPendingRelease.has(e)) return;\n      const t = e.GetObjectClass();\n      let s = this._instancesPendingDestroy.get(t);\n      if (s) {\n        if (s.has(e)) return;\n        s.add(e);\n      } else s = /* @__PURE__ */ new Set(), s.add(e), this._instancesPendingDestroy.set(t, s);\n      if (this.IsDebug() && C3Debugger.InstanceDestroyed(e), e._MarkDestroyed(), this._hasPendingInstances = true, e.IsInContainer()) for (const t2 of e.siblings()) this.DestroyInstance(t2);\n      for (const t2 of e.children()) t2.GetDestroyWithParent() && this.DestroyInstance(t2);\n      if (!this._layoutManager.IsEndingLayout() && !this._isLoadingState) {\n        const t2 = this.GetEventSheetManager();\n        t2.BlockFlushingInstances(true), e._TriggerOnDestroyed(), t2.BlockFlushingInstances(false);\n      }\n      e._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout());\n    }\n    FlushPendingInstances() {\n      this._hasPendingInstances && (this._isFlushingPendingInstances = true, this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), this._isFlushingPendingInstances = false, this._hasPendingInstances = false, this.UpdateRender());\n    }\n    _FlushInstancesPendingCreate() {\n      for (const e of this._instancesPendingCreate) {\n        const t = e.GetObjectClass();\n        t._AddInstance(e);\n        for (const s of t.GetFamilies()) s._AddInstance(e), s._SetIIDsStale();\n      }\n      C33.clearArray(this._instancesPendingCreate);\n    }\n    _FlushInstancesPendingDestroy() {\n      this._dispatcher.SetDelayRemoveEventsEnabled(true);\n      for (const [e, t] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(e, t), t.clear();\n      this._instancesPendingDestroy.clear(), this._dispatcher.SetDelayRemoveEventsEnabled(false);\n    }\n    _FlushInstancesPendingDestroyForObjectClass(e, t) {\n      for (const e2 of t) {\n        const t2 = this._eventObjects[\"instancedestroy\"];\n        t2.instance = e2, this._dispatcher.dispatchEvent(t2), this._instancesByUid.delete(e2.GetUID()), this._instanceTimes.delete(e2);\n        const s = e2.GetWorldInfo();\n        s && (s._RemoveFromCollisionCells(), s._RemoveFromRenderCells(), s._MarkDestroyed()), this._instancesPendingRelease.add(e2), this._objectCount--;\n      }\n      C33.arrayRemoveAllInSet(e.GetInstances(), t), e._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(e);\n      for (const s of e.GetFamilies()) C33.arrayRemoveAllInSet(s.GetInstances(), t), s._SetIIDsStale(), this._instancesPendingReleaseAffectedObjectClasses.add(s);\n      if (e.GetPlugin().IsWorldType()) {\n        const e2 = new Set([...t].map((e3) => e3.GetWorldInfo().GetLayer()));\n        for (const s of e2) s._RemoveAllInstancesInSet(t);\n      }\n    }\n    _GetInstancesPendingCreate() {\n      return this._instancesPendingCreate;\n    }\n    *instancesPendingCreateForObjectClass(e) {\n      for (const t of this._GetInstancesPendingCreate()) e.IsFamily() ? t.GetObjectClass().BelongsToFamily(e) && (yield t) : t.GetObjectClass() === e && (yield t);\n    }\n    _GetNewUID() {\n      return this._nextUid++;\n    }\n    _MapInstanceByUID(e, t) {\n      this._instancesByUid.set(e, t);\n    }\n    _SetAutoSuspendEnabled(e) {\n      e = !!e, this._isAutoSuspendEnabled !== e && (this._isAutoSuspendEnabled = !!e, this._isAutoSuspendEnabled && this._isPageVisibilitySuspended && (this.SetSuspended(false), this._isPageVisibilitySuspended = false));\n    }\n    _IsAutoSuspendEnabled() {\n      return this._isAutoSuspendEnabled;\n    }\n    _OnRendererContextLost() {\n      this._dispatcher.dispatchEvent(C33.New(C33.Event, \"renderercontextlost\")), this.SetSuspended(true);\n      for (const e2 of this._allObjectClasses) !e2.IsFamily() && e2.HasLoadedTextures() && e2.ReleaseTextures();\n      const e = this.GetMainRunningLayout();\n      e && e._OnRendererContextLost(), C33.ImageInfo.OnRendererContextLost(), C33.ImageAsset.OnRendererContextLost();\n    }\n    async _OnRendererContextRestored() {\n      await this.GetMainRunningLayout()._Load(null, this.GetRenderer()), this._dispatcher.dispatchEvent(C33.New(C33.Event, \"renderercontextrestored\")), this.SetSuspended(false), this.UpdateRender();\n    }\n    _OnVisibilityChange(e) {\n      if (!this._isAutoSuspendEnabled) return;\n      const t = e[\"hidden\"];\n      this.SetSuspended(t), this._isPageVisibilitySuspended = t, t || this.UpdateRender();\n    }\n    _OnWindowBlur(e) {\n      this.IsPreview() && this._pauseOnBlur && !C33.Platform.IsMobile && (e.data[\"parentHasFocus\"] || (this.SetSuspended(true), this._isPausedOnBlur = true));\n    }\n    _OnWindowFocus() {\n      this._isPausedOnBlur && (this.SetSuspended(false), this._isPausedOnBlur = false);\n    }\n    _RequestAnimationFrame() {\n      const e = this._tickCallbacks;\n      \"vsync\" === this._framerateMode ? -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.normal)) : \"unlimited-tick\" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = C33.RequestUnlimitedAnimationFrame(e.tickOnly)), -1 === this._rafId && (this._rafId = self.requestAnimationFrame(e.renderOnly))) : -1 === this._ruafId && (this._ruafId = C33.RequestUnlimitedAnimationFrame(e.normal));\n    }\n    _CancelAnimationFrame() {\n      -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId), this._rafId = -1), -1 !== this._ruafId && (C33.CancelUnlimitedAnimationFrame(this._ruafId), this._ruafId = -1);\n    }\n    IsSuspended() {\n      return this._suspendCount > 0;\n    }\n    SetSuspended(e) {\n      if (this.IsExportToVideo()) return;\n      const t = this.IsSuspended();\n      this._suspendCount += e ? 1 : -1, this._suspendCount < 0 && (this._suspendCount = 0);\n      const s = this.IsSuspended();\n      if (!t && s) console.log(\"[Construct] Suspending\"), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(C33.New(C33.Event, \"suspend\")), this.DispatchUserScriptEvent(C33.New(C33.Event, \"suspend\")), this.Trigger(C33.Plugins.System.Cnds.OnSuspend, null, null);\n      else if (t && !s) {\n        console.log(\"[Construct] Resuming\");\n        const e2 = performance.now();\n        this._lastTickTime = e2, this._fpsLastTime = e2, this._fpsFrameCount = 0, this._fps = 0, this._tpsTickCount = 0, this._tps = 0, this._mainThreadTime = 0, this._mainThreadTimeCounter = 0, this._dispatcher.dispatchEvent(C33.New(C33.Event, \"resume\")), this.DispatchUserScriptEvent(C33.New(C33.Event, \"resume\")), this.Trigger(C33.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(e2);\n      }\n    }\n    _AddBehInstToTick(e) {\n      this._behInstsToTick.Add(e);\n    }\n    _AddBehInstToPostTick(e) {\n      this._behInstsToPostTick.Add(e);\n    }\n    _AddBehInstToTick2(e) {\n      this._behInstsToTick2.Add(e);\n    }\n    _RemoveBehInstToTick(e) {\n      this._behInstsToTick.Remove(e);\n    }\n    _RemoveBehInstToPostTick(e) {\n      this._behInstsToPostTick.Remove(e);\n    }\n    _RemoveBehInstToTick2(e) {\n      this._behInstsToTick2.Remove(e);\n    }\n    _CallBehaviorTickMethod(e, t) {\n      const s = t ? performance.now() : 0;\n      let i;\n      return e instanceof ISDKBehaviorInstanceBase ? (i = e._tick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.Tick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;\n    }\n    _BehaviorTick() {\n      const e = this.IsDebug();\n      this._behInstsToTick.SetQueueingEnabled(true);\n      for (const t of this._behInstsToTick) this._CallBehaviorTickMethod(t, e);\n      this._behInstsToTick.SetQueueingEnabled(false);\n    }\n    _CallBehaviorPostTickMethod(e, t) {\n      const s = t ? performance.now() : 0;\n      let i;\n      return e instanceof ISDKBehaviorInstanceBase ? (i = e._postTick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.PostTick(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;\n    }\n    _BehaviorPostTick() {\n      const e = this.IsDebug();\n      this._behInstsToPostTick.SetQueueingEnabled(true);\n      for (const t of this._behInstsToPostTick) this._CallBehaviorPostTickMethod(t, e);\n      this._behInstsToPostTick.SetQueueingEnabled(false);\n    }\n    _CallBehaviorTick2Method(e, t) {\n      const s = t ? performance.now() : 0;\n      let i;\n      return e instanceof ISDKBehaviorInstanceBase ? (i = e._tick2(), t && C3Debugger.AddIndividualBehaviorTickTime(e.behavior, performance.now() - s)) : (i = e.Tick2(), t && C3Debugger.AddIndividualBehaviorTickTime(e.GetBehavior(), performance.now() - s)), i;\n    }\n    _BehaviorTick2() {\n      const e = this.IsDebug();\n      this._behInstsToTick2.SetQueueingEnabled(true);\n      for (const t of this._behInstsToTick2) this._CallBehaviorTick2Method(t, e);\n      this._behInstsToTick2.SetQueueingEnabled(false);\n    }\n    *_DebugBehaviorTick() {\n      const e = this.IsDebug();\n      this._behInstsToTick.SetQueueingEnabled(true);\n      for (const t of this._behInstsToTick) {\n        const s = this._CallBehaviorTickMethod(t, e);\n        C33.IsIterator(s) && (yield* s);\n      }\n      this._behInstsToTick.SetQueueingEnabled(false);\n    }\n    *_DebugBehaviorPostTick() {\n      const e = this.IsDebug();\n      this._behInstsToPostTick.SetQueueingEnabled(true);\n      for (const t of this._behInstsToPostTick) {\n        const s = this._CallBehaviorPostTickMethod(t, e);\n        C33.IsIterator(s) && (yield* s);\n      }\n      this._behInstsToPostTick.SetQueueingEnabled(false);\n    }\n    *_DebugBehaviorTick2() {\n      const e = this.IsDebug();\n      this._behInstsToTick2.SetQueueingEnabled(true);\n      for (const t of this._behInstsToTick2) {\n        const s = this._CallBehaviorTick2Method(t, e);\n        C33.IsIterator(s) && (yield* s);\n      }\n      this._behInstsToTick2.SetQueueingEnabled(false);\n    }\n    async Tick(e, t, s) {\n      this._hasStartedTicking = true;\n      const i = \"background-wake\" === s, n = \"background-wake\" !== s && \"skip-render\" !== s, a = this.GetLayoutManager(), r = this.GetCanvasManager();\n      if (!this._hasStarted || this.IsSuspended() && !t && !i) return;\n      const o = performance.now();\n      this._isInTick = true, this._MeasureDt(e || 0), this._tpsTickCount++, this._ReleasePendingInstances();\n      const h = this.Step_BeforePreTick();\n      this.IsDebugging() && await h;\n      const l = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects[\"pretick\"]);\n      l instanceof Promise && await l, this.DispatchUserScriptEvent(this._userScriptEventObjects[\"pretick\"]);\n      const c = this.Step_AfterPreTick();\n      this.IsDebugging() && await c, this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad(), a.IsPendingChangeMainLayout() && await this._MaybeChangeLayout();\n      const d = this.Step_RunEventsEtc();\n      this.IsDebugging() && await d;\n      const _ = a.GetMainRunningLayout(), u = _._GetPendingSetHTMLLayerCount();\n      let g = false;\n      if (-1 !== u && (_._ResetPendingHTMLLayerCount(), r.GetHTMLLayerCount() !== u)) {\n        const e2 = this.GetCanvasManager().SetHTMLLayerCount(u);\n        this.IsInWorker() && (g = true, await e2);\n      }\n      this.PostComponentMessageToDOM(\"canvas\", \"update-html-layer-dom-state\", { \"layersDomState\": _._GetRootLayers().filter((e2) => e2.IsHTMLElementsLayer()).map((e2) => e2._GetHTMLLayerDOMState()) }), n && this.Render(), g && this.PostComponentMessageToDOM(\"canvas\", \"cleanup-html-layers\"), this.IsExportToVideo() && (await this._ExportToVideoAddFrame(), this.GetGameTime() >= this.GetExportVideoDuration()) ? this._ExportToVideoFinish() : (this.IsSuspended() || i || this._RequestAnimationFrame(), this._tickCount++, this._tickCountNoSave++, this._isInTick = false, this._mainThreadTimeCounter += performance.now() - o);\n    }\n    async Step_BeforePreTick() {\n      const e = this._eventSheetManager, t = this.IsDebug();\n      this.FlushPendingInstances(), e.BlockFlushingInstances(true), this.PushCurrentLayout(this.GetMainRunningLayout()), t && C3Debugger.StartMeasuringTime(), this.IsDebugging() ? await e.DebugRunScheduledWaits() : e.RunScheduledWaits(), t && C3Debugger.AddEventsTime(), this.PopCurrentLayout(), e.BlockFlushingInstances(false), this.FlushPendingInstances(), e.BlockFlushingInstances(true);\n    }\n    async Step_AfterPreTick() {\n      const e = this._eventSheetManager, t = this.IsDebug(), s = this.IsDebugging(), i = this._dispatcher, n = this._eventObjects, a = this._userScriptEventObjects;\n      t && C3Debugger.StartMeasuringTime(), s ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick(), s ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick(), t && C3Debugger.AddBehaviorTotalTickTime(), t && C3Debugger.StartMeasuringTime(), s ? await this.DebugFireGeneratorEventAndBreak(n[\"tick\"]) : i.dispatchEvent(n[\"tick\"]), t && C3Debugger.AddPluginTotalTickTime(), e.BlockFlushingInstances(false), this.DispatchUserScriptEvent(a[\"tick\"]);\n    }\n    async Step_RunEventsEtc() {\n      const e = this._eventSheetManager, t = this._dispatcher, s = this._eventObjects, i = this._userScriptEventObjects, n = this.IsDebug(), a = this.IsDebugging();\n      n && C3Debugger.StartMeasuringTime(), a ? await e.DebugRunEvents(this._layoutManager) : e.RunEvents(this._layoutManager), n && C3Debugger.AddEventsTime(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), this._isLayoutFirstTick = false, e.BlockFlushingInstances(true), n && C3Debugger.StartMeasuringTime(), a ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2(), n && C3Debugger.AddBehaviorTotalTickTime(), n && C3Debugger.StartMeasuringTime(), a ? await this.DebugFireGeneratorEventAndBreak(s[\"tick2\"]) : t.dispatchEvent(s[\"tick2\"]), n && C3Debugger.AddPluginTotalTickTime(), e.BlockFlushingInstances(false), this.DispatchUserScriptEvent(i[\"tick2\"]), a && await e.RunQueuedDebugTriggersAsync(), this.FlushPendingInstances(), this._ReleasePendingInstances();\n    }\n    _ReleasePendingInstances() {\n      if (0 === this._instancesPendingRelease.size) return;\n      const e = this._dispatcher;\n      e.SetDelayRemoveEventsEnabled(true);\n      for (const e2 of this._instancesPendingReleaseAffectedObjectClasses) e2.GetSolStack().RemoveInstances(this._instancesPendingRelease);\n      this._instancesPendingReleaseAffectedObjectClasses.clear(), this._eventSheetManager._OnInstancesReleased(this._instancesPendingRelease);\n      for (const e2 of this._instancesPendingRelease) e2.Release();\n      this._instancesPendingRelease.clear(), e.SetDelayRemoveEventsEnabled(false);\n    }\n    async _MaybeChangeLayout() {\n      const e = this.GetLayoutManager();\n      let t = 0;\n      for (; e.IsPendingChangeMainLayout() && t++ < 10; ) await this._DoChangeLayout(e.GetPendingChangeMainLayout());\n    }\n    _MeasureDt(e) {\n      let t = 0;\n      if (this.IsExportToVideo()) t = 1 / this.GetExportVideoFramerate(), this._dtRaw = t, this._dt1 = t;\n      else if (0 !== this._lastTickTime) {\n        t = Math.max(e - this._lastTickTime, 0) / 1e3, t > 0.5 && (t = 0), this._dtRaw = t, this._dt1 = C33.clamp(t, this._minDt, this._maxDt);\n      }\n      this._lastTickTime = e, this._dt = this._dt1 * this._timeScale, this._gameTime.Add(this._dt), this._gameTimeRaw.Add(t * this._timeScale), this._wallTime.Add(this._dt1);\n      for (const [e2, t2] of this._instanceTimes) t2.Add(this._dt1 * e2.GetTimeScale());\n      this._canvasManager && this._canvasManager._UpdateTick(), e - this._fpsLastTime >= 1e3 && (this._fpsLastTime += 1e3, e - this._fpsLastTime >= 1e3 && (this._fpsLastTime = e), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._tps = this._tpsTickCount, this._tpsTickCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1e3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug() && C3Debugger.Update1sPerfStats());\n    }\n    _SetTrackingInstanceTime(e, t) {\n      if (t) {\n        if (!this._instanceTimes.has(e)) {\n          const t2 = C33.New(C33.KahanSum);\n          t2.Copy(this._gameTime), this._instanceTimes.set(e, t2);\n        }\n      } else this._instanceTimes.delete(e);\n    }\n    _GetInstanceGameTime(e) {\n      const t = this._instanceTimes.get(e);\n      return t ? t.Get() : this.GetGameTime();\n    }\n    async _DoChangeLayout(e) {\n      const t = this._dispatcher, s = this.GetLayoutManager().GetMainRunningLayout();\n      await s._StopRunning(), s._Unload(e, this.GetRenderer()), s === e && this._eventSheetManager.ClearAllScheduledWaits(), this._collisionEngine.ClearRegisteredCollisions(), this._ReleasePendingInstances(), t.dispatchEvent(this._eventObjects[\"beforelayoutchange\"]), C33.Asyncify.SetHighThroughputMode(true), await e._Load(s, this.GetRenderer()), C33.Asyncify.SetHighThroughputMode(false), await e._StartRunning(false), t.dispatchEvent(this._eventObjects[\"layoutchange\"]), this.UpdateRender(), this._isLayoutFirstTick = true, this.FlushPendingInstances(), this._ExportToVideoAddKeyframe();\n    }\n    UpdateRender() {\n      this._needRender = true;\n    }\n    GetWebGLRenderer() {\n      return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null;\n    }\n    GetWebGPURenderer() {\n      return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null;\n    }\n    GetRenderer() {\n      return this._canvasManager ? this._canvasManager.GetRenderer() : null;\n    }\n    Render() {\n      const e = this._canvasManager;\n      if (!e || e.IsRendererContextLost()) return;\n      const t = this.GetRenderer(), s = t.SupportsGPUProfiling(), i = s && t.IsWebGL(), n = s && t.IsWebGPU();\n      if (i && t.CheckForQueryResults(), !this._needRender && !this.IsExportToVideo()) return void t.IncrementFrameNumber();\n      const a = this._layoutManager.GetMainRunningLayout();\n      this._fpsFrameCount++, t.Start();\n      const r = this.IsDebug();\n      r && C3Debugger.StartMeasuringTime(), this._needRender = false;\n      let o = null;\n      i && (o = e.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), t.StartQuery(o));\n      let h = null;\n      n && (h = t.StartFrameTiming(2 * (1 + a.GetLayerCount())), t.StartMeasuringRenderPassTime(0, 1)), this.Uses3DFeatures() && \"low\" === e.GetCurrentFullscreenScalingQuality() ? t.SetFixedSizeDepthBuffer(e.GetDrawWidth(), e.GetDrawHeight()) : t.SetAutoSizeDepthBuffer(), this._Render(this.GetRenderer(), a), o && t.EndQuery(o), n && (t.StopMeasuringRenderPassTime(), this._canvasManager._AddWebGPUFrameTiming(h)), t.Finish(), r && (C3Debugger.AddDrawCallsTime(), C3Debugger.UpdateInspectHighlight()), e && e._MaybeTakeSnapshot();\n    }\n    _NeedsHTMLLayerCompositing(e) {\n      return \"low\" === this.GetCanvasManager().GetCurrentFullscreenScalingQuality() || e.IsWebGL() && (this.UsesAnyBackgroundBlending() || this.Uses3DFeatures());\n    }\n    _Render(e, t) {\n      e.SetTextureFillMode(), e.SetAlphaBlend(), e.SetColorRgba(1, 1, 1, 1), e.SetRenderTarget(null), e.SetTexture(null), e.SetDepthEnabled(this.Uses3DFeatures()), this._NeedsHTMLLayerCompositing(e) && t._MaybeStartDrawToOwnTexture(e);\n      const s = t.GetHTMLLayerCount();\n      for (let i = 1; i < s; ++i) t.DrawForHTMLLayerIndex(e, i), e.IsWebGPU() && e.Restart();\n      this._NeedsHTMLLayerCompositing(e) || t._MaybeStartDrawToOwnTexture(e), t.DrawMain(e);\n    }\n    Trigger(e, t, s) {\n      if (!this._hasStarted) return false;\n      const i = !this._isInTick && !this._eventSheetManager.IsInTrigger();\n      let n = 0;\n      i && (n = performance.now());\n      const a = this.IsDebug();\n      a && this.SetDebuggingEnabled(false);\n      const r = this._eventSheetManager._Trigger(this._layoutManager, e, t, s);\n      if (i) {\n        const e2 = performance.now() - n;\n        this._mainThreadTimeCounter += e2, a && C3Debugger.AddTriggersTime(e2);\n      }\n      return a && this.SetDebuggingEnabled(true), r;\n    }\n    DebugTrigger(e, t, s) {\n      if (!this.IsDebugging()) return this.Trigger(e, t, s);\n      if (this.HitBreakpoint()) throw new Error(\"called DebugTrigger() while stopped on breakpoint\");\n      if (!this._isInTick && !this._eventSheetManager.IsInTrigger()) throw new Error(\"called DebugTrigger() outside of event code - use TriggerAsync() instead\");\n      return this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, s);\n    }\n    async TriggerAsync(e, t, s) {\n      if (!this.IsDebugging()) return this.Trigger(e, t, s);\n      if (!this._hasStarted) return false;\n      if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(e, t, s);\n      if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(e, t, s);\n      const i = performance.now(), n = this._eventSheetManager._DebugTrigger(this._layoutManager, e, t, s);\n      let a = n.next();\n      for (; !a.done; ) await this.DebugBreak(a.value), a = n.next();\n      return this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(), this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame()), this._mainThreadTimeCounter += performance.now() - i, a.value;\n    }\n    FastTrigger(e, t, s) {\n      const i = this.IsDebug();\n      i && this.SetDebuggingEnabled(false);\n      const n = this._eventSheetManager._FastTrigger(this._layoutManager, e, t, s);\n      return i && this.SetDebuggingEnabled(true), n;\n    }\n    DebugFastTrigger(e, t, s) {\n      return this._eventSheetManager._DebugFastTrigger(this._layoutManager, e, t, s);\n    }\n    ScheduleTriggers(e) {\n      return this._scheduleTriggersThrottle.Add(e);\n    }\n    PushCurrentLayout(e) {\n      this._currentLayoutStack.push(e);\n    }\n    PopCurrentLayout() {\n      if (!this._currentLayoutStack.length) throw new Error(\"layout stack empty\");\n      this._currentLayoutStack.pop();\n    }\n    GetCurrentLayout() {\n      return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout();\n    }\n    GetDt(e) {\n      return e && -1 !== e.GetTimeScale() ? this._dt1 * e.GetTimeScale() : this._dt;\n    }\n    _GetDtFast() {\n      return this._dt;\n    }\n    GetDt1() {\n      return this._dt1;\n    }\n    GetDtRaw() {\n      return this._dtRaw;\n    }\n    GetTimeScale() {\n      return this._timeScale;\n    }\n    SetTimeScale(e) {\n      (isNaN(e) || e < 0) && (e = 0), this._timeScale = e;\n    }\n    SetMinDt(e) {\n      this._minDt = Math.max(e, 0);\n    }\n    GetMinDt() {\n      return this._minDt;\n    }\n    SetMaxDt(e) {\n      this._maxDt = Math.max(e, 0);\n    }\n    GetMaxDt() {\n      return this._maxDt;\n    }\n    GetFramesPerSecond() {\n      return this._fps;\n    }\n    GetTicksPerSecond() {\n      return this._tps;\n    }\n    GetMainThreadTime() {\n      return this._mainThreadTime;\n    }\n    GetStartTime() {\n      return this._startTime;\n    }\n    GetGameTime() {\n      return this._gameTime.Get();\n    }\n    GetGameTimeRaw() {\n      return this._gameTimeRaw.Get();\n    }\n    GetWallTime() {\n      return this._wallTime.Get();\n    }\n    GetTickCount() {\n      return this._tickCount;\n    }\n    GetTickCountNoSave() {\n      return this._tickCountNoSave;\n    }\n    GetObjectCount() {\n      return this._objectCount;\n    }\n    GetProjectName() {\n      return this._projectName;\n    }\n    GetProjectVersion() {\n      return this._projectVersion;\n    }\n    GetProjectUniqueId() {\n      return this._projectUniqueId;\n    }\n    GetAppId() {\n      return this._appId;\n    }\n    GetExportTimestamp() {\n      return this._exportTimestamp;\n    }\n    GetInstanceByUID(e) {\n      if (this._isLoadingState) throw new Error(\"cannot call while loading state - wait until afterload event\");\n      return this._instancesByUid.get(e) || null;\n    }\n    _RemoveInstanceFromUIDMap(e) {\n      if (this._isLoadingState) throw new Error(\"cannot call while loading state - wait until afterload event\");\n      this._instancesByUid.delete(e);\n    }\n    _RefreshUidMap() {\n      this._instancesByUid.clear();\n      for (const e of this._allObjectClasses) if (!e.IsFamily()) for (const t of e.GetInstances()) this._instancesByUid.set(t.GetUID(), t);\n    }\n    IsPreview() {\n      return \"preview\" === this._exportType;\n    }\n    IsDebug() {\n      return this._isDebug;\n    }\n    GetExportType() {\n      return this._exportType;\n    }\n    IsNWjs() {\n      return \"nwjs\" === this.GetExportType() || this._isNWjs;\n    }\n    IsCordova() {\n      return \"cordova\" === this._exportType;\n    }\n    IsAndroidWebView() {\n      return \"Android\" === C33.Platform.OS && (\"cordova\" === this._exportType || \"playable-ad-single-file\" === this._exportType || \"playable-ad-zip\" === this._exportType || \"instant-games\" === this._exportType);\n    }\n    IsiOSCordova() {\n      return this._isiOSCordova;\n    }\n    IsiOSWebView() {\n      return this._isiOSWebView;\n    }\n    IsWindowsWebView2() {\n      return this._isWindowsWebView2;\n    }\n    IsAnyWebView2Wrapper() {\n      return this._isAnyWebView2Wrapper;\n    }\n    GetCollisionEngine() {\n      return this._collisionEngine;\n    }\n    GetSolidBehavior() {\n      return this._addonManager.GetSolidBehavior();\n    }\n    GetJumpthruBehavior() {\n      return this._addonManager.GetJumpthruBehavior();\n    }\n    Uses3DFeatures() {\n      return this._uses3dFeatures;\n    }\n    GetZScaleFactor() {\n      return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight());\n    }\n    GetDefaultCameraZ(e) {\n      return this.GetRenderer().GetDefaultCameraZ(e || this.GetViewportHeight());\n    }\n    IsLayoutFirstTick() {\n      return this._isLayoutFirstTick;\n    }\n    SetPixelRoundingEnabled(e) {\n      e = !!e, this._isPixelRoundingEnabled !== e && (this._isPixelRoundingEnabled = e, this.GetLayoutManager().SetAllLayerMVChanged(), this.UpdateRender());\n    }\n    IsPixelRoundingEnabled() {\n      return this._isPixelRoundingEnabled;\n    }\n    GetTextIconSet(e) {\n      if (!this._iconChangeHandlers.has(e)) {\n        const t2 = () => this.DeleteTextIconSet(e);\n        this._iconChangeHandlers.set(e, t2), e.Dispatcher().addEventListener(\"animationframeimagechange\", t2);\n      }\n      const t = this._textIconManager.GetIconSet(e);\n      return t.HasLoaded() || t.LoadContent().then(() => this.UpdateRender()), t;\n    }\n    DeleteTextIconSet(e) {\n      this._textIconManager.DeleteIconSet(e);\n    }\n    _GetTextIconSetMeta(e) {\n      const t = [];\n      for (const s of e.GetAnimations()) for (const e2 of s.GetFrames()) {\n        const s2 = e2.GetImageInfo();\n        t.push({ source: e2, width: s2.GetWidth(), height: s2.GetHeight(), tag: e2.GetTag() });\n      }\n      return { icons: t };\n    }\n    async _GetTextIconSetContent(e) {\n      const t = C33.New(C33.PromiseThrottle), s = [], i = /* @__PURE__ */ new Map();\n      for (const n2 of e.GetAnimations()) for (const e2 of n2.GetFrames()) {\n        const n3 = e2.GetImageInfo().GetImageAsset();\n        i.has(n3) || (i.set(n3, null), s.push(t.Add(async () => {\n          const e3 = await n3.LoadToDrawable();\n          i.set(n3, e3);\n        })));\n      }\n      await Promise.all(s);\n      const n = [];\n      for (const s2 of e.GetAnimations()) for (const e2 of s2.GetFrames()) n.push(t.Add(async () => {\n        const t2 = e2.GetImageInfo(), s3 = i.get(t2.GetImageAsset()), n2 = await t2.ExtractImageToCanvas(s3);\n        return { drawable: await createImageBitmap(n2) };\n      }));\n      const a = await Promise.all(n);\n      for (const e2 of i.values()) e2 instanceof ImageBitmap && e2[\"close\"] && e2[\"close\"]();\n      return { icons: a };\n    }\n    SaveToSlot(e) {\n      this._saveToSlotName = e, this._saveToJsonString = false;\n    }\n    SaveToJsonString() {\n      this._saveToSlotName = \"\", this._saveToJsonString = true;\n    }\n    LoadFromSlot(e) {\n      this._loadFromSlotName = e;\n    }\n    LoadFromJsonString(e) {\n      this._loadFromJson = e;\n    }\n    GetLastSaveJsonString() {\n      return this._lastSaveJson;\n    }\n    _NeedsHandleSaveOrLoad() {\n      return !!(this._saveToSlotName || this._saveToJsonString || this._loadFromSlotName || null !== this._loadFromJson);\n    }\n    async _HandleSaveOrLoad() {\n      if (this._saveToSlotName && (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad()), this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug() && C3Debugger.StepIfPausedInDebugger()), this._saveToJsonString) {\n        const e = await this._SaveToJsonString();\n        this._lastSaveJson = e, await this.TriggerAsync(C33.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = \"\", this._ClearSaveOrLoad();\n      }\n      if (null !== this._loadFromJson) {\n        this.FlushPendingInstances();\n        try {\n          await this._DoLoadFromJsonString(this._loadFromJson), this._lastSaveJson = this._loadFromJson, await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = \"\";\n        } catch (e) {\n          console.error(\"[Construct] Failed to load state from JSON string: \", e), await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadFailed, null);\n        }\n        this._ClearSaveOrLoad();\n      }\n    }\n    _ClearSaveOrLoad() {\n      this._saveToSlotName = \"\", this._saveToJsonString = false, this._loadFromSlotName = \"\", this._loadFromJson = null;\n    }\n    _GetProjectStorage() {\n      return this._projectStorage || (this._projectStorage = localforage.createInstance({ name: \"c3-localstorage-\" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._projectStorage;\n    }\n    _GetSavegamesStorage() {\n      return this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({ name: \"c3-savegames-\" + this.GetProjectUniqueId(), description: this.GetProjectName() })), this._savegamesStorage;\n    }\n    async _DoSaveToSlot(e) {\n      const t = await this._SaveToJsonString();\n      try {\n        await this._GetSavegamesStorage().setItem(e, t), console.log(\"[Construct] Saved state to storage (\" + t.length + \" chars)\"), this._lastSaveJson = t, await this.TriggerAsync(C33.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = \"\";\n      } catch (e2) {\n        console.error(\"[Construct] Failed to save state to storage: \", e2), await this.TriggerAsync(C33.Plugins.System.Cnds.OnSaveFailed, null);\n      }\n    }\n    async _DoLoadFromSlot(e) {\n      try {\n        const t = await this._GetSavegamesStorage().getItem(e);\n        if (!t) throw new Error(\"empty slot\");\n        console.log(\"[Construct] Loaded state from storage (\" + t.length + \" chars)\"), await this._DoLoadFromJsonString(t), this._lastSaveJson = t, await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = \"\";\n      } catch (e2) {\n        console.error(\"[Construct] Failed to load state from storage: \", e2), await this.TriggerAsync(C33.Plugins.System.Cnds.OnLoadFailed, null);\n      }\n    }\n    async _SaveToJsonString() {\n      const e = { \"c3save\": true, \"version\": 1, \"rt\": { \"time\": this.GetGameTime(), \"timeRaw\": this.GetGameTimeRaw(), \"walltime\": this.GetWallTime(), \"timescale\": this.GetTimeScale(), \"tickcount\": this.GetTickCount(), \"next_uid\": this._nextUid, \"running_layout\": this.GetMainRunningLayout().GetSID(), \"start_time_offset\": Date.now() - this._startTime }, \"types\": {}, \"layouts\": {}, \"events\": this._eventSheetManager._SaveToJson(), \"timelines\": this._timelineManager._SaveToJson(), \"user_script_data\": null };\n      for (const t2 of this._allObjectClasses) t2.IsFamily() || t2.HasNoSaveBehavior() || (e[\"types\"][t2.GetSID().toString()] = t2._SaveToJson());\n      for (const t2 of this._layoutManager.GetAllLayouts()) e[\"layouts\"][t2.GetSID().toString()] = t2._SaveToJson();\n      const t = this._CreateUserScriptEvent(\"save\");\n      return t.saveData = null, await this.DispatchUserScriptEventAsyncWait(t), e[\"user_script_data\"] = t.saveData, JSON.stringify(e);\n    }\n    IsLoadingState() {\n      return this._isLoadingState;\n    }\n    async _DoLoadFromJsonString(e) {\n      const t = this.GetLayoutManager(), s = JSON.parse(e);\n      if (s[\"c2save\"]) throw new Error(\"C2 saves are incompatible with C3 runtime\");\n      if (!s[\"c3save\"]) throw new Error(\"not valid C3 save data\");\n      if (s[\"version\"] > 1) throw new Error(\"C3 save data from future version\");\n      this.ClearIntancesNeedingAfterLoad(), this._dispatcher.dispatchEvent(C33.New(C33.Event, \"beforeload\"));\n      for (const e2 of this.allInstances()) {\n        e2.GetObjectClass().HasNoSaveBehavior() || e2._OnBeforeLoad();\n      }\n      const i = s[\"rt\"];\n      this._gameTime.Set(i[\"time\"]), i.hasOwnProperty(\"timeRaw\") && this._gameTimeRaw.Set(i[\"timeRaw\"]), this._wallTime.Set(i[\"walltime\"]), this._timeScale = i[\"timescale\"], this._tickCount = i[\"tickcount\"], this._startTime = Date.now() - i[\"start_time_offset\"];\n      const n = i[\"running_layout\"];\n      this._isLoadingState = true;\n      let a = false;\n      if (n !== this.GetMainRunningLayout().GetSID()) {\n        const e2 = t.GetLayoutBySID(n);\n        if (!e2) return;\n        await this._DoChangeLayout(e2), a = true;\n      }\n      for (const [e2, i2] of Object.entries(s[\"layouts\"])) {\n        const s2 = parseInt(e2, 10), n2 = t.GetLayoutBySID(s2);\n        n2 && n2._LoadFromJson(i2);\n      }\n      const r = /* @__PURE__ */ new Set();\n      for (const [e2, t2] of Object.entries(s[\"types\"])) {\n        const s2 = parseInt(e2, 10), i2 = this.GetObjectClassBySID(s2);\n        !i2 || i2.IsFamily() || i2.HasNoSaveBehavior() || i2._LoadFromJson(t2, r);\n      }\n      for (const e2 of this._layoutManager.GetAllLayouts()) for (const t2 of e2.allLayers()) t2._LoadFromJsonAfterInstances();\n      if (this.FlushPendingInstances(), this._RefreshUidMap(), this._isLoadingState = false, a) {\n        for (const e2 of this.allInstances()) e2.SetupInitialSceneGraphConnections();\n        for (const [e2, t2] of Object.entries(s[\"types\"])) {\n          const s2 = parseInt(e2, 10), i2 = this.GetObjectClassBySID(s2);\n          !i2 || i2.IsFamily() || i2.HasNoSaveBehavior() || i2._SetupSceneGraphConnectionsOnChangeOfLayout(t2);\n        }\n      }\n      this._nextUid = i[\"next_uid\"], this._eventSheetManager._LoadFromJson(s[\"events\"]);\n      for (const e2 of this._allObjectClasses) if (!e2.IsFamily() && e2.IsInContainer()) for (const t2 of e2.GetInstances()) {\n        const s2 = t2.GetIID();\n        t2._ClearSiblings();\n        for (const i2 of e2.GetContainer().objectTypes()) {\n          if (i2 === e2) continue;\n          const n2 = i2.GetInstances();\n          if (s2 < 0 || s2 >= n2.length) throw new Error(\"missing sibling instance\");\n          t2._AddSibling(n2[s2]);\n        }\n      }\n      this._timelineManager._LoadFromJson(s[\"timelines\"]), t.SetAllLayerProjectionChanged(), t.SetAllLayerMVChanged();\n      for (const e2 of r) e2._OnCreatedForLoadingSavegame();\n      this.DoAfterLoad(), this._dispatcher.dispatchEvent(C33.New(C33.Event, \"afterload\")), this.DispatchUserScriptEvent(this._CreateUserScriptEvent(\"afterload\"));\n      for (const [e2, t2] of Object.entries(s[\"types\"])) {\n        const t3 = parseInt(e2, 10), s2 = this.GetObjectClassBySID(t3);\n        s2 && s2._ClearLoadInstancesJson();\n      }\n      const o = this._CreateUserScriptEvent(\"load\");\n      o.saveData = s[\"user_script_data\"], await this.DispatchUserScriptEventAsyncWait(o), this.UpdateRender();\n    }\n    SortOnTmpHierarchyPosition(e, t) {\n      return t.GetWorldInfo().GetTmpHierarchyPosition() - e.GetWorldInfo().GetTmpHierarchyPosition();\n    }\n    AddInstanceNeedingAfterLoad(e, t) {\n      e.GetWorldInfo() && (this._instancesNeedingAfterLoadMap.has(e) || (this._instancesNeedingAfterLoadMap.set(e, t), this._instancesNeedingAfterLoadArray.push(e)));\n    }\n    ClearIntancesNeedingAfterLoad() {\n      this._instancesNeedingAfterLoadMap = /* @__PURE__ */ new WeakMap(), C33.clearArray(this._instancesNeedingAfterLoadArray), C33.SceneGraphInfo.ClearUpdatedInstances();\n    }\n    DoAfterLoad(e = \"full\", t = null) {\n      this._instancesNeedingAfterLoadArray.sort(this.SortOnTmpHierarchyPosition), t || (t = {}), t.processedWorldInfo = /* @__PURE__ */ new Set();\n      const s = this._instancesNeedingAfterLoadArray.length;\n      for (const s2 of this._instancesNeedingAfterLoadArray) s2._OnAfterLoad(this._instancesNeedingAfterLoadMap.get(s2), e, t);\n      for (const s2 of this._instancesNeedingAfterLoadArray) s2._OnAfterLoad2(this._instancesNeedingAfterLoadMap.get(s2), e, t);\n      if (this.ClearIntancesNeedingAfterLoad(), s) {\n        this.FlushPendingInstances(), this._RefreshUidMap();\n        for (const e2 of this._layoutManager.GetAllLayouts()) for (const t2 of e2.allLayers()) t2._SortInstancesByLastCachedZIndex(), t2.SetZIndicesChanged();\n      }\n    }\n    async AddJobWorkerScripts(e) {\n      const t = await Promise.all(e.map(async (e2) => {\n        if (this.IsCordova() && this._assetManager.IsFileProtocol() || \"playable-ad-single-file\" === this.GetExportType()) {\n          const t2 = await this._assetManager.FetchBlob(e2);\n          return URL.createObjectURL(t2);\n        }\n        return new URL(e2, location.href).toString();\n      }));\n      this._jobScheduler.ImportScriptsToJobWorkers(t);\n    }\n    AddJobWorkerBlob(e, t) {\n      this._jobScheduler.SendBlobToJobWorkers(e, t);\n    }\n    AddJobWorkerBuffer(e, t) {\n      this._jobScheduler.SendBufferToJobWorkers(e, t);\n    }\n    AddJob(e, t, s, i) {\n      return this._jobScheduler.AddJob(e, t, s, null, null, i);\n    }\n    BroadcastJob(e, t, s, i) {\n      return this._jobScheduler.BroadcastJob(e, t, s, i);\n    }\n    GetMaxNumJobWorkers() {\n      return this._jobScheduler.GetMaxNumWorkers();\n    }\n    InvokeDownload(e, t) {\n      this.PostComponentMessageToDOM(\"runtime\", \"invoke-download\", { \"url\": e, \"filename\": t });\n    }\n    async RasterSvgImage(e, t, s, i, n, a) {\n      if (i = i || t, n = n || s, this.IsInWorker()) {\n        return (await this.PostComponentMessageToDOMAsync(\"runtime\", \"raster-svg-image\", { \"blob\": e, \"imageWidth\": t, \"imageHeight\": s, \"surfaceWidth\": i, \"surfaceHeight\": n, \"imageBitmapOpts\": a }))[\"imageBitmap\"];\n      }\n      {\n        const r = await self[\"C3_RasterSvgImageBlob\"](e, t, s, i, n);\n        return a ? await self.createImageBitmap(r, a) : r;\n      }\n    }\n    async GetSvgImageSize(e) {\n      return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync(\"runtime\", \"get-svg-image-size\", { \"blob\": e }) : await self[\"C3_GetSvgImageSize\"](e);\n    }\n    RequestDeviceOrientationEvent() {\n      this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = true, this.PostComponentMessageToDOM(\"runtime\", \"enable-device-orientation\"));\n    }\n    RequestDeviceMotionEvent() {\n      this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = true, this.PostComponentMessageToDOM(\"runtime\", \"enable-device-motion\"));\n    }\n    Random() {\n      return this._randomNumberCallback();\n    }\n    SetRandomNumberGeneratorCallback(e) {\n      this._randomNumberCallback = e;\n    }\n    _GetRemotePreviewStatusInfo() {\n      const e = this.GetRenderer();\n      return { \"fps\": this.GetFramesPerSecond(), \"tps\": this.GetTicksPerSecond(), \"cpu\": this.GetMainThreadTime(), \"gpu\": this.GetGPUUtilisation(), \"layout\": this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : \"\", \"renderer\": e.IsWebGL() ? e.GetUnmaskedRenderer() : e.GetAdapterInfoString() };\n    }\n    HitBreakpoint() {\n      return !!this.IsDebug() && C3Debugger.HitBreakpoint();\n    }\n    DebugBreak(e) {\n      return this.IsDebugging() ? C3Debugger.DebugBreak(e) : Promise.resolve();\n    }\n    DebugBreakNext() {\n      return !!this.IsDebugging() && C3Debugger.BreakNext();\n    }\n    SetDebugBreakpointsEnabled(e) {\n      this._breakpointsEnabled = !!e, this._UpdateDebuggingFlag();\n    }\n    AreDebugBreakpointsEnabled() {\n      return this._breakpointsEnabled;\n    }\n    IsDebugging() {\n      return this._isDebugging;\n    }\n    SetDebuggingEnabled(e) {\n      e ? this._debuggingDisabled-- : this._debuggingDisabled++, this._UpdateDebuggingFlag();\n    }\n    _UpdateDebuggingFlag() {\n      this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled;\n    }\n    IsCPUProfiling() {\n      return this.IsDebug() && C3Debugger.IsCPUProfiling();\n    }\n    IsGPUProfiling() {\n      return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && C3Debugger.IsGPUProfiling();\n    }\n    async DebugIterateAndBreak(e) {\n      if (e) for (const t of e) await this.DebugBreak(t);\n    }\n    DebugFireGeneratorEventAndBreak(e) {\n      return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(e));\n    }\n    _InvokeFunctionFromJS(e) {\n      return this._eventSheetManager._InvokeFunctionFromJS(e[\"name\"], e[\"params\"]);\n    }\n    _GetHTMLLayerWrapElement(e) {\n      if (this.IsInWorker()) throw new Error(\"not supported in worker mode\");\n      return self[\"c3_runtimeInterface\"][\"_GetHTMLWrapElement\"](e);\n    }\n    GetIRuntime() {\n      return this._iRuntime;\n    }\n    _CreateUserScriptEvent(e) {\n      const t = C33.New(C33.Event, e, false);\n      return t.runtime = this._iRuntime, t;\n    }\n    _InitScriptInterfaces() {\n      this._iRuntime = new self.IRuntime(this), this._userScriptEventObjects = { \"pretick\": this._CreateUserScriptEvent(\"pretick\"), \"tick\": this._CreateUserScriptEvent(\"tick\"), \"tick2\": this._CreateUserScriptEvent(\"tick2\") };\n    }\n    _InitObjectsScriptInterface() {\n      const e = {};\n      for (const t of this._allObjectClasses) e[t.GetJsPropName()] = { value: t.GetIObjectClass(), enumerable: true, writable: false };\n      this._iRuntime._InitObjects(e);\n    }\n    _InitGlobalVariableScriptInterface() {\n      const e = {};\n      for (const t of this.GetEventSheetManager().GetAllGlobalVariables()) e[t.GetJsPropName()] = t._GetScriptInterfaceDescriptor();\n      this._iRuntime._InitGlobalVars(e);\n    }\n    _GetCommonScriptInterfaces() {\n      return this._commonScriptInterfaces;\n    }\n    _MapScriptInterface(e, t) {\n      this._interfaceMap.set(e, t);\n    }\n    _UnwrapScriptInterface(e) {\n      return this._interfaceMap.get(e);\n    }\n    _UnwrapIObjectClass(e) {\n      if (!(e instanceof self.IObjectClass)) throw new TypeError(\"expected IObjectClass\");\n      const t = this._UnwrapScriptInterface(e);\n      if (!(t && t instanceof C33.ObjectClass)) throw new Error(\"invalid IObjectClass\");\n      return t;\n    }\n    _UnwrapIInstance(e) {\n      if (!(e instanceof self.IInstance)) throw new TypeError(\"expected IInstance\");\n      const t = this._UnwrapScriptInterface(e);\n      if (!(t && t instanceof C33.Instance)) throw new Error(\"invalid IInstance\");\n      return t;\n    }\n    _UnwrapIWorldInstance(e) {\n      if (!(e instanceof self.IWorldInstance)) throw new TypeError(\"expected IWorldInstance\");\n      const t = this._UnwrapScriptInterface(e);\n      if (!(t && t instanceof C33.Instance)) throw new Error(\"invalid IInstance\");\n      return t;\n    }\n  }, self[\"C3_CreateRuntime\"] = C33.Runtime.Create, self[\"C3_InitRuntime\"] = (e, t) => e.Init(t);\n}\n{\n  const C33 = self.C3;\n  C33.JobSchedulerRuntime = class extends C33.DefendedBase {\n    constructor(r, e) {\n      super(), this._runtime = r, this._jobPromises = /* @__PURE__ */ new Map(), this._nextJobId = 0, this._inputPort = e[\"inputPort\"], e[\"outputPort\"].onmessage = (r2) => this._OnJobWorkerMessage(r2), this._maxNumWorkers = e[\"maxNumWorkers\"], this._jobWorkerCount = 1, this._isCreatingWorker = false, this._hadErrorCreatingWorker = false;\n    }\n    GetMaxNumWorkers() {\n      return this._maxNumWorkers;\n    }\n    ImportScriptsToJobWorkers(r) {\n      this._inputPort.postMessage({ \"type\": \"_import_scripts\", \"scripts\": r });\n    }\n    SendBlobToJobWorkers(r, e) {\n      this._inputPort.postMessage({ \"type\": \"_send_blob\", \"blob\": r, \"id\": e });\n    }\n    SendBufferToJobWorkers(r, e) {\n      this._inputPort.postMessage({ \"type\": \"_send_buffer\", \"buffer\": r, \"id\": e }, [r]);\n    }\n    AddJob(r, e, o, s, t, i) {\n      if (o || (o = []), \"number\" == typeof i && (i = Math.floor(i)) <= 0) throw new Error(\"invalid maxWorkerNum\");\n      const n = this._nextJobId++, a = { \"type\": r, \"isBroadcast\": false, \"maxWorkerNum\": i, \"jobId\": n, \"params\": e, \"transferables\": o }, _ = new Promise((r2, e2) => {\n        this._jobPromises.set(n, { resolve: r2, progress: s, reject: e2, cancelled: false, maxWorkerNum: i });\n      });\n      return t && t.SetAction(() => this._CancelJob(n)), this._inputPort.postMessage(a, o), this._MaybeCreateExtraWorker(), _;\n    }\n    BroadcastJob(r, e, o, s) {\n      if (o || (o = []), \"number\" == typeof s && (s = Math.floor(s)) <= 0) throw new Error(\"invalid maxWorkerNum\");\n      const t = { \"type\": r, \"isBroadcast\": true, \"maxWorkerNum\": s, \"jobId\": this._nextJobId++, \"params\": e, \"transferables\": o };\n      this._inputPort.postMessage(t, o);\n    }\n    _CancelJob(r) {\n      const e = this._jobPromises.get(r);\n      e && (e.cancelled = true, e.resolve = null, e.progress = null, e.reject = null, this._inputPort.postMessage({ \"type\": \"_cancel\", \"jobId\": r }));\n    }\n    _OnJobWorkerMessage(r) {\n      const e = r.data, o = e[\"type\"], s = e[\"jobId\"];\n      switch (o) {\n        case \"result\":\n          this._OnJobResult(s, e[\"result\"]);\n          break;\n        case \"progress\":\n          this._OnJobProgress(s, e[\"progress\"]);\n          break;\n        case \"error\":\n          this._OnJobError(s, e[\"error\"]);\n          break;\n        case \"ready\":\n          this._OnJobWorkerReady();\n          break;\n        default:\n          throw new Error(`unknown message from worker '${o}'`);\n      }\n    }\n    _OnJobResult(r, e) {\n      const o = this._jobPromises.get(r);\n      if (!o) throw new Error(\"invalid job ID\");\n      o.cancelled || o.resolve(e), this._jobPromises.delete(r);\n    }\n    _OnJobProgress(r, e) {\n      const o = this._jobPromises.get(r);\n      if (!o) throw new Error(\"invalid job ID\");\n      !o.cancelled && o.progress && o.progress(e);\n    }\n    _OnJobError(r, e) {\n      const o = this._jobPromises.get(r);\n      if (!o) throw new Error(\"invalid job ID\");\n      o.cancelled || o.reject(e), this._jobPromises.delete(r);\n    }\n    _OnJobWorkerReady() {\n      this._isCreatingWorker && (this._isCreatingWorker = false, this._jobWorkerCount++, this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({ \"type\": \"_no_more_workers\" }));\n    }\n    _GetWorkerCountNeededForPendingJobs() {\n      let r = 0;\n      const e = [...this._jobPromises.values()].sort((r2, e2) => (r2.maxWorkerNum || 1 / 0) - (e2.maxWorkerNum || 1 / 0));\n      for (const o of e) {\n        r < (o.maxWorkerNum || 1 / 0) && r++;\n      }\n      return r;\n    }\n    async _MaybeCreateExtraWorker() {\n      if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._GetWorkerCountNeededForPendingJobs() <= this._jobWorkerCount)) try {\n        this._isCreatingWorker = true;\n        (await this._runtime.PostComponentMessageToDOMAsync(\"runtime\", \"create-job-worker\"))[\"outputPort\"].onmessage = (r) => this._OnJobWorkerMessage(r);\n      } catch (r) {\n        this._hadErrorCreatingWorker = true, this._isCreatingWorker = false, console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, r);\n      }\n    }\n  };\n}\n{\n  self[\"C3_Shaders\"] = {};\n}\n{\n  {\n    let ForEachOrdered_SortInstances = function(e2, t2) {\n      const n2 = e2[1], r2 = t2[1];\n      if (\"number\" == typeof n2 && \"number\" == typeof r2) return n2 - r2;\n      {\n        const e3 = \"\" + n2, t3 = \"\" + r2;\n        return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;\n      }\n    };\n    ForEachOrdered_SortInstances2 = ForEachOrdered_SortInstances;\n    const e = self.C3;\n    let t = null, n = \"\", r = \"\", a = [], i = \"\", s = \"\", o = \"\";\n    const u = e.New(e.ArrayStack);\n    e.Plugins.System = class extends e.SDKPluginBase {\n      constructor(e2) {\n        super(e2), this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack(), this._eventStack = this._runtime.GetEventSheetManager().GetEventStack(), this._imagesLoadingTotal = 0, this._imagesLoadingComplete = 0, this._functionMaps = /* @__PURE__ */ new Map();\n      }\n      Release() {\n        super.Release();\n      }\n      UpdateRender() {\n        this._runtime.UpdateRender();\n      }\n      Trigger(e2) {\n        this._runtime.Trigger(e2, null, null);\n      }\n      GetRegex(e2, a2) {\n        return t && e2 === n && a2 === r || (t = new RegExp(e2, a2), n = e2, r = a2), t.lastIndex = 0, t;\n      }\n      GetRegexMatches(e2, t2, n2) {\n        if (e2 === i && t2 === s && n2 === o) return a;\n        const r2 = this.GetRegex(t2, n2);\n        return a = e2.match(r2), i = e2, s = t2, o = n2, a;\n      }\n      async _LoadTexturesForObjectClasses(t2, n2) {\n        if (!n2.length) return;\n        this._imagesLoadingTotal += n2.length;\n        const r2 = [];\n        for (const e2 of n2) r2.push(t2.MaybeLoadTexturesFor(e2));\n        await e.PromiseAllWithProgress(r2, () => {\n          this._imagesLoadingComplete++;\n        }), this._imagesLoadingComplete++, this._imagesLoadingComplete === this._imagesLoadingTotal && (this._imagesLoadingComplete = 0, this._imagesLoadingTotal = 0, this._runtime.Trigger(e.Plugins.System.Cnds.OnImageLoadingComplete, null, null));\n      }\n      GetImageLoadingProgress() {\n        return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal;\n      }\n      _UnloadTexturesForObjectClasses(e2, t2) {\n        for (const n2 of t2) 0 === n2.GetInstanceCount() && e2.MaybeUnloadTexturesFor(n2);\n      }\n      _GetForEachStack() {\n        return u;\n      }\n      _Repeat(e2) {\n        const t2 = this._runtime.GetEventSheetManager(), n2 = t2.GetEventStack(), r2 = n2.GetCurrentStackFrame(), a2 = r2.GetCurrentEvent(), i2 = a2.GetSolModifiers(), s2 = r2.IsSolModifierAfterCnds(), o2 = n2.Push(a2), u2 = t2.GetLoopStack(), l = u2.Push();\n        if (l.SetEnd(e2), s2) for (let n3 = 0; n3 < e2 && !l.IsStopped(); ++n3) t2.PushCopySol(i2), l.SetIndex(n3), a2.Retrigger(r2, o2), t2.PopSol(i2);\n        else for (let t3 = 0; t3 < e2 && !l.IsStopped(); ++t3) l.SetIndex(t3), a2.Retrigger(r2, o2);\n        return n2.Pop(), u2.Pop(), false;\n      }\n      *_DebugRepeat(e2) {\n        const t2 = this._runtime.GetEventSheetManager(), n2 = t2.GetEventStack(), r2 = n2.GetCurrentStackFrame(), a2 = r2.GetCurrentEvent(), i2 = a2.GetSolModifiers(), s2 = r2.IsSolModifierAfterCnds(), o2 = n2.Push(a2), u2 = t2.GetLoopStack(), l = u2.Push();\n        if (l.SetEnd(e2), s2) for (let n3 = 0; n3 < e2 && !l.IsStopped(); ++n3) t2.PushCopySol(i2), l.SetIndex(n3), yield* a2.DebugRetrigger(r2, o2), t2.PopSol(i2);\n        else for (let t3 = 0; t3 < e2 && !l.IsStopped(); ++t3) l.SetIndex(t3), yield* a2.DebugRetrigger(r2, o2);\n        return n2.Pop(), u2.Pop(), false;\n      }\n      _While() {\n        const e2 = this._runtime.GetEventSheetManager(), t2 = e2.GetEventStack(), n2 = t2.GetCurrentStackFrame(), r2 = n2.GetCurrentEvent(), a2 = r2.GetSolModifiers(), i2 = n2.IsSolModifierAfterCnds(), s2 = t2.Push(r2), o2 = e2.GetLoopStack(), u2 = o2.Push();\n        if (i2) for (let t3 = 0; !u2.IsStopped(); ++t3) e2.PushCopySol(a2), u2.SetIndex(t3), r2.Retrigger(n2, s2) || u2.Stop(), e2.PopSol(a2);\n        else for (let e3 = 0; !u2.IsStopped(); ++e3) u2.SetIndex(e3), r2.Retrigger(n2, s2) || u2.Stop();\n        return t2.Pop(), o2.Pop(), false;\n      }\n      *_DebugWhile() {\n        const e2 = this._runtime.GetEventSheetManager(), t2 = e2.GetEventStack(), n2 = t2.GetCurrentStackFrame(), r2 = n2.GetCurrentEvent(), a2 = r2.GetSolModifiers(), i2 = n2.IsSolModifierAfterCnds(), s2 = t2.Push(r2), o2 = e2.GetLoopStack(), u2 = o2.Push();\n        if (i2) for (let t3 = 0; !u2.IsStopped(); ++t3) {\n          e2.PushCopySol(a2), u2.SetIndex(t3);\n          (yield* r2.DebugRetrigger(n2, s2)) || u2.Stop(), e2.PopSol(a2);\n        }\n        else for (let e3 = 0; !u2.IsStopped(); ++e3) {\n          u2.SetIndex(e3);\n          (yield* r2.DebugRetrigger(n2, s2)) || u2.Stop();\n        }\n        return t2.Pop(), o2.Pop(), false;\n      }\n      _For(e2, t2, n2) {\n        const r2 = this._runtime.GetEventSheetManager(), a2 = r2.GetEventStack(), i2 = a2.GetCurrentStackFrame(), s2 = i2.GetCurrentEvent(), o2 = s2.GetSolModifiers(), u2 = i2.IsSolModifierAfterCnds(), l = a2.Push(s2), c = r2.GetLoopStack(), h = c.Push();\n        if (h.SetName(e2), h.SetEnd(n2), n2 < t2) if (u2) for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) r2.PushCopySol(o2), h.SetIndex(e3), s2.Retrigger(i2, l), r2.PopSol(o2);\n        else for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) h.SetIndex(e3), s2.Retrigger(i2, l);\n        else if (u2) for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) r2.PushCopySol(o2), h.SetIndex(e3), s2.Retrigger(i2, l), r2.PopSol(o2);\n        else for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) h.SetIndex(e3), s2.Retrigger(i2, l);\n        return a2.Pop(), c.Pop(), false;\n      }\n      *_DebugFor(e2, t2, n2) {\n        const r2 = this._runtime.GetEventSheetManager(), a2 = r2.GetEventStack(), i2 = a2.GetCurrentStackFrame(), s2 = i2.GetCurrentEvent(), o2 = s2.GetSolModifiers(), u2 = i2.IsSolModifierAfterCnds(), l = a2.Push(s2), c = r2.GetLoopStack(), h = c.Push();\n        if (h.SetName(e2), h.SetEnd(n2), n2 < t2) if (u2) for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) r2.PushCopySol(o2), h.SetIndex(e3), yield* s2.DebugRetrigger(i2, l), r2.PopSol(o2);\n        else for (let e3 = t2; e3 >= n2 && !h.IsStopped(); --e3) h.SetIndex(e3), yield* s2.DebugRetrigger(i2, l);\n        else if (u2) for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) r2.PushCopySol(o2), h.SetIndex(e3), yield* s2.DebugRetrigger(i2, l), r2.PopSol(o2);\n        else for (let e3 = t2; e3 <= n2 && !h.IsStopped(); ++e3) h.SetIndex(e3), yield* s2.DebugRetrigger(i2, l);\n        return a2.Pop(), c.Pop(), false;\n      }\n      _ForEach(t2) {\n        const n2 = t2.GetCurrentSol(), r2 = n2.GetInstances();\n        if (0 === r2.length) return false;\n        const a2 = this._runtime.GetEventSheetManager(), i2 = a2.GetEventStack(), s2 = i2.GetCurrentStackFrame(), o2 = s2.GetCurrentEvent(), l = o2.GetSolModifiers(), c = s2.IsSolModifierAfterCnds(), h = i2.Push(o2), g = a2.GetLoopStack(), S = g.Push(), d = t2.IsInContainer(), p = u.Push();\n        if (e.shallowAssignArray(p, r2), S.SetEnd(p.length), c) for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {\n          a2.PushCopySol(l);\n          const n4 = p[e2];\n          t2.GetCurrentSol().SetSinglePicked(n4), d && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), o2.Retrigger(s2, h), a2.PopSol(l);\n        }\n        else {\n          n2._SetSelectAll(false);\n          const t3 = n2._GetOwnInstances();\n          e.clearArray(t3), t3.push(null);\n          for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {\n            const n4 = p[e2];\n            t3[0] = n4, d && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), o2.Retrigger(s2, h);\n          }\n        }\n        return i2.Pop(), g.Pop(), e.clearArray(p), u.Pop(), false;\n      }\n      *_DebugForEach(t2) {\n        const n2 = t2.GetCurrentSol(), r2 = n2.GetInstances();\n        if (0 === r2.length) return false;\n        const a2 = this._runtime.GetEventSheetManager(), i2 = a2.GetEventStack(), s2 = i2.GetCurrentStackFrame(), o2 = s2.GetCurrentEvent(), l = o2.GetSolModifiers(), c = s2.IsSolModifierAfterCnds(), h = i2.Push(o2), g = a2.GetLoopStack(), S = g.Push(), d = t2.IsInContainer(), p = u.Push();\n        if (e.shallowAssignArray(p, r2), S.SetEnd(p.length), c) for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {\n          a2.PushCopySol(l);\n          const n4 = p[e2];\n          t2.GetCurrentSol().SetSinglePicked(n4), d && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), yield* o2.DebugRetrigger(s2, h), a2.PopSol(l);\n        }\n        else {\n          n2._SetSelectAll(false);\n          const t3 = n2._GetOwnInstances();\n          e.clearArray(t3), t3.push(null);\n          for (let e2 = 0, n3 = p.length; e2 < n3 && !S.IsStopped(); ++e2) {\n            const n4 = p[e2];\n            t3[0] = n4, d && n4.SetSiblingsSinglePicked(), S.SetIndex(e2), yield* o2.DebugRetrigger(s2, h);\n          }\n        }\n        return i2.Pop(), g.Pop(), e.clearArray(p), u.Pop(), false;\n      }\n      _ForEachOrdered(t2, n2) {\n        const r2 = t2.GetCurrentSol(), a2 = r2.GetInstances();\n        if (0 === a2.length) return false;\n        const i2 = this._runtime.GetEventSheetManager(), s2 = i2.GetEventStack(), o2 = i2.GetCurrentCondition(), l = s2.GetCurrentStackFrame(), c = l.GetCurrentEvent(), h = c.GetSolModifiers(), g = l.IsSolModifierAfterCnds(), S = s2.Push(c), d = i2.GetLoopStack(), p = d.Push(), m = t2.IsInContainer(), G = u.Push();\n        e.clearArray(G), p.SetEnd(a2.length);\n        for (let e2 = 0, t3 = a2.length; e2 < t3; ++e2) G.push([a2[e2], o2.ReevaluateParameter(1, e2)]);\n        if (G.sort(ForEachOrdered_SortInstances), 1 === n2 && G.reverse(), g) for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {\n          i2.PushCopySol(h);\n          const n4 = G[e2][0];\n          t2.GetCurrentSol().SetSinglePicked(n4), m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), c.Retrigger(l, S), i2.PopSol(h);\n        }\n        else {\n          r2._SetSelectAll(false);\n          const t3 = r2._GetOwnInstances();\n          e.clearArray(t3), t3.push(null);\n          for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {\n            const n4 = G[e2][0];\n            t3[0] = n4, m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), c.Retrigger(l, S);\n          }\n        }\n        return s2.Pop(), d.Pop(), e.clearArray(G), u.Pop(), false;\n      }\n      *_DebugForEachOrdered(t2, n2) {\n        const r2 = t2.GetCurrentSol(), a2 = r2.GetInstances();\n        if (0 === a2.length) return false;\n        const i2 = this._runtime.GetEventSheetManager(), s2 = i2.GetEventStack(), o2 = i2.GetCurrentCondition(), l = s2.GetCurrentStackFrame(), c = l.GetCurrentEvent(), h = c.GetSolModifiers(), g = l.IsSolModifierAfterCnds(), S = s2.Push(c), d = i2.GetLoopStack(), p = d.Push(), m = t2.IsInContainer(), G = u.Push();\n        e.clearArray(G), p.SetEnd(a2.length);\n        for (let e2 = 0, t3 = a2.length; e2 < t3; ++e2) G.push([a2[e2], o2.ReevaluateParameter(1, e2)]);\n        if (G.sort(ForEachOrdered_SortInstances), 1 === n2 && G.reverse(), g) for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {\n          i2.PushCopySol(h);\n          const n4 = G[e2][0];\n          t2.GetCurrentSol().SetSinglePicked(n4), m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), yield* c.DebugRetrigger(l, S), i2.PopSol(h);\n        }\n        else {\n          r2._SetSelectAll(false);\n          const t3 = r2._GetOwnInstances();\n          e.clearArray(t3), t3.push(null);\n          for (let e2 = 0, n3 = G.length; e2 < n3 && !p.IsStopped(); ++e2) {\n            const n4 = G[e2][0];\n            t3[0] = n4, m && n4.SetSiblingsSinglePicked(), p.SetIndex(e2), yield* c.DebugRetrigger(l, S);\n          }\n        }\n        return s2.Pop(), d.Pop(), e.clearArray(G), u.Pop(), false;\n      }\n      _GetFunctionMap(e2, t2) {\n        let n2 = this._functionMaps.get(e2);\n        return n2 || (t2 ? (n2 = { defaultFunc: null, strMap: /* @__PURE__ */ new Map() }, this._functionMaps.set(e2, n2), n2) : null);\n      }\n      _DoCallMappedFunction(e2, t2, n2, r2, a2) {\n        t2.GetEventBlock().RunAsMappedFunctionCall(n2, t2.IsCopyPicked()), r2 && e2.PopSol(a2);\n      }\n      *_DebugDoCallMappedFunction(e2, t2, n2, r2, a2) {\n        yield* t2.GetEventBlock().DebugRunAsMappedFunctionCall(n2, t2.IsCopyPicked()), r2 && e2.PopSol(a2);\n      }\n    };\n  }\n  {\n    const l = self.C3;\n    l.Plugins.System.Type = class extends l.DefendedBase {\n      constructor(e) {\n        super(), this._objectClass = e, this._runtime = e.GetRuntime(), this._plugin = e.GetPlugin();\n      }\n      OnCreate() {\n      }\n      Release() {\n        this._objectClass = null, this._runtime = null, this._plugin = null;\n      }\n    };\n  }\n  {\n    const c = self.C3;\n    c.Plugins.System.Instance = class extends c.DefendedBase {\n      constructor(e, t) {\n        super(), this._inst = e, this._objectClass = this._inst.GetObjectClass(), this._sdkType = this._objectClass.GetSdkType(), this._runtime = this._inst.GetRuntime();\n      }\n      Release() {\n        this._inst = null, this._objectClass = null, this._sdkType = null, this._runtime = null;\n      }\n    };\n  }\n  {\n    const h = self.C3, g = [];\n    h.Plugins.System.Cnds = { EveryTick: () => true, OnLayoutStart: () => true, OnLayoutEnd: () => true, OnSuspend: () => true, OnResume: () => true, IsSuspended() {\n      return this._runtime.IsSuspended();\n    }, Else() {\n      const e = this._runtime.GetCurrentEventStackFrame();\n      return !e.GetElseBranchRan() && !e.GetLastEventTrue();\n    }, TriggerOnce() {\n      const e = this._runtime.GetCurrentCondition().GetSavedDataMap();\n      let t = e.get(\"TriggerOnce_lastTick\");\n      void 0 === t && (t = -1, e.set(\"TriggerOnce_lastTick\", -1));\n      const n = this._runtime.GetTickCount();\n      return e.set(\"TriggerOnce_lastTick\", n), this._runtime.IsLayoutFirstTick() || t !== n - 1;\n    }, Every(e) {\n      const t = this._runtime.GetCurrentCondition().GetSavedDataMap(), n = t.get(\"Every_lastTime\") || 0, r = this._runtime.GetGameTime();\n      t.has(\"Every_seconds\") || t.set(\"Every_seconds\", e);\n      const a = t.get(\"Every_seconds\");\n      return r >= n + a ? (t.set(\"Every_lastTime\", n + a), r >= t.get(\"Every_lastTime\") + 0.04 && t.set(\"Every_lastTime\", r), t.set(\"Every_seconds\", e), true) : (r < n - 0.1 && t.set(\"Every_lastTime\", r), false);\n    }, IsGroupActive(e) {\n      const t = this._runtime.GetEventSheetManager().GetEventGroupByName(e);\n      return t && t.IsGroupActive();\n    }, IsPreview() {\n      return this._runtime.IsPreview();\n    }, IsMobile: () => h.Platform.IsMobile, OnLoadFinished: () => true, OnCanvasSnapshot: () => true, EffectsSupported: () => true, OnSaveComplete: () => true, OnSaveFailed: () => true, OnLoadComplete: () => true, OnLoadFailed: () => true, ObjectUIDExists(e) {\n      return !!this._runtime.GetInstanceByUID(e);\n    }, IsOnPlatform(e) {\n      switch (e) {\n        case 0:\n          return \"browser\" === h.Platform.Context;\n        case 1:\n          return \"iOS\" === h.Platform.OS;\n        case 2:\n          return \"Android\" === h.Platform.OS;\n        case 8:\n          return \"cordova\" === h.Platform.Context;\n        case 9:\n          return \"scirra-arcade\" === this._runtime.GetExportType();\n        case 10:\n          return \"nwjs\" === h.Platform.Context;\n        case 13:\n          return \"windows-uwp\" === this._runtime.GetExportType();\n        default:\n          return false;\n      }\n    }, RegexTest(e, t, n) {\n      return this.GetRegex(t, n).test(e);\n    }, Compare: (e, t, n) => h.compare(e, t, n), CompareBetween: (e, t, n) => e >= t && e <= n, CompareVar: (e, t, n) => h.compare(e.GetValue(), t, n), CompareBoolVar: (e) => !!e.GetValue(), CompareTime(e, t) {\n      const n = this._runtime.GetGameTime();\n      if (0 === e) {\n        const e2 = this._runtime.GetCurrentCondition().GetSavedDataMap();\n        return !e2.get(\"CompareTime_executed\") && n >= t && (e2.set(\"CompareTime_executed\", true), true);\n      }\n      return h.compare(n, e, t);\n    }, IsNaN: (e) => isNaN(e), AngleWithin: (e, t, n) => h.angleDiff(h.toRadians(e), h.toRadians(n)) <= h.toRadians(t), IsClockwiseFrom: (e, t) => h.angleClockwise(h.toRadians(e), h.toRadians(t)), IsBetweenAngles(e, t, n) {\n      let r = h.toRadians(e), a = h.toRadians(t), i = h.toRadians(n);\n      return !h.angleClockwise(i, a) ? !(!h.angleClockwise(r, a) && h.angleClockwise(r, i)) : h.angleClockwise(r, a) && !h.angleClockwise(r, i);\n    }, IsValueType: (e, t) => \"number\" == typeof e ? 0 === t : 1 === t, EvaluateExpression: (e) => !!e, OnSignal(e) {\n      return e.toLowerCase() === this._runtime.GetEventSheetManager().GetCurrentSignalTag();\n    }, PickByComparison(e, t, n, r) {\n      if (!e) return false;\n      const a = this._GetForEachStack(), i = a.Push(), s = e.GetCurrentSol();\n      h.shallowAssignArray(i, s.GetInstances()), s.IsSelectAll() && h.clearArray(s._GetOwnElseInstances());\n      const o = this._runtime.GetCurrentCondition();\n      let u = 0;\n      for (let e2 = 0, a2 = i.length; e2 < a2; ++e2) {\n        const a3 = i[e2];\n        i[u] = a3, t = o.ReevaluateParameter(1, e2), r = o.ReevaluateParameter(3, e2), h.compare(t, n, r) ? ++u : s._PushElseInstance(a3);\n      }\n      h.truncateArray(i, u), s.SetArrayPicked(i);\n      const l = !!i.length;\n      return h.clearArray(i), a.Pop(), e.ApplySolToContainer(), l;\n    }, PickByEvaluate(e, t) {\n      if (!e) return false;\n      const n = this._GetForEachStack(), r = n.Push(), a = e.GetCurrentSol();\n      h.shallowAssignArray(r, a.GetInstances()), a.IsSelectAll() && h.clearArray(a._GetOwnElseInstances());\n      const i = this._runtime.GetCurrentCondition();\n      let s = 0;\n      for (let e2 = 0, t2 = r.length; e2 < t2; ++e2) {\n        const t3 = r[e2];\n        r[s] = t3, i.ReevaluateParameter(1, e2) ? ++s : a._PushElseInstance(t3);\n      }\n      h.truncateArray(r, s), a.SetArrayPicked(r);\n      const o = !!r.length;\n      return h.clearArray(r), n.Pop(), e.ApplySolToContainer(), o;\n    }, PickByHighestLowestValue(e, t, n) {\n      if (!e) return false;\n      const r = e.GetCurrentSol(), a = r.GetInstances();\n      if (0 === a.length) return false;\n      const i = this._runtime.GetCurrentCondition();\n      let s = null, o = 0;\n      for (let e2 = 0, r2 = a.length; e2 < r2; ++e2) {\n        const r3 = a[e2];\n        n = i.ReevaluateParameter(2, e2), (null === s || 0 === t && n < o || 1 === t && n > o) && (o = n, s = r3);\n      }\n      return r.PickOne(s), e.ApplySolToContainer(), true;\n    }, PickNth(e, t) {\n      if (!e) return false;\n      const n = e.GetCurrentSol(), r = n.GetInstances();\n      if ((t = Math.floor(t)) >= r.length) return false;\n      const a = r[t];\n      return n.PickOne(a), e.ApplySolToContainer(), true;\n    }, PickRandom(e) {\n      if (!e) return false;\n      const t = e.GetCurrentSol(), n = t.GetInstances(), r = Math.floor(this._runtime.Random() * n.length);\n      if (r >= n.length) return false;\n      const a = n[r];\n      return t.PickOne(a), e.ApplySolToContainer(), true;\n    }, PickAll(e) {\n      if (!e) return false;\n      if (!e.GetInstanceCount()) return false;\n      return e.GetCurrentSol()._SetSelectAll(true), e.ApplySolToContainer(), true;\n    }, PickOverlappingPoint(e, t, n) {\n      if (!e) return false;\n      const r = e.GetCurrentSol(), a = r.GetInstances(), i = this._runtime.GetCurrentEvent().IsOrBlock(), s = this._runtime.GetCurrentCondition().IsInverted();\n      r.IsSelectAll() ? (h.shallowAssignArray(g, a), r.ClearArrays(), r._SetSelectAll(false)) : i ? (h.shallowAssignArray(g, r._GetOwnElseInstances()), h.clearArray(r._GetOwnElseInstances())) : (h.shallowAssignArray(g, r._GetOwnInstances()), h.clearArray(r._GetOwnInstances()));\n      for (let e2 = 0, a2 = g.length; e2 < a2; ++e2) {\n        const a3 = g[e2];\n        h.xor(a3.GetWorldInfo().ContainsPoint(t, n), s) ? r._PushInstance(a3) : r._PushElseInstance(a3);\n      }\n      return e.ApplySolToContainer(), h.xor(!!r._GetOwnInstances().length, s);\n    }, PickLastCreated(e) {\n      if (!e) return false;\n      const t = e.IsFamily();\n      let n = null;\n      const r = this._runtime._GetInstancesPendingCreate();\n      for (let a = r.length - 1; a >= 0; --a) {\n        const i = r[a];\n        if (t) {\n          if (i.GetObjectClass().BelongsToFamily(e)) {\n            n = i;\n            break;\n          }\n        } else if (i.GetObjectClass() === e) {\n          n = i;\n          break;\n        }\n      }\n      if (!n) {\n        const t2 = e.GetInstances();\n        t2.length && (n = t2.at(-1));\n      }\n      if (!n) return false;\n      return e.GetCurrentSol().PickOne(n), e.ApplySolToContainer(), true;\n    }, Repeat(e) {\n      return this._runtime.IsDebugging() ? this._DebugRepeat(e) : this._Repeat(e);\n    }, While() {\n      return this._runtime.IsDebugging() ? this._DebugWhile() : this._While();\n    }, For(e, t, n) {\n      return this._runtime.IsDebugging() ? this._DebugFor(e, t, n) : this._For(e, t, n);\n    }, ForEach(e) {\n      return this._runtime.IsDebugging() ? this._DebugForEach(e) : this._ForEach(e);\n    }, ForEachOrdered(e, t, n) {\n      return this._runtime.IsDebugging() ? this._DebugForEachOrdered(e, n) : this._ForEachOrdered(e, n);\n    }, LayerVisible: (e) => !!e && e.IsVisible(), LayerInteractive: (e) => !!e && e.IsSelfAndParentsInteractive(), LayerIsHTML: (e) => !!e && e.IsHTMLElementsLayer(), LayerEmpty: (e) => !!e && !e.GetInstanceCount(), LayerCmpOpacity: (e, t, n) => !!e && h.compare(100 * e.GetOpacity(), t, n), LayerNameExists(e) {\n      const t = this._runtime.GetMainRunningLayout();\n      return !!t && t.HasLayerByName(e);\n    }, OnImageLoadingComplete: () => true, IsLoadingImages() {\n      return this._imagesLoadingTotal > 0;\n    }, TemplateExists(e, t) {\n      const n = this._runtime.GetTemplateManager();\n      return !!n && (!!t && !!n.GetTemplateData(e, t));\n    } };\n  }\n  {\n    let SortZOrderList = function(e, t) {\n      const n = e[0] - t[0];\n      if (0 !== n) return n;\n      return e[1] - t[1];\n    }, SortInstancesByValue = function(e, t) {\n      return e[1] - t[1];\n    };\n    SortZOrderList2 = SortZOrderList, SortInstancesByValue2 = SortInstancesByValue;\n    const S = self.C3;\n    const d = [], p = [], m = S.New(S.Rect), G = S.New(S.Color), y = [];\n    S.Plugins.System.Acts = { SetVar(e, t) {\n      e.SetValue(t);\n    }, AddVar(e, t) {\n      e.IsNumber() && \"number\" != typeof t && (t = parseFloat(t)), e.SetValue(e.GetValue() + t);\n    }, SubVar(e, t) {\n      e.IsNumber() && e.SetValue(e.GetValue() - t);\n    }, SetBoolVar(e, t) {\n      e.SetValue(!!t);\n    }, ToggleBoolVar(e) {\n      e.SetValue(!e.GetValue());\n    }, ResetEventVar(e) {\n      e.SetValue(e.GetInitialValue());\n    }, ResetGlobals(e) {\n      this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue(e);\n    }, CreateObject(e, t, n, r, a, i) {\n      if (!e || !t) return;\n      const s = this._runtime.CreateInstance(e, t, n, r, a, i);\n      if (!s) return;\n      a && t.SortAndAddInstancesByZIndex(s);\n      const o = this._runtime.GetEventSheetManager();\n      o.BlockFlushingInstances(true), s._TriggerOnCreatedOnSelfAndRelated(), o.BlockFlushingInstances(false);\n      const u = /* @__PURE__ */ new Map();\n      s.CollectInstancesToPick(u, e, a);\n      for (const [e2, t2] of u) e2.GetCurrentSol().SetSetPicked(t2);\n    }, CreateObjectByName(e, t, n, r, a, i) {\n      if (!e || !t) return;\n      const s = this._runtime.GetObjectClassByName(e);\n      s && S.Plugins.System.Acts.CreateObject.call(this, s, t, n, r, a, i);\n    }, RecreateInitialObjects(e, t, n, r, a, i, s, o, u, l, c) {\n      if (!e) return;\n      const h = this._runtime.GetCurrentLayout();\n      let g = h;\n      if (i) {\n        const e2 = this._runtime.GetLayoutManager().GetLayoutByName(i);\n        if (!e2) return;\n        g = e2;\n      }\n      let S2 = null;\n      if ((\"number\" != typeof s || s >= 0) && (S2 = g.GetLayer(s), !S2)) return;\n      let d2 = null;\n      if ((\"number\" != typeof o || o >= 0) && (d2 = h.GetLayer(o), !d2)) return;\n      m.set(t, n, r, a);\n      const p2 = g.RecreateInitialObjects(e, m, S2, d2, u, l, c);\n      e.GetCurrentSol().SetArrayPicked(p2), e.ApplySolToContainer();\n    }, StopLoop() {\n      const e = this._loopStack;\n      e.IsInLoop() && e.GetCurrent().Stop();\n    }, SetGroupActive(e, t) {\n      const n = this._runtime.GetEventSheetManager().GetEventGroupByName(e);\n      n && (0 === t ? n.SetGroupActive(false) : 1 === t ? n.SetGroupActive(true) : n.SetGroupActive(!n.IsGroupActive()));\n    }, SetTimescale(e) {\n      this._runtime.SetTimeScale(e);\n    }, SetObjectTimescale(e, t) {\n      if (t < 0 && (t = 0), !e) return;\n      const n = e.GetCurrentSol().GetInstances();\n      for (const e2 of n) e2.SetTimeScale(t);\n    }, RestoreObjectTimescale(e) {\n      if (!e) return;\n      const t = e.GetCurrentSol().GetInstances();\n      for (const e2 of t) e2.RestoreTimeScale();\n    }, Wait(e, t) {\n      if (e < 0) return;\n      const n = this._runtime.GetEventSheetManager().AddScheduledWait();\n      return t ? n.InitTimer(e) : n.InitWallTimer(e), true;\n    }, WaitForSignal(e) {\n      return this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(e), true;\n    }, WaitForPreviousActions() {\n      const e = this._runtime.GetEventSheetManager();\n      return e.AddScheduledWait().InitPromise(e.GetPromiseForAllAsyncActions()), true;\n    }, Signal(e) {\n      this._runtime.GetEventSheetManager().Signal(e);\n    }, async SnapshotCanvas(e, t, n, r, a, i) {\n      const s = this._runtime.GetCanvasManager();\n      s && (this.UpdateRender(), await s.SnapshotCanvas(0 === e ? \"image/png\" : \"image/jpeg\", t / 100, n, r, a, i), await this._runtime.TriggerAsync(S.Plugins.System.Cnds.OnCanvasSnapshot, null));\n    }, SetCanvasSize(e, t) {\n      if (e <= 0 || t <= 0) return;\n      this._runtime.SetViewportSize(e, t), this._runtime.GetCurrentLayout().BoundScrolling();\n      const n = this._runtime.GetCanvasManager();\n      n && (\"off\" === n.GetCurrentFullscreenMode() || this._runtime.SetOriginalViewportSize(e, t), n.SetSize(n.GetLastWidth(), n.GetLastHeight(), true), this._runtime.UpdateRender());\n    }, SetFullscreenQuality(e) {\n      const t = this._runtime.GetCanvasManager();\n      t && \"off\" !== t.GetCurrentFullscreenMode() && (t.SetFullscreenScalingQuality(0 !== e ? \"high\" : \"low\"), t.SetSize(t.GetLastWidth(), t.GetLastHeight(), true));\n    }, SaveState(e) {\n      this._runtime.SaveToSlot(e);\n    }, SaveStateJSON() {\n      this._runtime.SaveToJsonString();\n    }, LoadState(e) {\n      this._runtime.LoadFromSlot(e);\n    }, LoadStateJSON(e) {\n      this._runtime.LoadFromJsonString(e);\n    }, SetHalfFramerateMode(e) {\n    }, ResetPersisted() {\n      for (const e of this._runtime.GetLayoutManager().GetAllLayouts()) e.ResetPersistData();\n    }, SetPixelRounding(e) {\n      this._runtime.SetPixelRoundingEnabled(0 !== e);\n    }, SetFramerateMinMax(e, t) {\n      this._runtime.SetMaxDt(1 / e), this._runtime.SetMinDt(1 / t);\n    }, SetDeltaTimeMinMax(e, t) {\n      this._runtime.SetMinDt(e), this._runtime.SetMaxDt(t);\n    }, SetFramerateMode(e) {\n      this._runtime._SetFramerateMode([\"vsync\", \"unlimited-tick\", \"unlimited-frame\"][e]);\n    }, SortZOrderByInstVar(e, t) {\n      if (!e) return;\n      const n = e.GetCurrentSol().GetInstances(), r = d, a = p, i = this._runtime.GetCurrentLayout(), s = e.IsFamily(), o = e.GetFamilyIndex();\n      for (let e2 = 0, i2 = n.length; e2 < i2; ++e2) {\n        const i3 = n[e2], u2 = i3.GetWorldInfo();\n        if (!u2) continue;\n        let l;\n        l = s ? i3.GetInstanceVariableValue(t + i3.GetObjectClass().GetFamilyInstanceVariableOffset(o)) : i3.GetInstanceVariableValue(t), r.push([u2.GetLayer().GetIndex(), u2.GetZIndex()]), a.push([i3, l]);\n      }\n      if (!r.length) return;\n      r.sort(SortZOrderList), a.sort(SortInstancesByValue);\n      let u = false;\n      for (let e2 = 0, t2 = r.length; e2 < t2; ++e2) {\n        const t3 = a[e2][0], n2 = i.GetLayerByIndex(r[e2][0]), s2 = r[e2][1], o2 = n2._GetInstances();\n        o2[s2] !== t3 && (o2[s2] = t3, t3.GetWorldInfo()._SetLayer(n2, true), n2.SetZIndicesChanged(t3), u = true);\n      }\n      u && this._runtime.UpdateRender(), S.clearArray(d), S.clearArray(p);\n    }, SetCollisionCellSize(e, t) {\n      e = Math.floor(e), t = Math.floor(t), e <= 0 || t <= 0 || !Number.isFinite(e) || !Number.isFinite(t) || this._runtime.GetCollisionEngine().SetCollisionCellSize(e, t);\n    }, GoToLayout(e) {\n      if (this._runtime.IsLoading()) return;\n      const t = this._runtime.GetLayoutManager();\n      t.IsPendingChangeMainLayout() || t.ChangeMainLayout(e);\n    }, GoToLayoutByName(e) {\n      if (this._runtime.IsLoading()) return;\n      const t = this._runtime.GetLayoutManager();\n      if (t.IsPendingChangeMainLayout()) return;\n      const n = t.GetLayoutByName(e);\n      n && t.ChangeMainLayout(n);\n    }, NextPrevLayout(e) {\n      if (this._runtime.IsLoading()) return;\n      const t = this._runtime.GetLayoutManager();\n      if (t.IsPendingChangeMainLayout()) return;\n      const n = t.GetAllLayouts(), r = n.indexOf(t.GetMainRunningLayout());\n      if (e && 0 === r) return;\n      if (!e && r === n.length - 1) return;\n      const a = n[r + (e ? -1 : 1)];\n      t.ChangeMainLayout(a);\n    }, RestartLayout() {\n      if (this._runtime.IsLoading()) return;\n      const e = this._runtime.GetLayoutManager();\n      e.IsPendingChangeMainLayout() || (e.ChangeMainLayout(e.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation());\n    }, SetLayerVisible(e, t) {\n      e && e.SetVisible(t);\n    }, SetLayerInteractive(e, t) {\n      e && e.SetInteractive(t);\n    }, SetLayerHTML(e, t) {\n      e && e.SetIsHTMLElementsLayer(t);\n    }, SetLayerOpacity(e, t) {\n      e && e.SetOpacity(t / 100);\n    }, SetLayerScale(e, t) {\n      e && e.SetOwnScale(t);\n    }, SetLayerScaleRate(e, t) {\n      e && e.SetScaleRate(t);\n    }, SetLayerAngle(e, t) {\n      e && e.SetAngle(S.toRadians(+t));\n    }, SetLayerScroll(e, t, n) {\n      e && (e.SetOwnScrollPositionEnabled(true), e.SetScrollX(t), e.SetScrollY(n));\n    }, RestoreLayerScroll(e) {\n      e && e.SetOwnScrollPositionEnabled(false);\n    }, SetLayerParallax(e, t, n) {\n      e && e.SetParallax(t / 100, n / 100);\n    }, SetLayerZElevation(e, t) {\n      e && e.SetZElevation(+t);\n    }, SetLayerRenderingMode(e, t) {\n      e && e.SetRenderAs3D(1 === t);\n    }, SetLayerBackground(e, t) {\n      if (!e) return;\n      G.setFromRgbValue(t), G.clamp();\n      const n = e.GetBackgroundColor();\n      n.equalsIgnoringAlpha(G) || (n.copyRgb(G), this.UpdateRender());\n    }, SetLayerTransparent(e, t) {\n      e && e.SetTransparent(t);\n    }, SetLayerBlendMode(e, t) {\n      e && e.SetBlendMode(t);\n    }, SetLayerEffectEnabled(e, t, n) {\n      if (!e) return;\n      const r = e.GetEffectList().GetEffectTypeByName(n);\n      if (!r) return;\n      const a = 1 === t;\n      r.IsActive() !== a && (r.SetActive(a), e.UpdateActiveEffects(), this._runtime.UpdateRender());\n    }, SetLayerEffectParam(e, t, n, r) {\n      if (!e) return;\n      const a = e.GetEffectList(), i = a.GetEffectTypeByName(t);\n      if (!i) return;\n      n = Math.floor(n);\n      const s = i.GetShaderProgram().GetParameterType(n);\n      if (!s) return;\n      \"color\" === s ? (G.setFromRgbValue(r), r = G) : \"percent\" === s && (r /= 100);\n      a.SetEffectParameter(i.GetIndex(), n, r) && i.IsActive() && this._runtime.UpdateRender();\n    }, SetLayerForceOwnTexture(e, t) {\n      e && e.SetForceOwnTexture(t);\n    }, SetLayoutScale(e) {\n      this._runtime.GetCurrentLayout().SetScale(+e);\n    }, SetLayoutAngle(e) {\n      this._runtime.GetCurrentLayout().SetAngle(S.toRadians(+e));\n    }, SetLayoutEffectEnabled(e, t) {\n      const n = this._runtime.GetCurrentLayout(), r = n.GetEffectList().GetEffectTypeByName(t);\n      if (!r) return;\n      const a = 1 === e;\n      r.IsActive() !== a && (r.SetActive(a), n.UpdateActiveEffects(), this._runtime.UpdateRender());\n    }, SetLayoutEffectParam(e, t, n) {\n      const r = this._runtime.GetCurrentLayout().GetEffectList(), a = r.GetEffectTypeByName(e);\n      if (!a) return;\n      t = Math.floor(t);\n      const i = a.GetShaderProgram().GetParameterType(t);\n      if (!i) return;\n      \"color\" === i ? (G.setFromRgbValue(n), n = G) : \"percent\" === i && (n /= 100);\n      r.SetEffectParameter(a.GetIndex(), t, n) && a.IsActive() && this._runtime.UpdateRender();\n    }, SetLayoutVanishingPoint(e, t) {\n      this._runtime.GetCurrentLayout().SetVanishingPointXY(e / 100, t / 100);\n    }, SetLayoutProjection(e) {\n      const t = this._runtime.GetCurrentLayout();\n      0 === e ? t.SetPerspectiveProjection() : t.SetOrthographicProjection();\n    }, ScrollX(e) {\n      this._runtime.GetCurrentLayout().SetScrollX(e);\n    }, ScrollY(e) {\n      this._runtime.GetCurrentLayout().SetScrollY(e);\n    }, Scroll(e, t) {\n      const n = this._runtime.GetCurrentLayout();\n      n.SetScrollX(e), n.SetScrollY(t);\n    }, ScrollToObject(e) {\n      if (!e) return;\n      const t = e.GetFirstPicked();\n      if (!t) return;\n      const n = t.GetWorldInfo();\n      if (!n) return;\n      const r = this._runtime.GetCurrentLayout();\n      r.SetScrollX(n.GetX()), r.SetScrollY(n.GetY());\n    }, AddLayer(e, t, n) {\n      const r = this._runtime.GetCurrentLayout();\n      try {\n        r.AddLayer(e, t, n);\n      } catch (e2) {\n        console.warn(\"[Construct] Cannot add layer: \", e2);\n      }\n    }, MoveLayer(e, t, n) {\n      if (!e) return;\n      const r = this._runtime.GetCurrentLayout();\n      try {\n        r.MoveLayer(e, t, n);\n      } catch (e2) {\n        console.warn(\"[Construct] Cannot move layer: \", e2);\n      }\n    }, RemoveLayer(e) {\n      if (!e) return;\n      this._runtime.GetCurrentLayout().RemoveLayer(e);\n    }, RemoveAllDynamicLayers() {\n      this._runtime.GetCurrentLayout().RemoveAllDynamicLayers();\n    }, async LoadObjectTextures(e) {\n      const t = this._runtime.GetMainRunningLayout();\n      if (!t || !e || this._runtime.IsLoading()) return;\n      const n = e.IsFamily() ? e.GetFamilyMembers() : [e];\n      await this._LoadTexturesForObjectClasses(t, n);\n    }, async LoadObjectTexturesByName(e) {\n      await S.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));\n    }, UnloadObjectTextures(e) {\n      const t = this._runtime.GetMainRunningLayout();\n      if (!t || !e) return;\n      const n = e.IsFamily() ? e.GetFamilyMembers() : [e];\n      this._UnloadTexturesForObjectClasses(t, n);\n    }, UnloadObjectTexturesByName(e) {\n      S.Plugins.System.Acts.UnloadObjectTextures.call(this, this._runtime.GetObjectClassByName(e));\n    }, UnloadUnusedTextures() {\n      const e = this._runtime.GetMainRunningLayout();\n      if (!e) return;\n      const t = e._GetTextureLoadedObjectTypes();\n      this._UnloadTexturesForObjectClasses(e, t);\n    }, async LoadLayoutTextures(e) {\n      const t = this._runtime.GetMainRunningLayout();\n      e && t && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t, e._GetInitialObjectClasses());\n    }, async LoadLayoutTexturesByName(e) {\n      const t = this._runtime.GetMainRunningLayout(), n = this._runtime.GetLayoutManager().GetLayoutByName(e);\n      n && t && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(t, n._GetInitialObjectClasses());\n    }, SetFunctionReturnValue(e) {\n      const t = this._eventStack.GetCurrentExpFuncStackFrame();\n      if (t) switch (t.GetFunctionReturnType()) {\n        case 1:\n          \"number\" == typeof e && t.SetFunctionReturnValue(e);\n          break;\n        case 2:\n          \"string\" == typeof e && t.SetFunctionReturnValue(e);\n          break;\n        case 3:\n          t.SetFunctionReturnValue(e);\n      }\n    }, MapFunction(e, t, n) {\n      const r = this._GetFunctionMap(e.toLowerCase(), true), a = r.strMap, i = t.toLowerCase();\n      a.has(i) && console.warn(`[Construct] Function map '${e}' string '${t}' already in map; overwriting entry`);\n      const s = S.first(a.values()) || r.defaultFunc;\n      if (s) {\n        if (0 !== s.GetReturnType() !== (0 !== n.GetReturnType())) return void console.error(`[Construct] Function map '${e}' string '${t}' function return type not compatible with other functions in the map; entry ignored`);\n      }\n      a.set(i, n);\n    }, MapFunctionDefault(e, t) {\n      const n = this._GetFunctionMap(e.toLowerCase(), true);\n      n.defaultFunc && console.warn(`[Construct] Function map '${e}' already has a default; overwriting entry`);\n      const r = S.first(n.strMap.values()) || n.defaultFunc;\n      if (r) {\n        if (0 !== r.GetReturnType() !== (0 !== t.GetReturnType())) return void console.error(`[Construct] Function map '${e}' default: function return type not compatible with other functions in the map; entry ignored`);\n      }\n      n.defaultFunc = t;\n    }, CallMappedFunction(e, t, n) {\n      const r = this._runtime, a = r.IsDebugging() ? y : null;\n      n = Math.floor(n);\n      const i = this._GetFunctionMap(e.toLowerCase(), false);\n      if (!i) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; call ignored`), a;\n      let s = i.strMap.get(t.toLowerCase());\n      if (!s) {\n        if (!i.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t}'; call ignored (consider setting a default)`), a;\n        s = i.defaultFunc, n = 0;\n      }\n      if (!s.IsEnabled()) return a;\n      if (0 !== s.GetReturnType()) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t}' has a return type so cannot be called`), a;\n      const o = r.GetEventSheetManager(), u = o.GetCurrentEvent(), l = u.GetSolModifiersIncludingParents(), c = l.length > 0;\n      c && (s.IsCopyPicked() ? o.PushCopySol(l) : o.PushCleanSol(l));\n      const h = [], g = o.FindFirstFunctionBlockParent(u);\n      if (g) {\n        const e2 = g.GetFunctionParameters();\n        for (let t2 = n, r2 = e2.length; t2 < r2; ++t2) h.push(e2[t2].GetValue());\n      }\n      const S2 = s.GetFunctionParameters();\n      for (let e2 = h.length, t2 = S2.length; e2 < t2; ++e2) h.push(S2[e2].GetInitialValue());\n      return r.IsDebugging() ? this._DebugDoCallMappedFunction(o, s, h, c, l) : this._DoCallMappedFunction(o, s, h, c, l);\n    } };\n  }\n  {\n    const f = self.C3;\n    f.Plugins.System.Exps = { int: function(e) {\n      return \"string\" == typeof e && (e = parseInt(e, 10), isNaN(e) && (e = 0)), Math.floor(e);\n    }, float: function(e) {\n      return \"string\" == typeof e && (e = parseFloat(e), isNaN(e) && (e = 0)), e;\n    }, str: (e) => e.toString(), len: (e) => \"string\" == typeof e ? e.length : 0, random(e, t) {\n      return void 0 === t ? this._runtime.Random() * e : this._runtime.Random() * (t - e) + e;\n    }, choose(...e) {\n      return e[Math.floor(this._runtime.Random() * e.length)];\n    }, chooseindex: (e, ...t) => (\"number\" != typeof e && (e = 0), t[e = f.clamp(Math.floor(e), 0, t.length - 1)]), pi: () => Math.PI, infinity: () => 1 / 0, sqrt: (e) => Math.sqrt(e), abs: (e) => Math.abs(e), round: (e) => Math.round(e), roundtodp(e, t) {\n      t = Math.max(Math.floor(t), 0);\n      const n = Math.pow(10, t);\n      return Math.round((e + Number.EPSILON) * n) / n;\n    }, floor: (e) => Math.floor(e), ceil: (e) => Math.ceil(e), sign: (e) => Math.sign(e), sin: (e) => Math.sin(f.toRadians(e)), cos: (e) => Math.cos(f.toRadians(e)), tan: (e) => Math.tan(f.toRadians(e)), asin: (e) => f.toDegrees(Math.asin(e)), acos: (e) => f.toDegrees(Math.acos(e)), atan: (e) => f.toDegrees(Math.atan(e)), exp: (e) => Math.exp(e), ln: (e) => Math.log(e), log10: (e) => Math.log10(e), max(...e) {\n      let t = e[0];\n      \"number\" != typeof t && (t = 0);\n      for (let n = 1, r = e.length; n < r; ++n) {\n        let r2 = e[n];\n        \"number\" == typeof r2 && (t < r2 && (t = r2));\n      }\n      return t;\n    }, min(...e) {\n      let t = e[0];\n      \"number\" != typeof t && (t = 0);\n      for (let n = 1, r = e.length; n < r; ++n) {\n        let r2 = e[n];\n        \"number\" == typeof r2 && (t > r2 && (t = r2));\n      }\n      return t;\n    }, clamp: (e, t, n) => f.clamp(e, t, n), distance: (e, t, n, r) => f.distanceTo(e, t, n, r), angle: (e, t, n, r) => f.toDegrees(f.angleTo(e, t, n, r)), lerp: (e, t, n) => f.lerp(e, t, n), unlerp: (e, t, n) => f.unlerp(e, t, n), qarp: (e, t, n, r) => f.qarp(e, t, n, r), cubic: (e, t, n, r, a) => f.cubic(e, t, n, r, a), cosp: (e, t, n) => f.cosp(e, t, n), anglediff: (e, t) => f.toDegrees(f.angleDiff(f.toRadians(e), f.toRadians(t))), anglelerp: (e, t, n) => f.toDegrees(f.angleLerp(f.toRadians(e), f.toRadians(t), n)), anglerotate: (e, t, n) => f.toDegrees(f.angleRotate(f.toRadians(e), f.toRadians(t), f.toRadians(n))), setbit: (e, t, n) => (e |= 0) & ~(1 << (t |= 0)) | (n = 0 !== n ? 1 : 0) << t, togglebit: (e, t) => (e |= 0) ^ 1 << (t |= 0), getbit: (e, t) => (e |= 0) & 1 << (t |= 0) ? 1 : 0, newline: () => \"\\n\", uppercase: (e) => \"string\" == typeof e ? e.toUpperCase() : \"\", lowercase: (e) => \"string\" == typeof e ? e.toLowerCase() : \"\", left: (e, t) => \"string\" == typeof e ? e.substr(0, t) : \"\", mid: (e, t, n) => \"string\" != typeof e ? \"\" : n < 0 ? e.substr(t) : e.substr(t, n), right: (e, t) => \"string\" == typeof e ? e.substr(Math.max(e.length - t, 0)) : \"\", trim: (e) => \"string\" == typeof e ? e.trim() : \"\", tokenat(e, t, n) {\n      if (\"string\" != typeof e || \"string\" != typeof n) return \"\";\n      let r = e.split(n);\n      return (t = Math.floor(t)) < 0 || t >= r.length ? \"\" : r[t];\n    }, tokencount: (e, t) => \"string\" == typeof e && \"string\" == typeof t && e.length ? e.split(t).length : 0, find: (e, t) => \"string\" == typeof e && \"string\" == typeof t ? e.search(new RegExp(f.EscapeRegex(t), \"i\")) : -1, findcase: (e, t) => \"string\" == typeof e && \"string\" == typeof t ? e.search(new RegExp(f.EscapeRegex(t), \"\")) : -1, replace: (e, t, n) => \"string\" == typeof e && \"string\" == typeof t && \"string\" == typeof n ? e.replace(new RegExp(f.EscapeRegex(t), \"gi\"), n) : \"string\" == typeof e ? e : \"\", stringsub(e, ...t) {\n      let n = e;\n      for (let e2 = 0, r = t.length; e2 < r; ++e2) n = n.replaceAll(`{${e2}}`, t[e2].toString());\n      return n;\n    }, regexsearch(e, t, n) {\n      const r = this.GetRegex(t, n);\n      return e ? e.search(r) : -1;\n    }, regexreplace(e, t, n, r) {\n      const a = this.GetRegex(t, n);\n      return e ? e.replace(a, r) : \"\";\n    }, regexmatchcount(e, t, n) {\n      const r = this.GetRegexMatches(e.toString(), t, n);\n      return r ? r.length : 0;\n    }, regexmatchat(e, t, n, r) {\n      r = Math.floor(r);\n      const a = this.GetRegexMatches(e.toString(), t, n);\n      return !a || r < 0 || r >= a.length ? \"\" : a[r];\n    }, zeropad(e, t) {\n      let n = e < 0 ? \"-\" : \"\";\n      e < 0 && (e = -e);\n      const r = t - e.toString().length;\n      return n += \"0\".repeat(Math.max(r, 0)), n + e.toString();\n    }, urlencode: (e) => encodeURIComponent(e), urldecode: (e) => decodeURIComponent(e), dt() {\n      return this._runtime._GetDtFast();\n    }, wallclockdt() {\n      return this._runtime.GetDt1();\n    }, timescale() {\n      return this._runtime.GetTimeScale();\n    }, wallclocktime() {\n      return (Date.now() - this._runtime.GetStartTime()) / 1e3;\n    }, unixtime: () => Date.now(), time() {\n      return this._runtime.GetGameTime();\n    }, tickcount() {\n      return this._runtime.GetTickCount();\n    }, objectcount() {\n      return this._runtime.GetObjectCount();\n    }, fps() {\n      return this._runtime.GetFramesPerSecond();\n    }, cpuutilisation() {\n      return this._runtime.GetMainThreadTime();\n    }, gpuutilisation() {\n      return this._runtime.GetGPUUtilisation();\n    }, windowwidth() {\n      return this._runtime.GetCanvasManager().GetDeviceWidth();\n    }, windowheight() {\n      return this._runtime.GetCanvasManager().GetDeviceHeight();\n    }, originalwindowwidth() {\n      return this._runtime.GetOriginalViewportWidth();\n    }, originalwindowheight() {\n      return this._runtime.GetOriginalViewportHeight();\n    }, originalviewportwidth() {\n      return this._runtime.GetOriginalViewportWidth();\n    }, originalviewportheight() {\n      return this._runtime.GetOriginalViewportHeight();\n    }, scrollx() {\n      return this._runtime.GetCurrentLayout().GetScrollX();\n    }, scrolly() {\n      return this._runtime.GetCurrentLayout().GetScrollY();\n    }, layoutname() {\n      return this._runtime.GetCurrentLayout().GetName();\n    }, layoutscale() {\n      return this._runtime.GetCurrentLayout().GetScale();\n    }, layoutangle() {\n      return f.toDegrees(this._runtime.GetCurrentLayout().GetAngle());\n    }, layoutwidth() {\n      return this._runtime.GetCurrentLayout().GetWidth();\n    }, layoutheight() {\n      return this._runtime.GetCurrentLayout().GetHeight();\n    }, vanishingpointx() {\n      return 100 * this._runtime.GetCurrentLayout().GetVanishingPointX();\n    }, vanishingpointy() {\n      return 100 * this._runtime.GetCurrentLayout().GetVanishingPointY();\n    }, viewportleft(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().getLeft() : 0;\n    }, viewporttop(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().getTop() : 0;\n    }, viewportright(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().getRight() : 0;\n    }, viewportbottom(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().getBottom() : 0;\n    }, viewportwidth(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().width() : 0;\n    }, viewportheight(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetViewport3D().height() : 0;\n    }, viewportmidx(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      if (t) {\n        const e2 = t.GetViewport3D();\n        return (e2.getLeft() + e2.getRight()) / 2;\n      }\n      return 0;\n    }, viewportmidy(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      if (t) {\n        const e2 = t.GetViewport3D();\n        return (e2.getTop() + e2.getBottom()) / 2;\n      }\n      return 0;\n    }, canvastolayerx(e, t, n) {\n      const r = this._runtime.GetCurrentLayout().GetLayer(e);\n      return r ? r.CanvasCssToLayer(t, n)[0] : 0;\n    }, canvastolayery(e, t, n) {\n      const r = this._runtime.GetCurrentLayout().GetLayer(e);\n      return r ? r.CanvasCssToLayer(t, n)[1] : 0;\n    }, layertocanvasx(e, t, n) {\n      const r = this._runtime.GetCurrentLayout().GetLayer(e);\n      return r ? r.LayerToCanvasCss(t, n)[0] : 0;\n    }, layertocanvasy(e, t, n) {\n      const r = this._runtime.GetCurrentLayout().GetLayer(e);\n      return r ? r.LayerToCanvasCss(t, n)[1] : 0;\n    }, layertolayerx(e, t, n, r) {\n      const a = this._runtime.GetCurrentLayout(), i = a.GetLayer(e), s = a.GetLayer(t);\n      if (!i || !s || i === s) return n;\n      const [o, u] = i.LayerToCanvasCss(n, r);\n      return s.CanvasCssToLayer(o, u)[0];\n    }, layertolayery(e, t, n, r) {\n      const a = this._runtime.GetCurrentLayout(), i = a.GetLayer(e), s = a.GetLayer(t);\n      if (!i || !s || i === s) return r;\n      const [o, u] = i.LayerToCanvasCss(n, r);\n      return s.CanvasCssToLayer(o, u)[1];\n    }, layerscale(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetOwnScale() : 0;\n    }, layerangle(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? f.toDegrees(t.GetOwnAngle()) : 0;\n    }, layeropacity(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? 100 * t.GetOpacity() : 0;\n    }, layerscalerate(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetScaleRate() : 0;\n    }, layerscrollx(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetScrollX() : 0;\n    }, layerscrolly(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetScrollY() : 0;\n    }, layerparallaxx(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? 100 * t.GetParallaxX() : 0;\n    }, layerparallaxy(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? 100 * t.GetParallaxY() : 0;\n    }, layerzelevation(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetZElevation() : 0;\n    }, layerindex(e) {\n      const t = this._runtime.GetCurrentLayout().GetLayer(e);\n      return t ? t.GetIndex() : -1;\n    }, canvassnapshot() {\n      const e = this._runtime.GetCanvasManager();\n      return e ? e.GetCanvasSnapshotUrl() : \"\";\n    }, loopindex(e) {\n      const t = this._loopStack;\n      if (!t.IsInLoop()) return 0;\n      if (e) {\n        const n = t.FindByName(e);\n        return n ? n.GetIndex() : 0;\n      }\n      return t.GetCurrent().GetIndex();\n    }, savestatejson() {\n      return this._runtime.GetLastSaveJsonString();\n    }, callmapped(e, t, ...n) {\n      const r = this._GetFunctionMap(e.toLowerCase(), false);\n      if (!r) return console.warn(`[Construct] Call mapped function: map name '${e}' not found; returning 0`), 0;\n      let a = r.strMap.get(t.toLowerCase());\n      if (!a) {\n        if (!r.defaultFunc) return console.warn(`[Construct] Call mapped function: no function associated with map '${e}' string '${t}'; returning 0 (consider setting a default)`), 0;\n        a = r.defaultFunc;\n      }\n      const i = a.GetReturnType(), s = a.GetDefaultReturnValue();\n      if (0 === i) return console.warn(`[Construct] Call mapped function: map '${e}' string '${t}' has no return type so cannot be called from an expression; returning 0`), 0;\n      if (!a.IsEnabled()) return s;\n      const o = this._runtime.GetEventSheetManager(), u = o.GetCurrentEvent().GetSolModifiersIncludingParents(), l = u.length > 0;\n      l && (a.IsCopyPicked() ? o.PushCopySol(u) : o.PushCleanSol(u));\n      const c = a.GetFunctionParameters();\n      for (let e2 = n.length, t2 = c.length; e2 < t2; ++e2) n.push(c[e2].GetInitialValue());\n      const h = a.GetEventBlock(), g = h.RunAsExpressionFunctionCall(h.GetSolModifiersIncludingParents(), a.IsCopyPicked(), i, s, ...n);\n      return l && o.PopSol(u), g;\n    }, loadingprogress() {\n      return this._runtime.GetAssetManager().GetLoadProgress();\n    }, imageloadingprogress() {\n      return this.GetImageLoadingProgress();\n    }, renderer() {\n      return this._runtime.GetWebGPURenderer() ? \"webgpu\" : \"webgl\";\n    }, rendererdetail() {\n      return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer();\n    }, imagememoryusage() {\n      let e = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();\n      return Math.round(100 * e / 1048576) / 100;\n    }, rgb: (e, t, n) => f.PackRGB(e, t, n), rgbex: (e, t, n) => f.PackRGBEx(e / 100, t / 100, n / 100), rgba: (e, t, n, r) => f.PackRGBAEx(e / 100, t / 100, n / 100, r / 100), rgbex255: (e, t, n) => f.PackRGBEx(e / 255, t / 255, n / 255), rgba255: (e, t, n, r) => f.PackRGBAEx(e / 255, t / 255, n / 255, r / 255), projectname() {\n      return this._runtime.GetProjectName();\n    }, projectversion() {\n      return this._runtime.GetProjectVersion();\n    }, projectid() {\n      return this._runtime.GetAppId();\n    }, projectuniqueid() {\n      return this._runtime.GetProjectUniqueId();\n    }, currenteventsheetname() {\n      return this._runtime.GetCurrentEvent().GetEventSheet().GetName();\n    }, currenteventnumber() {\n      return this._runtime.GetCurrentEvent().GetDisplayNumber();\n    } };\n  }\n}\nvar ForEachOrdered_SortInstances2;\nvar SortZOrderList2;\nvar SortInstancesByValue2;\n{\n  {\n    const t = self.C3;\n    t.Plugins.Sprite = class extends t.SDKPluginBase {\n      constructor(t2) {\n        super(t2);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const t = self.C3, e = self.C3X, n = [];\n    t.Plugins.Sprite.Type = class extends t.SDKTypeBase {\n      constructor(t2) {\n        super(t2), this._animations = t2.GetAnimations();\n      }\n      Release() {\n        t.clearArray(this._animations), super.Release();\n      }\n      OnCreate() {\n        for (const t2 of this._animations) t2.LoadAllAssets(this._runtime);\n      }\n      LoadTextures(t2) {\n        const e2 = { sampling: this._runtime.GetSampling() };\n        return Promise.all(this._animations.map((n2) => n2.LoadAllTextures(t2, e2)));\n      }\n      ReleaseTextures() {\n        for (const t2 of this._animations) t2.ReleaseAllTextures();\n      }\n      OnDynamicTextureLoadComplete() {\n        this._UpdateAllCurrentTexture();\n      }\n      _UpdateAllCurrentTexture() {\n        for (const t2 of this._objectClass.instancesIncludingPendingCreate()) t2.GetSdkInstance()._UpdateCurrentTexture();\n      }\n      FinishCondition(e2) {\n        t.Plugins.Sprite.FinishCollisionCondition(this, e2);\n      }\n      BeforeRunAction(t2) {\n        n.push({ objectClass: null, createHierarchy: false, instances: [] });\n      }\n      _SpawnPickInstance(t2, e2, i2) {\n        const r = n.at(-1);\n        r.objectClass = t2, r.createHierarchy = i2, r.instances.push(e2);\n      }\n      AfterRunAction(t2) {\n        const e2 = n.pop(), i2 = e2.objectClass, r = e2.createHierarchy;\n        if (!i2) return;\n        const a = /* @__PURE__ */ new Map();\n        for (const t3 of e2.instances) t3.CollectInstancesToPick(a, i2, r);\n        for (const [t3, e3] of a) t3.GetCurrentSol().SetSetPicked(e3);\n      }\n      _AddAnimation(t2) {\n        const e2 = this.GetObjectClass().AddAnimation(t2), n2 = this.GetRuntime();\n        return e2.GetFrameAt(0).GetImageInfo().LoadStaticTexture(n2.GetRenderer(), { sampling: n2.GetSampling() }).then(() => this._UpdateAllCurrentTexture()), e2;\n      }\n      _RemoveAnimation(t2) {\n        for (const e2 of this._objectClass.instancesIncludingPendingCreate()) e2.GetSdkInstance()._OnAnimationRemoved(t2);\n        this.GetObjectClass().RemoveAnimation(t2);\n      }\n      _AddAnimationFrame(e2, n2) {\n        const i2 = this._objectClass.GetAnimationByName(e2);\n        if (!i2) throw new Error(`cannot find animation name '${e2}'`);\n        let r = i2.FrameTagOrIndexToIndex(n2);\n        r < 0 && (r += i2.GetFrameCount() + 1);\n        const a = t.AnimationFrameInfo.CreateDynamic(this.GetRuntime());\n        i2.InsertFrameAt(a, r);\n        const s = this.GetRuntime();\n        a.GetImageInfo().LoadStaticTexture(s.GetRenderer(), { sampling: s.GetSampling() }).then(() => this._UpdateAllCurrentTexture());\n        for (const t2 of this._objectClass.instancesIncludingPendingCreate()) t2.GetSdkInstance()._OnAnimationFramesChanged();\n        return a;\n      }\n      _RemoveAnimationFrame(t2, e2) {\n        const n2 = this._objectClass.GetAnimationByName(t2);\n        if (!n2) throw new Error(`cannot find animation name '${t2}'`);\n        if (1 === n2.GetFrameCount()) throw new Error(`cannot remove last frame from animation '${t2}'`);\n        let i2 = n2.FrameTagOrIndexToIndex(e2);\n        i2 < 0 && (i2 += n2.GetFrameCount()), n2.RemoveFrameAt(i2);\n        for (const t3 of this._objectClass.instancesIncludingPendingCreate()) t3.GetSdkInstance()._OnAnimationFramesChanged();\n      }\n      GetScriptInterfaceClass() {\n        return self.ISpriteObjectType;\n      }\n    };\n    const i = /* @__PURE__ */ new WeakMap();\n    self.ISpriteObjectType = class extends self.IObjectType {\n      constructor(t2) {\n        super(t2), i.set(this, t2.GetSdkType());\n      }\n      getAnimation(t2) {\n        e.RequireString(t2);\n        const n2 = i.get(this).GetObjectClass().GetAnimationByName(t2);\n        return n2 ? n2.GetIAnimation() : null;\n      }\n      getAllAnimations() {\n        return i.get(this).GetObjectClass().GetAllAnimations().map((t2) => t2.GetIAnimation());\n      }\n      addAnimation(t2) {\n        return e.RequireString(t2), i.get(this)._AddAnimation(t2).GetIAnimation();\n      }\n      removeAnimation(t2) {\n        e.RequireString(t2), i.get(this)._RemoveAnimation(t2);\n      }\n      addAnimationFrame(t2, n2) {\n        if (e.RequireString(t2), \"number\" != typeof n2 && \"string\" != typeof n2) throw new TypeError(\"invalid insert location\");\n        return i.get(this)._AddAnimationFrame(t2, n2).GetIAnimationFrame();\n      }\n      removeAnimationFrame(t2, n2) {\n        if (e.RequireString(t2), \"number\" != typeof n2 && \"string\" != typeof n2) throw new TypeError(\"invalid insert location\");\n        i.get(this)._RemoveAnimationFrame(t2, n2);\n      }\n    };\n  }\n  {\n    const t = self.C3, e = self.C3X, n = 0, i = 1, r = 2, a = 3, s = t.New(t.Rect), o = t.New(t.Quad), m = t.New(t.Vector2), h = 1, u = 2, c = 4;\n    t.Plugins.Sprite.Instance = class extends t.SDKWorldInstanceBase {\n      constructor(e2, s2) {\n        super(e2);\n        let o2 = true, m2 = \"\", c2 = 0, l2 = true;\n        s2 && (o2 = !!s2[n], m2 = s2[i], c2 = s2[r], l2 = s2[a]), this._currentAnimation = this._objectClass.GetAnimationByName(m2) || this._objectClass.GetAnimations()[0], this._currentFrameIndex = t.clamp(c2, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n        const d2 = this._currentAnimationFrame.GetImageInfo();\n        this._currentTexture = d2.GetTexture(), this._currentRcTex = d2.GetTexRect(), this._currentQuadTex = d2.GetTexQuad(), this.HandleRendererContextLoss(), e2.SetFlag(u, true), e2.SetFlag(h, this._currentAnimation.GetSpeed() >= 0), this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed()), this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo(), this._animationTimer = t.New(t.KahanSum), this._frameStartTime = 0, this._animationRepeats = 0, this._animTriggerName = \"\", this._changeAnimFrameIndex = -1, this._changeAnimationName = \"\", this._changeAnimationFrom = 0;\n        const g = this.GetWorldInfo();\n        this._bquadRef = g.GetBoundingQuad(), g.SetVisible(o2), g.SetCollisionEnabled(l2), g.SetOriginX(this._currentAnimationFrame.GetOriginX()), g.SetOriginY(this._currentAnimationFrame.GetOriginY()), g.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly()), g.SetBboxChanged(), 1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking();\n      }\n      Release() {\n        this._currentAnimation = null, this._currentAnimationFrame = null, this._currentTexture = null, this._animationTimer = null, super.Release();\n      }\n      GetCurrentImageInfo() {\n        return this._currentAnimationFrame.GetImageInfo();\n      }\n      IsOriginalSizeKnown() {\n        return true;\n      }\n      OnRendererContextLost() {\n        this._currentTexture = null;\n      }\n      OnRendererContextRestored() {\n        this._UpdateCurrentTexture();\n      }\n      Draw(t2) {\n        const e2 = this._currentTexture;\n        if (null === e2) return;\n        t2.SetTexture(e2);\n        const n2 = this.GetWorldInfo();\n        n2.HasMesh() ? this._DrawMesh(n2, t2) : this._DrawStandard(n2, t2);\n      }\n      _DrawStandard(t2, e2) {\n        let n2 = this._bquadRef;\n        this._runtime.IsPixelRoundingEnabled() && (n2 = t2.PixelRoundQuad(n2)), e2.Quad4(n2, this._currentQuadTex);\n      }\n      _DrawMesh(t2, e2) {\n        const n2 = t2.GetTransformedMesh();\n        if (t2.IsMeshChanged()) {\n          t2.CalculateBbox(s, o, false);\n          let e3 = o;\n          this._runtime.IsPixelRoundingEnabled() && (e3 = t2.PixelRoundQuad(e3)), n2.CalculateTransformedMesh(t2.GetSourceMesh(), e3, this._currentQuadTex), t2.SetMeshChanged(false);\n        }\n        n2.Draw(e2);\n      }\n      GetAnimationTime() {\n        return this._animationTimer.Get();\n      }\n      IsAnimationPlaying() {\n        return this._inst.GetFlag(u);\n      }\n      SetAnimationPlaying(t2) {\n        this._inst.SetFlag(u, t2);\n      }\n      IsPlayingForwards() {\n        return this._inst.GetFlag(h);\n      }\n      SetPlayingForwards(t2) {\n        this._inst.SetFlag(h, t2);\n      }\n      IsInAnimationTrigger() {\n        return this._inst.GetFlag(c);\n      }\n      SetInAnimationTrigger(t2) {\n        this._inst.SetFlag(c, t2);\n      }\n      Tick() {\n        this._changeAnimationName && this._DoChangeAnimation(), this._changeAnimFrameIndex >= 0 && this._DoChangeAnimFrame();\n        const e2 = this._currentAnimationSpeed;\n        if (!this.IsAnimationPlaying() || 0 === e2) return void this._StopTicking();\n        const n2 = this._runtime.GetDt(this._inst);\n        this._animationTimer.Add(n2);\n        const i2 = this.GetAnimationTime(), r2 = this._currentAnimationFrame, a2 = r2.GetDuration() / e2;\n        if (i2 < this._frameStartTime + a2) return;\n        const s2 = this._currentAnimation, o2 = this._currentAnimationRepeatTo, m2 = s2.GetFrameCount(), h2 = s2.GetRepeatCount(), u2 = s2.IsLooping(), c2 = s2.IsPingPong();\n        this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--, this._frameStartTime += a2, this._currentFrameIndex >= m2 && (c2 ? (this.SetPlayingForwards(false), this._currentFrameIndex = m2 - 2) : u2 ? this._currentFrameIndex = o2 : (this._animationRepeats++, this._animationRepeats >= h2 ? this._FinishAnimation(false) : this._currentFrameIndex = o2)), this._currentFrameIndex < 0 && (c2 ? (this._currentFrameIndex = 1, this.SetPlayingForwards(true), u2 || (this._animationRepeats++, this._animationRepeats >= h2 && this._FinishAnimation(true))) : u2 ? this._currentFrameIndex = o2 : (this._animationRepeats++, this._animationRepeats >= h2 ? this._FinishAnimation(true) : this._currentFrameIndex = o2)), this._currentFrameIndex = t.clamp(this._currentFrameIndex, 0, m2 - 1);\n        const l2 = s2.GetFrameAt(this._currentFrameIndex);\n        i2 > this._frameStartTime + l2.GetDuration() / e2 && (this._frameStartTime = i2), this._OnFrameChanged(r2, l2);\n      }\n      _FinishAnimation(e2) {\n        this._currentFrameIndex = e2 ? 0 : this._currentAnimation.GetFrameCount() - 1, this.SetAnimationPlaying(false), this._animTriggerName = this._currentAnimation.GetName(), this.SetInAnimationTrigger(true), this.DispatchScriptEvent(\"animationend\", false, { animationName: this._animTriggerName }), this.Trigger(t.Plugins.Sprite.Cnds.OnAnyAnimFinished), this.Trigger(t.Plugins.Sprite.Cnds.OnAnimFinished), this.SetInAnimationTrigger(false), this._animationRepeats = 0;\n      }\n      _OnFrameChanged(e2, n2, i2) {\n        if (e2 === n2) return;\n        const r2 = this.GetWorldInfo(), a2 = e2.GetImageInfo(), s2 = n2.GetImageInfo(), o2 = a2.GetWidth(), m2 = a2.GetHeight(), h2 = s2.GetWidth(), u2 = s2.GetHeight();\n        i2 && i2.onFrameChange ? i2.onFrameChange(r2, o2, m2, h2, u2) : (o2 !== h2 && r2.SetWidth(r2.GetWidth() * (h2 / o2)), m2 !== u2 && r2.SetHeight(r2.GetHeight() * (u2 / m2))), r2.SetOriginX(n2.GetOriginX()), r2.SetOriginY(n2.GetOriginY()), r2.SetSourceCollisionPoly(n2.GetCollisionPoly()), r2.SetBboxChanged(), this._currentAnimationFrame = n2, this._currentTexture = s2.GetTexture(), this._currentRcTex = s2.GetTexRect(), this._currentQuadTex = s2.GetTexQuad();\n        const c2 = this.GetInstance().GetBehaviorInstances();\n        for (let t2 = 0, i3 = c2.length; t2 < i3; ++t2) c2[t2].OnSpriteFrameChanged(e2, n2);\n        this.DispatchScriptEvent(\"framechange\", false, { animationName: this._currentAnimation.GetName(), animationFrame: this._currentFrameIndex }), this.Trigger(t.Plugins.Sprite.Cnds.OnFrameChanged), this._runtime.UpdateRender();\n      }\n      _StartAnim(t2) {\n        this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime(), 1 === t2 && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame()), this._StartTicking();\n      }\n      _SetAnim(t2, e2, n2) {\n        this._changeAnimationName = t2, this._changeAnimationFrom = e2, this._StartTicking(), !n2 && this.IsInAnimationTrigger() || this._DoChangeAnimation();\n      }\n      _GetCurrentAnimation() {\n        return this._currentAnimation;\n      }\n      _GetCurrentAnimationName() {\n        return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName();\n      }\n      _OnAnimationRemoved(e2) {\n        t.equalsNoCase(e2, this._GetCurrentAnimationName()) && this._SetAnim(this._objectClass.GetFirstAnimation().GetName(), 1, true);\n      }\n      _SetAnimFrame(t2) {\n        if (\"string\" == typeof t2) if (String(Number(t2)) === t2) t2 = Number(t2);\n        else {\n          const e2 = this._objectClass.GetAnimationByName(this._GetCurrentAnimationName());\n          if (!e2) return;\n          if (-1 === (t2 = e2.GetFrameIndexByTag(t2))) return;\n        }\n        isFinite(t2) && (this._changeAnimFrameIndex = t2, this.IsInAnimationTrigger() || this._DoChangeAnimFrame());\n      }\n      _OnAnimationFramesChanged() {\n        if (this._changeAnimationName || -1 !== this._changeAnimFrameIndex) return;\n        const e2 = this._currentAnimationFrame, n2 = this._currentAnimation.GetFrameAt(t.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1));\n        e2 !== n2 && this._OnFrameChanged(e2, n2), this._currentAnimation.GetFrameCount() > 1 && this._currentAnimationSpeed > 0 && this._StartTicking();\n      }\n      _GetAnimFrame() {\n        return this._currentFrameIndex;\n      }\n      _GetAnimFrameTag() {\n        return this._currentAnimationFrame.GetTag();\n      }\n      _SetAnimSpeed(t2) {\n        this._currentAnimationSpeed = Math.abs(t2), this.SetPlayingForwards(t2 >= 0), this._currentAnimationSpeed > 0 && this._StartTicking();\n      }\n      _GetAnimSpeed() {\n        return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed;\n      }\n      _SetAnimRepeatToFrame(e2) {\n        \"string\" == typeof e2 && -1 === (e2 = this._currentAnimation.GetFrameIndexByTag(e2)) || (e2 = t.clamp(Math.floor(e2), 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationRepeatTo = e2);\n      }\n      _GetAnimRepeatToFrame() {\n        return this._currentAnimationRepeatTo;\n      }\n      _DoChangeAnimation(e2) {\n        const n2 = this._currentAnimationFrame, i2 = this._objectClass.GetAnimationByName(this._changeAnimationName);\n        if (this._changeAnimationName = \"\", !i2) return;\n        if (i2 === this._currentAnimation && this.IsAnimationPlaying()) return;\n        this._currentAnimation = i2, this.SetPlayingForwards(i2.GetSpeed() >= 0), this._currentAnimationSpeed = Math.abs(i2.GetSpeed()), this._currentAnimationRepeatTo = i2.GetRepeatTo(), this._currentFrameIndex = t.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), 1 === this._changeAnimationFrom && (this._currentFrameIndex = 0), this.SetAnimationPlaying(true), this._frameStartTime = this.GetAnimationTime();\n        const r2 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n        this._OnFrameChanged(n2, r2, e2);\n      }\n      _DoChangeAnimFrame(e2) {\n        const n2 = this._currentAnimationFrame, i2 = this._currentFrameIndex;\n        if (this._currentFrameIndex = t.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1), this._changeAnimFrameIndex = -1, !e2 && i2 === this._currentFrameIndex) return;\n        const r2 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n        this._OnFrameChanged(n2, r2), this._frameStartTime = this.GetAnimationTime();\n      }\n      _UpdateCurrentTexture() {\n        const t2 = this._currentAnimationFrame.GetImageInfo();\n        this._currentTexture = t2.GetTexture(), this._currentRcTex = t2.GetTexRect(), this._currentQuadTex = t2.GetTexQuad(), this.GetWorldInfo().SetMeshChanged(true);\n      }\n      GetTexture() {\n        return this._currentTexture;\n      }\n      GetTexRect() {\n        return this._currentRcTex;\n      }\n      GetTexQuad() {\n        return this._currentQuadTex;\n      }\n      GetImagePointCount() {\n        return this._currentAnimationFrame.GetImagePointCount();\n      }\n      GetImagePoint(t2) {\n        const e2 = this._currentAnimationFrame, n2 = this.GetWorldInfo();\n        let i2 = null;\n        if (\"string\" == typeof t2) i2 = e2.GetImagePointByName(t2);\n        else {\n          if (\"number\" != typeof t2) throw new TypeError(\"expected string or number\");\n          i2 = e2.GetImagePointByIndex(t2 - 1);\n        }\n        let r2 = n2.GetTotalZElevation();\n        if (!i2) return [n2.GetX(), n2.GetY(), r2];\n        if (m.copy(i2.GetVec2()), n2.HasMesh()) {\n          const [t3, e3, i3] = n2.GetSourceMesh().TransformPoint(m.getX(), m.getY());\n          m.set(t3, e3), r2 += i3;\n        }\n        return m.offset(-e2.GetOriginX(), -e2.GetOriginY()), m.scale(n2.GetWidth(), n2.GetHeight()), m.rotate(n2.GetAngle()), m.offset(n2.GetX(), n2.GetY()), [m.getX(), m.getY(), r2];\n      }\n      GetCollisionPolyPointCount() {\n        return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount();\n      }\n      GetCollisionPolyPoint(t2) {\n        t2 = Math.floor(t2);\n        const e2 = this.GetWorldInfo(), n2 = e2.GetTransformedCollisionPoly(), i2 = n2.pointCount();\n        if (t2 === i2 && (t2 = 0), t2 < 0 || t2 >= i2) return [0, 0];\n        const r2 = n2.pointsArr();\n        return [r2[2 * t2 + 0] + e2.GetX(), r2[2 * t2 + 1] + e2.GetY()];\n      }\n      GetDebuggerProperties() {\n        const e2 = t.Plugins.Sprite.Acts, n2 = \"plugins.sprite.debugger.animation-properties\";\n        return [{ title: n2 + \".title\", properties: [{ name: n2 + \".current-animation\", value: this._currentAnimation.GetName(), onedit: (t2) => this.CallAction(e2.SetAnim, t2, 0) }, { name: n2 + \".current-frame\", value: this._currentFrameIndex, onedit: (t2) => this.CallAction(e2.SetAnimFrame, t2) }, { name: n2 + \".is-playing\", value: this.IsAnimationPlaying(), onedit: (t2) => t2 ? this.CallAction(e2.StartAnim, 0) : this.CallAction(e2.StopAnim) }, { name: n2 + \".speed\", value: this._currentAnimationSpeed, onedit: (t2) => this.CallAction(e2.SetAnimSpeed, t2) }, { name: n2 + \".repeats\", value: this._animationRepeats, onedit: (t2) => this._animationRepeats = t2 }] }];\n      }\n      SaveToJson() {\n        const t2 = { \"a\": this._currentAnimation.GetSID() };\n        0 !== this._frameStartTime && (t2[\"fs\"] = this._frameStartTime);\n        const e2 = this.GetAnimationTime();\n        0 !== e2 && (t2[\"at\"] = e2), 0 !== this._currentFrameIndex && (t2[\"f\"] = this._currentFrameIndex), 0 !== this._currentAnimationSpeed && (t2[\"cas\"] = this._currentAnimationSpeed), 1 !== this._animationRepeats && (t2[\"ar\"] = this._animationRepeats), 0 !== this._currentAnimationRepeatTo && (t2[\"rt\"] = this._currentAnimationRepeatTo), this.IsAnimationPlaying() || (t2[\"ap\"] = this.IsAnimationPlaying()), this.IsPlayingForwards() || (t2[\"af\"] = this.IsPlayingForwards());\n        const n2 = this.GetWorldInfo();\n        return n2.IsCollisionEnabled() && (t2[\"ce\"] = n2.IsCollisionEnabled()), t2;\n      }\n      LoadFromJson(e2) {\n        const n2 = this.GetObjectClass().GetAnimationBySID(e2[\"a\"]);\n        n2 && (this._currentAnimation = n2), this._frameStartTime = e2.hasOwnProperty(\"fs\") ? e2[\"fs\"] : 0, this._animationTimer.Set(e2.hasOwnProperty(\"at\") ? e2[\"at\"] : 0);\n        const i2 = e2.hasOwnProperty(\"f\") ? e2[\"f\"] : 0;\n        this._currentFrameIndex = t.clamp(i2, 0, this._currentAnimation.GetFrameCount() - 1), this._currentAnimationSpeed = e2.hasOwnProperty(\"cas\") ? e2[\"cas\"] : 0, this._animationRepeats = e2.hasOwnProperty(\"ar\") ? e2[\"ar\"] : 1;\n        const r2 = e2.hasOwnProperty(\"rt\") ? e2[\"rt\"] : 0;\n        this._currentAnimationRepeatTo = t.clamp(r2, 0, this._currentAnimation.GetFrameCount() - 1), this.SetAnimationPlaying(!e2.hasOwnProperty(\"ap\") || !!e2[\"ap\"]), this.SetPlayingForwards(!e2.hasOwnProperty(\"af\") || !!e2[\"af\"]);\n        const a2 = this._currentAnimation.GetFrameAt(this._currentFrameIndex);\n        this._currentAnimationFrame = a2, this._UpdateCurrentTexture();\n        const s2 = this.GetWorldInfo();\n        s2.SetOriginX(a2.GetOriginX()), s2.SetOriginY(a2.GetOriginY()), s2.SetSourceCollisionPoly(a2.GetCollisionPoly()), s2.SetCollisionEnabled(!!e2[\"ce\"]), this.IsAnimationPlaying() && this._StartTicking();\n      }\n      GetPropertyValueByIndex(e2) {\n        const n2 = this.GetWorldInfo();\n        switch (e2) {\n          case a:\n            return n2.IsCollisionEnabled();\n          case r:\n            return t.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1);\n          case i:\n            return this._currentAnimation.GetName();\n        }\n      }\n      SetPropertyValueByIndex(e2, n2, s2) {\n        const o2 = this.GetWorldInfo();\n        switch (e2) {\n          case a:\n            o2.SetCollisionEnabled(!!n2);\n            break;\n          case r: {\n            this.SetAnimationPlaying(false);\n            const e3 = this._currentAnimation.GetFrameCount() - 1, i2 = n2 = t.clamp(n2, 0, e3), r2 = this._currentAnimation.GetFrameAt(this._currentFrameIndex), a2 = this._currentAnimation.GetFrameAt(i2);\n            this._OnFrameChanged(r2, a2, s2), this._currentFrameIndex = t.clamp(i2, 0, e3);\n            break;\n          }\n          case i:\n            this._changeAnimationName = n2, this._DoChangeAnimation(s2);\n            this._currentAnimation.GetFrameCount() > 1 && this._currentAnimation.GetSpeed() > 0 ? this._StartTicking() : this._StopTicking();\n            break;\n        }\n      }\n      GetScriptInterfaceClass() {\n        return self.ISpriteInstance;\n      }\n    };\n    const l = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new Map([[\"current-frame\", 0], [\"beginning\", 1]]);\n    self.ISpriteInstance = class extends self.IWorldInstance {\n      constructor() {\n        super(), l.set(this, self.IInstance._GetInitInst().GetSdkInstance());\n      }\n      getImagePointCount() {\n        return l.get(this).GetImagePointCount();\n      }\n      getImagePointX(t2) {\n        return this.getImagePoint(t2)[0];\n      }\n      getImagePointY(t2) {\n        return this.getImagePoint(t2)[1];\n      }\n      getImagePointZ(t2) {\n        return this.getImagePoint(t2)[2];\n      }\n      getImagePoint(t2) {\n        if (\"string\" != typeof t2 && \"number\" != typeof t2) throw new TypeError(\"expected string or number\");\n        return l.get(this).GetImagePoint(t2);\n      }\n      getPolyPointCount() {\n        return l.get(this).GetCollisionPolyPointCount();\n      }\n      getPolyPointX(t2) {\n        return e.RequireFiniteNumber(t2), l.get(this).GetCollisionPolyPoint(t2)[0];\n      }\n      getPolyPointY(t2) {\n        return e.RequireFiniteNumber(t2), l.get(this).GetCollisionPolyPoint(t2)[1];\n      }\n      getPolyPoint(t2) {\n        return e.RequireFiniteNumber(t2), l.get(this).GetCollisionPolyPoint(t2);\n      }\n      stopAnimation() {\n        l.get(this).SetAnimationPlaying(false);\n      }\n      startAnimation(t2 = \"current-frame\") {\n        e.RequireString(t2);\n        const n2 = d.get(t2);\n        if (void 0 === n2) throw new Error(\"invalid mode\");\n        l.get(this)._StartAnim(n2);\n      }\n      setAnimation(t2, n2 = \"beginning\") {\n        e.RequireString(t2), e.RequireString(n2);\n        const i2 = d.get(n2);\n        if (void 0 === i2) throw new Error(\"invalid mode\");\n        const r2 = l.get(this);\n        if (!r2.GetObjectClass().GetAnimationByName(t2)) throw new Error(`animation name \"${t2}\" does not exist`);\n        r2._SetAnim(t2, i2);\n      }\n      getAnimation(t2) {\n        e.RequireString(t2);\n        const n2 = l.get(this).GetObjectClass().GetAnimationByName(t2);\n        return n2 ? n2.GetIAnimation() : null;\n      }\n      get animation() {\n        return l.get(this)._GetCurrentAnimation().GetIAnimation();\n      }\n      get animationName() {\n        return l.get(this)._GetCurrentAnimationName();\n      }\n      set animationFrame(t2) {\n        e.RequireFiniteNumber(t2), l.get(this)._SetAnimFrame(t2);\n      }\n      get animationFrame() {\n        return l.get(this)._GetAnimFrame();\n      }\n      set animationFrameTag(t2) {\n        e.RequireString(t2), l.get(this)._SetAnimFrame(t2);\n      }\n      get animationFrameTag() {\n        return l.get(this)._GetAnimFrameTag();\n      }\n      set animationSpeed(t2) {\n        e.RequireFiniteNumber(t2), l.get(this)._SetAnimSpeed(t2);\n      }\n      get animationSpeed() {\n        return l.get(this)._GetAnimSpeed();\n      }\n      set animationRepeatToFrame(t2) {\n        e.RequireFiniteNumber(t2), l.get(this)._SetAnimRepeatToFrame(t2);\n      }\n      get animationRepeatToFrame() {\n        return l.get(this)._GetAnimRepeatToFrame();\n      }\n      get imageWidth() {\n        return l.get(this).GetCurrentImageInfo().GetWidth();\n      }\n      get imageHeight() {\n        return l.get(this).GetCurrentImageInfo().GetHeight();\n      }\n      getImageSize() {\n        const t2 = l.get(this).GetCurrentImageInfo();\n        return [t2.GetWidth(), t2.GetHeight()];\n      }\n      async replaceCurrentAnimationFrame(n2) {\n        e.RequireInstanceOf(n2, Blob);\n        const i2 = l.get(this), r2 = i2.GetRuntime(), a2 = i2.GetCurrentImageInfo(), s2 = t.New(t.ImageInfo);\n        if (s2.LoadDynamicBlobAsset(r2, n2), await s2.LoadStaticTexture(r2.GetRenderer(), { sampling: r2.GetSampling() }), i2.WasReleased()) return void s2.Release();\n        a2.ReplaceWith(s2);\n        const o2 = i2.GetSdkType();\n        o2._UpdateAllCurrentTexture(), o2.GetObjectClass().Dispatcher().dispatchEvent(new t.Event(\"animationframeimagechange\")), r2.UpdateRender();\n      }\n      setSolidCollisionFilter(t2, n2) {\n        e.RequireString(n2), l.get(this).GetWorldInfo().SetSolidCollisionFilter(!!t2, n2);\n      }\n    };\n  }\n  {\n    const t = self.C3;\n    t.Plugins.Sprite.Cnds = { IsAnimPlaying(e) {\n      return t.equalsNoCase(this._GetCurrentAnimationName(), e);\n    }, CompareFrame(e, n) {\n      return t.compare(this._currentFrameIndex, e, n);\n    }, CompareFrameTag(e, n) {\n      if (\"string\" != typeof n) return false;\n      const i = this._currentAnimationFrame.GetTag();\n      return t.compare(i.toLowerCase(), e, n.toLowerCase());\n    }, CompareAnimSpeed(e, n) {\n      return t.compare(this._GetAnimSpeed(), e, n);\n    }, OnAnimFinished(e) {\n      return t.equalsNoCase(this._animTriggerName, e);\n    }, OnAnyAnimFinished: () => true, OnFrameChanged: () => true, IsMirrored() {\n      return this.GetWorldInfo().GetWidth() < 0;\n    }, IsFlipped() {\n      return this.GetWorldInfo().GetHeight() < 0;\n    }, OnURLLoaded: () => true, OnURLFailed: () => true, IsCollisionEnabled() {\n      return this.GetWorldInfo().IsCollisionEnabled();\n    } };\n  }\n  {\n    const t = self.C3;\n    t.Plugins.Sprite.Acts = { Spawn(t2, e, n, i, r) {\n      if (!t2 || !e) return;\n      const [a, s] = this.GetImagePoint(n), o = this._runtime.CreateInstance(t2, e, a, s, i, r);\n      if (!o) return;\n      if (i && e.SortAndAddInstancesByZIndex(o), t2.GetPlugin().IsRotatable()) {\n        const t3 = o.GetWorldInfo();\n        t3.SetAngle(this.GetWorldInfo().GetAngle()), t3.SetBboxChanged();\n      }\n      const m = this._runtime.GetEventSheetManager();\n      m.BlockFlushingInstances(true), o._TriggerOnCreatedOnSelfAndRelated(), m.BlockFlushingInstances(false), t2 !== this._runtime.GetCurrentAction().GetObjectClass() && this._sdkType._SpawnPickInstance(t2, o, i);\n    }, StopAnim() {\n      this.SetAnimationPlaying(false);\n    }, StartAnim(t2) {\n      this._StartAnim(t2);\n    }, SetAnim(t2, e) {\n      this._SetAnim(t2, e);\n    }, SetAnimFrame(t2) {\n      this._SetAnimFrame(t2);\n    }, SetAnimSpeed(t2) {\n      this._SetAnimSpeed(t2);\n    }, SetAnimRepeatToFrame(t2) {\n      this._SetAnimRepeatToFrame(t2);\n    }, AddRemoveAnimation(t2, e) {\n      try {\n        0 === t2 ? this.GetSdkType()._AddAnimation(e) : this.GetSdkType()._RemoveAnimation(e);\n      } catch (e2) {\n        console.error(`[Construct] Error ${0 === t2 ? \"adding\" : \"removing\"} animation: `, e2);\n      }\n    }, AddRemoveAnimationFrame(t2, e, n) {\n      try {\n        0 === t2 ? this.GetSdkType()._AddAnimationFrame(e, n) : this.GetSdkType()._RemoveAnimationFrame(e, n);\n      } catch (e2) {\n        console.error(`[Construct] Error ${0 === t2 ? \"adding\" : \"removing\"} animation frame: `, e2);\n      }\n    }, SetMirrored(t2) {\n      const e = this.GetWorldInfo(), n = e.GetWidth(), i = Math.abs(n) * (0 === t2 ? -1 : 1);\n      n !== i && (e.SetWidth(i), e.SetBboxChanged());\n    }, SetFlipped(t2) {\n      const e = this.GetWorldInfo(), n = e.GetHeight(), i = Math.abs(n) * (0 === t2 ? -1 : 1);\n      n !== i && (e.SetHeight(i), e.SetBboxChanged());\n    }, SetScale(t2) {\n      const e = this._currentAnimationFrame.GetImageInfo(), n = this.GetWorldInfo(), i = n.GetWidth() < 0 ? -1 : 1, r = n.GetHeight() < 0 ? -1 : 1, a = e.GetWidth() * t2 * i, s = e.GetHeight() * t2 * r;\n      n.GetWidth() === a && n.GetHeight() === s || (n.SetSize(a, s), n.SetBboxChanged());\n    }, async LoadURL(e, n, i) {\n      const r = this._currentAnimationFrame.GetImageInfo(), a = this.GetWorldInfo(), s = this._runtime, o = this._sdkType;\n      if (r.GetURL() === e) return 0 === n && (a.SetSize(r.GetWidth(), r.GetHeight()), a.SetBboxChanged()), void this.Trigger(t.Plugins.Sprite.Cnds.OnURLLoaded);\n      const m = t.New(t.ImageInfo);\n      try {\n        if (await m.LoadDynamicAsset(s, e), !m.IsLoaded()) throw new Error(\"image failed to load\");\n        if (this.WasReleased()) return void m.Release();\n        await m.LoadStaticTexture(s.GetRenderer(), { sampling: s.GetSampling() });\n      } catch (e2) {\n        return console.error(\"Load image from URL failed: \", e2), void (this.WasReleased() || this.Trigger(t.Plugins.Sprite.Cnds.OnURLFailed));\n      }\n      this.WasReleased() ? m.Release() : (r.ReplaceWith(m), o._UpdateAllCurrentTexture(), o.GetObjectClass().Dispatcher().dispatchEvent(new t.Event(\"animationframeimagechange\")), s.UpdateRender(), 0 === n && (a.SetSize(r.GetWidth(), r.GetHeight()), a.SetBboxChanged()), await this.TriggerAsync(t.Plugins.Sprite.Cnds.OnURLLoaded));\n    }, SetCollisions(t2) {\n      this.GetWorldInfo().SetCollisionEnabled(t2);\n    }, SetSolidCollisionFilter(t2, e) {\n      this.GetWorldInfo().SetSolidCollisionFilter(0 === t2, e);\n    }, SetEffect(t2) {\n      this.GetWorldInfo().SetBlendMode(t2), this._runtime.UpdateRender();\n    } };\n  }\n  self.C3.Plugins.Sprite.Exps = { AnimationFrame() {\n    return this._GetAnimFrame();\n  }, AnimationFrameTag() {\n    return this._GetAnimFrameTag();\n  }, AnimationFrameCount() {\n    return this._currentAnimation.GetFrameCount();\n  }, AnimationName() {\n    return this._currentAnimation.GetName();\n  }, AnimationSpeed() {\n    return this._GetAnimSpeed();\n  }, OriginalAnimationSpeed() {\n    return this._currentAnimation.GetSpeed();\n  }, ImagePointX(t) {\n    return this.GetImagePoint(t)[0];\n  }, ImagePointY(t) {\n    return this.GetImagePoint(t)[1];\n  }, ImagePointZ(t) {\n    return this.GetImagePoint(t)[2];\n  }, ImagePointCount() {\n    return this.GetImagePointCount();\n  }, ImageWidth() {\n    return this.GetCurrentImageInfo().GetWidth();\n  }, ImageHeight() {\n    return this.GetCurrentImageInfo().GetHeight();\n  }, PolyPointXAt(t) {\n    return this.GetCollisionPolyPoint(t)[0];\n  }, PolyPointYAt(t) {\n    return this.GetCollisionPolyPoint(t)[1];\n  }, PolyPointCount() {\n    return this.GetCollisionPolyPointCount();\n  } };\n}\n{\n  {\n    const e = self.C3;\n    e.Plugins.Keyboard = class extends e.SDKPluginBase {\n      constructor(e2) {\n        super(e2);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    let GetKeyboardSdkInstance = function() {\n      return t.GetSingleGlobalInstance().GetSdkInstance();\n    };\n    GetKeyboardSdkInstance2 = GetKeyboardSdkInstance;\n    const r = self.C3;\n    self.C3X;\n    r.Plugins.Keyboard.Type = class extends r.SDKTypeBase {\n      constructor(e) {\n        super(e);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n      GetScriptInterfaceClass() {\n        return self.IKeyboardObjectType;\n      }\n    };\n    let t = null;\n    self.IKeyboardObjectType = class extends self.IObjectType {\n      constructor(e) {\n        super(e), t = e, e.GetRuntime()._GetCommonScriptInterfaces().keyboard = this;\n      }\n      isKeyDown(e) {\n        const r2 = GetKeyboardSdkInstance();\n        if (\"string\" == typeof e) return r2.IsKeyDown(e);\n        if (\"number\" == typeof e) return r2.IsKeyCodeDown(e);\n        throw new TypeError(\"expected string or number\");\n      }\n    };\n  }\n  {\n    const s = self.C3, n = \"keyboard\";\n    s.Plugins.Keyboard.Instance = class extends s.SDKInstanceBase {\n      constructor(e, r) {\n        super(e, n), this._keysDownByString = /* @__PURE__ */ new Set(), this._keysDownByWhich = /* @__PURE__ */ new Set(), this._triggerWhich = 0, this._triggerString = \"\", this._triggerTypedKey = \"\", this._isKeyboardLockSupported = false;\n        const t = this.GetRuntime().Dispatcher();\n        this._disposables = new s.CompositeDisposable(s.Disposable.From(t, \"keydown\", (e2) => this._OnKeyDown(e2.data)), s.Disposable.From(t, \"keyup\", (e2) => this._OnKeyUp(e2.data)), s.Disposable.From(t, \"window-blur\", () => this._OnWindowOrKeyboardBlur()), s.Disposable.From(t, \"keyboard-blur\", () => this._OnWindowOrKeyboardBlur())), this._runtime.AddLoadPromise(this._Init());\n      }\n      Release() {\n        super.Release();\n      }\n      async _Init() {\n        const e = await this.PostToDOMAsync(\"init\");\n        this._isKeyboardLockSupported = e[\"isKeyboardLockSupported\"];\n      }\n      _OnKeyDown(e) {\n        const r = e[\"which\"], t = e[\"code\"] || r.toString(), n2 = e[\"key\"];\n        this._keysDownByString.has(t) || (this._keysDownByString.add(t), this._keysDownByWhich.add(r), this._triggerString = t, this._triggerWhich = r, this._triggerTypedKey = n2, this.Trigger(s.Plugins.Keyboard.Cnds.OnAnyKey), this.Trigger(s.Plugins.Keyboard.Cnds.OnKey), this.Trigger(s.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyCode));\n      }\n      _OnKeyUp(e) {\n        const r = e[\"which\"], t = e[\"code\"] || r.toString(), n2 = e[\"key\"];\n        this._keysDownByString.delete(t), this._keysDownByWhich.delete(r), this._triggerString = t, this._triggerWhich = r, this._triggerTypedKey = n2, this.Trigger(s.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyCodeReleased);\n      }\n      _OnWindowOrKeyboardBlur() {\n        for (const e of this._keysDownByWhich) this._keysDownByWhich.delete(e), this._triggerWhich = e, this.Trigger(s.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(s.Plugins.Keyboard.Cnds.OnKeyCodeReleased);\n        this._keysDownByString.clear();\n      }\n      IsKeyDown(e) {\n        return this._keysDownByString.has(e);\n      }\n      IsKeyCodeDown(e) {\n        return this._keysDownByWhich.has(e);\n      }\n      SaveToJson() {\n        return { \"tk\": this._triggerWhich, \"tkk\": this._triggerTypedKey };\n      }\n      LoadFromJson(e) {\n        this._triggerWhich = e[\"tk\"], e.hasOwnProperty(\"tkk\") && (this._triggerTypedKey = e[\"tkk\"]);\n      }\n      GetDebuggerProperties() {\n        const e = \"plugins.keyboard\";\n        return [{ title: e + \".name\", properties: [{ name: e + \".debugger.last-key-code\", value: this._triggerWhich }, { name: e + \".debugger.last-key-string\", value: s.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich) }, { name: e + \".debugger.last-typed-key\", value: this._triggerTypedKey }] }];\n      }\n    };\n  }\n  {\n    const i = self.C3, a = [\"ShiftLeft\", \"ShiftRight\", \"ControlLeft\", \"ControlRight\", \"AltLeft\", \"AltRight\", \"MetaLeft\", \"MetaRight\"];\n    i.Plugins.Keyboard.Cnds = { IsKeyDown(e) {\n      return this._keysDownByWhich.has(e);\n    }, OnKey(e) {\n      return this._triggerWhich === e;\n    }, OnAnyKey: () => true, OnAnyKeyReleased: () => true, OnKeyReleased(e) {\n      return this._triggerWhich === e;\n    }, IsKeyCodeDown(e) {\n      return e = Math.floor(e), this._keysDownByWhich.has(e);\n    }, OnKeyCode(e) {\n      return this._triggerWhich === e;\n    }, OnKeyCodeReleased(e) {\n      return this._triggerWhich === e;\n    }, OnLeftRightKeyPressed(e) {\n      const r = a[e];\n      return this._triggerString === r;\n    }, OnLeftRightKeyReleased(e) {\n      const r = a[e];\n      return this._triggerString === r;\n    }, IsLeftRightKeyDown(e) {\n      const r = a[e];\n      return this._keysDownByString.has(r);\n    }, IsKeyboardLockSupported() {\n      return this._isKeyboardLockSupported;\n    }, OnKeyboardLocked: () => true, OnKeyboardLockError: () => true };\n  }\n  {\n    const o = self.C3;\n    o.Plugins.Keyboard.Acts = { async LockKeyboard(e) {\n      if (!this._isKeyboardLockSupported) return;\n      let r = [];\n      e && (r = e.split(\",\"));\n      (await this.PostToDOMAsync(\"lock-keyboard\", { \"keysArr\": r }))[\"isOk\"] ? this.Trigger(o.Plugins.Keyboard.Cnds.OnKeyboardLocked) : this.Trigger(o.Plugins.Keyboard.Cnds.OnKeyboardLockError);\n    }, UnlockKeyboard() {\n      this._isKeyboardLockSupported && this.PostToDOMAsync(\"unlock-keyboard\");\n    } };\n  }\n  {\n    let StringFromCharCode = function(e) {\n      switch (e = Math.floor(e)) {\n        case 8:\n          return \"backspace\";\n        case 9:\n          return \"tab\";\n        case 13:\n          return \"enter\";\n        case 16:\n          return \"shift\";\n        case 17:\n          return \"control\";\n        case 18:\n          return \"alt\";\n        case 19:\n          return \"pause\";\n        case 20:\n          return \"capslock\";\n        case 27:\n          return \"esc\";\n        case 33:\n          return \"pageup\";\n        case 34:\n          return \"pagedown\";\n        case 35:\n          return \"end\";\n        case 36:\n          return \"home\";\n        case 37:\n          return \"\\u2190\";\n        case 38:\n          return \"\\u2191\";\n        case 39:\n          return \"\\u2192\";\n        case 40:\n          return \"\\u2193\";\n        case 45:\n          return \"insert\";\n        case 46:\n          return \"del\";\n        case 91:\n          return \"left window key\";\n        case 92:\n          return \"right window key\";\n        case 93:\n          return \"select\";\n        case 96:\n          return \"numpad 0\";\n        case 97:\n          return \"numpad 1\";\n        case 98:\n          return \"numpad 2\";\n        case 99:\n          return \"numpad 3\";\n        case 100:\n          return \"numpad 4\";\n        case 101:\n          return \"numpad 5\";\n        case 102:\n          return \"numpad 6\";\n        case 103:\n          return \"numpad 7\";\n        case 104:\n          return \"numpad 8\";\n        case 105:\n          return \"numpad 9\";\n        case 106:\n          return \"numpad *\";\n        case 107:\n          return \"numpad +\";\n        case 109:\n          return \"numpad -\";\n        case 110:\n          return \"numpad .\";\n        case 111:\n          return \"numpad /\";\n        case 112:\n          return \"F1\";\n        case 113:\n          return \"F2\";\n        case 114:\n          return \"F3\";\n        case 115:\n          return \"F4\";\n        case 116:\n          return \"F5\";\n        case 117:\n          return \"F6\";\n        case 118:\n          return \"F7\";\n        case 119:\n          return \"F8\";\n        case 120:\n          return \"F9\";\n        case 121:\n          return \"F10\";\n        case 122:\n          return \"F11\";\n        case 123:\n          return \"F12\";\n        case 144:\n          return \"numlock\";\n        case 145:\n          return \"scroll lock\";\n        case 186:\n          return \";\";\n        case 187:\n          return \"=\";\n        case 188:\n          return \",\";\n        case 189:\n          return \"-\";\n        case 190:\n          return \".\";\n        case 191:\n          return \"/\";\n        case 192:\n          return \"'\";\n        case 219:\n          return \"[\";\n        case 220:\n          return \"\\\\\";\n        case 221:\n          return \"]\";\n        case 222:\n          return \"#\";\n        case 223:\n          return \"`\";\n        default:\n          return String.fromCharCode(e);\n      }\n    };\n    StringFromCharCode2 = StringFromCharCode;\n    self.C3.Plugins.Keyboard.Exps = { LastKeyCode() {\n      return this._triggerWhich;\n    }, StringFromKeyCode: (e) => StringFromCharCode(e), TypedKey() {\n      return this._triggerTypedKey;\n    } };\n  }\n}\nvar GetKeyboardSdkInstance2;\nvar StringFromCharCode2;\n{\n  {\n    const t = self.C3;\n    t.Plugins.Touch = class extends t.SDKPluginBase {\n      constructor(t2) {\n        super(t2);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    let GetTouchSdkInstance = function() {\n      return i.GetSingleGlobalInstance().GetSdkInstance();\n    };\n    GetTouchSdkInstance2 = GetTouchSdkInstance;\n    const e = self.C3, s = self.C3X;\n    e.Plugins.Touch.Type = class extends e.SDKTypeBase {\n      constructor(t) {\n        super(t);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n      GetScriptInterfaceClass() {\n        return self.ITouchObjectType;\n      }\n    };\n    let i = null;\n    self.ITouchObjectType = class extends self.IObjectType {\n      constructor(t) {\n        super(t), i = t, t.GetRuntime()._GetCommonScriptInterfaces().touch = this;\n      }\n      requestPermission(t) {\n        s.RequireString(t);\n        const e2 = GetTouchSdkInstance();\n        if (\"orientation\" === t) return e2._RequestPermission(0);\n        if (\"motion\" === t) return e2._RequestPermission(1);\n        throw new Error(\"invalid type\");\n      }\n    };\n  }\n  {\n    const n = self.C3, r = \"touch\";\n    n.Plugins.Touch.Instance = class extends n.SDKInstanceBase {\n      constructor(t, e) {\n        super(t, r), this._touches = /* @__PURE__ */ new Map(), this._useMouseInput = false, this._isMouseDown = false, this._orientCompassHeading = 0, this._orientAlpha = 0, this._orientBeta = 0, this._orientGamma = 0, this._accX = 0, this._accY = 0, this._accZ = 0, this._accWithGX = 0, this._accWithGY = 0, this._accWithGZ = 0, this._triggerIndex = 0, this._triggerId = 0, this._triggerPermission = 0, this._curTouchX = 0, this._curTouchY = 0, this._getTouchIndex = 0, this._triggerType = 0, this._permissionPromises = [], e && (this._useMouseInput = e[0]), this.AddDOMMessageHandler(\"permission-result\", (t2) => this._OnPermissionResult(t2));\n        const s = this.GetRuntime().Dispatcher();\n        this._disposables = new n.CompositeDisposable(n.Disposable.From(s, \"pointerdown\", (t2) => this._OnPointerDown(t2.data)), n.Disposable.From(s, \"pointermove\", (t2) => this._OnPointerMove(t2.data)), n.Disposable.From(s, \"pointerup\", (t2) => this._OnPointerUp(t2.data, false)), n.Disposable.From(s, \"pointercancel\", (t2) => this._OnPointerUp(t2.data, true)), n.Disposable.From(s, \"deviceorientation\", (t2) => this._OnDeviceOrientation(t2.data)), n.Disposable.From(s, \"deviceorientationabsolute\", (t2) => this._OnDeviceOrientationAbsolute(t2.data)), n.Disposable.From(s, \"devicemotion\", (t2) => this._OnDeviceMotion(t2.data)), n.Disposable.From(s, \"tick2\", (t2) => this._OnTick2()));\n      }\n      Release() {\n        this._touches.clear(), super.Release();\n      }\n      _OnPointerDown(t) {\n        if (\"mouse\" === t[\"pointerType\"]) {\n          if (!this._useMouseInput) return;\n          this._isMouseDown = true;\n        }\n        const e = t[\"pointerId\"];\n        if (this._touches.has(e)) return;\n        const s = t[\"pageX\"] - this._runtime.GetCanvasClientX(), i = t[\"pageY\"] - this._runtime.GetCanvasClientY(), r2 = performance.now(), o = this._touches.size;\n        this._triggerIndex = o, this._triggerId = e;\n        const u = n.New(n.Plugins.Touch.TouchInfo);\n        u.Init(r2, s, i, e, o), this._touches.set(e, u), this.Trigger(n.Plugins.Touch.Cnds.OnNthTouchStart), this.Trigger(n.Plugins.Touch.Cnds.OnTouchStart), this._curTouchX = s, this._curTouchY = i, this._triggerType = 0, this.Trigger(n.Plugins.Touch.Cnds.OnTouchObject);\n      }\n      _OnPointerMove(t) {\n        if (\"mouse\" === t[\"pointerType\"] && !this._isMouseDown) return;\n        const e = this._touches.get(t[\"pointerId\"]);\n        if (!e) return;\n        const s = performance.now();\n        if (s - e.GetTime() < 2) return;\n        const i = t[\"pageX\"] - this._runtime.GetCanvasClientX(), n2 = t[\"pageY\"] - this._runtime.GetCanvasClientY();\n        e.Update(s, i, n2, t[\"width\"], t[\"height\"], t[\"pressure\"]);\n      }\n      _OnPointerUp(t, e) {\n        if (\"mouse\" === t[\"pointerType\"]) {\n          if (!this._isMouseDown) return;\n          this._isMouseDown = false;\n        }\n        const s = performance.now(), i = t[\"pointerId\"], r2 = this._touches.get(i);\n        if (r2) {\n          if (this._triggerIndex = r2.GetStartIndex(), this._triggerId = r2.GetId(), !e) {\n            const e2 = t[\"pageX\"] - this._runtime.GetCanvasClientX(), s2 = t[\"pageY\"] - this._runtime.GetCanvasClientY();\n            this._curTouchX = e2, this._curTouchY = s2, this._triggerType = 1, this.Trigger(n.Plugins.Touch.Cnds.OnTouchObject);\n          }\n          if (this.Trigger(n.Plugins.Touch.Cnds.OnNthTouchEnd), this.Trigger(n.Plugins.Touch.Cnds.OnTouchEnd), !e) {\n            const t2 = r2.ShouldTriggerTap(s);\n            \"single-tap\" === t2 ? (this.Trigger(n.Plugins.Touch.Cnds.OnTapGesture), this._curTouchX = r2.GetX(), this._curTouchY = r2.GetY(), this.Trigger(n.Plugins.Touch.Cnds.OnTapGestureObject)) : \"double-tap\" === t2 && (this.Trigger(n.Plugins.Touch.Cnds.OnDoubleTapGesture), this._curTouchX = r2.GetX(), this._curTouchY = r2.GetY(), this.Trigger(n.Plugins.Touch.Cnds.OnDoubleTapGestureObject));\n          }\n          r2.Release(), this._touches.delete(i);\n        }\n      }\n      _RequestPermission(t) {\n        return this._PostToDOMMaybeSync(\"request-permission\", { \"type\": t }), new Promise((e, s) => {\n          this._permissionPromises.push({ type: t, resolve: e, reject: s });\n        });\n      }\n      _OnPermissionResult(t) {\n        const e = t[\"result\"], s = t[\"type\"];\n        this._triggerPermission = s;\n        const i = this._permissionPromises.filter((t2) => t2.type === s);\n        for (const t2 of i) t2.resolve(e ? \"granted\" : \"denied\");\n        this._permissionPromises = this._permissionPromises.filter((t2) => t2.type !== s), e ? (this.Trigger(n.Plugins.Touch.Cnds.OnPermissionGranted), 0 === s ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(n.Plugins.Touch.Cnds.OnPermissionDenied);\n      }\n      _OnDeviceOrientation(t) {\n        \"number\" == typeof t[\"webkitCompassHeading\"] ? this._orientCompassHeading = t[\"webkitCompassHeading\"] : t[\"absolute\"] && (this._orientCompassHeading = t[\"alpha\"]), this._orientAlpha = t[\"alpha\"], this._orientBeta = t[\"beta\"], this._orientGamma = t[\"gamma\"];\n      }\n      _OnDeviceOrientationAbsolute(t) {\n        this._orientCompassHeading = t[\"alpha\"];\n      }\n      _OnDeviceMotion(t) {\n        const e = t[\"acceleration\"];\n        e && (this._accX = e[\"x\"], this._accY = e[\"y\"], this._accZ = e[\"z\"]);\n        const s = t[\"accelerationIncludingGravity\"];\n        s && (this._accWithGX = s[\"x\"], this._accWithGY = s[\"y\"], this._accWithGZ = s[\"z\"]);\n      }\n      _OnTick2() {\n        const t = performance.now();\n        let e = 0;\n        for (const s of this._touches.values()) s.GetTime() <= t - 50 && s._SetLastTime(t), s.ShouldTriggerHold(t) && (this._triggerIndex = s.GetStartIndex(), this._triggerId = s.GetId(), this._getTouchIndex = e, this.Trigger(n.Plugins.Touch.Cnds.OnHoldGesture), this._curTouchX = s.GetX(), this._curTouchY = s.GetY(), this.Trigger(n.Plugins.Touch.Cnds.OnHoldGestureObject), this._getTouchIndex = 0), ++e;\n      }\n      _GetTouchByIndex(t) {\n        t = Math.floor(t);\n        for (const e of this._touches.values()) {\n          if (0 === t) return e;\n          --t;\n        }\n        return null;\n      }\n      _IsClientPosOnCanvas(t, e) {\n        return t >= 0 && e >= 0 && t < this._runtime.GetCanvasCssWidth() && e < this._runtime.GetCanvasCssHeight();\n      }\n      GetDebuggerProperties() {\n        return [{ title: \"plugins.touch.debugger.touches\", properties: [...this._touches.values()].map((t) => ({ name: \"$\" + t.GetId(), value: t.GetX() + \", \" + t.GetY() })) }];\n      }\n    };\n  }\n  {\n    const o = self.C3;\n    o.Plugins.Touch.Cnds = { OnTouchStart: () => true, OnTouchEnd: () => true, IsInTouch() {\n      return this._touches.size > 0;\n    }, OnTouchObject(t, e) {\n      return !!t && (e === this._triggerType && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false)));\n    }, IsTouchingObject(t) {\n      if (!t) return false;\n      const e = this._runtime.GetCurrentCondition().IsInverted(), s = [...this._touches.values()].filter((t2) => this._IsClientPosOnCanvas(t2.GetX(), t2.GetY())).map((t2) => [t2.GetX(), t2.GetY()]);\n      return o.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, s, e), e);\n    }, CompareTouchSpeed(t, e, s) {\n      const i = this._GetTouchByIndex(t);\n      return !!i && o.compare(i.GetSpeed(), e, s);\n    }, OrientationSupported: () => true, MotionSupported: () => true, CompareOrientation(t, e, s) {\n      this._runtime.RequestDeviceOrientationEvent();\n      let i = 0;\n      return i = 0 === t ? this._orientAlpha : 1 === t ? this._orientBeta : this._orientGamma, o.compare(i, e, s);\n    }, CompareAcceleration(t, e, s) {\n      this._runtime.RequestDeviceMotionEvent();\n      let i = 0;\n      return i = 0 === t ? this._accWithGX : 1 === t ? this._accWithGY : 2 === t ? this._accWithGZ : 3 === t ? this._accX : 4 === t ? this._accY : this._accZ, o.compare(i, e, s);\n    }, OnNthTouchStart(t) {\n      return (t = Math.floor(t)) === this._triggerIndex;\n    }, OnNthTouchEnd(t) {\n      return (t = Math.floor(t)) === this._triggerIndex;\n    }, HasNthTouch(t) {\n      return t = Math.floor(t), this._touches.size >= t + 1;\n    }, OnHoldGesture: () => true, OnTapGesture: () => true, OnDoubleTapGesture: () => true, OnHoldGestureObject(t) {\n      return !!t && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false));\n    }, OnTapGestureObject(t) {\n      return !!t && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false));\n    }, OnDoubleTapGestureObject(t) {\n      return !!t && (!!this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) && this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(t, [[this._curTouchX, this._curTouchY]], false));\n    }, OnPermissionGranted(t) {\n      return this._triggerPermission === t;\n    }, OnPermissionDenied(t) {\n      return this._triggerPermission === t;\n    } };\n  }\n  self.C3.Plugins.Touch.Acts = { RequestPermission(t) {\n    this._RequestPermission(t);\n  } };\n  {\n    const u = self.C3;\n    u.Plugins.Touch.Exps = { TouchCount() {\n      return this._touches.size;\n    }, X(t) {\n      const e = this._GetTouchByIndex(this._getTouchIndex);\n      return e ? e.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, true) : 0;\n    }, Y(t) {\n      const e = this._GetTouchByIndex(this._getTouchIndex);\n      return e ? e.GetPositionForLayer(this._runtime.GetCurrentLayout(), t, false) : 0;\n    }, XAt(t, e) {\n      const s = this._GetTouchByIndex(t);\n      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, true) : 0;\n    }, YAt(t, e) {\n      const s = this._GetTouchByIndex(t);\n      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, false) : 0;\n    }, XForID(t, e) {\n      const s = this._touches.get(t);\n      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, true) : 0;\n    }, YForID(t, e) {\n      const s = this._touches.get(t);\n      return s ? s.GetPositionForLayer(this._runtime.GetCurrentLayout(), e, false) : 0;\n    }, AbsoluteX() {\n      const t = this._GetTouchByIndex(0);\n      return t ? t.GetX() : 0;\n    }, AbsoluteY() {\n      const t = this._GetTouchByIndex(0);\n      return t ? t.GetY() : 0;\n    }, AbsoluteXAt(t) {\n      const e = this._GetTouchByIndex(t);\n      return e ? e.GetX() : 0;\n    }, AbsoluteYAt(t) {\n      const e = this._GetTouchByIndex(t);\n      return e ? e.GetY() : 0;\n    }, AbsoluteXForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetX() : 0;\n    }, AbsoluteYForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetY() : 0;\n    }, SpeedAt(t) {\n      const e = this._GetTouchByIndex(t);\n      return e ? e.GetSpeed() : 0;\n    }, SpeedForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetSpeed() : 0;\n    }, AngleAt(t) {\n      const e = this._GetTouchByIndex(t);\n      return e ? u.toDegrees(e.GetAngle()) : 0;\n    }, AngleForID(t) {\n      const e = this._touches.get(t);\n      return e ? u.toDegrees(e.GetAngle()) : 0;\n    }, CompassHeading() {\n      return this._runtime.RequestDeviceOrientationEvent(), this._orientCompassHeading;\n    }, Alpha() {\n      return this._runtime.RequestDeviceOrientationEvent(), this._orientAlpha;\n    }, Beta() {\n      return this._runtime.RequestDeviceOrientationEvent(), this._orientBeta;\n    }, Gamma() {\n      return this._runtime.RequestDeviceOrientationEvent(), this._orientGamma;\n    }, AccelerationXWithG() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accWithGX;\n    }, AccelerationYWithG() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accWithGY;\n    }, AccelerationZWithG() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accWithGZ;\n    }, AccelerationX() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accX;\n    }, AccelerationY() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accY;\n    }, AccelerationZ() {\n      return this._runtime.RequestDeviceMotionEvent(), this._accZ;\n    }, TouchIndex() {\n      return this._triggerIndex;\n    }, TouchID() {\n      return this._triggerId;\n    }, WidthForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetWidth() : 0;\n    }, HeightForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetHeight() : 0;\n    }, PressureForID(t) {\n      const e = this._touches.get(t);\n      return e ? e.GetPressure() : 0;\n    } };\n  }\n}\nvar GetTouchSdkInstance2;\n{\n  const C33 = self.C3, GESTURE_HOLD_THRESHOLD = 15, GESTURE_HOLD_TIMEOUT = 500, GESTURE_TAP_TIMEOUT = 333, GESTURE_DOUBLETAP_THRESHOLD = 25;\n  let lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4;\n  C33.Plugins.Touch.TouchInfo = class extends C33.DefendedBase {\n    constructor() {\n      super(), this._pointerId = 0, this._startIndex = 0, this._startTime = 0, this._time = 0, this._lastTime = 0, this._startX = 0, this._startY = 0, this._x = 0, this._y = 0, this._lastX = 0, this._lastY = 0, this._width = 0, this._height = 0, this._pressure = 0, this._hasTriggeredHold = false, this._isTooFarForHold = false;\n    }\n    Release() {\n    }\n    Init(t, s, i, e, h) {\n      this._pointerId = e, this._startIndex = h, this._time = t, this._lastTime = t, this._startTime = t, this._startX = s, this._startY = i, this._x = s, this._y = i, this._lastX = s, this._lastY = i;\n    }\n    Update(t, s, i, e, h, _) {\n      this._lastTime = this._time, this._time = t, this._lastX = this._x, this._lastY = this._y, this._x = s, this._y = i, this._width = e, this._height = h, this._pressure = _, !this._isTooFarForHold && C33.distanceTo(this._startX, this._startY, this._x, this._y) >= 15 && (this._isTooFarForHold = true);\n    }\n    GetId() {\n      return this._pointerId;\n    }\n    GetStartIndex() {\n      return this._startIndex;\n    }\n    GetTime() {\n      return this._time;\n    }\n    _SetLastTime(t) {\n      this._lastTime = t;\n    }\n    GetX() {\n      return this._x;\n    }\n    GetY() {\n      return this._y;\n    }\n    GetSpeed() {\n      const t = C33.distanceTo(this._x, this._y, this._lastX, this._lastY), s = (this._time - this._lastTime) / 1e3;\n      return s > 0 ? t / s : 0;\n    }\n    GetAngle() {\n      return C33.angleTo(this._lastX, this._lastY, this._x, this._y);\n    }\n    GetWidth() {\n      return this._width;\n    }\n    GetHeight() {\n      return this._height;\n    }\n    GetPressure() {\n      return this._pressure;\n    }\n    ShouldTriggerHold(t) {\n      return !this._hasTriggeredHold && (t - this._startTime >= 500 && !this._isTooFarForHold && C33.distanceTo(this._startX, this._startY, this._x, this._y) < 15 && (this._hasTriggeredHold = true, true));\n    }\n    ShouldTriggerTap(t) {\n      return this._hasTriggeredHold ? \"\" : t - this._startTime <= 333 && !this._isTooFarForHold && C33.distanceTo(this._startX, this._startY, this._x, this._y) < 15 ? t - lastTapTime <= 666 && C33.distanceTo(lastTapX, lastTapY, this._x, this._y) < 25 ? (lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4, \"double-tap\") : (lastTapX = this._x, lastTapY = this._y, lastTapTime = t, \"single-tap\") : \"\";\n    }\n    GetPositionForLayer(t, s, i) {\n      if (void 0 === s) {\n        return t.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(this._x, this._y)[i ? 0 : 1];\n      }\n      {\n        const e = t.GetLayer(s);\n        return e ? e.CanvasCssToLayer(this._x, this._y)[i ? 0 : 1] : 0;\n      }\n    }\n  };\n}\n{\n  {\n    const e = self.C3;\n    e.Plugins.TiledBg = class extends e.SDKPluginBase {\n      constructor(e2) {\n        super(e2);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    let WrapModeToStr = function(e) {\n      switch (e) {\n        case 0:\n          return \"clamp-to-edge\";\n        case 1:\n          return \"repeat\";\n        case 2:\n          return \"mirror-repeat\";\n      }\n      return \"repeat\";\n    };\n    WrapModeToStr2 = WrapModeToStr;\n    const t = self.C3;\n    t.Plugins.TiledBg.Type = class extends t.SDKTypeBase {\n      constructor(e, t2) {\n        super(e), this._wrapX = \"repeat\", this._wrapY = \"repeat\", t2 && (this._wrapX = WrapModeToStr(t2[0]), this._wrapY = WrapModeToStr(t2[1]));\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n        this.GetImageInfo().LoadAsset(this._runtime);\n      }\n      LoadTextures(e) {\n        return this.GetImageInfo().LoadStaticTexture(e, { sampling: this._runtime.GetSampling(), wrapX: this._wrapX, wrapY: this._wrapY });\n      }\n      ReleaseTextures() {\n        this.GetImageInfo().ReleaseTexture();\n      }\n      GetWrapModeX() {\n        return this._wrapX;\n      }\n      GetWrapModeY() {\n        return this._wrapY;\n      }\n    };\n  }\n  {\n    const i = self.C3, a = self.C3X, n = 0, s = 4, l = 5, r = 6, g = 7, m = 8, d = 9, h = 10, o = 11, _ = 12, u = 13, R = 14, f = i.New(i.Rect), S = i.New(i.Quad), I = i.New(i.Rect), c = i.New(i.Quad);\n    i.Plugins.TiledBg.Instance = class extends i.SDKWorldInstanceBase {\n      constructor(e, t) {\n        super(e), this._imageOffsetX = 0, this._imageOffsetY = 0, this._imageScaleX = 1, this._imageScaleY = 1, this._imageAngle = 0, this._enableTileRandomization = false, this._tileXRandom = 0, this._tileYRandom = 0, this._tileAngleRandom = 0, this._tileBlendMarginX = 0, this._tileBlendMarginY = 0, this._ownImageInfo = null, t && (this.GetWorldInfo().SetVisible(!!t[n]), this._imageOffsetX = t[s], this._imageOffsetY = t[l], this._imageScaleX = t[r], this._imageScaleY = t[g], this._imageAngle = i.toRadians(t[m]), this._enableTileRandomization = !!t[d], this._tileXRandom = t[h], this._tileYRandom = t[o], this._tileAngleRandom = t[_], this._tileBlendMarginX = t[u], this._tileBlendMarginY = t[R]);\n      }\n      Release() {\n        this._ReleaseOwnImage(), super.Release();\n      }\n      _ReleaseOwnImage() {\n        this._ownImageInfo && (this._ownImageInfo.Release(), this._ownImageInfo = null);\n      }\n      CalculateTextureCoordsFor3DFace(e, t, i2) {\n        const a2 = this.GetCurrentImageInfo(), n2 = a2.GetWidth(), s2 = a2.GetHeight(), l2 = this._imageOffsetX / n2, r2 = this._imageOffsetY / s2, g2 = this._imageAngle;\n        I.set(0, 0, e / (n2 * this._imageScaleX), t / (s2 * this._imageScaleY)), I.offset(-l2, -r2), 0 === g2 ? i2.setFromRect(I) : i2.setFromRotatedRect(I, -g2);\n      }\n      SetTilingShaderProgram(e, t = true) {\n        if (this._enableTileRandomization) {\n          const t2 = this.GetCurrentImageInfo();\n          e.SetTileRandomizationMode(), e.SetTileRandomizationInfo(t2.GetWidth() * this._imageScaleX, t2.GetHeight() * this._imageScaleY, this._tileXRandom, this._tileYRandom, this._tileAngleRandom, this._tileBlendMarginX, this._tileBlendMarginY);\n        } else t && e.SetTextureFillMode();\n      }\n      Draw(e) {\n        const t = this.GetCurrentImageInfo(), i2 = t.GetTexture();\n        if (null === i2) return;\n        this.SetTilingShaderProgram(e), e.SetTexture(i2);\n        const a2 = t.GetWidth(), n2 = t.GetHeight();\n        let s2 = this._imageOffsetX / a2, l2 = this._imageOffsetY / n2;\n        0 !== this._imageAngle || this._enableTileRandomization || (\"repeat\" === this.GetSdkType().GetWrapModeX() && (s2 %= 1), \"repeat\" === this.GetSdkType().GetWrapModeY() && (l2 %= 1));\n        const r2 = this.GetWorldInfo();\n        I.set(0, 0, r2.GetWidth() / (a2 * this._imageScaleX), r2.GetHeight() / (n2 * this._imageScaleY)), I.offset(-s2, -l2), r2.HasMesh() ? this._DrawMesh(r2, e) : this._DrawStandard(r2, e);\n      }\n      _DrawStandard(e, t) {\n        let i2 = e.GetBoundingQuad();\n        this._runtime.IsPixelRoundingEnabled() && (i2 = e.PixelRoundQuad(i2)), 0 === this._imageAngle ? t.Quad3(i2, I) : (c.setFromRotatedRect(I, -this._imageAngle), t.Quad4(i2, c));\n      }\n      _DrawMesh(e, t) {\n        const i2 = e.GetTransformedMesh();\n        if (e.IsMeshChanged()) {\n          e.CalculateBbox(f, S, false);\n          let t2 = S;\n          this._runtime.IsPixelRoundingEnabled() && (t2 = e.PixelRoundQuad(t2));\n          let a2 = I;\n          0 !== this._imageAngle && (c.setFromRotatedRect(I, -this._imageAngle), a2 = c), i2.CalculateTransformedMesh(e.GetSourceMesh(), t2, a2), e.SetMeshChanged(false);\n        }\n        i2.Draw(t);\n      }\n      GetCurrentImageInfo() {\n        return this._ownImageInfo || this._objectClass.GetImageInfo();\n      }\n      IsOriginalSizeKnown() {\n        return true;\n      }\n      GetTexture() {\n        return this.GetCurrentImageInfo().GetTexture();\n      }\n      _SetMeshChanged() {\n        this.GetWorldInfo().SetMeshChanged(true);\n      }\n      _SetImageOffsetX(e) {\n        this._imageOffsetX !== e && (this._imageOffsetX = e, this._runtime.UpdateRender(), this._SetMeshChanged());\n      }\n      _GetImageOffsetX() {\n        return this._imageOffsetX;\n      }\n      _SetImageOffsetY(e) {\n        this._imageOffsetY !== e && (this._imageOffsetY = e, this._runtime.UpdateRender(), this._SetMeshChanged());\n      }\n      _GetImageOffsetY() {\n        return this._imageOffsetY;\n      }\n      _SetImageScaleX(e) {\n        this._imageScaleX !== e && (this._imageScaleX = e, this._runtime.UpdateRender(), this._SetMeshChanged());\n      }\n      _GetImageScaleX() {\n        return this._imageScaleX;\n      }\n      _SetImageScaleY(e) {\n        this._imageScaleY !== e && (this._imageScaleY = e, this._runtime.UpdateRender(), this._SetMeshChanged());\n      }\n      _GetImageScaleY() {\n        return this._imageScaleY;\n      }\n      _SetImageAngle(e) {\n        this._imageAngle !== e && (this._imageAngle = e, this._runtime.UpdateRender(), this._SetMeshChanged());\n      }\n      _GetImageAngle() {\n        return this._imageAngle;\n      }\n      _SetTileRandomizationEnabled(e) {\n        e = !!e, this._enableTileRandomization !== e && (this._enableTileRandomization = e, this._runtime.UpdateRender());\n      }\n      _IsTileRandomizationEnabled() {\n        return this._enableTileRandomization;\n      }\n      _SetTileXRandom(e) {\n        this._tileXRandom !== e && (this._tileXRandom = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());\n      }\n      _GetTileXRandom() {\n        return this._tileXRandom;\n      }\n      _SetTileYRandom(e) {\n        this._tileYRandom !== e && (this._tileYRandom = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());\n      }\n      _GetTileYRandom() {\n        return this._tileYRandom;\n      }\n      _SetTileAngleRandom(e) {\n        this._tileAngleRandom !== e && (this._tileAngleRandom = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());\n      }\n      _GetTileAngleRandom() {\n        return this._tileAngleRandom;\n      }\n      _SetTileBlendMarginX(e) {\n        this._tileBlendMarginX !== e && (this._tileBlendMarginX = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());\n      }\n      _GetTileBlendMarginX() {\n        return this._tileBlendMarginX;\n      }\n      _SetTileBlendMarginY(e) {\n        this._tileBlendMarginY !== e && (this._tileBlendMarginY = e, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender());\n      }\n      _GetTileBlendMarginY() {\n        return this._tileBlendMarginY;\n      }\n      SaveToJson() {\n        const e = {};\n        return 0 !== this._imageOffsetX && (e[\"iox\"] = this._imageOffsetX), 0 !== this._imageOffsetY && (e[\"ioy\"] = this._imageOffsetY), 1 !== this._imageScaleX && (e[\"isx\"] = this._imageScaleX), 1 !== this._imageScaleY && (e[\"isy\"] = this._imageScaleY), 0 !== this._imageAngle && (e[\"ia\"] = this._imageAngle), this._enableTileRandomization && (e[\"tr\"] = true), 1 !== this._tileXRandom && (e[\"trx\"] = this._tileXRandom), 1 !== this._tileYRandom && (e[\"try\"] = this._tileYRandom), 1 !== this._tileAngleRandom && (e[\"tra\"] = this._tileAngleRandom), 0.1 !== this._tileBlendMarginX && (e[\"trbmx\"] = this._tileBlendMarginX), 0.1 !== this._tileBlendMarginY && (e[\"trbmy\"] = this._tileBlendMarginY), e;\n      }\n      LoadFromJson(e) {\n        this._imageOffsetX = e[\"iox\"] || 0, this._imageOffsetY = e[\"ioy\"] || 0, this._imageScaleX = e.hasOwnProperty(\"isx\") ? e[\"isx\"] : 1, this._imageScaleY = e.hasOwnProperty(\"isy\") ? e[\"isy\"] : 1, this._imageAngle = e[\"ia\"] || 0, this._enableTileRandomization = !!e[\"tr\"], this._tileXRandom = e.hasOwnProperty(\"trx\") ? e[\"trx\"] : 1, this._tileYRandom = e.hasOwnProperty(\"try\") ? e[\"try\"] : 1, this._tileAngleRandom = e.hasOwnProperty(\"tra\") ? e[\"tra\"] : 1, this._tileBlendMarginX = e.hasOwnProperty(\"trbmx\") ? e[\"trbmx\"] : 0.1, this._tileBlendMarginY = e.hasOwnProperty(\"trbmy\") ? e[\"trbmy\"] : 0.1;\n      }\n      GetDebuggerProperties() {\n        const e = \"plugins.tiledbg.properties\";\n        return [{ title: e + \".image-transform.name\", properties: [{ name: e + \".image-offset-x.name\", value: this._GetImageOffsetX(), onedit: (e2) => this._SetImageOffsetX(e2) }, { name: e + \".image-offset-y.name\", value: this._GetImageOffsetY(), onedit: (e2) => this._SetImageOffsetY(e2) }, { name: e + \".image-scale-x.name\", value: 100 * this._GetImageScaleX(), onedit: (e2) => this._SetImageScaleX(e2 / 100) }, { name: e + \".image-scale-y.name\", value: 100 * this._GetImageScaleY(), onedit: (e2) => this._SetImageScaleY(e2 / 100) }, { name: e + \".image-angle.name\", value: i.toDegrees(this._GetImageAngle()), onedit: (e2) => this._SetImageAngle(i.toRadians(e2)) }] }, { title: e + \".tile-randomization.name\", properties: [{ name: e + \".enable-tile-randomization.name\", value: this._IsTileRandomizationEnabled(), onedit: (e2) => this._SetTileRandomizationEnabled(e2) }, { name: e + \".x-random.name\", value: 100 * this._GetTileXRandom(), onedit: (e2) => this._SetTileXRandom(e2 / 100) }, { name: e + \".y-random.name\", value: 100 * this._GetTileYRandom(), onedit: (e2) => this._SetTileYRandom(e2 / 100) }, { name: e + \".angle-random.name\", value: 100 * this._GetTileAngleRandom(), onedit: (e2) => this._SetTileAngleRandom(e2 / 100) }, { name: e + \".blend-margin-x.name\", value: 100 * this._GetTileBlendMarginX(), onedit: (e2) => this._SetTileBlendMarginX(e2 / 100) }, { name: e + \".blend-margin-y.name\", value: 100 * this._GetTileBlendMarginY(), onedit: (e2) => this._SetTileBlendMarginY(e2 / 100) }] }];\n      }\n      GetPropertyValueByIndex(e) {\n        switch (e) {\n          case s:\n            return this._GetImageOffsetX();\n          case l:\n            return this._GetImageOffsetY();\n          case r:\n            return this._GetImageScaleX();\n          case g:\n            return this._GetImageScaleY();\n          case m:\n            return this._GetImageAngle();\n          case d:\n            return this._IsTileRandomizationEnabled();\n          case h:\n            return this._GetTileXRandom();\n          case o:\n            return this._GetTileYRandom();\n          case _:\n            return this._GetTileAngleRandom();\n          case u:\n            return this._GetTileBlendMarginX();\n          case R:\n            return this._GetTileBlendMarginY();\n        }\n      }\n      SetPropertyValueByIndex(e, t) {\n        switch (e) {\n          case s:\n            this._SetImageOffsetX(t);\n            break;\n          case l:\n            this._SetImageOffsetY(t);\n            break;\n          case r:\n            this._SetImageScaleX(t);\n            break;\n          case g:\n            this._SetImageScaleY(t);\n            break;\n          case m:\n            this._SetImageAngle(t);\n            break;\n          case d:\n            this._SetTileRandomizationEnabled(!!t);\n            break;\n          case h:\n            this._SetTileXRandom(t);\n            break;\n          case o:\n            this._SetTileYRandom(t);\n            break;\n          case _:\n            this._SetTileAngleRandom(t);\n            break;\n          case u:\n            this._SetTileBlendMarginX(t);\n            break;\n          case R:\n            this._SetTileBlendMarginY(t);\n        }\n      }\n      GetScriptInterfaceClass() {\n        return self.ITiledBackgroundInstance;\n      }\n    };\n    const T = /* @__PURE__ */ new WeakMap();\n    self.ITiledBackgroundInstance = class extends self.IWorldInstance {\n      constructor() {\n        super(), T.set(this, self.IInstance._GetInitInst().GetSdkInstance());\n      }\n      set imageOffsetX(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetImageOffsetX(e);\n      }\n      get imageOffsetX() {\n        return T.get(this)._GetImageOffsetX();\n      }\n      set imageOffsetY(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetImageOffsetY(e);\n      }\n      get imageOffsetY() {\n        return T.get(this)._GetImageOffsetY();\n      }\n      setImageOffset(e, t) {\n        a.RequireFiniteNumber(e), a.RequireFiniteNumber(t);\n        const i2 = T.get(this);\n        i2._SetImageOffsetX(e), i2._SetImageOffsetY(t);\n      }\n      getImageOffset() {\n        const e = T.get(this);\n        return [e._GetImageOffsetX(), e._GetImageOffsetY()];\n      }\n      set imageScaleX(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetImageScaleX(e);\n      }\n      get imageScaleX() {\n        return T.get(this)._GetImageScaleX();\n      }\n      set imageScaleY(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetImageScaleY(e);\n      }\n      get imageScaleY() {\n        return T.get(this)._GetImageScaleY();\n      }\n      setImageScale(e, t) {\n        a.RequireFiniteNumber(e), a.RequireFiniteNumber(t);\n        const i2 = T.get(this);\n        i2._SetImageScaleX(e), i2._SetImageScaleY(t);\n      }\n      getImageScale() {\n        const e = T.get(this);\n        return [e._GetImageScaleX(), e._GetImageScaleY()];\n      }\n      set imageAngle(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetImageAngle(e);\n      }\n      get imageAngle() {\n        return T.get(this)._GetImageAngle();\n      }\n      set imageAngleDegrees(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetImageAngle(i.toRadians(e));\n      }\n      get imageAngleDegrees() {\n        return i.toDegrees(T.get(this)._GetImageAngle());\n      }\n      get imageWidth() {\n        return T.get(this).GetCurrentImageInfo().GetWidth();\n      }\n      get imageHeight() {\n        return T.get(this).GetCurrentImageInfo().GetHeight();\n      }\n      getImageSize() {\n        const e = T.get(this).GetCurrentImageInfo();\n        return [e.GetWidth(), e.GetHeight()];\n      }\n      set enableTileRandomization(e) {\n        T.get(this)._SetTileRandomizationEnabled(!!e);\n      }\n      get enableTileRandomization() {\n        return T.get(this)._IsTileRandomizationEnabled();\n      }\n      set tileXRandom(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetTileXRandom(e);\n      }\n      get tileXRandom() {\n        return T.get(this)._GetTileXRandom();\n      }\n      set tileYRandom(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetTileYRandom(e);\n      }\n      get tileYRandom() {\n        return T.get(this)._GetTileYRandom();\n      }\n      setTileRandom(e, t) {\n        a.RequireFiniteNumber(e), a.RequireFiniteNumber(t);\n        const i2 = T.get(this);\n        i2._SetTileXRandom(e), i2._SetTileYRandom(t);\n      }\n      getTileRandom() {\n        const e = T.get(this);\n        return [e._GetTileXRandom(), e._GetTileYRandom()];\n      }\n      set tileAngleRandom(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetTileAngleRandom(e);\n      }\n      get tileAngleRandom() {\n        return T.get(this)._GetTileAngleRandom();\n      }\n      set tileBlendMarginX(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetTileBlendMarginX(e);\n      }\n      get tileBlendMarginX() {\n        return T.get(this)._GetTileBlendMarginX();\n      }\n      set tileBlendMarginY(e) {\n        a.RequireFiniteNumber(e), T.get(this)._SetTileBlendMarginY(e);\n      }\n      get tileBlendMarginY() {\n        return T.get(this)._GetTileBlendMarginY();\n      }\n      setTileBlendMargin(e, t) {\n        a.RequireFiniteNumber(e), a.RequireFiniteNumber(t);\n        const i2 = T.get(this);\n        i2._SetTileBlendMarginX(e), i2._SetTileBlendMarginY(t);\n      }\n      getTileBlendMargin() {\n        const e = T.get(this);\n        return [e._GetTileBlendMarginX(), e._GetTileBlendMarginY()];\n      }\n      async replaceImage(e) {\n        a.RequireInstanceOf(e, Blob);\n        const t = T.get(this), n2 = t.GetRuntime(), s2 = i.New(i.ImageInfo);\n        s2.LoadDynamicBlobAsset(n2, e), await s2.LoadStaticTexture(n2.GetRenderer(), { sampling: n2.GetSampling(), wrapX: t.GetSdkType().GetWrapModeX(), wrapY: t.GetSdkType().GetWrapModeY() }), t.WasReleased() ? s2.Release() : (t._ReleaseOwnImage(), t._ownImageInfo = s2, n2.UpdateRender());\n      }\n    };\n  }\n  self.C3.Plugins.TiledBg.Cnds = { OnURLLoaded: () => true, OnURLFailed: () => true, IsTileRandomizationEnabled() {\n    return this._IsTileRandomizationEnabled();\n  } };\n  {\n    const G = self.C3;\n    G.Plugins.TiledBg.Acts = { SetImageOffsetX(e) {\n      this._SetImageOffsetX(e);\n    }, SetImageOffsetY(e) {\n      this._SetImageOffsetY(e);\n    }, SetImageScaleX(e) {\n      this._SetImageScaleX(e / 100);\n    }, SetImageScaleY(e) {\n      this._SetImageScaleY(e / 100);\n    }, SetImageAngle(e) {\n      this._SetImageAngle(G.toRadians(e));\n    }, SetTileRandomizationEnabled(e) {\n      this._SetTileRandomizationEnabled(e);\n    }, SetTilePosRandom(e, t) {\n      this._SetTileXRandom(e / 100), this._SetTileYRandom(t / 100);\n    }, SetTileAngleRandom(e) {\n      this._SetTileAngleRandom(e / 100);\n    }, SetTileBlendMargin(e, t) {\n      this._SetTileBlendMarginX(e / 100), this._SetTileBlendMarginY(t / 100);\n    }, SetEffect(e) {\n      this.GetWorldInfo().SetBlendMode(e), this._runtime.UpdateRender();\n    }, async LoadURL(e, t) {\n      if (this._ownImageInfo && this._ownImageInfo.GetURL() === e) return;\n      const i = this._runtime, a = G.New(G.ImageInfo);\n      try {\n        if (await a.LoadDynamicAsset(i, e, true), !a.IsLoaded()) throw new Error(\"image failed to load\");\n        if (this.WasReleased()) return a.Release(), null;\n        if (!await a.LoadStaticTexture(i.GetRenderer(), { sampling: i.GetSampling(), wrapX: this.GetSdkType().GetWrapModeX(), wrapY: this.GetSdkType().GetWrapModeY() })) return;\n      } catch (e2) {\n        return console.error(\"Load image from URL failed: \", e2), void (this.WasReleased() || this.Trigger(G.Plugins.TiledBg.Cnds.OnURLFailed));\n      }\n      this.WasReleased() ? a.Release() : (this._ReleaseOwnImage(), this._ownImageInfo = a, i.UpdateRender(), await this.TriggerAsync(G.Plugins.TiledBg.Cnds.OnURLLoaded));\n    } };\n  }\n  {\n    const X = self.C3;\n    X.Plugins.TiledBg.Exps = { ImageWidth() {\n      return this.GetCurrentImageInfo().GetWidth();\n    }, ImageHeight() {\n      return this.GetCurrentImageInfo().GetHeight();\n    }, ImageOffsetX() {\n      return this._imageOffsetX;\n    }, ImageOffsetY() {\n      return this._imageOffsetY;\n    }, ImageScaleX() {\n      return 100 * this._imageScaleX;\n    }, ImageScaleY() {\n      return 100 * this._imageScaleY;\n    }, ImageAngle() {\n      return X.toDegrees(this._imageAngle);\n    }, TileXRandom() {\n      return 100 * this._GetTileXRandom();\n    }, TileYRandom() {\n      return 100 * this._GetTileYRandom();\n    }, TileAngleRandom() {\n      return 100 * this._GetTileAngleRandom();\n    }, TileBlendMarginX() {\n      return 100 * this._GetTileBlendMarginX();\n    }, TileBlendMarginY() {\n      return 100 * this._GetTileBlendMarginY();\n    } };\n  }\n}\nvar WrapModeToStr2;\n{\n  {\n    const t = self.C3;\n    t.Plugins.Spritefont2 = class extends t.SDKPluginBase {\n      constructor(t2) {\n        super(t2);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const t = self.C3;\n    t.Plugins.Spritefont2.Type = class extends t.SDKTypeBase {\n      constructor(e) {\n        super(e), this._spriteFont = t.New(self.SpriteFont);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n        this.GetImageInfo().LoadAsset(this._runtime);\n      }\n      LoadTextures(t2) {\n        return this.GetImageInfo().LoadStaticTexture(t2, { sampling: this._runtime.GetSampling() });\n      }\n      ReleaseTextures() {\n        this.GetImageInfo().ReleaseTexture();\n      }\n      GetSpriteFont() {\n        return this._spriteFont;\n      }\n      UpdateSettings(t2, e, i, r) {\n        const s = this.GetImageInfo(), n = this._spriteFont;\n        n.SetWidth(s.GetWidth()), n.SetHeight(s.GetHeight()), n.SetCharacterWidth(t2), n.SetCharacterHeight(e), n.SetCharacterSet(i), n.SetSpacingData(r), n.UpdateCharacterMap();\n      }\n    };\n  }\n  {\n    const t = self.C3, e = self.C3X, i = t.New(t.Vector2), r = 0, s = 1, n = 2, a = 3, h = 4, c = 5, o = 6, _ = 7, g = 8, p = 9, S = 10, l = 11, d = 14, T = [\"left\", \"center\", \"right\"], u = [\"top\", \"center\", \"bottom\"], G = [\"word\", \"cjk\", \"character\"];\n    t.Plugins.Spritefont2.Instance = class extends t.SDKWorldInstanceBase {\n      constructor(e2, i2) {\n        super(e2), this._text = \"\", this._enableBBcode = true, this._characterWidth = 16, this._characterHeight = 16, this._characterSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#\\\"'&()[]|`\\\\/@\\xB0+=*$\\xA3\\u20AC<>\";\n        let r2 = \"\";\n        if (this._characterScale = 1, this._characterSpacing = 0, this._lineHeight = 0, this._horizontalAlign = 0, this._verticalAlign = 0, this._wrapMode = \"word\", this._needsTextLayout = true, this._readAloud = false, this._screenReaderText = null, this._spriteFontText = null, this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, i2) {\n          this._text = i2[0], this._enableBBcode = i2[1], this._characterWidth = i2[2], this._characterHeight = i2[3], this._characterSet = i2[4], r2 = i2[5], this._characterScale = i2[6], this._characterSpacing = i2[7], this._lineHeight = i2[8], this._horizontalAlign = i2[9], this._verticalAlign = i2[10], this._wrapMode = G[i2[11]];\n          this.GetWorldInfo().SetVisible(i2[12]), this._readAloud = !!i2[d];\n        }\n        this._sdkType.UpdateSettings(this._characterWidth, this._characterHeight, this._characterSet, r2), this._spriteFontText = t.New(self.SpriteFontText, this._sdkType.GetSpriteFont());\n        const s2 = this.GetWorldInfo();\n        this._spriteFontText.SetSize(s2.GetWidth(), s2.GetHeight()), this._UpdateSettings(), this._UpdateScreenReaderText(), this._inst.SetMustMitigateZFighting();\n      }\n      Release() {\n        this._CancelTypewriter(), this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null), this._spriteFontText.Release(), this._spriteFontText = null, super.Release();\n      }\n      _UpdateSettings() {\n        const t2 = this._spriteFontText;\n        t2 && (t2.SetBBCodeEnabled(this._enableBBcode), t2.SetText(this._text), t2.SetWordWrapMode(this._wrapMode), t2.SetHorizontalAlign(T[this._horizontalAlign]), t2.SetVerticalAlign(u[this._verticalAlign]), t2.SetSpacing(this._characterSpacing), t2.SetLineHeight(this._lineHeight));\n      }\n      _UpdateTextSize() {\n        const t2 = this.GetWorldInfo();\n        this._spriteFontText.SetSize(t2.GetWidth(), t2.GetHeight()), this._spriteFontText.SetScale(this._characterScale);\n      }\n      _UpdateScreenReaderText() {\n        if (this._readAloud) {\n          let e2 = this._text;\n          this._enableBBcode && (e2 = t.BBString.StripAnyTags(e2)), this._screenReaderText ? this._screenReaderText.SetText(e2) : this._screenReaderText = t.New(t.ScreenReaderText, this._runtime, e2);\n        } else this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null);\n      }\n      Draw(t2) {\n        const e2 = this._objectClass.GetImageInfo(), i2 = e2.GetTexture();\n        if (!i2) return;\n        t2.SetTexture(i2);\n        const r2 = this.GetWorldInfo();\n        let s2 = r2.GetBoundingQuad();\n        const n2 = this._spriteFontText;\n        n2.SetScale(this._characterScale), n2.SetSceneGraphScale(r2.GetSceneGraphScale()), this._runtime.IsPixelRoundingEnabled() && (s2 = r2.PixelRoundQuad(s2)), n2.SetSize(r2.GetWidth(), r2.GetHeight()), n2.GetSpriteFont().SetTexRect(e2.GetTexRect()), n2.SetColor(r2.GetUnpremultipliedColor()), n2.Draw(t2, s2.getTlx(), s2.getTly(), r2.GetAngle()), this._needsTextLayout = false;\n      }\n      SaveToJson() {\n        const t2 = { \"t\": this._text, \"ebbc\": this._enableBBcode, \"csc\": this._characterScale, \"csp\": this._characterSpacing, \"lh\": this._lineHeight, \"ha\": this._horizontalAlign, \"va\": this._verticalAlign, \"w\": this._wrapMode, \"cw\": this._sdkType.GetSpriteFont().GetCharacterWidth(), \"ch\": this._sdkType.GetSpriteFont().GetCharacterHeight(), \"cs\": this._sdkType.GetSpriteFont().GetCharacterSet(), \"sd\": this._sdkType.GetSpriteFont().GetSpacingData() };\n        return -1 !== this._typewriterEndTime && (t2[\"tw\"] = { \"st\": this._typewriterStartTime, \"en\": this._typewriterEndTime, \"l\": this._typewriterLength }), t2;\n      }\n      LoadFromJson(t2) {\n        if (this._CancelTypewriter(), this._text = t2[\"t\"], this._enableBBcode = t2[\"ebbc\"], this._characterScale = t2[\"csc\"], this._characterSpacing = t2[\"csp\"], this._lineHeight = t2[\"lh\"], this._horizontalAlign = t2[\"ha\"], this._verticalAlign = t2[\"va\"], t2.hasOwnProperty(\"w\")) {\n          const e3 = t2[\"w\"];\n          this._wrapMode = \"boolean\" == typeof e3 ? e3 ? \"word\" : \"character\" : e3;\n        } else this._wrapMode = \"word\";\n        if (t2.hasOwnProperty(\"tw\")) {\n          const e3 = t2[\"tw\"];\n          this._typewriterStartTime = e3[\"st\"], this._typewriterEndTime = e3[\"en\"], this._typewriterLength = t2[\"l\"];\n        }\n        const e2 = this._sdkType.GetSpriteFont();\n        e2.SetCharacterWidth(t2[\"cw\"]), e2.SetCharacterHeight(t2[\"ch\"]), e2.SetCharacterSet(t2[\"cs\"]), e2.SetSpacingData(t2[\"sd\"]), this._UpdateSettings(), this._UpdateScreenReaderText(), -1 !== this._typewriterEndTime && this._StartTicking();\n      }\n      GetPropertyValueByIndex(t2) {\n        switch (t2) {\n          case r:\n            return this.GetText();\n          case s:\n            return this._enableBBcode;\n          case n:\n            return this._sdkType.GetSpriteFont().GetCharacterWidth();\n          case a:\n            return this._sdkType.GetSpriteFont().GetCharacterHeight();\n          case h:\n            return this._sdkType.GetSpriteFont().GetCharacterSet();\n          case c:\n            return this._sdkType.GetSpriteFont().GetSpacingData();\n          case o:\n            return this._GetScale();\n          case _:\n            return this._GetCharacterSpacing();\n          case g:\n            return this._GetLineHeight();\n          case p:\n            return this._GetHAlign();\n          case S:\n            return this._GetVAlign();\n          case l:\n            return this._GetWrapMode();\n        }\n      }\n      SetPropertyValueByIndex(t2, e2) {\n        switch (t2) {\n          case r:\n            this._SetText(e2);\n            break;\n          case s:\n            if (this._enableBBcode === !!e2) return;\n            this._enableBBcode = !!e2, this._UpdateSettings();\n            break;\n          case n:\n            this._sdkType.GetSpriteFont().SetCharacterWidth(e2);\n            break;\n          case a:\n            this._sdkType.GetSpriteFont().SetCharacterHeight(e2);\n            break;\n          case h:\n            this._sdkType.GetSpriteFont().SetCharacterSet(e2);\n            break;\n          case c:\n            this._sdkType.GetSpriteFont().SetSpacingData(e2);\n            break;\n          case o:\n            this._SetScale(e2);\n            break;\n          case _:\n            this._SetCharacterSpacing(e2);\n            break;\n          case g:\n            this._SetLineHeight(e2);\n            break;\n          case p:\n            this._SetHAlign(e2);\n            break;\n          case S:\n            this._SetVAlign(e2);\n            break;\n          case l:\n            this._SetWrapMode(e2);\n        }\n      }\n      _SetText(t2) {\n        this._text !== t2 && (this._text = t2, this._spriteFontText.SetText(t2), this._UpdateScreenReaderText(), this._runtime.UpdateRender());\n      }\n      GetText() {\n        return this._text;\n      }\n      _StartTypewriter(e2, i2) {\n        this._SetText(e2), this._typewriterStartTime = this._runtime.GetWallTime(), this._typewriterEndTime = this._typewriterStartTime + i2 / this.GetInstance().GetActiveTimeScale(), this._typewriterLength = t.CountGraphemes(t.BBString.StripAnyTags(e2)), this._spriteFontText.SetDrawMaxCharacterCount(0), this._StartTicking();\n      }\n      _CancelTypewriter() {\n        this._typewriterStartTime = -1, this._typewriterEndTime = -1, this._typewriterLength = 0, this._spriteFontText.SetDrawMaxCharacterCount(-1), this._StopTicking();\n      }\n      _FinishTypewriter() {\n        -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(t.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender());\n      }\n      _SetScale(t2) {\n        this._characterScale !== t2 && (this._characterScale = t2, this._spriteFontText.SetScale(this._characterScale), this._runtime.UpdateRender());\n      }\n      _GetScale() {\n        return this._characterScale;\n      }\n      _SetCharacterSpacing(t2) {\n        this._characterSpacing !== t2 && (this._characterSpacing = t2, this._spriteFontText.SetSpacing(this._characterSpacing), this._runtime.UpdateRender());\n      }\n      _GetCharacterSpacing() {\n        return this._characterSpacing;\n      }\n      _SetLineHeight(t2) {\n        this._lineHeight !== t2 && (this._lineHeight = t2, this._spriteFontText.SetLineHeight(this._lineHeight), this._runtime.UpdateRender());\n      }\n      _GetLineHeight() {\n        return this._lineHeight;\n      }\n      _SetHAlign(t2) {\n        this._horizontalAlign !== t2 && (this._horizontalAlign = t2, this._UpdateSettings(), this._runtime.UpdateRender());\n      }\n      _GetHAlign() {\n        return this._horizontalAlign;\n      }\n      _SetVAlign(t2) {\n        this._verticalAlign !== t2 && (this._verticalAlign = t2, this._UpdateSettings(), this._runtime.UpdateRender());\n      }\n      _GetVAlign() {\n        return this._verticalAlign;\n      }\n      _SetWrapModeByIndex(t2) {\n        this._SetWrapMode(G[t2]);\n      }\n      _SetWrapMode(t2) {\n        this._wrapMode !== t2 && (this._wrapMode = t2, this._UpdateSettings(), this._runtime.UpdateRender());\n      }\n      _GetWrapMode() {\n        return this._wrapMode;\n      }\n      _SetReadAloud(t2) {\n        this._readAloud = !!t2, this._UpdateScreenReaderText();\n      }\n      _IsReadAloud() {\n        return this._readAloud;\n      }\n      _GetTextWidth() {\n        return this._UpdateTextSize(), this._spriteFontText.GetTextWidth();\n      }\n      _GetTextHeight() {\n        return this._UpdateTextSize(), this._spriteFontText.GetTextHeight();\n      }\n      _GetTagAtPosition(t2, e2) {\n        this._UpdateTextSize();\n        const r2 = this.GetWorldInfo();\n        i.set(t2 - r2.GetX(), e2 - r2.GetY()), i.rotate(-r2.GetAngle()), i.offset(r2.GetWidth() * r2.GetOriginX(), r2.GetHeight() * r2.GetOriginY());\n        const s2 = this._spriteFontText.HitTestFragment(i.getX(), i.getY());\n        if (s2) {\n          const t3 = s2.GetStyleTag(\"tag\");\n          if (t3) return t3.param;\n        }\n        return \"\";\n      }\n      _HasTagAtPosition(e2, i2, r2) {\n        const s2 = this._GetTagAtPosition(i2, r2);\n        return s2 && t.equalsNoCase(e2, s2);\n      }\n      _GetTagPosition(t2, e2) {\n        this._UpdateTextSize(), e2 = Math.floor(e2);\n        const r2 = this._spriteFontText.FindFragmentWithTag(t2, e2);\n        if (!r2) return null;\n        const s2 = this.GetWorldInfo();\n        return i.set(r2.GetPosX(), r2.GetPosY()), i.offset(-s2.GetWidth() * s2.GetOriginX(), -s2.GetHeight() * s2.GetOriginY()), i.rotate(s2.GetAngle()), i.offset(s2.GetX(), s2.GetY()), { x: i.getX(), y: i.getY(), width: r2.GetWidth(), height: r2.GetHeight() };\n      }\n      _GetTagCount(t2) {\n        return this._UpdateTextSize(), this._spriteFontText.CountFragmentsWithTag(t2);\n      }\n      Tick() {\n        const e2 = this._runtime.GetWallTime();\n        if (e2 >= this._typewriterEndTime) this._CancelTypewriter(), this.Trigger(t.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender();\n        else {\n          let i2 = t.relerp(this._typewriterStartTime, this._typewriterEndTime, e2, 0, this._typewriterLength);\n          i2 = Math.floor(i2), i2 !== this._spriteFontText.GetDrawMaxCharacterCount() && (this._spriteFontText.SetDrawMaxCharacterCount(i2), this._runtime.UpdateRender());\n        }\n      }\n      GetDebuggerProperties() {\n        const t2 = \"plugins.spritefont2\";\n        return [{ title: t2 + \".name\", properties: [{ name: t2 + \".properties.text.name\", value: this.GetText(), onedit: (t3) => this._SetText(t3) }, { name: t2 + \".properties.scale.name\", value: this._GetScale(), onedit: (t3) => this._SetScale(t3) }, { name: t2 + \".properties.character-spacing.name\", value: this._GetCharacterSpacing(), onedit: (t3) => this._SetCharacterSpacing(t3) }, { name: t2 + \".properties.line-height.name\", value: this._GetLineHeight(), onedit: (t3) => this._SetLineHeight(t3) }] }];\n      }\n      GetScriptInterfaceClass() {\n        return self.ISpriteFontInstance;\n      }\n    };\n    const x = /* @__PURE__ */ new WeakMap(), w = /* @__PURE__ */ new Map([[\"left\", 0], [\"center\", 1], [\"right\", 2]]), y = /* @__PURE__ */ new Map([[\"top\", 0], [\"center\", 1], [\"bottom\", 2]]);\n    self.ISpriteFontInstance = class extends self.IWorldInstance {\n      constructor() {\n        super(), x.set(this, self.IInstance._GetInitInst().GetSdkInstance());\n      }\n      get text() {\n        return x.get(this).GetText();\n      }\n      set text(t2) {\n        e.RequireString(t2);\n        const i2 = x.get(this);\n        i2._CancelTypewriter(), i2._SetText(t2);\n      }\n      typewriterText(t2, i2) {\n        e.RequireString(t2), e.RequireFiniteNumber(i2);\n        const r2 = x.get(this);\n        r2._CancelTypewriter(), r2._StartTypewriter(t2, i2);\n      }\n      typewriterFinish() {\n        x.get(this)._FinishTypewriter();\n      }\n      set characterScale(t2) {\n        e.RequireFiniteNumber(t2), x.get(this)._SetScale(t2);\n      }\n      get characterScale() {\n        return x.get(this)._GetScale();\n      }\n      set characterSpacing(t2) {\n        e.RequireFiniteNumber(t2), x.get(this)._SetCharacterSpacing(t2);\n      }\n      get characterSpacing() {\n        return x.get(this)._GetCharacterSpacing();\n      }\n      set lineHeight(t2) {\n        e.RequireFiniteNumber(t2), x.get(this)._SetLineHeight(t2);\n      }\n      get lineHeight() {\n        return x.get(this)._GetLineHeight();\n      }\n      set horizontalAlign(t2) {\n        e.RequireString(t2);\n        const i2 = w.get(t2);\n        if (void 0 === i2) throw new Error(\"invalid mode\");\n        x.get(this)._SetHAlign(i2);\n      }\n      get horizontalAlign() {\n        return T[x.get(this)._GetHAlign()];\n      }\n      set verticalAlign(t2) {\n        e.RequireString(t2);\n        const i2 = y.get(t2);\n        if (void 0 === i2) throw new Error(\"invalid mode\");\n        x.get(this)._SetVAlign(i2);\n      }\n      get verticalAlign() {\n        return u[x.get(this)._GetVAlign()];\n      }\n      set wordWrapMode(t2) {\n        if (!G.includes(t2)) throw new Error(\"invalid mode\");\n        x.get(this)._SetWrapMode(t2);\n      }\n      get wordWrapMode() {\n        return x.get(this)._GetWrapMode();\n      }\n      set readAloud(t2) {\n        x.get(this)._SetReadAloud(!!t2);\n      }\n      get readAloud() {\n        return x.get(this)._IsReadAloud();\n      }\n      get textWidth() {\n        return x.get(this)._GetTextWidth();\n      }\n      get textHeight() {\n        return x.get(this)._GetTextHeight();\n      }\n      getTextSize() {\n        const t2 = x.get(this);\n        return [t2._GetTextWidth(), t2._GetTextHeight()];\n      }\n      hasTagAtPosition(t2, i2, r2) {\n        return e.RequireString(t2), e.RequireFiniteNumber(i2), e.RequireFiniteNumber(r2), x.get(this)._HasTagAtPosition(t2, i2, r2);\n      }\n      getTagAtPosition(t2, i2) {\n        return e.RequireFiniteNumber(t2), e.RequireFiniteNumber(i2), x.get(this)._GetTagAtPosition(t2, i2);\n      }\n      getTagPositionAndSize(t2, i2 = 0) {\n        return e.RequireString(t2), e.RequireFiniteNumber(i2), x.get(this)._GetTagPosition(t2, i2);\n      }\n      getTagCount(t2) {\n        return e.RequireString(t2), x.get(this)._GetTagCount(t2);\n      }\n    };\n  }\n  {\n    const t = self.C3;\n    t.Plugins.Spritefont2.Cnds = { CompareText(e, i) {\n      return i ? this._text === e : t.equalsNoCase(this._text, e);\n    }, IsRunningTypewriterText() {\n      return -1 !== this._typewriterEndTime;\n    }, OnTypewriterTextFinished: () => true, HasTagAtPosition(t2, e, i) {\n      return this._HasTagAtPosition(t2, e, i);\n    } };\n  }\n  self.C3.Plugins.Spritefont2.Acts = { SetText(t) {\n    this._CancelTypewriter(), \"number\" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), this._SetText(t.toString());\n  }, AppendText(t) {\n    this._CancelTypewriter(), \"number\" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), (t = t.toString()) && this._SetText(this._text + t);\n  }, TypewriterText(t, e) {\n    this._CancelTypewriter(), \"number\" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), this._StartTypewriter(t.toString(), e);\n  }, TypewriterFinish() {\n    this._FinishTypewriter();\n  }, SetScale(t) {\n    this._SetScale(t);\n  }, SetCharacterSpacing(t) {\n    this._SetCharacterSpacing(t);\n  }, SetLineHeight(t) {\n    this._SetLineHeight(t);\n  }, SetCharacterWidth(t, e) {\n    let i = false;\n    const r = this._sdkType.GetSpriteFont();\n    for (const s of t) if (\" \" === s) r.SetSpaceWidth(e), i = true;\n    else {\n      const t2 = r.GetCharacter(s);\n      t2 && (t2.SetDisplayWidth(e), i = true);\n    }\n    i && r.SetCharacterWidthsChanged(), this._runtime.UpdateRender();\n  }, SetEffect(t) {\n    this.GetWorldInfo().SetBlendMode(t), this._runtime.UpdateRender();\n  }, SetHAlign(t) {\n    this._SetHAlign(t);\n  }, SetVAlign(t) {\n    this._SetVAlign(t);\n  }, SetWrapping(t) {\n    this._SetWrapModeByIndex(t);\n  }, SetReadAloud(t) {\n    this._SetReadAloud(t);\n  } };\n  {\n    const t = self.C3;\n    t.Plugins.Spritefont2.Exps = { CharacterWidth(t2) {\n      const e = this._sdkType.GetSpriteFont().GetCharacter(t2);\n      return e ? e.GetDisplayWidth() : this._sdkType.GetSpriteFont().GetCharacterWidth();\n    }, CharacterHeight() {\n      return this._characterHeight;\n    }, CharacterScale() {\n      return this._characterScale;\n    }, CharacterSpacing() {\n      return this._characterSpacing;\n    }, LineHeight() {\n      return this._lineHeight;\n    }, Text() {\n      return this._text;\n    }, PlainText() {\n      return this._enableBBcode ? t.BBString.StripAnyTags(this._text) : this._text;\n    }, TextWidth() {\n      return this._GetTextWidth();\n    }, TextHeight() {\n      return this._GetTextHeight();\n    }, TagAtPosition(t2, e) {\n      return this._GetTagAtPosition(t2, e);\n    }, TagCount(t2) {\n      return this._GetTagCount(t2);\n    }, TagX(t2, e) {\n      const i = this._GetTagPosition(t2, e);\n      return i ? i.x : 0;\n    }, TagY(t2, e) {\n      const i = this._GetTagPosition(t2, e);\n      return i ? i.y : 0;\n    }, TagWidth(t2, e) {\n      const i = this._GetTagPosition(t2, e);\n      return i ? i.width : 0;\n    }, TagHeight(t2, e) {\n      const i = this._GetTagPosition(t2, e);\n      return i ? i.height : 0;\n    } };\n  }\n}\n{\n  const C33 = self.C3;\n  self.SpriteFontCharacter = class {\n    constructor(t, e, i, s) {\n      let h = t.GetCharacterWidth(), r = t.GetCharacterHeight();\n      this._spriteFont = t, this._char = e, this._pxRect = new C33.Rect(i, s, i + h, s + r), this._texRect = new C33.Rect(), this._displayWidth = -1, this._UpdateTexRect();\n    }\n    Release() {\n      this._spriteFont = null, this._pxRect = null, this._texRect = null;\n    }\n    _UpdateTexRect() {\n      let t = this._spriteFont.GetWidth(), e = this._spriteFont.GetHeight();\n      this._texRect.copy(this._pxRect), this._texRect.divide(t, e), this._texRect.lerpInto(this._spriteFont.GetTexRect());\n    }\n    GetSpriteFont() {\n      return this._spriteFont;\n    }\n    GetChar() {\n      return this._char;\n    }\n    GetTexRect() {\n      return this._texRect;\n    }\n    SetDisplayWidth(t) {\n      this._displayWidth = t;\n    }\n    GetDisplayWidth() {\n      return this._displayWidth < 0 ? this._spriteFont.GetCharacterWidth() : this._displayWidth;\n    }\n  };\n}\n{\n  let getOffsetParam = function(t, e) {\n    t = t.trim();\n    const a = parseFloat(t);\n    return isFinite(a) ? t.endsWith(\"%\") ? e * a / 100 : a : 0;\n  }, normalizeCssColorString = function(t) {\n    return canvasColorCtx || (canvasColorCtx = C33.CreateCanvas(32, 32).getContext(\"2d\")), canvasColorCtx.fillStyle = \"#FFFFFF\", canvasColorCtx.fillStyle = t, canvasColorCtx.fillStyle;\n  };\n  getOffsetParam2 = getOffsetParam, normalizeCssColorString2 = normalizeCssColorString;\n  const C33 = self.C3, tmpRect = new C33.Rect(), tmpQuad = new C33.Quad(), tmpColor = new C33.Color(), VALID_HORIZ_ALIGNMENTS = /* @__PURE__ */ new Set([\"left\", \"center\", \"right\"]), VALID_VERT_ALIGNMENTS = /* @__PURE__ */ new Set([\"top\", \"center\", \"bottom\"]), VALID_WORD_WRAP_MODES = /* @__PURE__ */ new Set([\"word\", \"cjk\", \"character\"]);\n  let canvasColorCtx = null;\n  self.SpriteFontText = class {\n    constructor(t) {\n      this._spriteFont = t, this._cssWidth = 0, this._cssHeight = 0, this._text = \"\", this._isBBcodeEnabled = false, this._bbString = null, this._wrappedText = C33.New(C33.WordWrap), this._wrapMode = \"word\", this._wordWrapChanged = false, this._textLayoutChanged = false, this._horizontalAlign = \"left\", this._verticalAlign = \"top\", this._scale = 1, this._sceneGraphScale = 1, this._spacing = 0, this._lineHeight = 0, this._color = C33.New(C33.Color), this._drawMaxCharCount = -1, this._drawCharCount = 0, this._measureTextCallback = (t2) => this._MeasureText(t2), this._spriteFont._AddSpriteFontText(this);\n    }\n    Release() {\n      this._spriteFont._RemoveSpriteFontText(this), this._color = null, this._measureTextCallback = null, this._wrappedText.Clear(), this._wrappedText = null, this._spriteFont = null, this._bbString = null;\n    }\n    _MeasureText(t) {\n      if (t.IsIcon()) return { width: 0, height: 0 };\n      const e = t.GetCharacterArray(), a = t.GetStyleTag(\"scale\"), s = (a ? parseFloat(a.param) : this._scale) * this._sceneGraphScale, i = t.GetStyleTag(\"scalex\"), r = (i ? parseFloat(i.param) : 1) * s, o = t.GetStyleTag(\"scaley\"), h = (o ? parseFloat(o.param) : 1) * s, n = this._spriteFont.GetCharacterHeight() * h + this._lineHeight, l = this.GetSpriteFont(), c = l.GetCharacterWidth() * r, _ = this.GetSpacing();\n      if (l.HasAnyCustomWidths()) {\n        let t2 = 0, a2 = 0;\n        for (const s2 of e) {\n          let e2 = c;\n          const i2 = l.GetCharacter(s2);\n          i2 ? e2 = i2.GetDisplayWidth() * r : \" \" === s2 && (e2 = l.GetSpaceWidth() * r), a2 += e2, ++t2;\n        }\n        return { width: a2 + t2 * _, height: n };\n      }\n      {\n        const t2 = e.length;\n        return { width: c * t2 + Math.max(t2, 0) * _, height: n };\n      }\n    }\n    _SetTextLayoutChanged() {\n      this._textLayoutChanged = true;\n    }\n    _SetWordWrapChanged() {\n      this._SetTextLayoutChanged(), this._wordWrapChanged = true, this._wrappedText.Clear();\n    }\n    SetSize(t, e) {\n      t <= 0 || e <= 0 || this._cssWidth === t && this._cssHeight === e || (this._cssWidth !== t ? this._SetWordWrapChanged() : this._SetTextLayoutChanged(), this._cssWidth = t, this._cssHeight = e);\n    }\n    SetDrawMaxCharacterCount(t) {\n      this._drawMaxCharCount = Math.floor(t);\n    }\n    GetDrawMaxCharacterCount() {\n      return this._drawMaxCharCount;\n    }\n    HitTestFragment(t, e) {\n      this._UpdateTextMeasurements();\n      const a = this._wrappedText.GetLines();\n      for (const s of a) if (e > s.GetPosY() && e < s.GetPosY() + s.GetHeight()) {\n        for (const e2 of s.fragments()) if (t >= e2.GetPosX() && t < e2.GetPosX() + e2.GetWidth()) return e2;\n      }\n      return null;\n    }\n    *fragmentsWithTag(t) {\n      this._UpdateTextMeasurements();\n      const e = this._wrappedText.GetLines();\n      for (const a of e) for (const e2 of a.fragments()) {\n        const a2 = e2.GetStyleTag(\"tag\");\n        a2 && C33.equalsNoCase(a2.param, t) && (yield e2);\n      }\n    }\n    FindFragmentWithTag(t, e) {\n      for (const a of this.fragmentsWithTag(t)) {\n        if (0 === e) return a;\n        --e;\n      }\n      return null;\n    }\n    CountFragmentsWithTag(t) {\n      let e = 0;\n      for (const a of this.fragmentsWithTag(t)) ++e;\n      return e;\n    }\n    _UpdateTextMeasurements() {\n      this._UpdateWordWrap(), this._UpdateTextLayout();\n    }\n    _UpdateWordWrap() {\n      if (!this._wordWrapChanged) return;\n      !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C33.BBString(this._text, { noEscape: true }));\n      const t = -this.GetSpacing();\n      this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, t), this._wordWrapChanged = false;\n    }\n    _UpdateTextLayout() {\n      this._textLayoutChanged && (this._LayoutText(), this._textLayoutChanged = false);\n    }\n    _LayoutText() {\n      let t = 0;\n      const e = this._lineHeight, a = C33.cloneArray(this._wrappedText.GetLines());\n      for (const t2 of a) {\n        t2.SetPosX(NaN), t2.SetPosY(NaN);\n        for (const e2 of t2.fragments()) e2.SetPosX(NaN), e2.SetPosY(NaN);\n      }\n      const s = a.reduce((t2, e2) => t2 + e2.GetHeight(), 0) - e;\n      \"center\" === this._verticalAlign ? t = Math.max(Math.floor(this._cssHeight / 2 - s / 2), 0) : \"bottom\" === this._verticalAlign && (t = Math.floor(this._cssHeight - s));\n      for (let s2 = 0, i = a.length; s2 < i; ++s2) {\n        const i2 = a[s2], r = i2.GetHeight();\n        if (s2 > 0 && t > this._cssHeight - (r - e)) break;\n        t >= 0 && this._LayoutTextLine(i2, t), t += r;\n      }\n    }\n    _LayoutTextLine(t, e) {\n      let a = 0;\n      \"center\" === this._horizontalAlign ? a = Math.max(Math.floor((this._cssWidth - t.GetWidth()) / 2), 0) : \"right\" === this._horizontalAlign && (a = Math.max(Math.floor(this._cssWidth - t.GetWidth()), 0)), t.SetPosX(a), t.SetPosY(e);\n      for (const s of t.fragments()) s.IsIcon() || (this._LayoutTextFragment(s, a, e), a += s.GetWidth());\n    }\n    _LayoutTextFragment(t, e, a) {\n      const s = t.GetStyleTag(\"offsetx\");\n      e += s ? getOffsetParam(s.param, t.GetHeight()) : 0;\n      const i = t.GetStyleTag(\"offsety\");\n      a += i ? getOffsetParam(i.param, t.GetHeight()) : 0, t.SetPosX(e), t.SetPosY(a);\n    }\n    Draw(t, e, a, s) {\n      this._UpdateTextMeasurements(), this._drawCharCount = 0;\n      const i = C33.cloneArray(this._wrappedText.GetLines()), r = Math.sin(s), o = Math.cos(s);\n      for (const s2 of i) this._DrawLine(t, s2, e, a, r, o);\n    }\n    _DrawLine(t, e, a, s, i, r) {\n      const o = e.GetPosX(), h = e.GetPosY();\n      if (!Number.isFinite(o) || !Number.isFinite(h)) return;\n      const n = e.GetHeight();\n      for (const o2 of e.fragments()) this._DrawFragment(t, o2, a, s, i, r, n);\n    }\n    _DrawFragment(t, e, a, s, i, r, o) {\n      let h = e.GetPosX(), n = e.GetPosY();\n      if (!Number.isFinite(h) || !Number.isFinite(n)) return;\n      let l = e.GetCharacterArray(), c = e.GetWidth();\n      if (-1 !== this._drawMaxCharCount) {\n        if (this._drawCharCount >= this._drawMaxCharCount) return;\n        this._drawCharCount + l.length > this._drawMaxCharCount && (l = l.slice(0, this._drawMaxCharCount - this._drawCharCount), c = this._MeasureText(e).width), this._drawCharCount += l.length;\n      }\n      const _ = e.GetStyleTag(\"background\");\n      if (C33.IsCharArrayAllWhitespace(l) && !_ || e.HasStyleTag(\"hide\")) return;\n      const p = e.GetStyleTag(\"scale\"), d = (p ? parseFloat(p.param) : this._scale) * this._sceneGraphScale, g = e.GetStyleTag(\"scalex\"), C = (g ? parseFloat(g.param) : 1) * d, u = e.GetStyleTag(\"scaley\"), S = (u ? parseFloat(u.param) : 1) * d, m = this._spriteFont.GetCharacterHeight() * S;\n      n += o - this._lineHeight - m;\n      let f = 1;\n      const x = e.GetStyleTag(\"opacity\");\n      x && (f = parseFloat(x.param) / 100), _ && (t.SetColorFillMode(), tmpColor.parseString(normalizeCssColorString(_.param)), tmpColor.setA(tmpColor.getA() * f * this._color.getA()), tmpColor.premultiply(), t.SetColor(tmpColor), tmpRect.set(h, n, h + c, n + m), tmpRect.getRight() > this._cssWidth && tmpRect.setRight(this._cssWidth), tmpQuad.setFromRotatedRectPrecalc(tmpRect, i, r), tmpQuad.offset(a, s), t.Quad(tmpQuad), t.SetTextureFillMode());\n      const G = e.GetStyleTag(\"color\");\n      G ? (tmpColor.parseString(normalizeCssColorString(G.param)), tmpColor.setA(this._color.getA())) : tmpColor.copy(this._color), tmpColor.setA(tmpColor.getA() * f), tmpColor.premultiply(), t.SetColor(tmpColor);\n      const T = this._spriteFont.GetCharacterWidth() * C, W = Math.abs(this.GetSpacing());\n      for (const e2 of l) {\n        const o2 = this._spriteFont.GetCharacter(e2);\n        if (o2) {\n          const e3 = o2.GetDisplayWidth() * C;\n          if (h + e3 > this._cssWidth + W + 1e-5) return;\n          tmpRect.set(h, n, h + T, n + m), tmpQuad.setFromRotatedRectPrecalc(tmpRect, i, r), tmpQuad.offset(a, s), t.Quad3(tmpQuad, o2.GetTexRect()), h += e3 + this._spacing;\n        } else h += this._spriteFont.GetSpaceWidth() * C + this._spacing;\n      }\n    }\n    GetSpriteFont() {\n      return this._spriteFont;\n    }\n    SetBBCodeEnabled(t) {\n      t = !!t, this._isBBcodeEnabled !== t && (this._isBBcodeEnabled = t, this._SetWordWrapChanged());\n    }\n    IsBBCodeEnabled() {\n      return this._isBBcodeEnabled;\n    }\n    SetText(t) {\n      this._text !== t && (this._text = t, this._SetWordWrapChanged());\n    }\n    SetWordWrapMode(t) {\n      if (!VALID_WORD_WRAP_MODES.has(t)) throw new Error(\"invalid word wrap mode\");\n      this._wrapMode !== t && (this._wrapMode = t, this._SetWordWrapChanged());\n    }\n    SetHorizontalAlign(t) {\n      if (!VALID_HORIZ_ALIGNMENTS.has(t)) throw new Error(\"invalid alignment\");\n      this._horizontalAlign !== t && (this._horizontalAlign = t, this._SetTextLayoutChanged());\n    }\n    SetVerticalAlign(t) {\n      if (!VALID_VERT_ALIGNMENTS.has(t)) throw new Error(\"invalid alignment\");\n      this._verticalAlign !== t && (this._verticalAlign = t, this._SetTextLayoutChanged());\n    }\n    SetScale(t) {\n      this._scale !== t && (this._scale = t, this._SetWordWrapChanged());\n    }\n    GetScale() {\n      return this._scale;\n    }\n    SetSceneGraphScale(t) {\n      this._sceneGraphScale !== t && (this._sceneGraphScale = t, this._SetWordWrapChanged());\n    }\n    GetSceneGraphScale() {\n      return this._sceneGraphScale;\n    }\n    SetSpacing(t) {\n      this._spacing !== t && (this._spacing = t, this._SetWordWrapChanged());\n    }\n    GetSpacing() {\n      return this._spacing;\n    }\n    SetLineHeight(t) {\n      this._lineHeight = t, this._SetWordWrapChanged();\n    }\n    GetLineHeight() {\n      return this._lineHeight;\n    }\n    SetOpacity(t) {\n      t = C33.clamp(t, 0, 1), this._color.a = t;\n    }\n    SetColor(t) {\n      this._color.equals(t) || this._color.copy(t);\n    }\n    GetColor() {\n      return this._color;\n    }\n    GetTextWidth() {\n      return this._UpdateTextMeasurements(), this._wrappedText.GetMaxLineWidth();\n    }\n    GetTextHeight() {\n      this._UpdateTextMeasurements();\n      const t = this._spriteFont.GetCharacterHeight() * this._scale, e = this._lineHeight, a = t + e;\n      return this._wrappedText.GetLineCount() * a - e;\n    }\n  };\n}\nvar getOffsetParam2;\nvar normalizeCssColorString2;\n{\n  const C33 = self.C3, SpriteFontText = self.SpriteFontText, DEFAULT_SPRITEFONT_OPTS = { width: 256, height: 256, characterWidth: 16, characterHeight: 16, characterSet: \"\" };\n  self.SpriteFont = class {\n    constructor(t) {\n      if ((t = Object.assign({}, DEFAULT_SPRITEFONT_OPTS, t)).width <= 0 || t.height <= 0 || t.characterWidth <= 0 || t.characterHeight <= 0) throw new Error(\"invalid size\");\n      this._width = t.width, this._height = t.height, this._characterWidth = t.characterWidth, this._characterHeight = t.characterHeight, this._characterSet = t.characterSet, this._spacingData = \"\", this._spacingParsed = null, this._hasAnyCustomWidths = false, this._spaceWidth = -1, this._texRect = new C33.Rect(0, 0, 1, 1), this._characterMap = /* @__PURE__ */ new Map(), this._mapChanged = true, this._allTexts = /* @__PURE__ */ new Set();\n    }\n    Release() {\n      this._texRect = null, this._ReleaseCharacters(), this._characterMap = null, this._allTexts && this._allTexts.clear(), this._allTexts = null;\n    }\n    _ReleaseCharacters() {\n      for (let t of this._characterMap.values()) t.Release();\n      this._characterMap.clear();\n    }\n    _AddSpriteFontText(t) {\n      this._allTexts.add(t);\n    }\n    _RemoveSpriteFontText(t) {\n      this._allTexts.delete(t);\n    }\n    UpdateCharacterMap() {\n      if (!this._mapChanged) return;\n      this._ReleaseCharacters();\n      let t = C33.SplitGraphemes(this._characterSet), h = Math.floor(this._width / this._characterWidth), e = h * Math.floor(this._height / this._characterHeight);\n      for (let a = 0, i = t.length; a < i && !(a >= e); ++a) {\n        let e2 = t[a];\n        if (this._characterMap.has(e2)) continue;\n        let i2 = a % h, r = Math.floor(a / h);\n        this._characterMap.set(e2, C33.New(self.SpriteFontCharacter, this, e2, i2 * this._characterWidth, r * this._characterHeight));\n      }\n      if (this._hasAnyCustomWidths = false, this._spaceWidth = -1, Array.isArray(this._spacingParsed)) for (let t2 of this._spacingParsed) {\n        if (!Array.isArray(t2)) continue;\n        if (2 !== t2.length) continue;\n        let h2 = t2[0], e2 = t2[1];\n        if (\"number\" == typeof h2 && isFinite(h2) && \"string\" == typeof e2 && h2 !== this._characterWidth) for (let t3 of e2) {\n          let e3 = this._characterMap.get(t3);\n          e3 ? (e3.SetDisplayWidth(h2), this._hasAnyCustomWidths = true) : \" \" === t3 && (this._spaceWidth = h2, this._hasAnyCustomWidths = true);\n        }\n      }\n      this._mapChanged = false;\n      for (let t2 of this._allTexts) t2._SetWordWrapChanged();\n    }\n    SetCharacterWidthsChanged() {\n      this._hasAnyCustomWidths = true;\n      for (const t of this._allTexts) t._SetWordWrapChanged();\n    }\n    GetCharacter(t) {\n      return this.UpdateCharacterMap(), this._characterMap.get(t) || null;\n    }\n    HasAnyCustomWidths() {\n      return this._hasAnyCustomWidths;\n    }\n    SetWidth(t) {\n      if ((t = Math.floor(t)) <= 0) throw new Error(\"invalid size\");\n      this._width !== t && (this._width = t, this._mapChanged = true);\n    }\n    GetWidth() {\n      return this._width;\n    }\n    SetHeight(t) {\n      if ((t = Math.floor(t)) <= 0) throw new Error(\"invalid size\");\n      this._height !== t && (this._height = t, this._mapChanged = true);\n    }\n    GetHeight() {\n      return this._height;\n    }\n    SetTexRect(t) {\n      if (!this._texRect.equals(t)) {\n        this._texRect.copy(t);\n        for (const t2 of this._characterMap.values()) t2._UpdateTexRect();\n      }\n    }\n    GetTexRect() {\n      return this._texRect;\n    }\n    SetCharacterWidth(t) {\n      if ((t = Math.floor(t)) <= 0) throw new Error(\"invalid size\");\n      this._characterWidth !== t && (this._characterWidth = t, this._mapChanged = true);\n    }\n    GetCharacterWidth() {\n      return this._characterWidth;\n    }\n    SetCharacterHeight(t) {\n      if ((t = Math.floor(t)) <= 0) throw new Error(\"invalid size\");\n      this._characterHeight !== t && (this._characterHeight = t, this._mapChanged = true);\n    }\n    GetCharacterHeight() {\n      return this._characterHeight;\n    }\n    SetCharacterSet(t) {\n      this._characterSet !== t && (this._characterSet = t, this._mapChanged = true);\n    }\n    GetCharacterSet() {\n      return this._characterSet;\n    }\n    SetSpacingData(t) {\n      if (this._spacingData !== t && (this._spacingData = t, this._mapChanged = true, this._spacingParsed = null, this._spacingData.length)) try {\n        this._spacingParsed = JSON.parse(this._spacingData);\n      } catch (t2) {\n        this._spacingParsed = null;\n      }\n    }\n    GetSpacingData() {\n      return this._spacingData;\n    }\n    SetSpaceWidth(t) {\n      t < 0 && (t = -1), this._spaceWidth !== t && (this._spaceWidth = t, this._spaceWidth >= 0 && (this._hasAnyCustomWidths = true));\n    }\n    GetSpaceWidth() {\n      return this._spaceWidth < 0 ? this._characterWidth : this._spaceWidth;\n    }\n  };\n}\n{\n  {\n    const e = self.C3;\n    e.Behaviors.solid = class extends e.SDKBehaviorBase {\n      constructor(e2) {\n        super(e2);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const e = self.C3;\n    e.Behaviors.solid.Type = class extends e.SDKBehaviorTypeBase {\n      constructor(e2) {\n        super(e2);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n    };\n  }\n  {\n    const e = self.C3, s = self.C3X, t = self.IBehaviorInstance, a = 0, n = 1, i = /* @__PURE__ */ new Set();\n    e.Behaviors.solid.Instance = class extends e.SDKBehaviorInstanceBase {\n      constructor(e2, s2) {\n        super(e2), this.SetEnabled(true), s2 && (this.SetEnabled(s2[a]), this.SetTags(s2[n]));\n      }\n      Release() {\n        super.Release();\n      }\n      SetEnabled(e2) {\n        this._inst._SetSolidEnabled(!!e2);\n      }\n      IsEnabled() {\n        return this._inst._IsSolidEnabled();\n      }\n      SetTags(e2) {\n        const s2 = this._inst.GetSavedDataMap();\n        if (!e2.trim()) return void s2.delete(\"solidTags\");\n        let t2 = s2.get(\"solidTags\");\n        t2 || (t2 = /* @__PURE__ */ new Set(), s2.set(\"solidTags\", t2)), t2.clear();\n        for (const s3 of e2.split(\" \")) s3 && t2.add(s3.toLowerCase());\n      }\n      GetTags() {\n        return this._inst.GetSavedDataMap().get(\"solidTags\") || i;\n      }\n      _GetTagsString() {\n        return [...this.GetTags()].join(\" \");\n      }\n      SaveToJson() {\n        return { \"e\": this.IsEnabled() };\n      }\n      LoadFromJson(e2) {\n        this.SetEnabled(e2[\"e\"]);\n      }\n      GetPropertyValueByIndex(e2) {\n        if (e2 === a) return this.IsEnabled();\n      }\n      SetPropertyValueByIndex(e2, s2) {\n        if (e2 === a) this.SetEnabled(s2);\n      }\n      GetDebuggerProperties() {\n        return [{ title: \"$\" + this.GetBehaviorType().GetName(), properties: [{ name: \"behaviors.solid.properties.enabled.name\", value: this.IsEnabled(), onedit: (e2) => this.SetEnabled(e2) }, { name: \"behaviors.solid.properties.tags.name\", value: this._GetTagsString(), onedit: (e2) => this.SetTags(e2) }] }];\n      }\n      GetScriptInterfaceClass() {\n        return self.ISolidBehaviorInstance;\n      }\n    };\n    const r = /* @__PURE__ */ new WeakMap();\n    self.ISolidBehaviorInstance = class extends t {\n      constructor() {\n        super(), r.set(this, t._GetInitInst().GetSdkInstance());\n      }\n      set isEnabled(e2) {\n        r.get(this).SetEnabled(!!e2);\n      }\n      get isEnabled() {\n        return r.get(this).IsEnabled();\n      }\n      set tags(e2) {\n        s.RequireString(e2), r.get(this).SetTags(e2);\n      }\n      get tags() {\n        return r.get(this)._GetTagsString();\n      }\n    };\n  }\n  self.C3.Behaviors.solid.Cnds = { IsEnabled() {\n    return this.IsEnabled();\n  } };\n  self.C3.Behaviors.solid.Acts = { SetEnabled(e) {\n    this.SetEnabled(e);\n  }, SetTags(e) {\n    this.SetTags(e);\n  } };\n  self.C3.Behaviors.solid.Exps = {};\n}\n{\n  {\n    const e = self.C3;\n    e.Behaviors.Tween = class extends e.SDKBehaviorBase {\n      constructor(e2) {\n        super(e2);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const e = self.C3;\n    e.Behaviors.Tween.Type = class extends e.SDKBehaviorTypeBase {\n      constructor(e2) {\n        super(e2);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n    };\n  }\n  {\n    const e = self.C3, s = e.Behaviors.Tween, t = 0;\n    s.Instance = class extends e.SDKBehaviorInstanceBase {\n      constructor(e2, s2) {\n        super(e2), this._allowMultiple = false, this._enabled = true, s2 && (this._allowMultiple = false, this._enabled = !!s2[t]), this._activeTweens = /* @__PURE__ */ new Map(), this._disabledTweens = [], this._waitingForReleaseTweens = /* @__PURE__ */ new Map(), this._finishingTween = null, this._activeTweensJson = null, this._disabledTweensJson = null, this._waitingForReleaseTweensJson = null, this._finishingTweenName = \"\", this._triggerTweens = [], this._afterLoad = (e3) => this._OnAfterLoad(), this.GetRuntime().Dispatcher().addEventListener(\"afterload\", this._afterLoad);\n      }\n      Release() {\n        this.GetRuntime().Dispatcher().removeEventListener(\"afterload\", this._afterLoad), this._afterLoad = null, this._finishingTween && (this.ReleaseAndCompleteTween(this._finishingTween), this._finishingTween = null), this.ReleaseAndCompleteTweens(), this._tweens = null, this.ClearDisabledList(), this._disabledTweens = null, this._ReleaseWaitingTweens(), this._waitingForReleaseTweens = null, this._triggerTweens = null, super.Release();\n      }\n      PushTriggerTween(e2) {\n        this._triggerTweens.push(e2);\n      }\n      PopTriggerTween() {\n        this._triggerTweens.pop();\n      }\n      GetTriggerTween() {\n        return this._triggerTweens[this._triggerTweens.length - 1];\n      }\n      SetEnabled(e2) {\n        this._enabled = !!e2, e2 ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();\n        for (const s2 of this.AllTweens()) e2 ? this.IsInDisabledList(s2) && s2.Resume() : ((s2.IsPlaying() || s2.IsScheduled()) && this.AddToDisabledList(s2), s2.Stop());\n        e2 && this.ClearDisabledList();\n      }\n      IsEnabled() {\n        return this._enabled;\n      }\n      AddToDisabledList(e2) {\n        this._disabledTweens.push(e2);\n      }\n      IsInDisabledList(e2) {\n        return this._disabledTweens.includes(e2);\n      }\n      ClearDisabledList() {\n        e.clearArray(this._disabledTweens);\n      }\n      GetFinishingTween() {\n        return this._finishingTween;\n      }\n      IsInstanceValid() {\n        const e2 = this.GetObjectInstance();\n        return !!e2 && !e2.IsDestroyed();\n      }\n      GetTween(e2, s2, t2 = false) {\n        const n = s2 ? this.PropertyTweens(s2, t2) : this.AllTweens(t2);\n        if (n && n.length) {\n          for (const s3 of n) if (s3.HasTags(e2)) return s3;\n        }\n      }\n      CheckTweensWithTags(e2, s2) {\n        for (const t2 of this._activeTweens.values()) for (const n of t2) if (!n.IsReleased() && n.HasTags(e2) && s2(n)) return true;\n        for (const t2 of this._waitingForReleaseTweens.values()) for (const n of t2) if (!n.IsReleased() && n.HasTags(e2) && s2(n)) return true;\n        return false;\n      }\n      CheckTweens(e2) {\n        for (const s2 of this._activeTweens.values()) for (const t2 of s2) if (!t2.IsReleased() && e2(t2)) return true;\n        for (const s2 of this._waitingForReleaseTweens.values()) for (const t2 of s2) if (!t2.IsReleased() && e2(t2)) return true;\n        return false;\n      }\n      GetTweenIncludingWaitingForRelease(e2, s2) {\n        return this.GetTween(e2, s2, true);\n      }\n      *GetTweens(e2, s2, t2 = false) {\n        const n = s2 ? this.PropertyTweens(s2, t2) : this.AllTweens(t2);\n        if (n && n.length) for (const s3 of n) s3.HasTags(e2) && (yield s3);\n      }\n      *GetTweensIncludingWaitingForRelease(e2, s2) {\n        yield* this.GetTweens(e2, s2, true);\n      }\n      PropertyTweens(e2, s2) {\n        if (s2) {\n          let s3 = this._activeTweens.get(e2), t2 = this._waitingForReleaseTweens.get(e2);\n          return s3 || (s3 = []), t2 || (t2 = []), s3.concat(t2).filter((e3) => e3).filter((e3) => !e3.IsReleased());\n        }\n        {\n          let s3 = this._activeTweens.get(e2);\n          return s3 || (s3 = []), s3.filter((e3) => e3).filter((e3) => !e3.IsReleased());\n        }\n      }\n      AllTweens(e2) {\n        if (e2) {\n          const e3 = [...this._activeTweens.values()].flat(), s2 = [...this._waitingForReleaseTweens.values()].flat();\n          return e3.concat(s2).filter((e4) => e4).filter((e4) => !e4.IsReleased());\n        }\n        return [...this._activeTweens.values()].flat().filter((e3) => e3).filter((e3) => !e3.IsReleased());\n      }\n      AllTweensIncludingWaitingForRelease() {\n        return this.AllTweens(true);\n      }\n      SaveToJson(e2 = \"full\") {\n        return { \"s\": false, \"e\": !!this._enabled, \"at\": this._SaveActiveTweensToJson(), \"dt\": this._SaveDisabledTweensToJson(), \"wt\": this._SaveWaitingForReleaseTweensToJson(), \"ft\": this._SaveFinishingTweenToJson() };\n      }\n      LoadFromJson(e2, s2 = \"full\") {\n        e2 && (this._activeTweensJson = e2[\"at\"], this._disabledTweensJson = e2[\"dt\"], this._waitingForReleaseTweensJson = e2[\"wt\"], this._finishingTweenName = e2[\"ft\"], this._allowMultiple = false, this._enabled = !!e2[\"e\"], \"state\" === s2 && this._OnAfterLoad());\n      }\n      _OnAfterLoad() {\n        const s2 = this.GetRuntime().GetTimelineManager();\n        if (this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, s2), this._disabledTweensJson) {\n          e.clearArray(this._disabledTweens);\n          for (const e2 of this._disabledTweensJson) this._PopulateTweenArray(this._disabledTweens, e2, s2);\n        }\n        this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, s2), this._finishingTween = this._GetTween(this._finishingTweenName, s2), this._enabled ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();\n      }\n      _PopulateTweenMap(s2, t2, n) {\n        if (s2) for (const i in s2) {\n          let a = t2.get(i);\n          a ? e.clearArray(a) : a = [];\n          const r = s2[i];\n          for (const s3 of r) {\n            if (this._PopulateTweenArray(a, s3[\"name\"], n)) this._LoadTweenFromJson(s3[\"name\"], s3, n);\n            else {\n              const t3 = e.TweenState.Build({ runtime: this.GetRuntime(), json: s3 });\n              e.TweenState.SetInstanceUID(t3, this.GetObjectInstance().GetUID()), t3.AddCompletedCallback((e2) => this._FinishTriggers(e2)), t3.SetBehaviorInstance(this), n.AddScheduledTimeline(t3), this._PopulateTweenArray(a, t3, n);\n            }\n          }\n          t2.set(i, a);\n        }\n      }\n      _GetTween(e2, s2) {\n        return s2.GetScheduledOrPlayingTimelineByName(e2);\n      }\n      _PopulateTweenArray(e2, s2, t2) {\n        if (\"string\" != typeof s2) return !!e2.push(s2);\n        {\n          const n = this._GetTween(s2, t2);\n          if (n) return !!e2.push(n);\n        }\n        return false;\n      }\n      _LoadTweenFromJson(s2, t2, n) {\n        if (\"string\" == typeof s2) {\n          const i = this._GetTween(s2, n);\n          i && (i._LoadFromJson(t2), e.TweenState.SetInstanceUID(i, this.GetObjectInstance().GetUID()), e.TweenState.SetBehaviorInstance(i, this));\n        } else s2._LoadFromJson(t2), e.TweenState.SetInstanceUID(s2, this.GetObjectInstance().GetUID()), e.TweenState.SetBehaviorInstance(s2, this);\n      }\n      _SaveActiveTweensToJson() {\n        const e2 = {};\n        for (const [s2, t2] of this._activeTweens) e2[s2] = t2.filter((e3) => !e3.IsReleased()).map((e3) => e3._SaveToJson());\n        return e2;\n      }\n      _SaveDisabledTweensToJson() {\n        return this._disabledTweens.filter((e2) => !e2.IsReleased()).map((e2) => e2.GetName());\n      }\n      _SaveWaitingForReleaseTweensToJson() {\n        const e2 = {};\n        for (const [s2, t2] of this._waitingForReleaseTweens) e2[s2] = t2.map((e3) => e3._SaveToJson());\n        return e2;\n      }\n      _SaveFinishingTweenToJson() {\n        return this._finishingTween ? this._finishingTween.GetName() : \"\";\n      }\n      Tick2() {\n        this._ReleaseWaitingTweens();\n      }\n      CreateTween(t2) {\n        const n = s.Config.GetPropertyTracksConfig(t2.property, t2.startValue, t2.endValue, t2.ease, t2.resultMode, this.GetObjectInstance()), i = s.Maps.GetPropertyFromIndex(t2.property);\n        s.Maps.IsValueId(i) || this.ReleaseTweens(t2.property);\n        const a = e.TweenState.Build({ runtime: this.GetRuntime(), id: i, tags: t2.tags, time: t2.time, instance: this.GetObjectInstance(), releaseOnComplete: !!t2.releaseOnComplete, loop: !!t2.loop, pingPong: !!t2.pingPong, repeatCount: t2.repeatCount, initialValueMode: t2.initialValueMode, propertyTracksConfig: n });\n        return a.AddCompletedCallback((e2) => this._FinishTriggers(e2)), a.SetBehaviorInstance(this), this._AddTween(a, t2.property), a;\n      }\n      _MaybeRemoveFromActiveTweenMap(e2) {\n        const s2 = e2.GetId();\n        if (this._activeTweens.has(s2)) {\n          const t2 = this._activeTweens.get(s2);\n          if (t2) {\n            const s3 = t2.indexOf(e2);\n            -1 !== s3 && t2.splice(s3, 1);\n          }\n        }\n      }\n      ReleaseTween(e2, s2 = false) {\n        this._MaybeRemoveFromActiveTweenMap(e2), e2.IsReleased() || this._IsInWaitingList(e2) || (e2.Stop(s2), this._AddToWaitingList(e2));\n      }\n      ReleaseTweens(t2, n = false) {\n        if (e.IsFiniteNumber(t2)) {\n          const i = s.Maps.GetPropertyFromIndex(t2);\n          if (!this._activeTweens.has(i)) return;\n          const a = this._activeTweens.get(i), r = this.GetFinishingTween();\n          for (const e2 of a) e2 !== r && (e2.IsReleased() || this._IsInWaitingList(e2) || (e2.Stop(n), e2.Release()));\n          e.clearArray(a);\n        } else {\n          const s2 = this.GetFinishingTween();\n          for (const e2 of this.AllTweens()) e2 !== s2 && (e2.IsReleased() || this._IsInWaitingList(e2) || (e2.Stop(n), e2.Release()));\n          for (const s3 of this._activeTweens.keys()) e.clearArray(this._activeTweens.get(s3)), this._activeTweens.delete(s3);\n          this._activeTweens.clear();\n        }\n      }\n      ReleaseAndCompleteTween(e2) {\n        this.ReleaseTween(e2, true);\n      }\n      ReleaseAndCompleteTweens() {\n        this.ReleaseTweens(NaN, true);\n      }\n      GetPropertyValueByIndex(e2) {\n        if (e2 === t) return this._enabled;\n      }\n      SetPropertyValueByIndex(e2, s2) {\n        if (e2 === t) this._enabled = !!s2;\n      }\n      _GetBehaviorType(e2) {\n        const s2 = e2.GetInstance().GetBehaviorInstances();\n        for (const e3 of s2) {\n          const s3 = e3.GetBehaviorType();\n          if (s3.GetInstanceSdkCtor() === this.constructor) return s3;\n        }\n      }\n      Trigger(e2, s2, t2, n) {\n        return this._runtime ? super.Trigger(e2) : s2.Trigger(e2, t2, n);\n      }\n      _FinishTriggers(e2) {\n        let t2, n;\n        if (this._finishingTween = e2, s.Cnds.SetFinishingTween(e2), this.GetRuntime()) t2 = this._inst, n = this._runtime, this.Trigger(s.Cnds.OnTweensFinished), this.Trigger(s.Cnds.OnAnyTweensFinished), this.ReleaseTween(e2);\n        else {\n          if (t2 = e2.GetInstance(), !t2) return;\n          if (t2 && t2.IsDestroyed()) return;\n          n = t2.GetRuntime();\n          const i = this._GetBehaviorType(e2);\n          this.Trigger(s.Cnds.OnTweensFinished, n, t2, i), this.Trigger(s.Cnds.OnAnyTweensFinished, n, t2, i), e2.Stop();\n        }\n        this._finishingTween = null, s.Cnds.SetFinishingTween(null), e2.GetDestroyInstanceOnComplete() && n.DestroyInstance(t2);\n      }\n      _AddTween(e2, t2) {\n        const n = s.Maps.GetPropertyFromIndex(t2);\n        this._activeTweens.has(n) || this._activeTweens.set(n, []);\n        this._activeTweens.get(n).push(e2);\n      }\n      _AddToWaitingList(e2) {\n        const s2 = e2.GetId();\n        this._waitingForReleaseTweens.has(s2) || this._waitingForReleaseTweens.set(s2, []), this._waitingForReleaseTweens.get(s2).push(e2), this.IsTicking2() || this._StartTicking2();\n      }\n      _IsInWaitingList(e2) {\n        const s2 = e2.GetId();\n        return !!this._waitingForReleaseTweens.has(s2) && this._waitingForReleaseTweens.get(s2).includes(e2);\n      }\n      _ReleaseWaitingTweens() {\n        if (this._waitingForReleaseTweens.size) {\n          for (const s2 of this._waitingForReleaseTweens.values()) {\n            for (const e2 of s2) e2.IsReleased() || e2.Release();\n            e.clearArray(s2);\n          }\n          this._waitingForReleaseTweens.clear(), this.IsTicking2() && this._StopTicking2();\n        }\n      }\n      GetDebuggerProperties() {\n        return [{ title: \"$\" + this.GetBehaviorType().GetName(), properties: [{ name: \"behaviors.tween.properties.enabled.name\", value: this.IsEnabled(), onedit: (e2) => this.SetEnabled(e2) }] }];\n      }\n      GetScriptInterfaceClass() {\n        return self.ITweenBehaviorInstance;\n      }\n    };\n  }\n  {\n    const e = self.C3;\n    let s = null;\n    e.Behaviors.Tween.Cnds = { OnAnyTweenLoop: () => true, OnTweensLoop(e2) {\n      const s2 = this.GetTriggerTween();\n      return !!s2 && s2.HasTags(e2);\n    }, OnAnyTweenPingPong(e2) {\n      const s2 = this.GetTriggerTween();\n      return !!s2 && (s2.GetPingPongState() === e2 || 2 === e2);\n    }, OnTweensPingPong(e2, s2) {\n      const t = this.GetTriggerTween();\n      return !!t && ((t.GetPingPongState() === s2 || 2 === s2) && t.HasTags(e2));\n    }, SetFinishingTween(e2) {\n      s = e2;\n    }, OnTweensFinished: (e2) => s.HasTags(e2), OnAnyTweensFinished: () => true, IsPlaying(s2) {\n      return this.CheckTweensWithTags(s2, e.TweenState.IsPlaying);\n    }, IsAnyPlaying() {\n      return this.CheckTweens(e.TweenState.IsPlaying);\n    }, IsPaused(s2) {\n      return this.CheckTweensWithTags(s2, e.TweenState.IsPaused);\n    }, IsAnyPaused() {\n      return this.CheckTweens(e.TweenState.IsPaused);\n    }, IsPingPong(s2, t) {\n      return 0 === t ? this.CheckTweensWithTags(s2, e.TweenState.IsPing) : 1 === t && this.CheckTweensWithTags(s2, e.TweenState.IsPong);\n    }, IsAnyPingPong(s2) {\n      return 0 === s2 ? this.CheckTweens(e.TweenState.IsPing) : 1 === s2 && this.CheckTweens(e.TweenState.IsPong);\n    } };\n  }\n  {\n    const e = self.C3, s = self.Ease, t = e.Behaviors.Tween;\n    t.Acts = { SetEnabled(e2) {\n      this.SetEnabled(!!e2);\n    }, async TweenOneProperty(...e2) {\n      if (!this.IsEnabled() || !this.IsInstanceValid()) return;\n      const s2 = this.CreateTween(t.TweenArguments.OneProperty(this, ...e2));\n      s2.Play() && await s2.GetPlayPromise();\n    }, async TweenTwoProperties(...e2) {\n      if (!this.IsEnabled() || !this.IsInstanceValid()) return;\n      const s2 = this.CreateTween(t.TweenArguments.TwoProperties(this, ...e2));\n      s2.Play() && await s2.GetPlayPromise();\n    }, async TweenValue(...e2) {\n      if (!this.IsEnabled() || !this.IsInstanceValid()) return;\n      const s2 = this.CreateTween(t.TweenArguments.ValueProperty(this, ...e2));\n      s2.Play() && await s2.GetPlayPromise();\n    }, PauseTweens(e2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.GetTweens(e2)) s2.Stop();\n    }, PauseAllTweens() {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const e2 of this.AllTweens()) e2.Stop();\n    }, ResumeTweens(e2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.GetTweens(e2)) s2.Resume();\n    }, ResumeAllTweens() {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const e2 of this.AllTweens()) e2.Resume();\n    }, StopTweens(e2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.GetTweens(e2)) this.ReleaseTween(s2);\n    }, StopAllTweens() {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const e2 of this.AllTweens()) this.ReleaseTween(e2);\n    }, SetOnePropertyTweensEndValue(s2, t2, n) {\n      if (!this.IsEnabled() || !this.IsInstanceValid()) return;\n      const i = e.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(t2);\n      for (const e2 of this.GetTweens(s2)) e2.BeforeSetEndValues([i]), e2.SetEndValue(n, i);\n    }, SetTwoPropertiesTweensEndValue(s2, t2, n, i) {\n      if (!this.IsEnabled() || !this.IsInstanceValid()) return;\n      const a = e.Behaviors.Tween.Maps.GetRealProperties(t2);\n      for (const e2 of this.GetTweens(s2)) e2.BeforeSetEndValues(a), e2.SetEndValue(n, a[0]), e2.SetEndValue(i, a[1]);\n    }, SetValuePropertyTweensStartValue(e2, s2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2, \"value\")) t2.SetStartValue(s2, \"value\");\n    }, SetValuePropertyTweensEndValue(e2, s2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2, \"value\")) t2.BeforeSetEndValues([\"value\"]), t2.SetEndValue(s2, \"value\");\n    }, SetTweensEase(e2, t2) {\n      if (!this.IsEnabled() || !this.IsInstanceValid()) return;\n      const n = s.GetEaseFromIndex(t2);\n      for (const s2 of this.GetTweens(e2)) s2.SetEase(n);\n    }, SetAllTweensEase(e2) {\n      if (!this.IsEnabled() || !this.IsInstanceValid()) return;\n      const t2 = s.GetEaseFromIndex(e2);\n      for (const e3 of this.AllTweens()) e3.SetEase(t2);\n    }, SetTweensTime(e2, s2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2)) t2.SetTime(s2);\n    }, SetAllTweensTime(e2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.AllTweens()) s2.SetTime(e2);\n    }, SetTweensPlaybackRate(e2, s2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2)) t2.SetPlaybackRate(s2);\n    }, SetAllTweensPlaybackRate(e2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.AllTweens()) s2.SetPlaybackRate(e2);\n    }, SetTweensDestroyOnComplete(e2, s2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const t2 of this.GetTweens(e2)) t2.SetDestroyInstanceOnComplete(!!s2);\n    }, SetAllTweensDestroyOnComplete(e2) {\n      if (this.IsEnabled() && this.IsInstanceValid()) for (const s2 of this.AllTweens()) s2.SetDestroyInstanceOnComplete(!!e2);\n    } };\n  }\n  self.C3.Behaviors.Tween.Exps = { Time(e) {\n    const s = this.GetTweenIncludingWaitingForRelease(e);\n    return s ? s.GetTime() : 0;\n  }, Progress(e) {\n    const s = this.GetTweenIncludingWaitingForRelease(e);\n    return s ? s.GetTime() / s.GetTotalTime() : 0;\n  }, PlaybackRate(e) {\n    const s = this.GetTweenIncludingWaitingForRelease(e);\n    return s ? s.GetPlaybackRate() : 0;\n  }, Value(e) {\n    const s = this.GetTweenIncludingWaitingForRelease(e, \"value\");\n    return s ? s.GetPropertyTrack(\"value\").GetSourceAdapterValue() : 0;\n  }, Tags() {\n    let e = this.GetFinishingTween();\n    return e ? e.GetStringTags() : (e = this.GetTriggerTween(), e ? e.GetStringTags() : \"\");\n  } };\n}\n{\n  const C33 = self.C3, Ease = self.Ease, PAIR_PROPERTIES = [\"position\", \"size\", \"scale\"], SINGLE_PROPERTIES = [\"offsetX\", \"offsetY\", \"offsetWidth\", \"offsetHeight\", \"offsetAngle\", \"offsetOpacity\", \"offsetColor\", \"offsetZElevation\", \"offsetScaleX\", \"offsetScaleY\"], VALUE_PROPERTIES = [\"value\"], PROPERTY_INDEX_TO_NAME = [].concat(PAIR_PROPERTIES).concat(SINGLE_PROPERTIES).concat(VALUE_PROPERTIES), PROPERTY_PAIR_TO_REAL_PROPERTIES = { \"position\": [\"offsetX\", \"offsetY\"], \"size\": [\"offsetWidth\", \"offsetHeight\"], \"scale\": [\"offsetScaleX\", \"offsetScaleY\"] }, ALL_REAL_PROPERTIES = Object.assign({}, PROPERTY_INDEX_TO_NAME.reduce((e, t) => Object.assign({}, e, { [t]: [t] }), {}), PROPERTY_PAIR_TO_REAL_PROPERTIES);\n  C33.Behaviors.Tween.Maps = class {\n    constructor() {\n    }\n    static GetEases() {\n      return [...Ease.GetRuntimeEaseNames()];\n    }\n    static GetEaseFromIndex(e) {\n      return [...Ease.GetRuntimeEaseNames()][e];\n    }\n    static GetPropertyFromIndex(e) {\n      return PROPERTY_INDEX_TO_NAME[e];\n    }\n    static GetPropertyIndexFromName(e) {\n      return PROPERTY_INDEX_TO_NAME.indexOf(e);\n    }\n    static GetPairPropertyFromIndex(e) {\n      return PAIR_PROPERTIES[e];\n    }\n    static GetSinglePropertyFromIndex(e) {\n      return SINGLE_PROPERTIES[e];\n    }\n    static GetValuePropertyFromIndex(e) {\n      return VALUE_PROPERTIES[e];\n    }\n    static GetPairProperties(e) {\n      return PROPERTY_PAIR_TO_REAL_PROPERTIES[e];\n    }\n    static GetRealProperties(e) {\n      return C33.IsString(e) ? ALL_REAL_PROPERTIES[e] : ALL_REAL_PROPERTIES[PROPERTY_INDEX_TO_NAME[e]];\n    }\n    static IsPairId(e) {\n      return !!PROPERTY_PAIR_TO_REAL_PROPERTIES[e];\n    }\n    static IsColorId(e) {\n      return \"offsetColor\" === e;\n    }\n    static IsAngleId(e) {\n      return \"offsetAngle\" === e;\n    }\n    static IsOpacityId(e) {\n      return \"offsetOpacity\" === e;\n    }\n    static IsValueId(e) {\n      return \"value\" === e;\n    }\n  };\n}\n{\n  const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween, TWEEN_CONFIGURATIONS = /* @__PURE__ */ new Map();\n  NAMESPACE.Config = class {\n    constructor() {\n    }\n    static GetPropertyTracksConfig(e, t, r, o, a, s) {\n      0 === TWEEN_CONFIGURATIONS.size && this._CreateConfigObjects();\n      const n = NAMESPACE.PropertyTypes.Pick(e);\n      let i = TWEEN_CONFIGURATIONS.get(n);\n      return C33.IsFiniteNumber(e) && (e = NAMESPACE.Maps.GetPropertyFromIndex(e)), this._GetConfig(i, e, t, r, o, a, s);\n    }\n    static TransformValue(e, t) {\n      return C33.Behaviors.Tween.GetPropertyTracksConfig(e).valueGetter(t);\n    }\n    static _CreateConfigObjects() {\n      const e = NAMESPACE.PropertyTypes, t = NAMESPACE.ValueGetters;\n      this._AddConfigObject(e.PAIR, this._GetPairConfig, t._GetPropertyValue), this._AddConfigObject(e.COLOR, this._GetColorConfig, t._GetColorPropertyValue), this._AddConfigObject(e.ANGLE, this._GetAngleConfig, t._GetPropertyAngleValue), this._AddConfigObject(e.VALUE, this._GetValueConfig, t._GetPropertyValue), this._AddConfigObject(e.OTHER, this._GetCommonConfig, t._GetPropertyValue);\n    }\n    static _AddConfigObject(e, t, r) {\n      TWEEN_CONFIGURATIONS.set(e, this._CreateConfigObject(e, t, r));\n    }\n    static _CreateConfigObject(e, t, r) {\n      return { name: e, configFunc: t, valueGetter: r };\n    }\n    static _GetConfig(e, t, r, o, a, s, n) {\n      return e.configFunc(t, e.valueGetter(r), e.valueGetter(o), a, s, n);\n    }\n    static _GetPairConfig(e, t, r, o, a, s) {\n      return NAMESPACE.Maps.GetPairProperties(e).map((e2, s2) => ({ sourceId: \"world-instance\", property: e2, type: \"float\", valueType: \"numeric\", startValue: t[s2], endValue: r[s2], ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a }));\n    }\n    static _GetColorConfig(e, t, r, o, a, s) {\n      return C33.Plugins.Text && s.GetPlugin() instanceof C33.Plugins.Text ? { sourceId: \"plugin\", sourceArgs: [7], property: \"color\", type: \"color\", valueType: \"color\", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a } : { sourceId: \"world-instance\", property: e, type: \"color\", valueType: \"color\", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };\n    }\n    static _GetAngleConfig(e, t, r, o, a, s) {\n      return { sourceId: \"world-instance\", property: e, type: \"angle\", valueType: \"angle\", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };\n    }\n    static _GetCommonConfig(e, t, r, o, a, s) {\n      return { sourceId: \"world-instance\", property: e, type: \"float\", valueType: \"numeric\", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };\n    }\n    static _GetValueConfig(e, t, r, o, a, s) {\n      return { sourceId: \"value\", property: e, type: \"float\", valueType: \"numeric\", startValue: t, endValue: r, ease: NAMESPACE.Maps.GetEaseFromIndex(o), resultMode: a };\n    }\n  };\n}\n{\n  const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween, COMMON_FIXED_ARGS = { resultMode: \"absolute\" }, COMMON_VARIABLE_ARGS = Object.assign({}, COMMON_FIXED_ARGS, { tags: \"\", property: \"\", time: 0, ease: 0, releaseOnComplete: 0, loop: false, pingPong: false, repeatCount: 1 }), ONE_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: \"current-state\", startValue: 0, endValue: 0 }), TWO_PROPERTIES_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: \"current-state\", startValue: [0, 0], endValue: [0, 0] }), COLOR_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, { initialValueMode: \"current-state\", startValue: [0, 0, 0], endValue: [0, 0, 0] }), VALUE_PROPERTY_ARGS = Object.assign({}, ONE_PROPERTY_ARGS, { initialValueMode: \"start-value\" }), X = 0, Y = 1, R = 0, G = 1, B = 2;\n  NAMESPACE.TweenArguments = class {\n    constructor() {\n    }\n    static _SetCommonProperties(e, t, R2, r, P, a, E, O) {\n      e.tags = t, e.time = R2, e.ease = r, e.releaseOnComplete = P, e.loop = a, e.pingPong = E, e.repeatCount = O;\n    }\n    static OneProperty(e, t, R2, r, P, a, E, O, A, _) {\n      const o = \"string\" == typeof R2 ? R2 : NAMESPACE.Maps.GetSinglePropertyFromIndex(R2), s = NAMESPACE.Maps.IsColorId(o) ? COLOR_PROPERTY_ARGS : ONE_PROPERTY_ARGS;\n      return this._SetCommonProperties(s, t, P, a, E, O, A, _), NAMESPACE.Maps.IsColorId(o) ? (COLOR_PROPERTY_ARGS.endValue[0] = C33.GetRValue(r), COLOR_PROPERTY_ARGS.endValue[1] = C33.GetGValue(r), COLOR_PROPERTY_ARGS.endValue[2] = C33.GetBValue(r), COLOR_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(o)) : NAMESPACE.Maps.IsOpacityId(o) ? ONE_PROPERTY_ARGS.endValue = r / 100 : ONE_PROPERTY_ARGS.endValue = r, s.property = NAMESPACE.Maps.GetPropertyIndexFromName(o), s;\n    }\n    static TwoProperties(e, t, R2, r, P, a, E, O, A, _, o) {\n      this._SetCommonProperties(TWO_PROPERTIES_ARGS, t, a, E, O, A, _, o);\n      const s = \"string\" == typeof R2 ? R2 : NAMESPACE.Maps.GetPairPropertyFromIndex(R2);\n      return TWO_PROPERTIES_ARGS.endValue[0] = r, TWO_PROPERTIES_ARGS.endValue[1] = P, TWO_PROPERTIES_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(s), TWO_PROPERTIES_ARGS;\n    }\n    static ValueProperty(e, t, R2, r, P, a, E, O, A, _) {\n      return this._SetCommonProperties(VALUE_PROPERTY_ARGS, t, P, a, E, O, A, _), VALUE_PROPERTY_ARGS.startValue = R2, VALUE_PROPERTY_ARGS.endValue = r, VALUE_PROPERTY_ARGS.property = NAMESPACE.Maps.GetPropertyIndexFromName(\"value\"), VALUE_PROPERTY_ARGS;\n    }\n  };\n}\n{\n  const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween, TYPE_CHECK_OBJECTS = [];\n  NAMESPACE.PropertyTypes = class {\n    constructor() {\n    }\n    static Pick(t) {\n      if (0 === TYPE_CHECK_OBJECTS.length) {\n        const t2 = TYPE_CHECK_OBJECTS;\n        t2.push({ checkFunc: NAMESPACE.Maps.IsPairId, result: this.PAIR }), t2.push({ checkFunc: NAMESPACE.Maps.IsColorId, result: this.COLOR }), t2.push({ checkFunc: NAMESPACE.Maps.IsAngleId, result: this.ANGLE }), t2.push({ checkFunc: NAMESPACE.Maps.IsValueId, result: this.VALUE }), t2.push({ checkFunc: () => true, result: this.OTHER });\n      }\n      C33.IsFiniteNumber(t) && (t = C33.Behaviors.Tween.Maps.GetPropertyFromIndex(t));\n      for (const e of TYPE_CHECK_OBJECTS) if (e.checkFunc(t)) return e.result;\n    }\n    static get PAIR() {\n      return \"pair\";\n    }\n    static get COLOR() {\n      return \"color\";\n    }\n    static get ANGLE() {\n      return \"angle\";\n    }\n    static get VALUE() {\n      return \"value\";\n    }\n    static get OTHER() {\n      return \"other\";\n    }\n  };\n}\n{\n  const C33 = self.C3, NAMESPACE = C33.Behaviors.Tween;\n  NAMESPACE.ValueGetters = class {\n    constructor() {\n    }\n    static _GetPropertyAngleValue(e) {\n      const t = C33.toRadians(parseFloat(e));\n      return C33.clampAngle(t);\n    }\n    static _GetColorPropertyValue(e) {\n      return e.slice(0);\n    }\n    static _GetPropertyValue(e) {\n      return e;\n    }\n  };\n}\n{\n  let getIndexForEase = function(e) {\n    C3X.RequireString(e);\n    const t = Ease.ToInternal(e);\n    let n;\n    if (n = t ? Ease.GetIndexForEase(t, null) : Ease.GetIndexForEase(e, null), -1 === n) throw new Error(`invalid ease name '${e}'`);\n    return n;\n  }, ValidateTags = function(e, t = false) {\n    if (!(t && null == e || \"string\" == typeof e || Array.isArray(e))) throw new Error(\"invalid tags\");\n  };\n  getIndexForEase2 = getIndexForEase, ValidateTags2 = ValidateTags;\n  const C33 = self.C3, C3X = self.C3X, IBehaviorInstance = self.IBehaviorInstance, Ease = self.Ease, NAMESPACE = C33.Behaviors.Tween, map = /* @__PURE__ */ new WeakMap(), TWEEN_PROPERTIES = /* @__PURE__ */ new Map([[\"x\", { name: \"offsetX\", type: \"one\" }], [\"y\", { name: \"offsetY\", type: \"one\" }], [\"width\", { name: \"offsetWidth\", type: \"one\" }], [\"height\", { name: \"offsetHeight\", type: \"one\" }], [\"angle\", { name: \"offsetAngle\", type: \"one\" }], [\"opacity\", { name: \"offsetOpacity\", type: \"one\" }], [\"color\", { name: \"offsetColor\", type: \"color\" }], [\"z-elevation\", { name: \"offsetZElevation\", type: \"one\" }], [\"x-scale\", { name: \"offsetScaleX\", type: \"one\" }], [\"y-scale\", { name: \"offsetScaleY\", type: \"one\" }], [\"position\", { name: \"position\", type: \"two\" }], [\"size\", { name: \"size\", type: \"two\" }], [\"scale\", { name: \"scale\", type: \"two\" }], [\"value\", { name: \"value\", type: \"value\" }]]);\n  const TWEEN_OPTS = { tags: \"\", destroyOnComplete: false, loop: false, pingPong: false, repeatCount: 1, startValue: 0 }, I_TWEEN_OPTS = { easeToIndexFunc: getIndexForEase };\n  self.ITweenBehaviorInstance = class extends IBehaviorInstance {\n    constructor() {\n      super(), map.set(this, IBehaviorInstance._GetInitInst().GetSdkInstance());\n    }\n    startTween(e, t, n, a, o) {\n      const s = map.get(this);\n      if (!s.IsEnabled() || !s.IsInstanceValid()) return null;\n      const r = TWEEN_PROPERTIES.get(e);\n      if (!r) throw new Error(\"invalid tween property\");\n      \"one\" === r.type || \"value\" === r.type ? C3X.RequireNumber(t) : (C3X.RequireArray(t), \"two\" === r.type ? (C3X.RequireNumber(t[0]), C3X.RequireNumber(t[1])) : \"color\" === r.type && (C3X.RequireNumber(t[0]), C3X.RequireNumber(t[1]), C3X.RequireNumber(t[2]))), \"angle\" === e ? t = C33.toDegrees(t) : \"opacity\" === e ? t *= 100 : \"color\" === e && (t = C33.PackRGBEx(t[0], t[1], t[2]));\n      const i = getIndexForEase(a);\n      let l;\n      if (C3X.RequireFiniteNumber(n), o = Object.assign({}, TWEEN_OPTS, o), \"value\" === r.type && C3X.RequireNumber(o.startValue), ValidateTags(o.tags, true), \"one\" === r.type || \"color\" === r.type ? l = s.CreateTween(NAMESPACE.TweenArguments.OneProperty(s, o.tags, r.name, t, n, i, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount)) : \"two\" === r.type ? l = s.CreateTween(NAMESPACE.TweenArguments.TwoProperties(s, o.tags, r.name, t[0], t[1], n, i, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount)) : \"value\" === r.type && (l = s.CreateTween(NAMESPACE.TweenArguments.ValueProperty(s, o.tags, o.startValue, t, n, i, !!o.destroyOnComplete, !!o.loop, !!o.pingPong, o.repeatCount))), l.SetBehaviorInstance(s.GetBehaviorInstance().GetSdkInstance()), !l.Play()) throw new Error(\"failed to start tween\");\n      return l.GetITweenState(s, I_TWEEN_OPTS);\n    }\n    *allTweens() {\n      const e = map.get(this);\n      for (const t of e.AllTweens()) yield t.GetITweenState(e, I_TWEEN_OPTS);\n    }\n    *tweensByTags(e) {\n      ValidateTags(e);\n      const t = map.get(this);\n      for (const n of t.GetTweens(e)) yield n.GetITweenState(t, I_TWEEN_OPTS);\n    }\n    get isEnabled() {\n      return map.get(this).IsEnabled();\n    }\n    set isEnabled(e) {\n      map.get(this).SetEnabled(e);\n    }\n  };\n}\nvar getIndexForEase2;\nvar ValidateTags2;\n{\n  {\n    const t = self.C3;\n    t.Behaviors.Platform = class extends t.SDKBehaviorBase {\n      constructor(t2) {\n        super(t2);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const e = self.C3;\n    e.Behaviors.Platform.Type = class extends e.SDKBehaviorTypeBase {\n      constructor(t) {\n        super(t);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n    };\n  }\n  {\n    let accelerate = function(t, e, s2, n2, h2) {\n      const r2 = e * h2, o2 = s2 * h2;\n      return i.clamp(t * h2 + 0.5 * n2 * h2 * h2, r2, o2);\n    };\n    accelerate2 = accelerate;\n    const i = self.C3, s = self.C3X, n = self.IBehaviorInstance, h = 0, r = 1, o = 2, l = 3, a = 4, _ = 5, u = 6, d = 7, m = 8, p = 9, g = 0.05;\n    i.Behaviors.Platform.Instance = class extends i.SDKBehaviorInstanceBase {\n      constructor(t, e) {\n        super(t), this._keyboardDisposables = null, this._leftKey = false, this._rightKey = false, this._jumpKey = false, this._jumped = false, this._doubleJumped = false, this._canDoubleJump = false, this._ignoreInput = false, this._simLeft = false, this._simRight = false, this._simJump = false, this._lastFloorObject = null, this._loadFloorUid = -1, this._lastFloorX = 0, this._lastFloorY = 0, this._floorIsJumpthru = false, this._wasOnFloor = false, this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst), this._loadJumpthruUid = -1, this._animMode = \"stopped\", this._fallThroughTime = -1, this._isFirstTick = true, this._dx = 0, this._dy = 0, this._downX = 0, this._downY = 0, this._rightX = 0, this._rightY = 0, this._g = 1500, this._g1 = 1500, this._ga = i.toRadians(90), this._maxSpeed = 330, this._acc = 1500, this._dec = 1500, this._jumpStrength = 650, this._maxFall = 1e3, this._enableDoubleJump = false, this._jumpSustain = 0, this._sustainTime = 0, this._defaultControls = true, this._ceilingCollisionMode = 0, this._isEnabled = true, e && (this._maxSpeed = e[h], this._acc = e[r], this._dec = e[o], this._jumpStrength = e[l], this._g = e[a], this._maxFall = e[_], this._enableDoubleJump = !!e[u], this._jumpSustain = e[d] / 1e3, this._defaultControls = !!e[m], this._isEnabled = !!e[p]);\n        const s2 = this._runtime.Dispatcher();\n        this._disposables = new i.CompositeDisposable(i.Disposable.From(s2, \"instancedestroy\", (t2) => this._OnInstanceDestroyed(t2.instance)), i.Disposable.From(s2, \"afterload\", (t2) => this._OnAfterLoad())), this._defaultControls && this._BindEvents(), this._isEnabled && this._StartPostTicking(), this._UpdateGravity();\n      }\n      Release() {\n        this._keyboardDisposables && (this._keyboardDisposables.Release(), this._keyboardDisposables = null), this._lastFloorObject = null, this._wasOverJumpthru = null, super.Release();\n      }\n      _BindEvents() {\n        if (this._keyboardDisposables) return;\n        const t = this._runtime.Dispatcher();\n        this._keyboardDisposables = new i.CompositeDisposable(i.Disposable.From(t, \"keydown\", (t2) => this._OnKeyDown(t2.data)), i.Disposable.From(t, \"keyup\", (t2) => this._OnKeyUp(t2.data)), i.Disposable.From(t, \"window-blur\", () => this._OnWindowOrKeyboardBlur()), i.Disposable.From(t, \"keyboard-blur\", () => this._OnWindowOrKeyboardBlur()));\n      }\n      _UnBindEvents() {\n        this._keyboardDisposables && (this._keyboardDisposables.Release(), this._keyboardDisposables = null);\n      }\n      _OnInstanceDestroyed(t) {\n        this._lastFloorObject === t && (this._lastFloorObject = null), this._wasOverJumpthru === t && (this._wasOverJumpthru = null);\n      }\n      _OnKeyDown(t) {\n        switch (t[\"key\"]) {\n          case \"ArrowLeft\":\n            this._leftKey = true;\n            break;\n          case \"ArrowRight\":\n            this._rightKey = true;\n            break;\n          case \"ArrowUp\":\n            this._jumpKey = true;\n        }\n      }\n      _OnKeyUp(t) {\n        switch (t[\"key\"]) {\n          case \"ArrowLeft\":\n            this._leftKey = false;\n            break;\n          case \"ArrowRight\":\n            this._rightKey = false;\n            break;\n          case \"ArrowUp\":\n            this._jumpKey = false, this._jumped = false;\n        }\n      }\n      _OnWindowOrKeyboardBlur() {\n        this._leftKey = false, this._rightKey = false, this._jumpKey = false, this._jumped = false;\n      }\n      SaveToJson() {\n        return { \"ii\": this._ignoreInput, \"lfx\": this._lastFloorX, \"lfy\": this._lastFloorY, \"lfo\": this._lastFloorObject ? this._lastFloorObject.GetUID() : -1, \"am\": this._animMode, \"en\": this._isEnabled, \"fallt\": this._fallThroughTime, \"ft\": this._isFirstTick, \"dx\": this._dx, \"dy\": this._dy, \"ms\": this._maxSpeed, \"acc\": this._acc, \"dec\": this._dec, \"js\": this._jumpStrength, \"g\": this._g, \"g1\": this._g1, \"mf\": this._maxFall, \"wof\": this._wasOnFloor, \"woj\": this._wasOverJumpthru ? this._wasOverJumpthru.GetUID() : -1, \"ga\": this._ga, \"edj\": this._enableDoubleJump, \"cdj\": this._canDoubleJump, \"dj\": this._doubleJumped, \"sus\": this._jumpSustain, \"dc\": this._defaultControls, \"cc\": this._ceilingCollisionMode };\n      }\n      LoadFromJson(t) {\n        this._ignoreInput = t[\"ii\"], this._lastFloorX = t[\"lfx\"], this._lastFloorY = t[\"lfy\"], this._loadFloorUid = t[\"lfo\"], this._animMode = t[\"am\"];\n        const e = t[\"en\"];\n        this._fallThroughTime = t[\"fallt\"] || -1, this._isFirstTick = t[\"ft\"], this._dx = t[\"dx\"], this._dy = t[\"dy\"], this._maxSpeed = t[\"ms\"], this._acc = t[\"acc\"], this._dec = t[\"dec\"], this._jumpStrength = t[\"js\"], this._g = t[\"g\"], this._g1 = t[\"g1\"], this._maxFall = t[\"mf\"], this._wasOnFloor = t[\"wof\"], this._loadJumpthruUid = t[\"woj\"], this._ga = t[\"ga\"], this._enableDoubleJump = t[\"edj\"], this._canDoubleJump = t[\"cdj\"], this._doubleJumped = t[\"dj\"], this._jumpSustain = t[\"sus\"], this._defaultControls = t[\"dc\"], this._ceilingCollisionMode = t[\"cc\"] || 0, this._leftKey = false, this._rightKey = false, this._jumpKey = false, this._jumped = false, this._simLeft = false, this._simRight = false, this._simJump = false, this._sustainTime = 0, this._defaultControls ? this._BindEvents() : this._UnBindEvents(), this._SetEnabled(e), this._UpdateGravity();\n      }\n      _OnAfterLoad() {\n        -1 === this._loadFloorUid ? this._lastFloorObject = null : this._lastFloorObject = this._runtime.GetInstanceByUID(this._loadFloorUid), -1 === this._loadJumpthruUid ? this._wasOverJumpthru = null : this._wasOverJumpthru = this._runtime.GetInstanceByUID(this._loadJumpthruUid);\n      }\n      _SetLastFloorObject(t) {\n        if (this._lastFloorObject = t, t) {\n          const e = t.GetWorldInfo();\n          this._lastFloorX = e.GetX(), this._lastFloorY = e.GetY();\n        }\n      }\n      _IsFallThroughEnabled() {\n        return this._runtime.GetGameTime() > this._fallThroughTime + g;\n      }\n      _UpdateGravity() {\n        this._downX = Math.cos(this._ga), this._downY = Math.sin(this._ga), this._rightX = Math.cos(this._ga - Math.PI / 2), this._rightY = Math.sin(this._ga - Math.PI / 2), this._downX = i.roundToDp(this._downX, 6), this._downY = i.roundToDp(this._downY, 6), this._rightX = i.roundToDp(this._rightX, 6), this._rightY = i.roundToDp(this._rightY, 6), this._g1 = this._g, this._g < 0 && (this._downX *= -1, this._downY *= -1, this._g = Math.abs(this._g));\n      }\n      _GetGDir() {\n        return this._g < 0 ? -1 : 1;\n      }\n      _IsOnFloor() {\n        const t = this._inst.GetWorldInfo(), e = this._runtime.GetCollisionEngine(), i2 = this._inst, s2 = this._lastFloorObject, n2 = t.GetX(), h2 = t.GetY();\n        if (t.OffsetXY(this._downX, this._downY), t.SetBboxChanged(), !s2 || !e.TestOverlap(i2, s2) || s2.GetObjectClass().HasSolidBehavior() && !e.IsSolidCollisionAllowed(s2, i2) || s2.GetObjectClass().HasJumpthruBehavior() && !s2._IsJumpthruEnabled()) {\n          let s3 = e.TestOverlapSolid(i2), r2 = null;\n          if (!s3 && this._IsFallThroughEnabled() && (r2 = e.TestOverlapJumpthru(i2, true)), t.SetXY(n2, h2), t.SetBboxChanged(), s3) return e.TestOverlap(i2, s3) ? null : (this._floorIsJumpthru = false, s3);\n          if (r2 && r2.length) {\n            let t2 = 0;\n            for (let s4 = 0, n3 = r2.length; s4 < n3; ++s4) r2[t2] = r2[s4], e.TestOverlap(i2, r2[s4]) || ++t2;\n            if (t2 >= 1) return this._floorIsJumpthru = true, r2[0];\n          }\n          return null;\n        }\n        return t.SetXY(n2, h2), t.SetBboxChanged(), s2;\n      }\n      PostTick() {\n        if (!this._isEnabled) return;\n        const t = this._runtime.GetDt(this._inst);\n        this._jumpKey || this._simJump || (this._jumped = false);\n        let e = this._leftKey || this._simLeft, i2 = this._rightKey || this._simRight, s2 = this._jumpKey || this._simJump, n2 = s2 && !this._jumped;\n        this._simLeft = false, this._simRight = false, this._simJump = false, this._ignoreInput && (e = false, i2 = false, s2 = false, n2 = false), s2 || (this._sustainTime = 0), this._HandleFirstTick();\n        const [h2, r2, o2] = this._TrackMovingPlatform();\n        let l2 = this._IsOnFloor();\n        const a2 = l2 && !this._wasOnFloor;\n        let _2 = false;\n        if ([_2, l2] = this._MaybePushOutSolid(l2), _2) return;\n        this._TrackFloor(l2, o2, h2, s2), n2 = this._HandleJump(l2, n2, s2), l2 || this._HandleAirTime(n2, s2, t), this._wasOnFloor = !!l2;\n        const u2 = this._CalculateHorizontalAcceleration(e, i2);\n        let d2 = false, m2 = 0;\n        if (0 !== this._dx && ([d2, l2] = this._HandleHorizontalMovement(t, u2, l2, n2)), 0 !== this._dy) {\n          const [e2, i3] = this._HandleVerticalMovement(t, l2);\n          d2 = d2 || e2, m2 = i3;\n        }\n        !d2 && a2 && this._dy < 0 && m2 > 0 && (this._dy = 0, d2 = true), this._ApplyHorizontalAcceleration(e, i2, u2, t), l2 && !n2 || d2 || (this._dy = Math.min(this._dy + this._g * t, this._maxFall)), this._HandleAnimationTriggers(l2, d2, n2), this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst);\n      }\n      _HandleFirstTick() {\n        if (!this._isFirstTick) return;\n        const t = this._inst, e = this._runtime.GetCollisionEngine();\n        (e.TestOverlapSolid(t) || e.TestOverlapJumpthru(t)) && e.PushOutSolid(t, -this._downX, -this._downY, 4, true), this._isFirstTick = false;\n      }\n      _TrackMovingPlatform() {\n        const t = this._lastFloorObject, e = t ? t.GetWorldInfo() : null;\n        let s2 = 0, n2 = 0, h2 = false;\n        if (t && 0 === this._dy && (e.GetY() !== this._lastFloorY || e.GetX() !== this._lastFloorX)) {\n          const t2 = this._inst, r2 = t2.GetWorldInfo(), o2 = this._runtime.GetCollisionEngine(), l2 = e.GetX(), a2 = e.GetY();\n          s2 = l2 - this._lastFloorX, n2 = a2 - this._lastFloorY, r2.OffsetXY(s2, n2), r2.SetBboxChanged(), this._lastFloorX = l2, this._lastFloorY = a2, h2 = true;\n          const _2 = o2.TestOverlapSolid(t2);\n          _2 && (o2.RegisterCollision(t2, _2), o2.PushOutSolid(t2, -s2, -n2, 2.5 * i.hypot2DFast(s2, n2)));\n        }\n        return [s2, n2, h2];\n      }\n      _MaybePushOutSolid(t) {\n        let e = false;\n        const i2 = this._inst, s2 = i2.GetWorldInfo(), n2 = this._runtime.GetCollisionEngine(), h2 = n2.TestOverlapSolid(i2);\n        if (!h2) return [false, t];\n        const r2 = Math.abs(s2.GetWidth()), o2 = Math.abs(s2.GetHeight());\n        return n2.PushOutSolid(i2, -this._downX, -this._downY, o2 / 8) ? (n2.RegisterCollision(i2, h2), t = h2, this._SetLastFloorObject(h2), this._floorIsJumpthru = false, this._dy = 0) : n2.PushOutSolidAxis(i2, this._rightX, this._rightY, r2 / 2) || n2.PushOutSolidAxis(i2, this._downX, this._downY, o2 / 2) || n2.PushOutSolidNearest(i2, Math.max(r2, o2) / 2) ? n2.RegisterCollision(i2, h2) : e = true, [e, t];\n      }\n      _TrackFloor(t, e, i2, s2) {\n        const n2 = this._inst, h2 = this._runtime.GetCollisionEngine();\n        if (t) {\n          const s3 = this._downX, r2 = this._downY, o2 = this._rightX, l2 = this._rightY;\n          if (this._doubleJumped = false, this._canDoubleJump = false, this._dy > 0 && (this._wasOnFloor || (h2.PushInFractional(n2, -s3, -r2, t, 16), this._wasOnFloor = true), this._dy = 0), this._lastFloorObject !== t) this._SetLastFloorObject(t), h2.RegisterCollision(n2, t);\n          else if (e) {\n            const t2 = h2.TestOverlapSolid(n2);\n            t2 && (h2.RegisterCollision(n2, t2), 0 !== i2 && (i2 > 0 ? h2.PushOutSolid(n2, -o2, -l2) : h2.PushOutSolid(n2, o2, l2)), h2.PushOutSolid(n2, -s3, -r2));\n          }\n        } else s2 || (this._canDoubleJump = true);\n      }\n      _HandleJump(t, e, s2) {\n        if (t && e || !t && this._enableDoubleJump && s2 && this._canDoubleJump && !this._doubleJumped) {\n          const s3 = this._inst, n2 = s3.GetWorldInfo(), h2 = this._runtime.GetCollisionEngine(), r2 = n2.GetX(), o2 = n2.GetY();\n          n2.OffsetXY(-this._downX, -this._downY), n2.SetBboxChanged(), h2.TestOverlapSolid(s3) ? e = false : (this._sustainTime = this._jumpSustain, this.Trigger(i.Behaviors.Platform.Cnds.OnJump), this._animMode = \"jumping\", this._dy = -this._jumpStrength, e = true, t ? this._jumped = true : this._doubleJumped = true), n2.SetXY(r2, o2), n2.SetBboxChanged();\n        }\n        return e;\n      }\n      _HandleAirTime(t, e, i2) {\n        e && this._sustainTime > 0 ? (this._dy = -this._jumpStrength, this._sustainTime -= i2) : this._lastFloorObject = null, t && (this._jumped = true);\n      }\n      _CalculateHorizontalAcceleration(t, e) {\n        let i2 = 0;\n        const s2 = this._acc, n2 = this._dec;\n        return t && !e && (i2 = this._dx > 0 ? -(s2 + n2) : -s2), e && !t && (i2 = this._dx < 0 ? s2 + n2 : s2), i2;\n      }\n      _ApplyHorizontalAcceleration(t, e, s2, n2) {\n        const h2 = this._dec;\n        t === e && (this._dx < 0 ? this._dx = Math.min(this._dx + h2 * n2, 0) : this._dx > 0 && (this._dx = Math.max(this._dx - h2 * n2, 0))), this._dx = i.clamp(this._dx + s2 * n2, -this._maxSpeed, this._maxSpeed);\n        const r2 = this._runtime.GetCollisionEngine(), o2 = this._dx < 0 ? this._GetWallObstacle(0, 1, 1) : null;\n        if (o2) this._dx = 0, r2.RegisterCollision(this._inst, o2);\n        else {\n          const t2 = this._dx > 0 ? this._GetWallObstacle(1, 1, 1) : null;\n          t2 && (this._dx = 0, r2.RegisterCollision(this._inst, t2));\n        }\n      }\n      _HandleHorizontalMovement(t, e, i2, s2) {\n        const n2 = this._inst, h2 = n2.GetWorldInfo(), r2 = this._runtime.GetCollisionEngine(), o2 = this._downX, l2 = this._downY, a2 = this._rightX, _2 = this._rightY, u2 = this._maxSpeed;\n        let d2 = false;\n        const m2 = new Set(r2.TestOverlapJumpthru(n2, true));\n        let p2 = h2.GetX(), g2 = h2.GetY();\n        const c2 = accelerate(this._dx, -u2, u2, e, t) * a2, S2 = accelerate(this._dx, -u2, u2, e, t) * _2;\n        h2.OffsetXY(a2 * (this._dx > 1 ? 1 : -1) - o2, _2 * (this._dx > 1 ? 1 : -1) - l2), h2.SetBboxChanged();\n        let b = false;\n        const f = r2.TestOverlapSolid(n2);\n        h2.SetXY(p2 + c2, g2 + S2), h2.SetBboxChanged();\n        let G = r2.TestOverlapSolid(n2);\n        if (!G && i2 && this._floorIsJumpthru && (G = r2.TestOverlapJumpthru(n2), m2.has(G) ? G = null : b = true), G) {\n          let e2 = Math.abs(this._dx * t) + 2;\n          f || !r2.PushOutSolid(n2, -o2, -l2, e2, b, G) ? (r2.RegisterCollision(n2, G), e2 = Math.max(Math.abs(this._dx * t * 2.5), Math.floor(h2.GetWidth())), r2.PushOutSolid(n2, a2 * (this._dx < 0 ? 1 : -1), _2 * (this._dx < 0 ? 1 : -1), e2, false) ? !i2 || b || this._floorIsJumpthru || (p2 = h2.GetX(), g2 = h2.GetY(), h2.OffsetXY(o2, l2), r2.TestOverlapSolid(n2) && r2.PushOutSolid(n2, -o2, -l2, 3, false) || (h2.SetXY(p2, g2), h2.SetBboxChanged())) : (h2.SetXY(p2, g2), h2.SetBboxChanged()), b || (this._dx = 0)) : !f && !s2 && Math.abs(this._dy) < Math.abs(this._jumpStrength / 4) && (this._dy = 0, i2 || (d2 = true));\n        } else {\n          const e2 = this._IsOnFloor();\n          if (i2 && !e2) {\n            const e3 = Math.ceil(Math.abs(this._dx * t)) + 2;\n            p2 = h2.GetX(), g2 = h2.GetY(), h2.OffsetXY(o2 * e3, l2 * e3), h2.SetBboxChanged();\n            const s3 = r2.TestOverlapJumpthru(n2);\n            let a3 = false;\n            s3 && !m2.has(s3) && r2.PushOutSolid(n2, -o2, -l2, e3 + 2, true, s3) && (i2 = s3, this._SetLastFloorObject(s3), this._floorIsJumpthru = true, a3 = true), a3 || (r2.TestOverlapSolid(n2) ? r2.PushOutSolid(n2, -o2, -l2, e3 + 2, false) : (h2.SetXY(p2, g2), h2.SetBboxChanged()));\n          } else e2 && (!i2 && this._floorIsJumpthru && (this._SetLastFloorObject(e2), this._dy = 0, d2 = true), 0 === this._dy && r2.PushInFractional(n2, -o2, -l2, e2, 16));\n        }\n        return [d2, i2];\n      }\n      _HandleVerticalMovement(t, e) {\n        const s2 = this._inst, n2 = s2.GetWorldInfo(), h2 = this._runtime.GetCollisionEngine(), r2 = this._downX, o2 = this._downY;\n        let l2 = false, a2 = n2.GetX(), _2 = n2.GetY();\n        const u2 = accelerate(this._dy, -1 / 0, this._maxFall, this._g, t);\n        n2.OffsetXY(u2 * r2, u2 * o2);\n        const d2 = n2.GetX(), m2 = n2.GetY();\n        n2.SetBboxChanged();\n        let p2 = h2.TestOverlapSolid(s2), g2 = false;\n        if (!p2 && this._dy > 0 && !e) {\n          const t2 = this._IsFallThroughEnabled() ? h2.TestOverlapJumpthru(s2, true) : null;\n          if (t2 && t2.length) {\n            if (this._wasOverJumpthru) {\n              n2.SetXY(a2, _2), n2.SetBboxChanged();\n              let e2 = 0;\n              for (let i2 = 0, n3 = t2.length; i2 < n3; ++i2) t2[e2] = t2[i2], h2.TestOverlap(s2, t2[i2]) || ++e2;\n              i.truncateArray(t2, e2), n2.SetXY(d2, m2), n2.SetBboxChanged();\n            }\n            t2.length >= 1 && (p2 = t2[0]);\n          }\n          g2 = !!p2;\n        }\n        if (p2) {\n          h2.RegisterCollision(s2, p2), this._sustainTime = 0;\n          let e2 = 1.1;\n          g2 && !this._wasOverJumpthru && (e2 = 2);\n          const i2 = Math.max(Math.abs(this._dy * t * e2), 2);\n          h2.PushOutSolid(s2, r2 * (this._dy < 0 ? 1 : -1), o2 * (this._dy < 0 ? 1 : -1), i2, g2, p2) ? (this._SetLastFloorObject(p2), this._floorIsJumpthru = g2, this._dy > 0 && (l2 = true), (this._dy > 0 || 0 === this._ceilingCollisionMode) && (this._dy = 0), this._dy < 0 && 1 === this._ceilingCollisionMode && h2.PushInFractional(s2, r2, o2, p2, 32)) : (n2.SetXY(a2, _2), n2.SetBboxChanged(), this._wasOnFloor = true, g2 || (this._dy = 0));\n        }\n        return [l2, u2];\n      }\n      _HandleAnimationTriggers(t, e, s2) {\n        \"falling\" !== this._animMode && this._dy > 0 && !t && (this.Trigger(i.Behaviors.Platform.Cnds.OnFall), this._animMode = \"falling\"), (t || e) && this._dy >= 0 && (\"falling\" === this._animMode || e || s2 && 0 === this._dy ? (this.Trigger(i.Behaviors.Platform.Cnds.OnLand), 0 === this._dx && 0 === this._dy ? this._animMode = \"stopped\" : this._animMode = \"moving\") : (\"stopped\" !== this._animMode && 0 === this._dx && 0 === this._dy && (this.Trigger(i.Behaviors.Platform.Cnds.OnStop), this._animMode = \"stopped\"), \"moving\" === this._animMode || 0 === this._dx && 0 === this._dy || s2 || (this.Trigger(i.Behaviors.Platform.Cnds.OnMove), this._animMode = \"moving\")));\n      }\n      _IsMoving() {\n        return 0 !== this._GetVectorX() || 0 !== this._GetVectorY();\n      }\n      _CheckIfStandingOnFloor() {\n        if (0 !== this._dy) return false;\n        const t = this._inst, e = this.GetWorldInfo(), i2 = this._runtime.GetCollisionEngine(), s2 = e.GetX(), n2 = e.GetY();\n        e.OffsetXY(this._downX, this._downY), e.SetBboxChanged();\n        const h2 = i2.TestOverlapSolid(t);\n        let r2 = null;\n        if (!h2 && this._IsFallThroughEnabled() && (r2 = i2.TestOverlapJumpthru(t, true)), e.SetXY(s2, n2), e.SetBboxChanged(), h2) return !i2.TestOverlap(t, h2);\n        if (r2 && r2.length) {\n          let e2 = 0;\n          for (let s3 = 0, n3 = r2.length; s3 < n3; ++s3) r2[e2] = r2[s3], i2.TestOverlap(t, r2[s3]) || e2++;\n          if (e2 >= 1) return true;\n        }\n        return false;\n      }\n      _IsByWall(t, e = 2, i2 = 3) {\n        return !!this._GetWallObstacle(t, e, i2);\n      }\n      _GetWallObstacle(t, e = 2, i2 = 3) {\n        const s2 = this._inst, n2 = this.GetWorldInfo(), h2 = this._runtime.GetCollisionEngine(), r2 = n2.GetX(), o2 = n2.GetY();\n        if (0 === t ? n2.OffsetXY(-this._rightX * e, -this._rightY * e) : n2.OffsetXY(this._rightX * e, this._rightY * e), n2.SetBboxChanged(), !h2.TestOverlapSolid(s2)) return n2.SetXY(r2, o2), n2.SetBboxChanged(), null;\n        n2.OffsetXY(-this._downX * i2, -this._downY * i2), n2.SetBboxChanged();\n        const l2 = h2.TestOverlapSolid(s2);\n        return n2.SetXY(r2, o2), n2.SetBboxChanged(), l2;\n      }\n      _FallThroughJumpThru() {\n        const t = this.GetWorldInfo(), e = t.GetX(), i2 = t.GetY();\n        t.OffsetXY(this._downX, this._downY), t.SetBboxChanged();\n        const s2 = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst, false);\n        t.SetXY(e, i2), t.SetBboxChanged(), s2 && (this._fallThroughTime = this._runtime.GetGameTime(), this._lastFloorObject = null);\n      }\n      _ResetDoubleJump(t) {\n        this._doubleJumped = !t;\n      }\n      _GetSpeed() {\n        return Math.hypot(this._dx, this._dy);\n      }\n      _GetMovingAngle() {\n        return Math.atan2(this._dy, this._dx);\n      }\n      _IsJumping() {\n        return this._dy < 0;\n      }\n      _IsFalling() {\n        return this._dy > 0;\n      }\n      _SetMaxSpeed(t) {\n        this._maxSpeed = Math.max(t, 0);\n      }\n      _GetMaxSpeed() {\n        return this._maxSpeed;\n      }\n      _SetAcceleration(t) {\n        this._acc = Math.max(t, 0);\n      }\n      _GetAcceleration() {\n        return this._acc;\n      }\n      _SetDeceleration(t) {\n        this._dec = Math.max(t, 0);\n      }\n      _GetDeceleration() {\n        return this._dec;\n      }\n      _SetJumpStrength(t) {\n        this._jumpStrength = Math.max(t, 0);\n      }\n      _GetJumpStrength() {\n        return this._jumpStrength;\n      }\n      _SetMaxFallSpeed(t) {\n        this._maxFall = Math.max(t, 0);\n      }\n      _GetMaxFallSpeed() {\n        return this._maxFall;\n      }\n      _SetGravity(t) {\n        if (this._g1 === t) return;\n        this._g = t, this._UpdateGravity();\n        const e = this._runtime.GetCollisionEngine(), i2 = this.GetWorldInfo();\n        e.TestOverlapSolid(this._inst) && (e.PushOutSolid(this._inst, this._downX, this._downY, 10), i2.OffsetXY(2 * this._downX, 2 * this._downY), i2.SetBboxChanged()), this._lastFloorObject = null;\n      }\n      _GetGravity() {\n        return this._g;\n      }\n      _SetGravityAngle(t) {\n        t = i.clampAngle(t), this._ga !== t && (this._ga = t, this._UpdateGravity(), this._lastFloorObject = null);\n      }\n      _GetGravityAngle() {\n        return this._ga;\n      }\n      _SetDoubleJumpEnabled(t) {\n        this._enableDoubleJump = !!t;\n      }\n      _IsDoubleJumpEnabled() {\n        return this._enableDoubleJump;\n      }\n      _SetJumpSustain(t) {\n        this._jumpSustain = t;\n      }\n      _GetJumpSustain() {\n        return this._jumpSustain;\n      }\n      _SetCeilingCollisionMode(t) {\n        this._ceilingCollisionMode = t;\n      }\n      _GetCeilingCollisionMode() {\n        return this._ceilingCollisionMode;\n      }\n      _SetVectorX(t) {\n        this._dx = t;\n      }\n      _GetVectorX() {\n        return this._dx;\n      }\n      _SetVectorY(t) {\n        this._dy = t;\n      }\n      _GetVectorY() {\n        return this._dy;\n      }\n      _SimulateControl(t) {\n        if (this._isEnabled) switch (t) {\n          case 0:\n            this._simLeft = true;\n            break;\n          case 1:\n            this._simRight = true;\n            break;\n          case 2:\n            this._simJump = true;\n        }\n      }\n      _SetDefaultControls(t) {\n        t = !!t, this._defaultControls !== t && (this._defaultControls = t, this._defaultControls ? this._BindEvents() : (this._UnBindEvents(), this._OnWindowOrKeyboardBlur()));\n      }\n      _IsDefaultControls() {\n        return this._defaultControls;\n      }\n      _SetIgnoreInput(t) {\n        this._ignoreInput = !!t;\n      }\n      _IsIgnoreInput() {\n        return this._ignoreInput;\n      }\n      _SetEnabled(t) {\n        t = !!t, this._isEnabled !== t && (this._isEnabled = t, this._isEnabled ? this._StartPostTicking() : (this._StopPostTicking(), this._lastFloorObject = null, this._simLeft = false, this._simRight = false, this._simJump = false));\n      }\n      _IsEnabled() {\n        return this._isEnabled;\n      }\n      GetPropertyValueByIndex(t) {\n        switch (t) {\n          case h:\n            return this._GetMaxSpeed();\n          case r:\n            return this._GetAcceleration();\n          case o:\n            return this._GetDeceleration();\n          case l:\n            return this._GetJumpStrength();\n          case a:\n            return this._GetGravity();\n          case _:\n            return this._GetMaxFallSpeed();\n          case u:\n            return this._IsDoubleJumpEnabled();\n          case d:\n            return 1e3 * this._GetJumpSustain();\n          case m:\n            return this._IsDefaultControls();\n          case p:\n            return this._IsEnabled();\n        }\n      }\n      SetPropertyValueByIndex(t, e) {\n        switch (t) {\n          case h:\n            this._SetMaxSpeed(e);\n            break;\n          case r:\n            this._SetAcceleration(e);\n            break;\n          case o:\n            this._SetDeceleration(e);\n            break;\n          case l:\n            this._SetJumpStrength(e);\n            break;\n          case a:\n            this._SetGravity(e);\n            break;\n          case _:\n            this._SetMaxFallSpeed(e);\n            break;\n          case u:\n            this._SetDoubleJumpEnabled(!!e);\n            break;\n          case d:\n            this._SetJumpSustain(e / 1e3);\n            break;\n          case m:\n            this._SetDefaultControls(!!e);\n            break;\n          case p:\n            this._SetEnabled(!!e);\n        }\n      }\n      GetDebuggerProperties() {\n        const t = \"behaviors.platform\";\n        return [{ title: \"$\" + this.GetBehaviorType().GetName(), properties: [{ name: t + \".debugger.vector-x\", value: this._GetVectorX(), onedit: (t2) => this._SetVectorX(t2) }, { name: t + \".debugger.vector-y\", value: this._GetVectorY(), onedit: (t2) => this._SetVectorY(t2) }, { name: t + \".properties.max-speed.name\", value: this._GetMaxSpeed(), onedit: (t2) => this._SetMaxSpeed(t2) }, { name: t + \".properties.acceleration.name\", value: this._GetAcceleration(), onedit: (t2) => this._SetAcceleration(t2) }, { name: t + \".properties.deceleration.name\", value: this._GetDeceleration(), onedit: (t2) => this._SetDeceleration(t2) }, { name: t + \".properties.jump-strength.name\", value: this._GetJumpStrength(), onedit: (t2) => this._SetJumpStrength(t2) }, { name: t + \".properties.gravity.name\", value: this._GetGravity(), onedit: (t2) => this._SetGravity(t2) }, { name: t + \".debugger.gravity-angle\", value: i.toDegrees(this._GetGravityAngle()), onedit: (t2) => this._SetGravityAngle(i.toRadians(t2)) }, { name: t + \".properties.max-fall-speed.name\", value: this._GetMaxFallSpeed(), onedit: (t2) => this._SetMaxFallSpeed(t2) }, { name: t + \".properties.double-jump.name\", value: this._IsDoubleJumpEnabled(), onedit: (t2) => this._SetDoubleJumpEnabled(t2) }, { name: t + \".properties.jump-sustain.name\", value: 1e3 * this._GetJumpSustain(), onedit: (t2) => this._SetJumpSustain(t2 / 1e3) }, { name: t + \".debugger.animation-mode\", value: [t + \".debugger.anim-\" + this._animMode] }, { name: t + \".properties.enabled.name\", value: this._IsEnabled(), onedit: (t2) => this._SetEnabled(t2) }] }];\n      }\n      GetScriptInterfaceClass() {\n        return self.IPlatformBehaviorInstance;\n      }\n    };\n    const c = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new Map([[\"left\", 0], [\"right\", 1], [\"jump\", 2]]);\n    self.IPlatformBehaviorInstance = class extends n {\n      constructor() {\n        super(), c.set(this, n._GetInitInst().GetSdkInstance());\n      }\n      fallThrough() {\n        c.get(this)._FallThroughJumpThru();\n      }\n      resetDoubleJump(t) {\n        c.get(this)._ResetDoubleJump(!!t);\n      }\n      simulateControl(t) {\n        s.RequireString(t);\n        const e = S.get(t);\n        if (\"number\" != typeof e) throw new Error(\"invalid control\");\n        c.get(this)._SimulateControl(e);\n      }\n      get speed() {\n        return c.get(this)._GetSpeed();\n      }\n      get maxSpeed() {\n        return c.get(this)._GetMaxSpeed();\n      }\n      set maxSpeed(t) {\n        s.RequireFiniteNumber(t), c.get(this)._SetMaxSpeed(t);\n      }\n      get acceleration() {\n        return c.get(this)._GetAcceleration();\n      }\n      set acceleration(t) {\n        s.RequireFiniteNumber(t), c.get(this)._SetAcceleration(t);\n      }\n      get deceleration() {\n        return c.get(this)._GetDeceleration();\n      }\n      set deceleration(t) {\n        s.RequireFiniteNumber(t), c.get(this)._SetDeceleration(t);\n      }\n      get jumpStrength() {\n        return c.get(this)._GetJumpStrength();\n      }\n      set jumpStrength(t) {\n        s.RequireFiniteNumber(t), c.get(this)._SetJumpStrength(t);\n      }\n      get maxFallSpeed() {\n        return c.get(this)._GetMaxFallSpeed();\n      }\n      set maxFallSpeed(t) {\n        s.RequireFiniteNumber(t), c.get(this)._SetMaxFallSpeed(t);\n      }\n      get gravity() {\n        return c.get(this)._GetGravity();\n      }\n      set gravity(t) {\n        s.RequireFiniteNumber(t), c.get(this)._SetGravity(t);\n      }\n      get gravityAngle() {\n        return c.get(this)._GetGravityAngle();\n      }\n      set gravityAngle(t) {\n        s.RequireFiniteNumber(t), c.get(this)._SetGravityAngle(t);\n      }\n      get isDoubleJumpEnabled() {\n        return c.get(this)._IsDoubleJumpEnabled();\n      }\n      set isDoubleJumpEnabled(t) {\n        c.get(this)._SetDoubleJumpEnabled(!!t);\n      }\n      get jumpSustain() {\n        return c.get(this)._GetJumpSustain();\n      }\n      set jumpSustain(t) {\n        s.RequireFiniteNumber(t), c.get(this)._SetJumpSustain(t);\n      }\n      get ceilingCollisionMode() {\n        return 0 === c.get(this)._GetCeilingCollisionMode() ? \"stop\" : \"preserve-momentum\";\n      }\n      set ceilingCollisionMode(t) {\n        s.RequireString(t);\n        const e = c.get(this);\n        if (\"stop\" === t) e._SetCeilingCollisionMode(0);\n        else {\n          if (\"preserve-momentum\" !== t) throw new Error(\"invalid mode\");\n          e._SetCeilingCollisionMode(1);\n        }\n      }\n      get isOnFloor() {\n        return c.get(this)._CheckIfStandingOnFloor();\n      }\n      isByWall(t) {\n        s.RequireString(t);\n        const e = c.get(this);\n        if (\"left\" === t) return e._IsByWall(0);\n        if (\"right\" === t) return e._IsByWall(1);\n        throw new Error(\"invalid side\");\n      }\n      get isMoving() {\n        return c.get(this)._IsMoving();\n      }\n      get isJumping() {\n        return c.get(this)._IsJumping();\n      }\n      get isFalling() {\n        return c.get(this)._IsFalling();\n      }\n      get vectorX() {\n        return c.get(this)._GetVectorX();\n      }\n      set vectorX(t) {\n        s.RequireFiniteNumber(t), c.get(this)._SetVectorX(t);\n      }\n      get vectorY() {\n        return c.get(this)._GetVectorY();\n      }\n      set vectorY(t) {\n        s.RequireFiniteNumber(t), c.get(this)._SetVectorY(t);\n      }\n      setVector(t, e) {\n        s.RequireFiniteNumber(t), s.RequireFiniteNumber(e);\n        const i2 = c.get(this);\n        i2._SetVectorX(t), i2._SetVectorY(e);\n      }\n      getVector() {\n        const t = c.get(this);\n        return [t._GetVectorX(), t._GetVectorY()];\n      }\n      get isDefaultControls() {\n        return c.get(this)._IsDefaultControls();\n      }\n      set isDefaultControls(t) {\n        c.get(this)._SetDefaultControls(!!t);\n      }\n      get isIgnoringInput() {\n        return c.get(this)._IsIgnoreInput();\n      }\n      set isIgnoringInput(t) {\n        c.get(this)._SetIgnoreInput(!!t);\n      }\n      get isEnabled() {\n        return c.get(this)._IsEnabled();\n      }\n      set isEnabled(t) {\n        c.get(this)._SetEnabled(!!t);\n      }\n    };\n  }\n  {\n    const b = self.C3;\n    b.Behaviors.Platform.Cnds = { IsMoving() {\n      return this._IsMoving();\n    }, CompareSpeed(t, e) {\n      return b.compare(this._GetSpeed(), t, e);\n    }, IsOnFloor() {\n      return this._CheckIfStandingOnFloor();\n    }, IsByWall(t) {\n      return this._IsByWall(t);\n    }, IsJumping() {\n      return this._IsJumping();\n    }, IsFalling() {\n      return this._IsFalling();\n    }, IsDoubleJumpEnabled() {\n      return this._IsDoubleJumpEnabled();\n    }, OnJump: () => true, OnFall: () => true, OnStop: () => true, OnMove: () => true, OnLand: () => true, IsEnabled() {\n      return this._IsEnabled();\n    } };\n  }\n  {\n    const f = self.C3;\n    f.Behaviors.Platform.Acts = { SetMaxSpeed(t) {\n      this._SetMaxSpeed(t);\n    }, SetAcceleration(t) {\n      this._SetAcceleration(t);\n    }, SetDeceleration(t) {\n      this._SetDeceleration(t);\n    }, SetJumpStrength(t) {\n      this._SetJumpStrength(t);\n    }, SetMaxFallSpeed(t) {\n      this._SetMaxFallSpeed(t);\n    }, SetGravity(t) {\n      this._SetGravity(t);\n    }, SimulateControl(t) {\n      this._SimulateControl(t);\n    }, SetIgnoreInput(t) {\n      this._SetIgnoreInput(!!t);\n    }, SetVectorX(t) {\n      this._SetVectorX(t);\n    }, SetVectorY(t) {\n      this._SetVectorY(t);\n    }, SetGravityAngle(t) {\n      this._SetGravityAngle(f.toRadians(t));\n    }, SetEnabled(t) {\n      this._SetEnabled(0 !== t);\n    }, FallThrough() {\n      this._FallThroughJumpThru();\n    }, SetDoubleJumpEnabled(t) {\n      this._SetDoubleJumpEnabled(0 !== t);\n    }, SetJumpSustain(t) {\n      this._SetJumpSustain(t / 1e3);\n    }, SetCeilingCollision(t) {\n      this._SetCeilingCollisionMode(t);\n    }, SetDefaultControls(t) {\n      this._SetDefaultControls(t);\n    }, ResetDoubleJump(t) {\n      this._ResetDoubleJump(t);\n    } };\n  }\n  {\n    const G = self.C3;\n    G.Behaviors.Platform.Exps = { Speed() {\n      return this._GetSpeed();\n    }, MaxSpeed() {\n      return this._GetMaxSpeed();\n    }, Acceleration() {\n      return this._GetAcceleration();\n    }, Deceleration() {\n      return this._GetDeceleration();\n    }, JumpStrength() {\n      return this._GetJumpStrength();\n    }, Gravity() {\n      return this._GetGravity();\n    }, GravityAngle() {\n      return G.toDegrees(this._GetGravityAngle());\n    }, MaxFallSpeed() {\n      return this._GetMaxFallSpeed();\n    }, MovingAngle() {\n      return G.toDegrees(this._GetMovingAngle());\n    }, VectorX() {\n      return this._GetVectorX();\n    }, VectorY() {\n      return this._GetVectorY();\n    }, JumpSustain() {\n      return 1e3 * this._GetJumpSustain();\n    } };\n  }\n}\nvar accelerate2;\n{\n  \"use strict\";\n  globalThis.clone = function(obj) {\n    if (null == obj || \"object\" != typeof obj)\n      return obj;\n    var result = obj.constructor();\n    for (var attr in obj) {\n      if (obj.hasOwnProperty(attr))\n        result[attr] = obj[attr];\n    }\n    return result;\n  };\n  {\n    C3.Behaviors.Rex_Platform_MoveTo = class Rex_Platform_MoveTo extends C3.SDKBehaviorBase {\n      constructor(opts) {\n        super(opts);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n}\n{\n  \"use strict\";\n  {\n    C3.Behaviors.Rex_Platform_MoveTo.Type = class Rex_Platform_MoveToType extends C3.SDKBehaviorTypeBase {\n      constructor(behaviorType) {\n        super(behaviorType);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n    };\n  }\n}\n{\n  \"use strict\";\n  {\n    C3.Behaviors.Rex_Platform_MoveTo.Instance = class Rex_Platform_MoveToInstance extends C3.SDKBehaviorInstanceBase {\n      constructor(behInst, properties) {\n        super(behInst);\n        this.wi = this._inst.GetWorldInfo();\n        this.inst = this._inst;\n        this.platformBehaviorInst = null;\n        this.isMoving = false;\n        this.target = {\n          \"m\": 0,\n          // 0: x mode , 1: distance mode\n          \"dir\": 0,\n          // 0:left , 1: right\n          \"x\": 0,\n          \"y\": 0,\n          \"d\": 0,\n          \"ds\": 0\n        };\n        this.isMyCall = false;\n        if (properties) {\n          this.activated = properties[0];\n        }\n        this._StartTicking();\n      }\n      Release() {\n        super.Release();\n      }\n      SaveToJson() {\n        return {\n          \"en\": this.activated,\n          \"im\": this.isMoving,\n          \"t\": clone2(this.target)\n        };\n      }\n      LoadFromJson(o) {\n        this.activated = o[\"en\"];\n        this.isMoving = o[\"im\"];\n        this.target = o[\"t\"];\n      }\n      getPlatformBehaviorInst() {\n        if (this.platformBehaviorInst != null)\n          return this.platformBehaviorInst;\n        if (!C3.Behaviors.Platform) {\n          return;\n        }\n        var behavior_insts = this.inst.GetBehaviorInstances();\n        var i, len = behavior_insts.length;\n        for (i = 0; i < len; i++) {\n          if (behavior_insts[i].GetObjectInstance().GetBehaviorInstanceFromCtor(C3.Behaviors.Platform)) {\n            this.platformBehaviorInst = behavior_insts[i];\n            return this.platformBehaviorInst;\n          }\n        }\n        return;\n      }\n      move(dir) {\n        var platformBehaviorInst = this.getPlatformBehaviorInst();\n        C3.Behaviors.Platform.Acts.SimulateControl.call(platformBehaviorInst.GetSdkInstance(), dir);\n      }\n      Tick() {\n        const dt = this._runtime.GetDt(this._inst);\n        if (!this.activated || !this.isMoving) {\n          return;\n        }\n        var is_hit_target = false;\n        if (this.target[\"m\"] == 0) {\n          if (this.target[\"dir\"] == 1 && this.wi.GetX() >= this.target[\"x\"] || this.target[\"dir\"] == 0 && this.wi.GetX() <= this.target[\"x\"])\n            is_hit_target = true;\n          else\n            this.move(this.target[\"dir\"]);\n        } else if (this.target[\"m\"] == 1) {\n          var x = this.wi.GetX();\n          var y = this.wi.GetY();\n          this.target[\"ds\"] += C3.distanceTo(this.target[\"x\"], this.target[\"y\"], x, y);\n          if (this.target[\"ds\"] >= this.target[\"d\"])\n            is_hit_target = true;\n          else {\n            this.move(this.target[\"dir\"]);\n            this.target[\"x\"] = x;\n            this.target[\"y\"] = y;\n          }\n        }\n        if (is_hit_target) {\n          this.isMoving = false;\n          this.isMyCall = true;\n          this.Trigger(C3.Behaviors.Rex_Platform_MoveTo.Cnds.OnHitTarget, this.inst);\n          this.isMyCall = false;\n        }\n      }\n      SetTargetPos(_x) {\n        this.isMoving = true;\n        this.target[\"m\"] = 0;\n        this.target[\"dir\"] = _x > this.wi.GetX() ? 1 : 0;\n        this.target[\"x\"] = _x;\n        this.target[\"y\"] = 0;\n        this.target[\"d\"] = 0;\n        this.target[\"ds\"] = 0;\n      }\n      SetTargetPosByDistance(distance, dir) {\n        this.isMoving = true;\n        this.target[\"m\"] = 1;\n        this.target[\"dir\"] = dir;\n        this.target[\"x\"] = this.wi.GetX();\n        this.target[\"y\"] = this.wi.GetY();\n        this.target[\"d\"] = distance;\n        this.target[\"ds\"] = 0;\n      }\n    };\n  }\n}\n{\n  \"use strict\";\n  {\n    C3.Behaviors.Rex_Platform_MoveTo.Cnds = {\n      OnHitTarget() {\n        return this.isMyCall;\n      },\n      IsMoving() {\n        return this.activated && this.isMoving;\n      }\n    };\n  }\n}\n{\n  \"use strict\";\n  {\n    C3.Behaviors.Rex_Platform_MoveTo.Acts = {\n      SetActivated(s) {\n        this.activated = s == 1;\n      },\n      SetTargetPosX(_x) {\n        this.SetTargetPos(_x);\n      },\n      SetTargetPosOnObject(objtype) {\n        if (!objtype)\n          return;\n        var inst = objtype.GetFirstPicked();\n        if (inst != null)\n          this.SetTargetPos(inst.GetWorldInfo().GetX());\n      },\n      SetTargetPosByDeltaX(_x) {\n        this.SetTargetPos(this.inst.GetWorldInfo().GetX() + _x);\n      },\n      SetTargetPosByDistance(distance, dir) {\n        this.SetTargetPosByDistance(distance, dir);\n      },\n      Stop() {\n        this.isMoving = false;\n      }\n    };\n  }\n}\n{\n  \"use strict\";\n  {\n    C3.Behaviors.Rex_Platform_MoveTo.Exps = {\n      Activated() {\n        return this.activated ? 1 : 0;\n      },\n      TargetX() {\n        var x = this.isMoving ? this.target[\"x\"] : 0;\n        return x;\n      }\n    };\n  }\n}\n{\n  {\n    const t = self.C3;\n    t.Behaviors.Pin = class extends t.SDKBehaviorBase {\n      constructor(t2) {\n        super(t2);\n      }\n      Release() {\n        super.Release();\n      }\n    };\n  }\n  {\n    const t = self.C3;\n    t.Behaviors.Pin.Type = class extends t.SDKBehaviorTypeBase {\n      constructor(t2) {\n        super(t2);\n      }\n      Release() {\n        super.Release();\n      }\n      OnCreate() {\n      }\n    };\n  }\n  {\n    const t = self.C3;\n    t.Behaviors.Pin.Instance = class extends t.SDKBehaviorInstanceBase {\n      constructor(s, e) {\n        super(s), this._pinInst = null, this._pinUid = -1, this._mode = \"\", this._propSet = /* @__PURE__ */ new Set(), this._pinDist = 0, this._pinAngle = 0, this._pinImagePoint = 0, this._dx = 0, this._dy = 0, this._dWidth = 0, this._dHeight = 0, this._dAngle = 0, this._dz = 0, this._lastKnownAngle = 0, this._destroy = false, e && (this._destroy = e[0]);\n        const i = this._runtime.Dispatcher();\n        this._disposables = new t.CompositeDisposable(t.Disposable.From(i, \"instancedestroy\", (t2) => this._OnInstanceDestroyed(t2.instance)), t.Disposable.From(i, \"afterload\", (t2) => this._OnAfterLoad()));\n      }\n      Release() {\n        this._pinInst = null, super.Release();\n      }\n      _SetPinInst(t2) {\n        t2 ? (this._pinInst = t2, this._StartTicking2()) : (this._pinInst = null, this._StopTicking2());\n      }\n      _Pin(s, e, i) {\n        if (!s) return;\n        const h = s.GetFirstPicked(this._inst);\n        if (!h) return;\n        this._mode = e, this._SetPinInst(h);\n        const n = this._inst.GetWorldInfo(), a = h.GetWorldInfo();\n        if (\"properties\" === this._mode) {\n          const s2 = this._propSet;\n          s2.clear();\n          for (const t2 of i) s2.add(t2);\n          this._dx = n.GetX() - a.GetX(), this._dy = n.GetY() - a.GetY(), this._dAngle = n.GetAngle() - a.GetAngle(), this._lastKnownAngle = n.GetAngle(), this._dz = n.GetZElevation() - a.GetZElevation(), s2.has(\"x\") && s2.has(\"y\") && (this._pinAngle = t.angleTo(a.GetX(), a.GetY(), n.GetX(), n.GetY()) - a.GetAngle(), this._pinDist = t.distanceTo(a.GetX(), a.GetY(), n.GetX(), n.GetY())), s2.has(\"width-abs\") ? this._dWidth = n.GetWidth() - a.GetWidth() : s2.has(\"width-scale\") && (this._dWidth = n.GetWidth() / a.GetWidth()), s2.has(\"height-abs\") ? this._dHeight = n.GetHeight() - a.GetHeight() : s2.has(\"height-scale\") && (this._dHeight = n.GetHeight() / a.GetHeight());\n        } else this._pinDist = t.distanceTo(a.GetX(), a.GetY(), n.GetX(), n.GetY());\n      }\n      SaveToJson() {\n        const t2 = this._propSet, s = this._mode, e = { \"uid\": this._pinInst && !this._pinInst.IsDestroyed() ? this._pinInst.GetUID() : -1, \"m\": s, \"d\": this._destroy };\n        return \"rope\" === s || \"bar\" === s ? e[\"pd\"] = this._pinDist : \"properties\" === s && (e[\"ps\"] = [...this._propSet], t2.has(\"imagepoint\") ? e[\"ip\"] = this._pinImagePoint : t2.has(\"x\") && t2.has(\"y\") ? (e[\"pa\"] = this._pinAngle, e[\"pd\"] = this._pinDist) : (t2.has(\"x\") && (e[\"dx\"] = this._dx), t2.has(\"y\") && (e[\"dy\"] = this._dy)), t2.has(\"angle\") && (e[\"da\"] = this._dAngle, e[\"lka\"] = this._lastKnownAngle), (t2.has(\"width-abs\") || t2.has(\"width-scale\")) && (e[\"dw\"] = this._dWidth), (t2.has(\"height-abs\") || t2.has(\"height-scale\")) && (e[\"dh\"] = this._dHeight), t2.has(\"z\") && (e[\"dz\"] = this._dz)), e;\n      }\n      LoadFromJson(t2) {\n        const s = t2[\"m\"], e = this._propSet;\n        if (e.clear(), this._pinUid = t2[\"uid\"], \"number\" != typeof s) {\n          if (this._mode = s, t2.hasOwnProperty(\"d\") && (this._destroy = !!t2[\"d\"]), \"rope\" === s || \"bar\" === s) this._pinDist = t2[\"pd\"];\n          else if (\"properties\" === s) {\n            for (const s2 of t2[\"ps\"]) e.add(s2);\n            e.has(\"imagepoint\") ? this._pinImagePoint = t2[\"ip\"] : e.has(\"x\") && e.has(\"y\") ? (this._pinAngle = t2[\"pa\"], this._pinDist = t2[\"pd\"]) : (e.has(\"x\") && (this._dx = t2[\"dx\"]), e.has(\"y\") && (this._dy = t2[\"dy\"])), e.has(\"angle\") && (this._dAngle = t2[\"da\"], this._lastKnownAngle = t2[\"lka\"] || 0), (e.has(\"width-abs\") || e.has(\"width-scale\")) && (this._dWidth = t2[\"dw\"]), (e.has(\"height-abs\") || e.has(\"height-scale\")) && (this._dHeight = t2[\"dh\"]), e.has(\"z\") && (this._dz = t2[\"dz\"]);\n          }\n        } else this._LoadFromJson_Legacy(t2);\n      }\n      _LoadFromJson_Legacy(t2) {\n        const s = this._propSet, e = t2[\"msa\"], i = t2[\"tsa\"], h = t2[\"pa\"], n = t2[\"pd\"];\n        switch (t2[\"m\"]) {\n          case 0:\n            this._mode = \"properties\", s.add(\"x\").add(\"y\").add(\"angle\"), this._pinAngle = h, this._pinDist = n, this._dAngle = e - i, this._lastKnownAngle = t2[\"lka\"];\n            break;\n          case 1:\n            this._mode = \"properties\", s.add(\"x\").add(\"y\"), this._pinAngle = h, this._pinDist = n;\n            break;\n          case 2:\n            this._mode = \"properties\", s.add(\"angle\"), this._dAngle = e - i, this._lastKnownAngle = t2[\"lka\"];\n            break;\n          case 3:\n            this._mode = \"rope\", this._pinDist = t2[\"pd\"];\n            break;\n          case 4:\n            this._mode = \"bar\", this._pinDist = t2[\"pd\"];\n        }\n      }\n      _OnAfterLoad() {\n        -1 === this._pinUid ? this._SetPinInst(null) : (this._SetPinInst(this._runtime.GetInstanceByUID(this._pinUid)), this._pinUid = -1);\n      }\n      _OnInstanceDestroyed(t2) {\n        this._pinInst === t2 && (this._SetPinInst(null), this._destroy && this._runtime.DestroyInstance(this._inst));\n      }\n      Tick2() {\n        const s = this._pinInst;\n        if (!s || s.IsDestroyed()) return;\n        const e = s.GetWorldInfo(), i = this._inst.GetWorldInfo(), h = this._mode;\n        let n = false;\n        if (\"rope\" === h || \"bar\" === h) {\n          const s2 = t.distanceTo(i.GetX(), i.GetY(), e.GetX(), e.GetY());\n          if (s2 > this._pinDist || \"bar\" === h && s2 < this._pinDist) {\n            const s3 = t.angleTo(e.GetX(), e.GetY(), i.GetX(), i.GetY());\n            i.SetXY(e.GetX() + Math.cos(s3) * this._pinDist, e.GetY() + Math.sin(s3) * this._pinDist), n = true;\n          }\n        } else {\n          const h2 = this._propSet;\n          let a = 0;\n          if (h2.has(\"imagepoint\")) {\n            const [t2, e2] = s.GetImagePoint(this._pinImagePoint);\n            i.EqualsXY(t2, e2) || (i.SetXY(t2, e2), n = true);\n          } else if (h2.has(\"x\") && h2.has(\"y\")) {\n            const t2 = e.GetX() + Math.cos(e.GetAngle() + this._pinAngle) * this._pinDist, s2 = e.GetY() + Math.sin(e.GetAngle() + this._pinAngle) * this._pinDist;\n            i.EqualsXY(t2, s2) || (i.SetXY(t2, s2), n = true);\n          } else a = e.GetX() + this._dx, h2.has(\"x\") && a !== i.GetX() && (i.SetX(a), n = true), a = e.GetY() + this._dy, h2.has(\"y\") && a !== i.GetY() && (i.SetY(a), n = true);\n          h2.has(\"angle\") && (this._lastKnownAngle !== i.GetAngle() && (this._dAngle = t.clampAngle(this._dAngle + (i.GetAngle() - this._lastKnownAngle))), a = t.clampAngle(e.GetAngle() + this._dAngle), a !== i.GetAngle() && (i.SetAngle(a), n = true), this._lastKnownAngle = i.GetAngle()), h2.has(\"width-abs\") && (a = e.GetWidth() + this._dWidth, a !== i.GetWidth() && (i.SetWidth(a), n = true)), h2.has(\"width-scale\") && (a = e.GetWidth() * this._dWidth, a !== i.GetWidth() && (i.SetWidth(a), n = true)), h2.has(\"height-abs\") && (a = e.GetHeight() + this._dHeight, a !== i.GetHeight() && (i.SetHeight(a), n = true)), h2.has(\"height-scale\") && (a = e.GetHeight() * this._dHeight, a !== i.GetHeight() && (i.SetHeight(a), n = true)), h2.has(\"z\") && (a = e.GetZElevation() + this._dz, a !== i.GetZElevation() && (i.SetZElevation(a), this._runtime.UpdateRender()));\n        }\n        n && i.SetBboxChanged();\n      }\n      GetDebuggerProperties() {\n        const t2 = \"behaviors.pin.debugger\";\n        return [{ title: \"$\" + this.GetBehaviorType().GetName(), properties: [{ name: t2 + \".is-pinned\", value: !!this._pinInst }, { name: t2 + \".pinned-uid\", value: this._pinInst ? this._pinInst.GetUID() : 0 }] }];\n      }\n    };\n  }\n  self.C3.Behaviors.Pin.Cnds = { IsPinned() {\n    return !!this._pinInst;\n  }, WillDestroy() {\n    return this._destroy;\n  } };\n  self.C3.Behaviors.Pin.Acts = { PinByDistance(t, s) {\n    this._Pin(t, 0 === s ? \"rope\" : \"bar\");\n  }, PinByProperties(t, s, e, i, h, n, a) {\n    const o = [];\n    s && o.push(\"x\"), e && o.push(\"y\"), i && o.push(\"angle\"), a && o.push(\"z\"), 1 === h ? o.push(\"width-abs\") : 2 === h && o.push(\"width-scale\"), 1 === n ? o.push(\"height-abs\") : 2 === n && o.push(\"height-scale\"), 0 !== o.length && this._Pin(t, \"properties\", o);\n  }, PinByImagePoint(t, s, e, i, h, n) {\n    const a = [\"imagepoint\"];\n    e && a.push(\"angle\"), n && a.push(\"z\"), 1 === i ? a.push(\"width-abs\") : 2 === i && a.push(\"width-scale\"), 1 === h ? a.push(\"height-abs\") : 2 === h && a.push(\"height-scale\"), this._pinImagePoint = s, this._Pin(t, \"properties\", a);\n  }, SetPinDistance(t) {\n    \"rope\" !== this._mode && \"bar\" !== this._mode || (this._pinDist = Math.max(t, 0));\n  }, SetDestroy(t) {\n    this._destroy = t;\n  }, Unpin() {\n    this._SetPinInst(null), this._mode = \"\", this._propSet.clear(), this._pinImagePoint = \"\";\n  }, Pin(t, s) {\n    switch (s) {\n      case 0:\n        this._Pin(t, \"properties\", [\"x\", \"y\", \"angle\"]);\n        break;\n      case 1:\n        this._Pin(t, \"properties\", [\"x\", \"y\"]);\n        break;\n      case 2:\n        this._Pin(t, \"properties\", [\"angle\"]);\n        break;\n      case 3:\n        this._Pin(t, \"rope\");\n        break;\n      case 4:\n        this._Pin(t, \"bar\");\n    }\n  } };\n  self.C3.Behaviors.Pin.Exps = { PinnedUID() {\n    return this._pinInst ? this._pinInst.GetUID() : -1;\n  } };\n}\n{\n  let unaryminus = function(n) {\n    return typeof n === \"number\" ? -n : n;\n  }, bothNumbers = function(a, b) {\n    return typeof a === \"number\" && typeof b === \"number\";\n  }, add = function(l, r) {\n    if (bothNumbers(l, r))\n      return l + r;\n    else\n      return l;\n  }, subtract = function(l, r) {\n    if (bothNumbers(l, r))\n      return l - r;\n    else\n      return l;\n  }, multiply = function(l, r) {\n    if (bothNumbers(l, r))\n      return l * r;\n    else\n      return l;\n  }, divide = function(l, r) {\n    if (bothNumbers(l, r))\n      return l / r;\n    else\n      return l;\n  }, mod = function(l, r) {\n    if (bothNumbers(l, r))\n      return l % r;\n    else\n      return l;\n  }, pow = function(l, r) {\n    if (bothNumbers(l, r))\n      return Math.pow(l, r);\n    else\n      return l;\n  }, and = function(l, r) {\n    if (typeof l === \"string\" || typeof r === \"string\") {\n      let lstr, rstr;\n      if (typeof l === \"number\")\n        lstr = (Math.round(l * 1e10) / 1e10).toString();\n      else\n        lstr = l;\n      if (typeof r === \"number\")\n        rstr = (Math.round(r * 1e10) / 1e10).toString();\n      else\n        rstr = r;\n      return lstr + rstr;\n    } else {\n      return l && r ? 1 : 0;\n    }\n  }, or = function(l, r) {\n    if (bothNumbers(l, r))\n      return l || r ? 1 : 0;\n    else\n      return l;\n  };\n  unaryminus2 = unaryminus, bothNumbers2 = bothNumbers, add2 = add, subtract2 = subtract, multiply2 = multiply, divide2 = divide, mod2 = mod, pow2 = pow, and2 = and, or2 = or;\n  const C33 = self.C3;\n  self.C3_ExpressionFuncs = [\n    () => \"slide\",\n    () => 0,\n    () => 5120,\n    () => 60,\n    () => 1,\n    (p) => {\n      const f0 = p._GetNode(0).GetBoundMethod();\n      return () => f0(0);\n    },\n    (p) => {\n      const f0 = p._GetNode(0).GetBoundMethod();\n      return () => f0(0) - 32;\n    },\n    (p) => {\n      const n0 = p._GetNode(0);\n      return () => n0.ExpBehavior(\"slide\");\n    },\n    (p) => {\n      const f0 = p._GetNode(0).GetBoundMethod();\n      return () => f0(\"R\", \"L\");\n    },\n    () => \"R\",\n    (p) => {\n      const f0 = p._GetNode(0).GetBoundMethod();\n      return () => f0(120, 256);\n    },\n    () => \"L\",\n    () => \"Walk\",\n    () => \"Idle\",\n    () => \"World\",\n    () => \"\",\n    () => 240,\n    () => 272,\n    (p) => {\n      const v0 = p._GetNode(0).GetVar();\n      return () => v0.GetValue();\n    }\n  ];\n}\nvar unaryminus2;\nvar bothNumbers2;\nvar add2;\nvar subtract2;\nvar multiply2;\nvar divide2;\nvar mod2;\nvar pow2;\nvar and2;\nvar or2;\n\n// file-map:scripts/objRefTable.js\nvar C32 = self.C3;\nself.C3_GetObjectRefTable = function() {\n  return [\n    C32.Plugins.Sprite,\n    C32.Behaviors.solid,\n    C32.Plugins.Keyboard,\n    C32.Plugins.Touch,\n    C32.Plugins.TiledBg,\n    C32.Behaviors.Tween,\n    C32.Behaviors.Platform,\n    C32.Behaviors.Rex_Platform_MoveTo,\n    C32.Plugins.Spritefont2,\n    C32.Behaviors.Pin,\n    C32.Plugins.System.Cnds.OnLayoutStart,\n    C32.JavaScriptInEvents.GameEvents_Event1_Act1,\n    C32.Behaviors.Tween.Acts.TweenValue,\n    C32.Plugins.System.Cnds.EveryTick,\n    C32.Plugins.Sprite.Acts.SetPos,\n    C32.Plugins.System.Exps.viewportleft,\n    C32.Plugins.System.Exps.viewportbottom,\n    C32.Plugins.System.Exps.viewportright,\n    C32.Plugins.Sprite.Acts.SetWidth,\n    C32.Plugins.System.Exps.viewportwidth,\n    C32.Plugins.TiledBg.Acts.SetImageOffsetX,\n    C32.Behaviors.Tween.Exps.Value,\n    C32.Plugins.TiledBg.Acts.SetImageOffsetY,\n    C32.Behaviors.Platform.Cnds.OnLand,\n    C32.Plugins.System.Acts.SetVar,\n    C32.Plugins.System.Exps.choose,\n    C32.Plugins.System.Cnds.CompareVar,\n    C32.Behaviors.Rex_Platform_MoveTo.Acts.SetTargetPosByDistance,\n    C32.Plugins.System.Exps.random,\n    C32.Behaviors.Rex_Platform_MoveTo.Cnds.OnHitTarget,\n    C32.Plugins.Sprite.Cnds.OnCollision,\n    C32.Behaviors.Rex_Platform_MoveTo.Acts.Stop,\n    C32.Plugins.Sprite.Acts.SetMirrored,\n    C32.Plugins.System.Cnds.Else,\n    C32.Behaviors.Platform.Cnds.IsMoving,\n    C32.Plugins.Sprite.Acts.SetAnim,\n    C32.Plugins.Sprite.Cnds.OnCreated,\n    C32.Plugins.Sprite.Acts.Spawn,\n    C32.Behaviors.Pin.Acts.PinByProperties,\n    C32.Plugins.System.Acts.CreateObject,\n    C32.Plugins.Sprite.Acts.SetInstanceVar\n  ];\n};\nself.C3_JsPropNameTable = [\n  { Solid: 0 },\n  { FloorBase: 0 },\n  { Keyboard: 0 },\n  { Touch: 0 },\n  { Tween: 0 },\n  { TiledBackground: 0 },\n  { nick: 0 },\n  { Platform: 0 },\n  { PlatformMoveTo: 0 },\n  { Character: 0 },\n  { BorderLeft: 0 },\n  { BorderRight: 0 },\n  { Pin: 0 },\n  { SpriteFont: 0 },\n  { Side: 0 },\n  { asigned: 0 },\n  { Nick: 0 }\n];\nself.InstanceType = {\n  FloorBase: class extends self.ISpriteInstance {\n  },\n  Keyboard: class extends self.IInstance {\n  },\n  Touch: class extends self.IInstance {\n  },\n  TiledBackground: class extends self.ITiledBackgroundInstance {\n  },\n  Character: class extends self.ISpriteInstance {\n  },\n  BorderLeft: class extends self.ISpriteInstance {\n  },\n  BorderRight: class extends self.ISpriteInstance {\n  },\n  SpriteFont: class extends self.ISpriteFontInstance {\n  }\n};\n\n// file-map:scripts/project/javaScriptInEvents.js\nvar scriptsInEvents = {\n  async GameEvents_Event1_Act1(runtime, localVars) {\n    window.addEventListener(\"message\", (event) => {\n      const data = event.data;\n      if (data.action === \"test\") {\n        runtime.callFunction(\"Spawn\", evet.data.value);\n      }\n    });\n  }\n};\nglobalThis.C3.JavaScriptInEvents = scriptsInEvents;\n/*!\n@fileoverview gl-matrix - High performance matrix and vector operations\n@author Brandon Jones\n@author Colin MacKenzie IV\n@version 3.4.1\n\nCopyright (c) 2015-2021, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n"
	},
	"scripts/dispatchworker.js": {
		"type": "application/javascript",
		"str": "\"use strict\";self.inputPort=null,self.jobQueue=[],self.jobWorkers=[],self.sentBlobs=[],self.sentBuffers=[],self.importedScripts=[],self.lastBroadcasts=new Map;class JobWorker{constructor(e,s){this._port=e,this._number=s,this._isReady=!1,this._isBusy=!1,this._port.onmessage=e=>this._OnMessage(e.data)}ImportScripts(e){this._port.postMessage({\"type\":\"_import_scripts\",\"scripts\":e})}SendBlob(e,s){this._port.postMessage({\"type\":\"_send_blob\",\"blob\":e,\"id\":s})}SendBuffer(e,s){this._port.postMessage({\"type\":\"_send_buffer\",\"buffer\":e,\"id\":s})}SendJob(e){if(this._isBusy||!this._isReady)throw new Error(\"cannot take job\");this._isBusy=!0,this._port.postMessage(e,e[\"transferables\"])}_InitBroadcast(e){this._port.postMessage(e,e[\"transferables\"])}SendReady(){this._port.postMessage({\"type\":\"_ready\"})}IsReady(){return this._isReady}_OnReady(){this._isReady=!0,this.MaybeStartNextJob()}IsBusy(){return this._isBusy}GetNumber(){return this._number}_OnMessage(e){const s=e[\"type\"];switch(s){case\"ready\":return void this._OnReady();case\"done\":return void this._OnJobDone();default:return void console.error(\"unknown message from worker '\"+s+\"'\")}}_OnJobDone(){this._isBusy=!1,this.MaybeStartNextJob()}MaybeStartNextJob(){if(this._isBusy||!this._isReady)return;const e=this._FindAvailableJob();if(-1===e)return;const s=self.jobQueue[e];s[\"isBroadcast\"]?(s[\"doneFlags\"][this._number]=!0,s[\"doneFlags\"].every((e=>e))&&self.jobQueue.splice(e,1)):self.jobQueue.splice(e,1),this.SendJob(s)}_FindAvailableJob(){for(let e=0,s=self.jobQueue.length;e<s;++e){const s=self.jobQueue[e];if(!(\"number\"==typeof s[\"maxWorkerNum\"]&&this._number>=s[\"maxWorkerNum\"])&&(!s[\"isBroadcast\"]||this._number<s[\"doneFlags\"].length&&!s[\"doneFlags\"][this._number]))return e}return-1}}let number=0;function AddJobWorker(e){const s=new JobWorker(e,number++);self.jobWorkers.push(s);for(const[e,t]of self.sentBlobs)s.SendBlob(e,t);for(const[e,t]of self.sentBuffers)s.SendBuffer(e,t);for(const e of self.importedScripts)s.ImportScripts(e);for(const e of self.lastBroadcasts.values())s._InitBroadcast(e);s.SendReady()}function CancelJob(e){for(let s=0,t=self.jobQueue.length;s<t;++s)if(self.jobQueue[s].jobId===e)return void self.jobQueue.splice(s,1)}function OnInputPortMessage(e){const s=e.data,t=s[\"type\"];if(\"_cancel\"!==t)if(\"_import_scripts\"!==t)if(\"_send_blob\"!==t)if(\"_send_buffer\"!==t){if(\"_no_more_workers\"===t)return self.sentBlobs.length=0,self.sentBuffers.length=0,self.importedScripts.length=0,void self.lastBroadcasts.clear();if(self.jobQueue.push(s),s[\"isBroadcast\"]){const e=s[\"maxWorkerNum\"],t=self.jobWorkers.length,o=\"number\"==typeof e?Math.min(e,t):t;s[\"doneFlags\"]=new Array(o).fill(!1),s[\"transferables\"]=[];const r=s[\"params\"]&&s[\"params\"][\"broadcastKey\"]?s[\"params\"][\"broadcastKey\"]:s[\"type\"];self.lastBroadcasts.delete(r),self.lastBroadcasts.set(r,s)}for(const e of self.jobWorkers)e.MaybeStartNextJob()}else{const e=s[\"buffer\"],t=s[\"id\"];for(const s of self.jobWorkers)s.SendBuffer(e,t);self.sentBuffers.push([e,t])}else{const e=s[\"blob\"],t=s[\"id\"];for(const s of self.jobWorkers)s.SendBlob(e,t);self.sentBlobs.push([e,t])}else{const e=s[\"scripts\"];for(const s of self.jobWorkers)s.ImportScripts(e);self.importedScripts.push(e)}else CancelJob(s.jobId)}self.addEventListener(\"message\",(e=>{const s=e.data,t=s[\"type\"];\"_init\"===t?(self.inputPort=s[\"in-port\"],self.inputPort.onmessage=OnInputPortMessage):\"_addJobWorker\"===t&&AddJobWorker(s[\"port\"])}));"
	},
	"scripts/jobworker.js": {
		"type": "application/javascript",
		"str": "\"use strict\";function FlipImageData(e,t,s){const r=4*t,o=new Uint8Array(r),n=e.buffer;for(let e=0,t=Math.floor(s/2);e<t;++e){const t=s-e-1,a=new Uint8Array(n,e*r,r),l=new Uint8Array(n,t*r,r);o.set(a),a.set(l),l.set(o)}}function UnpremultiplyImageData(e){for(let t=0,s=e.length;t<s;t+=4){const s=e[t+3];if(255===s)continue;const r=255/s;e[t]*=r,e[t+1]*=r,e[t+2]*=r}}function SendReady(){self.dispatchPort.postMessage({\"type\":\"ready\"}),self.outputPort.postMessage({\"type\":\"ready\"})}function SendError(e,t){e||self.outputPort.postMessage({\"type\":\"error\",\"jobId\":self.activeJobId,\"error\":t.toString()}),SendDone()}function SendResult(e,t){if(!e){const e=t.transferables||[];self.outputPort.postMessage({\"type\":\"result\",\"jobId\":self.activeJobId,\"result\":t.result},e)}SendDone()}function SendDone(){self.activeJobId=null,self.dispatchPort.postMessage({\"type\":\"done\"})}function SendProgress(e){self.outputPort.postMessage({\"type\":\"progress\",\"jobId\":self.activeJobId,\"progress\":e})}function OnDispatchWorkerMessage(e){const t=e.data,s=t[\"type\"];if(\"_import_scripts\"===s)return void importScripts(...t[\"scripts\"]);if(\"_send_blob\"===s)return void self.sentBlobs.set(t[\"id\"],t[\"blob\"]);if(\"_send_buffer\"===s)return void self.sentBuffers.set(t[\"id\"],t[\"buffer\"]);if(\"_ready\"===s)return void SendReady();const r=t[\"jobId\"],o=t[\"isBroadcast\"],n=t[\"params\"];let a;if(self.activeJobId=r,self.JobHandlers.hasOwnProperty(s)){try{a=self.JobHandlers[s](n)}catch(e){return void SendError(o,\"Exception in job handler: \"+e)}a&&a.then?a.then((e=>SendResult(o,e))).catch((e=>SendError(o,\"Rejection in job handler: \"+e))):SendResult(o,a)}else console.error(`no handler for message type '${s}'`)}self.dispatchPort=null,self.outputPort=null,self.workerNumber=-1,self.activeJobId=null,self.sentBlobs=new Map,self.sentBuffers=new Map,self.JobHandlers={},self.JobHandlers[\"ProcessImageData\"]=function(e){const t=e[\"buffer\"],s=new Uint8Array(t),r=e[\"width\"],o=e[\"height\"];return e[\"flipY\"]&&FlipImageData(s,r,o),e[\"unpremultiply\"]&&UnpremultiplyImageData(s),{result:t,transferables:[t]}},self.addEventListener(\"message\",(e=>{const t=e.data,s=t[\"type\"];switch(s){case\"init\":return self.workerNumber=t[\"number\"],self.dispatchPort=t[\"dispatch-port\"],self.dispatchPort.onmessage=OnDispatchWorkerMessage,void(self.outputPort=t[\"output-port\"]);case\"terminate\":return void self.close();default:return void console.error(\"unknown message '\"+s+\"'\")}}));"
	},
	"data.json": {
		"type": "application/json",
		"str": "{\"project\":[\"Widget Test\",null,[[[0,false,true,true,true,true,true,true,true,false,false,false,false,true,true,true,true,false,false,1,\"Sprite\",\"\"],[2,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,1,\"Keyboard\",\"\"],[3,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,1,\"Touch\",\"\"],[4,false,true,true,true,true,true,true,true,true,false,false,false,true,true,false,true,false,false,1,\"TiledBg\",\"\"],[8,false,true,true,true,true,true,true,true,true,false,false,false,true,false,false,true,false,false,1,\"Spritefont2\",\"\"]],[[1,1,\"solid\",\"\"],[5,1,\"Tween\",\"\"],[6,1,\"Platform\",\"\"],[7,1,\"Rex_Platform_MoveTo\",\"\"],[9,1,\"Pin\",\"\"]]],[[\"FloorBase\",0,false,[],1,0,null,[[\"Animation 1\",5,false,1,0,false,824096530033285,[[\"images/shared-0-sheet0.png\",242654,1543,1537,256,256,false,1,0,0,[],[],\"\"]]]],[[\"Solid\",1,926717937061248,0]],false,false,834443959607531,[],null,1,null],[\"Keyboard\",2,false,[],0,0,null,null,[],false,false,846813611445947,[],null,2,null,[],4],[\"Touch\",3,false,[],0,0,null,null,[],false,false,622394779683910,[],null,3,null,[true],5],[\"TiledBackground\",4,false,[],1,0,[\"images/tiledbackground-sheet0.png\",27802,0,0,1024,1024,false],null,[[\"Tween\",5,127489340899720,4]],false,false,330711282785909,[],null,5,[1,1]],[\"Character\",0,false,[[580238561355994,2,\"nick\",6]],2,0,null,[[\"Idle\",3,true,1,0,false,171265645233378,[[\"images/shared-0-sheet0.png\",242654,1029,1025,512,512,false,1,0.5,0.5,[[\"Image Point 1\",0.5,-0.125]],[0.08203125,-0.3828125,0.29296875,-0.162109375,0.197265625,0.30859375,0.06640625,0.486328125,-0.064453125,0.478515625,-0.21875,0.306640625,-0.208984375,-0.376953125],\"\"],[\"images/shared-0-sheet0.png\",242654,515,1025,512,512,false,1,0.5,0.5,[[\"Image Point 1\",0.5,-0.125]],[0.083984375,-0.375,0.294921875,-0.154296875,0.19921875,0.31640625,0.0625,0.484375,-0.060546875,0.48046875,-0.216796875,0.314453125,-0.20703125,-0.369140625],\"\"]]],[\"Walk\",6,true,1,0,false,146853682384959,[[\"images/shared-0-sheet0.png\",242654,1,1025,512,512,false,1,0.5,0.5,[[\"Image Point 1\",0.5,-0.125]],[0.08203125,-0.3828125,0.29296875,-0.162109375,0.197265625,0.30859375,0.06640625,0.486328125,-0.099609375,0.466796875,-0.21875,0.306640625,-0.208984375,-0.376953125],\"\"],[\"images/shared-0-sheet0.png\",242654,1029,1,512,512,false,1,0.5,0.5,[[\"Image Point 1\",0.5,-0.125]],[0.08203125,-0.37109375,0.29296875,-0.150390625,0.197265625,0.3203125,0.03515625,0.484375,-0.060546875,0.45703125,-0.21875,0.318359375,-0.208984375,-0.365234375],\"\"],[\"images/shared-0-sheet0.png\",242654,515,1,512,512,false,1,0.5,0.5,[[\"Image Point 1\",0.5,-0.125]],[0.08203125,-0.3828125,0.29296875,-0.162109375,0.197265625,0.30859375,-0.009765625,0.478515625,-0.21875,0.306640625,-0.208984375,-0.376953125],\"\"],[\"images/shared-0-sheet0.png\",242654,1,1,512,512,false,1,0.5,0.5,[[\"Image Point 1\",0.5,-0.125]],[0.08203125,-0.37109375,0.29296875,-0.150390625,0.197265625,0.3203125,0.056640625,0.4609375,-0.046875,0.482421875,-0.21875,0.318359375,-0.208984375,-0.365234375],\"\"]]]],[[\"Platform\",6,532016892433385,7],[\"PlatformMoveTo\",7,738625701341655,8]],false,false,953832783564797,[],null,9,null],[\"BorderLeft\",0,false,[],1,0,null,[[\"Animation 1\",5,false,1,0,false,615623035386878,[[\"images/shared-0-sheet0.png\",242654,1543,1537,256,256,false,1,1,1,[],[],\"\"]]]],[[\"Solid\",1,597270069776301,0]],false,false,743125059447981,[],null,10,null],[\"BorderRight\",0,false,[],1,0,null,[[\"Animation 1\",5,false,1,0,false,234277662898298,[[\"images/shared-0-sheet0.png\",242654,1543,1537,256,256,false,1,0,1,[],[],\"\"]]]],[[\"Solid\",1,369993674769560,0]],false,false,503574858197633,[],null,11,null],[\"SpriteFont\",8,false,[],1,0,[\"images/shared-0-sheet0.png\",242654,1543,1,256,512,false],null,[[\"Pin\",9,294414516324519,12]],false,false,999766977010304,[],null,13,null]],[],[[\"World\",480,640,true,false,0.5,0.5,\"Game Events\",432742789998375,[[\"Background\",0,425966799724604,true,[94,94,94],false,1,1,1,false,false,1,0,true,[[[-2320,-2240,0,5120,5120,0,0,[1,1,1,1],0,0,0,0,[],null,null,null,[\"\",\"\"]],3,3,[],[[true]],[true,0,1,1,0,0,0.125,0.125,0,false,1,1,1,0.1,0.1],\"\"]],[],0,true,false,false,[]],[\"World\",1,956192815849486,true,[94,94,94],true,1,1,1,false,false,1,0,true,[[[0,608,0,480,96,0,0,[1,1,1,1],0,0,0,0,[],null,null,null,[\"\",\"\"]],0,2,[],[[true,\"\"]],[true,\"Animation 1\",0,true],\"\"],[[0,608,0,64,240,0,0,[1,1,1,1],1,1,0,0,[],null,null,null,[\"\",\"\"]],5,7,[],[[true,\"\"]],[true,\"Animation 1\",0,true],\"\"],[[480,608,0,64,240,0,0,[1,1,1,1],0,1,0,0,[],null,null,null,[\"\",\"\"]],6,8,[],[[true,\"\"]],[true,\"Animation 1\",0,true],\"\"]],[],0,true,false,false,[]]],[],[]],[\"Repository\",960,1280,false,false,0.5,0.5,null,195594786957213,[[\"Layer 0\",0,734973518947970,true,[94,94,94],false,1,1,1,false,false,1,0,true,[[[204,234,0,96,96,0,0,[1,1,1,1],0.5,0.5,0,0,[],null,null,null,[\"\",\"\"]],4,6,[\"\"],[[90,1500,1500,650,1500,1000,false,0,false,true],[true]],[true,\"Idle\",0,true],\"\"],[[174,142,0,142.8994966623286,17.096768539002085,0,0,[1,1,1,1],0,0,0,0,[],null,null,null,[\"\",\"\"]],7,9,[],[[false]],[\"Text\",true,32,32,\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#\\\"'&()[]|`\\\\/@°+=*$£€<>\",\"\",0.5,0,0,0,2,0,true,0,false],\"\"]],[],0,true,false,false,[]]],[],[]]],[[\"Game Events\",[[1,\"Side\",1,\"R\",false,false,593680768998745,false,14],[1,\"asigned\",2,false,false,false,325714571169910,false,15],[0,0,false,null,248484206066645,1,[[-1,10,null,1,false,false,false,812644781418388,null]],[[-3,11,[false,false,0]],[3,12,\"Tween\",312627409792249,2048,null,[[1,[0]],[0,[1]],[0,[2]],[0,[3]],[18,0],[3,0],[3,1],[3,0],[0,[4]]]]]],[4,[\"get\",0,[],true,false,false],false,null,748345529394492,2,[],[]],[0,0,false,null,550889646090374,3,[[-1,13,null,0,false,false,false,383143360604122,null]],[[0,14,null,336946050218782,0,null,[[0,[5,[4,15]]],[0,[6,[4,16]]]]],[5,14,null,229684347628410,0,null,[[0,[5,[4,15]]],[0,[6,[4,16]]]]],[6,14,null,517983272234884,0,null,[[0,[5,[4,17]]],[0,[6,[4,16]]]]],[0,18,null,766527568647601,0,null,[[0,[5,[4,19]]]]],[3,20,null,244653297811260,0,null,[[0,[7,[0,3,\"Tween\",21,false]]]]],[3,22,null,123840141434448,0,null,[[0,[7,[0,3,\"Tween\",21,false]]]]]]],[0,0,false,null,135493771425430,4,[[4,23,\"Platform\",1,false,false,false,932030340514973,null]],[[-1,24,null,649748004177847,0,null,[[11,593680768998745],[7,[8,[4,25]]]]]],[[0,0,false,null,903442323611059,5,[[-1,26,null,0,false,false,false,932478794006089,null,[[11,593680768998745],[8,0],[7,[9]]]]],[[4,27,\"PlatformMoveTo\",960979210496730,0,null,[[0,[10,[4,28]]],[3,1]]]]],[0,0,false,null,971377050637143,6,[[-1,26,null,0,false,false,false,702371533195056,null,[[11,593680768998745],[8,0],[7,[11]]]]],[[4,27,\"PlatformMoveTo\",784026475131441,0,null,[[0,[10,[4,28]]],[3,0]]]]]]],[0,0,false,null,179095972503133,7,[[4,29,\"PlatformMoveTo\",1,false,false,false,432704015125280,null]],[[-1,24,null,902936418955610,0,null,[[11,593680768998745],[7,[8,[4,25]]]]]],[[0,0,false,null,411274905857922,8,[[-1,26,null,0,false,false,false,501981678313007,null,[[11,593680768998745],[8,0],[7,[9]]]]],[[4,27,\"PlatformMoveTo\",691492244429329,0,null,[[0,[10,[4,28]]],[3,1]]]]],[0,0,false,null,307748418298985,9,[[-1,26,null,0,false,false,false,512671396416288,null,[[11,593680768998745],[8,0],[7,[11]]]]],[[4,27,\"PlatformMoveTo\",834783580046043,0,null,[[0,[10,[4,28]]],[3,0]]]]]]],[0,0,false,null,204578139320103,10,[[4,30,null,0,false,false,true,495161050031866,null,[[4,5]]]],[[4,31,\"PlatformMoveTo\",449559978039439,0,null],[4,27,\"PlatformMoveTo\",183986248463005,0,null,[[0,[10,[4,28]]],[3,1]]],[-1,24,null,672049911846192,0,null,[[11,593680768998745],[7,[9]]]]]],[0,0,false,null,730571202724727,11,[[4,30,null,0,false,false,true,722529094062157,null,[[4,6]]]],[[4,31,\"PlatformMoveTo\",904961002705402,0,null],[4,27,\"PlatformMoveTo\",622938203398961,0,null,[[0,[10,[4,28]]],[3,0]]],[-1,24,null,863770927564378,0,null,[[11,593680768998745],[7,[11]]]]]],[0,0,false,null,326459513872773,12,[[-1,26,null,0,false,false,false,842414015880492,null,[[11,593680768998745],[8,0],[7,[9]]]]],[[4,32,null,569696209401328,0,null,[[3,1]]]]],[0,0,false,null,195257440642356,13,[[-1,33,null,0,false,false,false,662021495016015,null]],[[4,32,null,987499143588185,0,null,[[3,0]]]]],[0,0,false,null,318911672730437,14,[[4,34,\"Platform\",0,false,false,false,817033155861708,null]],[[4,35,null,321677247246554,0,null,[[1,[12]],[3,1]]]]],[0,0,false,null,423507761455710,15,[[-1,33,null,0,false,false,false,593457830532609,null]],[[4,35,null,620883878180553,0,null,[[1,[13]],[3,1]]]]],[0,0,false,null,758467658155415,16,[[4,36,null,1,false,false,false,501612769640190,null]],[[4,37,null,676651992410814,257,null,[[4,7],[5,[14]],[7,[4]],[16,false],[20,[15]]]],[7,38,\"Pin\",462327240080256,0,null,[[4,4],[16,true],[16,true],[16,true],[3,0],[3,0],[16,false]]]]],[4,[\"Spawn\",0,[[1,\"Nick\",1,\"\",false,false,546234970119796,false,16]],true,false,false],false,null,293279411025578,17,[],[[-1,39,null,782687485362680,256,null,[[4,4],[5,[14]],[0,[16]],[0,[17]],[16,false],[20,[15]]]],[4,40,null,251958551149346,0,null,[[10,0],[7,[18,[3,546234970119796]]]]]]]]]],[],\"media/\",false,480,640,3,false,\"trilinear\",false,\"1.0.0.0\",false,false,1,1,10,false,true,1,true,0.7853981633974483,[],\"icons/\",[],\"normalized\",\"6it25b9o158\",\"fonts/\",[[\"Timeline 1\",5,0.1,\"default\",\"default\",[],0,0,1,\"\",1,1]],\"high-performance\",[],1748562641121,\"vsync\",\"\",\"icons/loading-logo.png\",false,4,false,null,[],\"folders\",1,10000,false,[[\"Flowchart 1\",[]]],\"auto\"]}"
	},
	"images/tiledbackground-sheet0.png": "data:image/png;base64,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",
	"images/shared-0-sheet0.png": "data:image/png;base64,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Xf5Rl+eqj9cpQIHGFGAAQGOOC1tFAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKi6AAMAjDkf2RWwUO0BCbuAK80vTR91/1utfml/pOld/lGX56qP1ylAgcYUYABAY44LW0UBClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUqLoAAwAYAHD+TVbrAIh6L1hHXb+0PGl61y+EqMtz1cfrFKBAYwowAKAxx4WtogAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpUXYABAAwAYADAOYGwARDSBXhpetcvhKjLc9XH6xSgQGMKMACgMceFraIABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKVF0g6gVDaXlRByBEvYAbdgBc7al3/6Ouv9RL2n9X+rDj4cof1kPafunPi7T90va4yud1ClCgOQQYANAc48RWUoACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUiF6j3AmTYBddSkLALnrVuT63rK/WKun7peER9/4X9AQnrIb3/ou5/1OWF9WR+ClCgPgIMAKiPO2ulAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABCtRdIOoFQ2l5YRdcpQvOLvBat6fW9ZX2P+r6peMhvV9c4xf2elgPBgCEHQHmpwAFohBgAEAUiiyDAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKNCEAlEvwErLC7vgKl1wdg1RrdtT6/pK+x91/dLxkN4vrvELez2sBwMAwo4A81OAAlEIMAAgCkWWQQEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKizAAMA6jwArJ4CFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABSgQhQADAKJQZBkUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKECBOgswAKDOA8DqKUABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAlEIMAAgCkWWQQEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKizAAMA6jwArJ4CFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABSgQhQADAKJQZBkUoAAFKEABClCAAhSgAAUo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IECAwAoV2BbbRq6Na++0qhPborvwyznigZHScbdcuHAoRextc/vOkWjevyoO/adHE67QQSubAAECBAgQIEBgxQkIAKy4kSm4YoFmU2zqzMf8WI48NhaznZ7FXIx3U6S50Ridm47p3tX+kvQVL4nWCRAgQIAAAQIECBAgQIBAnwV671dMxMShO6eZuFMT3U6K5vr90Xx9IiZudIFCn6fhdAQIECBAgAABAtULCABUvwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAEAQGAEqaoBwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoXkAAoPoVAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECJQgIAJQwRT0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQPUCAgDVrwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEChBQACghCnqgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqFxAAqH4FABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBACQICACVMUQ8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUL2AAED1KwCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEoQEAAoYYp6IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHqBQQAql8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQgoAAQAlT1AMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVC8gAFD9CgAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRIEBABKmKIeCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB6AQGA6lcAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUICAAUMIU9UCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC1QsIAFS/AgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAQBAYASpqgHAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKheQACg+hUAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIlCAgAlDBFPRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA9QICANWvAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAKCEKeqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBKoXEACofgUAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAJAgIAJUxRDwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQvYAAQPUrAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEShAQAChhinogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeoFBACqXwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFCCgABACVPUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhULyAAUP0KACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBEgQEAEqYoh4IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHoBAYDqVwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJQgIABQwhT1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLVCwgAVL8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgBAEBgBKmqAcCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqF5AAKD6FQBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAiUICACUMEU9ECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgED1AgIA1a8AAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoQUAAoIQp6oEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEqhcQAKh+BQAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQAkCAgAlTFEPBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFC9gABA9SsAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRKEBAAKGGKeiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB6gUEAKpfAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUIKAAEAJU9QDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFQvIABQ/QoAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIESBAQASpiiHggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgegEBgOpXAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlCAgAFDCFPVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAtULCABUvwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAEAQGAEqaoBwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoXkAAoPoVAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECJQgIAJQwRT0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQPUCAgDVrwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEChBQACghCnqgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqFxAAqH4FABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBACQICACVMUQ8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUL2AAED1KwCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEoQEAAoYYp6IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHqBQQAql8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQgoAAQAlT1AMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVC8gAFD9CgAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRIEBABKmKIeCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB6AQGA6lcAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUICAAUMIU9UCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC1QsIAFS/AgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAQBAYASpqgHAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKheQACg+hUAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIlCAgAlDBFPRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA9QICANWvAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAKCEKeqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBKoXEACofgUAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAJAgIAJUxRDwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQvYAAQPUrAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEShAQAChhinogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeoFBACqXwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFCCgABACVPUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhULyAAUP0KACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBEgQEAEqYoh4IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHoBAYDqVwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJQgIABQwhT1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLVCwgAVL8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgBAEBgBKmqAcCBAgQIECAAAECmRVSxQAAIABJREFUBAgQIECAAAECBAgQIECAAAECBAgQqF5AAKD6FQBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAiUICACUMEU9ECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgED1AgIA1a8AAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoQUAAoIQp6oEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEqhcQAKh+BQAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQAkCAgAlTFEPBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFC9gABA9SsAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRKEBAAKGGKeiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB6gUEAKpfAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUIKAAEAJU9QDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFQvIABQ/QoAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIESBAQASpiiHggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgegEBgOpXAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlCAgAFDCFPVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAtULCABUvwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAEAQGAEqaoBwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoXkAAoPoVAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECJQgIAJQwRT0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQPUCAgDVrwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEChBQACghCnqgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqFxAAqH4FABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBACQICACVMUQ8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUL2AAED1KwCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEoQEAAoYYp6IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHqBQQAql8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQgoAAQAlT1AMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVC8gAFD9CgAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRIEBABKmKIeCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB6AQGA6lcAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUICAAUMIU9UCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC1QsIAFS/AgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAQBAYASpqgHAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKheQACg+hUAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIlCAgAlDBFPRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA9QICANWvAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAKCEKeqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBKoXEACofgUAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAJAgIAJUxRDwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQvYAAQPUrAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEShAQAChhinogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeoFBACqXwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFCCgABACVPUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhULyAAUP0KACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBEgQEAEqYoh4IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHoBAYDqVwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJQgIABQwhT1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLVCwgAVL8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgBAEBgBKmqAcCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqF5AAKD6FQBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAiUICACUMEU9ECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgED1AgIA1a8AAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoQUAAoIQp6oEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEqhcQAKh+BQAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQAkCAgAlTFEPBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFC9gABA9SsAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRKEBAAKGGKeiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB6gUEAKpfAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUIKAAEAJU9QDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFQvIABQ/QoAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIESBAQASpiiHggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgegEBgOpXAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlCAgAFDCFPVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAtULCABUvwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAEAQGAEqaoBwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoXkAAoPoVAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECJQgIAJQwRT0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQPUCAgDVrwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEChBQACghCnqgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqFxAAqH4FABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBACQICACVMUQ8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUL2AAED1KwCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEoQEAAoYYp6IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHqBQQAql8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQgoAAQAlT1AMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVC8gAFD9CgAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRIEBABKmKIeCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB6AQGA6lcAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUICAAUMIU9UCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC1QsIAFS/AgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAQBAYASpqgHAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKheQACg+hUAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIlCAgAlDBFPRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA9QICANWvAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAKCEKeqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBKoXEACofgUAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAJAgIAJUxRDwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQvYAAQPUrAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEShAQAChhinogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeoFBACqXwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFCCgABACVPUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhULyAAUP0KACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBEgQEAEqYoh4IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHoBAYDqVwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJQgIABQwhT1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLVCwgAVL8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgBAEBgBKmqAcCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqF5AAKD6FQBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAiUICACUMEU9ECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgED1AgIA1a8AAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoQUAAoIQp6oEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEqhcQAKh+BQAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQAkCAgAlTFEPBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFC9gABA9SsAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRKEBAAKGGKeiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB6gUEAKpfAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUIKAAEAJU9QDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFQvIABQ/QoAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIESBAQASpiiHggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgegEBgOpXAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlCAgAFDCFPVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAtULCABUvwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAEAQGAEqaoBwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoXkAAoPoVAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECJQgIAJQwRT0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQPUCAgDVrwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEChBQACghCnqgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqFxAAqH4FABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBACQICACVMUQ8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUL2AAED1KwCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEoQEAAoYYp6IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHqBQQAql8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQgoAAQAlT1AMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVC8gAFD9CgAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRIEBABKmKIeCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB6AQGA6lcAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUICAAUMIU9UCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC1QsIAFS/AgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAQBAYASpqgHAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKheQACg+hUAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIlCAgAlDBFPRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA9QICANWvAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAKCEKeqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBKoXEACofgUAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAJAgIAJUxRDwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQvYAAQPUrAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEShAQAChhinogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeoFBACqXwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFCCgABACVPUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhULyAAUP0KACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBEgQEAEqYoh4IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHoBAYDqVwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJQgIABQwhT1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLVCwgAVL8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgBAEBgBKmqAcCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqF5AAKD6FQBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAiUICACUMEU9ECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgED1AgIA1a8AAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoQUAAoIQp6oEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEqhcQAKh+BQAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQAkCAgAlTFEPBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFC9gABA9SsAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRKEBAAKGGKeiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB6gUEAKpfAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUIKAAEAJU9QDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFQvIABQ/QoAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIESBAQASpiiHggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgegEBgOpXAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlCAgAFDCFPVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAtULCABUvwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAEAQGAEqaoBwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoXkAAoPoVAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECJQgIAJQwRT0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQPUCAgDVrwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEChBQACghCnqgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqFxAAqH4FABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBACQICACVMUQ8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUL2AAED1KwCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEoQEAAoYYp6IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHqBQQAql8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQgoAAQAlT1AMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVC8gAFD9CgAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRIEBABKmKIeCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB6AQGA6lcAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUICAAUMIU9UCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC1QsIAFS/AgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAQBAYASpqgHAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKheQACg+hUAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIlCAgAlDBFPRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA9QICANWvAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAKCEKeqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBKoXEACofgUAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAJAgIAJUxRDwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQvYAAQPUrAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEShAQAChhinogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeoFBACqXwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFCCgABACVPUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhULyAAUP0KACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBEgQEAEqYoh4IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHoBAYDqVwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJQgIABQwhT1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLVCwgAVL8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgBAEBgBKmqAcCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqF5AAKD6FQBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAiUICACUMEU9ECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgED1AgIA1a8AAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoQUAAoIQp6oEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEqhcQAKh+BQAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQAkCAgAlTFEPBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFC9gABA9SsAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRKEBAAKGGKeiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB6gUEAKpfAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUIKAAEAJU9QDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFQvIABQ/QoAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIESBAQASpiiHggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgegEBgOpXAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlCAgAFDCFPVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECD29ma4AAAgAElEQVRAgAABAtULCABUvwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAEAQGAEqaoBwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoXkAAoPoVAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECJQgIAJQwRT0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQPUCAgDVrwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEChBQACghCnqgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqFxAAqH4FABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBACQICACVMUQ8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUL2AAED1KwCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEoQEAAoYYp6IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHqBQQAql8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQgoAAQAlT1AMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVC8gAFD9CgAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRIEBABKmKIeCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB6AQGA6lcAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUICAAUMIU9UCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC1QsIAFS/AgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAQBAYASpqgHAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKheQACg+hUAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIlCAgAlDBFPRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA9QICANWvAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKEFAAKCEKeqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBKoXEACofgUAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAJAgIAJUxRDwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQvYAAQPUrAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEShAQAChhinogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeoFBACqXwEABAgQIECAAAECBAgQIECAAAECBAgQIECAwP9n716g7brv+sB/9zn3aUm2nolpiOMkTmTLiUmsQEKBiRsCmaEwrA6FWSmFTgulKTAlrEKHFpiBMoXpNDAUStfMrEIpzLTDwJQChQBJbOXtkCiJX7Jsy5IsP2TZkmXpSrrPs/esfSUnli3pnnNfunfvz1nLK461X7/P73e11v3v3/n/CBAgQIAAgSYIaABoQhbFQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKtF9AA0PoSAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECTRDQANCELIqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBFovoAGg9SUAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSaIKABoAlZFAMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQItF5AA0DrSwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRBQANAE7IoBgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBovYAGgNaXAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaIKABoAmZFEMBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINB6AQ0ArS8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQBAENAE3IohgIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoPUCGgBaXwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAJAhoAmpBFMRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA6wU0ALS+BAAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQBMENAA0IYtiIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHWC2gAaH0JACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBJghoAGhCFsVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAq0X0ADQ+hIAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJNENAA0IQsioEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEWi+gAaD1JQCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJogoAGgCVkUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAi0XkADQOtLAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEFAA0ATsigGAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGi9gAaA1pcAAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBogoAGgCZkUQwECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0HoBDQCtLwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINAEAQ0ATciiGAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECg9QIaAFpfAgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAkCGgCakEUxECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDrBTQAtL4EABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAEwQ0ADQhi2IgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdYLaABofQkAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIEmCGgAaEIWxUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECrRfQAND6EgBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAk0Q0ADQhCyKgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRaL6ABoPUlAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEmiCgAaAJWRQDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECLReQANA60sAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAg0QUADQBOyKAYCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaL2ABoDWlwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGiCgAaAJmRRDAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQegENAK0vAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0AQBDQBNyKIYCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKD1AhoAWl8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgCQIaAJqQRTEQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQOsFNAC0vgQAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEATBDQANCGLYiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB1gtoAGh9CQAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSYIaABoQhbFQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKtF9AA0PoSAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECTRDQANCELIqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBFovoAGg9SUAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSaIKABoAlZFAMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQItF5AA0DrSwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRBQANAE7IoBgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBovYAGgNaXAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaIKABoAmZFEMBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINB6AQ0ArS8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQBAENAE3IohgIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoPUCGgBaXwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAJAhoAmpBFMRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA6wU0ALS+BAAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQBMENAA0IYtiIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHWC2gAaH0JACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBJghoAGhCFsVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAq0X0ADQ+hIAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJNENAA0IQsioEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEWi+gAaD1JQCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJogoAGgCVkUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAi0XkADQOtLAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEFAA0ATsigGAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGi9gAaA1pcAAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBogoAGgCZkUQwECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0HoBDQCtLwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINAEAQ0ATciiGAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECg9QIaAFpfAgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAkCGgCakEUxECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDrBTQAtL4EABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAEwQ0ADQhi2IgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdYLaABofQkAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIEmCGgAaEIWxUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECrRfQAND6EgBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAk0Q0ADQhCyKgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRaL6ABoPUlAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEmiCgAaAJWRQDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECLReQANA60sAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAg0QUADQBOyKAYCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaL2ABoDWlwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGiCgAaAJmRRDAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQegENAK0vAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0AQBDQBNyKIYCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKD1AhoAWl8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgCQIaAJqQRTEQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQOsFNAC0vgQAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEATBDQANCGLYiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB1gtoAGh9CQAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSYIaABoQhbFQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKtF9AA0PoSAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECTRDQANCELIqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBFovoAGg9SUAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSaIKABoAlZFAMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQItF5AA0DrSwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRBQANAE7IoBgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBovYAGgNaXAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaIKABoAmZFEMBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINB6AQ0ArS8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQBAENAE3IohgIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoPUCGgBaXwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAJAhoAmpBFMRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA6wU0ALS+BAAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQBMENAA0IYtiIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHWC2gAaH0JACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBJghoAGhCFsVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAq0X0ADQ+hIAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJNENAA0IQsioEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEWi+gAaD1JQCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJogoAGgCVkUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAi0XkADQOtLAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEFAA0ATsigGAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGi9gAaA1pcAAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBogoAGgCZkUQwECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0HoBDQCtLwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINAEAQ0ATciiGAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECg9QIaAFpfAgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAkCGgCakEUxECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDrBTQAtL4EABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAEwQ0ADQhi2IgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdYLaABofQkAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIEmCGgAaEIWxUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECrRfQAND6EgBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAk0Q0ADQhCyKgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRaL6ABoPUlAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEmiCgAaAJWRQDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECLReQANA60sAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAg0QUADQBOyKAYCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaL2ABoDWlwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGiCgAaAJmRRDAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQegENAK0vAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0AQBDQBNyKIYCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKD1AhoAWl8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgCQIaAJqQRTEQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQOsFNAC0vgQAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEATBDQANCGLYiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB1gtoAGh9CQAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSYIaABoQhbFQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKtF9AA0PoSAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECTRDQANCELIqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBFovoAGg9SUAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSaIKABoAlZFAMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQItF5AA0DrSwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRBQANAE7IoBgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBovYAGgNaXAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaIKABoAmZFEMBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINB6AQ0ArS8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQBAENAE3IohgIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoPUCGgBaXwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAJAhoAmpBFMRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA6wU0ALS+BAAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQBMENAA0IYtiIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHWC2gAaH0JACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBJghoAGhCFsVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAq0X0ADQ+hIAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJNENAA0IQsioEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEWi+gAaD1JQCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJogoAGgCVkUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAi0XkADQOtLAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEFAA0ATsigGAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGi9gAaA1pcAAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBogoAGgCZkUQwECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0HoBDQCtLwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINAEAQ0ATciiGAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECg9QIaAFpfAgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAkCGgCakEUxECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDrBTQAtL4EABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAEwQ0ADQhi2IgQIAAAbxAifgAACAASURBVAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdYLaABofQkAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIEmCGgAaEIWxUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECrRfQAND6EgBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAk0Q0ADQhCyKgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRaL6ABoPUlAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEmiCgAaAJWRQDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECLReQANA60sAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAg0QUADQBOyKAYCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaL2ABoDWlwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGiCgAaAJmRRDAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQegENAK0vAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0AQBDQBNyKIYCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKD1AhoAWl8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgCQIaAJqQRTEQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQOsFNAC0vgQAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEATBDQANCGLYiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB1gtoAGh9CQAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSYIaABoQhbFQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKtF9AA0PoSAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECTRDQANCELIqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBFovoAGg9SUAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSaIKABoAlZFAMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQItF5AA0DrSwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRBQANAE7IoBgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBovYAGgNaXAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaIKABoAmZFEMBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINB6AQ0ArS8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQBAENAE3IohgIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoPUCGgBaXwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAJAhoAmpBFMRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA6wU0ALS+BAAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQBMENAA0IYtiIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHWC2gAaH0JACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBJghoAGhCFsVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAq0X0ADQ+hIAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJNENAA0IQsioEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEWi+gAaD1JQCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJogoAGgCVkUAwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAi0XkADQOtLAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEFAA0ATsigGAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGi9gAaA1pcAAAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBogoAGgCZkUQwECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0HoBDQCtLwEABAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINAEAQ0ATciiGAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECg9QIaAFpfAgAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAkCGgCakEUxECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDrBTQAtL4EABAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAEwQ0ADQhi2IgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdYLaABofQkAIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIEmCGgAaEIWxUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECrRfQAND6EgBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAk0Q0ADQhCyKgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRaL6ABoPUlAIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEmiCgAaAJWRQDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECLReQANA60sAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAg0QUADQBOyKAYCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaL2ABoDWlwAAAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEGiCgAaAJmRRDAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQegENAK0vAQAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0AQBDQBNyKIYCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKD1AhoAWl8CAAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgCQIaAJqQRTEQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQOsFNAC0vgQAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEATBDQANCGLYiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB1gtoAGh9CQAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSYIaABoQhbFQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKtF9AA0PoSAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECTRDQANCELIqBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBFovoAGg9SUAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSaIKABoAlZFAMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQItF5AA0DrSwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRBQANAE7IoBgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBovYAGgNaXAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaIKABoAmZFEMBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINB6AQ0ArS8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQBAENAE3IohgIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoPUCGgBaXwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAJAhoAmpBFMRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA6wU0ALS+BAAQ6Eug/rui2JVdQzOZKUYyUu3Lvrkk1YV/+rqIgwgQIECAAAECBAgQIECAAIF1JWA9YF2ly8MSIECAAAECBAgQSDQAqAICBK4kUOzO7qHZPL9lKBt2djLzVVU6O5LyVNXNw1UvJ4aTE1OZfX5reqf35PBMkhIpAQIECBAgQIAAAQIECBAgsK4FrAes6/R5eAIECBAgQIAAgTYLaABoc/bFTuDKAp3bctv4aGbelqLzj8tU7yyS0XongAun1S/6z1VVTqUoJopUjxdFsbdXlJ8aGc59s1MbntmbvVMaApQZAQIECBAgQIAAAQIECBBYVwLWA9ZVujwsAQIECBAgQIAAgYsFNACoCAIELiVQ3JbbrhntzrynqopfS5XrB2CqGwOeTzpfqKq5PyzSuXMi5WMP5aGzmgEGUHQoAQIECBAgQIAAAQIECBBYfQHrAatv7o4ECBAgQIAAAQIEllVAA8CycroYgWYI3JSbRjdn+BurIr9VJNuWEFWVZLJI7i2r6vc66fzpdIYO35t7JzUDLEHVqQQIECBAYPUFzP9dfXN3JECAAAECqy5gPWDVyd2QAAECBAgQIECAwLILaABYdlIXJLDuBTrvyBt2zhVDv59k5zJHczbp3J0qv1WMT911dnL02L7sm01SNwr4ECBAgAABAmtPwPzftZcTT0SAAAECBFZKwHrASsm6LgECBAgQIECAAIFVFNAAsIrYbkVgPQjszM5NmzrdD6SqfmAFn7dKkaeTzu9UZfnbyTX792ZvvSuARoAVRHdpAgQIECAwoID5vwOCOZwAAQIECKxnAesB6zl7np0AAQIECBAgQIDAlwU0AKgGAgReLNC5Pbd9XaeY/WCSDatEc66q8mdJ+auT6X52X/adMx5gleTdhgABAgQIXF7A/F/VQYAAAQIE2iVgPaBd+RYtAQIECBAgQIBAgwU0ADQ4uUIjMKjA7uy+pts592/KKu8d9NxlOH4myYfKavifFxnea0eAZRB1CQIECBAgsEgB838XCec0AgQIECCwTgWsB6zTxHlsAgQIECBAgAABApcQ0ACgLAgQeEGguH1k55s7s52PJ7n2arFUyVSnyO+kLP5FmfGH92bvnNEAVysb7kuAAAECLRUw/7eliRc2AQIECLRWwHpAa1MvcAIECBAgQIAAgSYKaABoYlbFRGARAruzeziZ+omiKP/pIk5f9lOK5ERZFb84nc5v3J/7nzUWYNmJXZAAAQIECFxSwPxfhUGAAAECBNolYD2gXfkWLQECBAgQIECAQPMFNAA0P8ciJNCXwO68cXuK7keK5La+Tlidg6okX0jV/YnhPP+JT+eJKbsBrA68uxAgQIBAawXM/21t6gVOgAABAm0VsB7Q1syLmwABAgQIECBAoKkCGgCamllxERhMoLg9t7y9U2RPktHBTl2VoyeLovjXI2O9X/rkuYeethvAqpi7CQECBAi0UMD83xYmXcgECBAg0HYB6wFtrwDxEyBAgAABAgQINE5AA0DjUnrVA3qhpord2d09lVOd63Kuuykj5US2deqnG8mx6tmMlXOZK27MjXM7sqP63fxu6ZvdVzV33d25+ceLoviFq/oUV775/G4AvSo/Op3i7n3ZN7OGn9WjESBAgACB9Shg/u96zJpnJkCAwNoRsB6wdnIxyJNYDxhEy7EECBAgQIAAAQIE1oGABoB1kKQ1/oh1DRW7smuol97oxrHulu5U+aqy231N1ctrik7vVUlnS8qMVymGipS9TifTZcpz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YpsiQIAAAQIECBAgQIAAAQIECBAgQIAAAQJrAQHA+gL2CewFBAD7G/gBgSsBAcCVrHcJECBAgAABAgQIECBAgAABAgQIECBAgMCHAgKAD4/iSwRiAQFADG6OQCggAAixTREgQIAAAQIECBAgQIAAAQIECBAgQIAAgbWAAGB9AfsE9gICgP0N/IDAlYAA4ErWuwQIECBAgAABAgQIECBAgAABAgQIECBA4EMBAcCHR/ElArGAACAGN0cgFBAAhNimCBAgQIAAAQIECBAgQIAAAQIECBAgQIDAWkAAsL6AfQJ7AQHA/gZ+QOBKQABwJetdAgQIECBAgAABAgQIECBAgAABAgQIECDwoYAA4MOj+BKBWEAAEIObIxAKCABCbFMECBAgQIAAAQIECBAgQIAAAQIECBAgQGAtIABYX8A+gb2AAGB/Az8gcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIEPhQQADw4VF8iUAsIACIwc0RCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIEEjPPXMAABI8SURBVCBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIHAlIAC4kvUuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAIBQQAIbYpAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBwJSAAuJL1LgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQCAUEACG2KQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgcCUgALiS9S4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEAgFBAAhtikCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHXrh3TAAAAIAzz7xoV46oBSHqPAAECBAhUAgKAStYuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBA4CggAjtiuCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAJSAAqGTtEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBo4AA4IjtigABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVAICgErWLgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQOAoIAI7YrggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQCUgAKhk7RIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgaOAAOCI7YoAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFQCAoBK1i4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEDgKCACO2K4IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAlIACoZO0SIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGjgADgiO2KAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhUAgKAStYuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBA4CggAjtiuCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAJSAAqGTtEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBo4AA4IjtigABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVAICgErWLgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQOAoIAI7YrggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQCUgAKhk7RIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgaOAAOCI7YoAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFQCAoBK1i4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEDgKCACO2K4IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAlIACoZO0SIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGjgADgiO2KAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhUAgKAStYuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBA4CggAjtiuCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAJSAAqGTtEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBo4AA4IjtigABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVAICgErWLgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQOAoMG+nSb0GX3O4AAAAASUVORK5CYII="
};
</script>
<script>
"use strict";!function(){let p=!0;"pass"!==(new class{#p="pass";getProp(){return this.#p}}).getProp()&&(p=!1),p&&(window["C3_ModernJSSupport_OK"]=!0)}();
</script>
<script>
"use strict";!function(){var e={"en-US":{"title":"Software update needed","message":"This content is not supported because your device's software appears to be out-of-date.","android-tip":"On Android, fix this by making sure the [a1]Android System Webview[/a1] app has updates enabled and is up-to-date.","ios-tip":"Alternatively if [b]Lockdown mode[/b] is enabled, try turning it off to view this content.","general-tip":"Try installing any available software updates. Alternatively try on a different device."},"es-ES":{"title":"Actualización de software necesaria","message":"Este contenido no es compatible porque el software de tu dispositivo parece no estar actualizado.","android-tip":"En Android, para solucionarlo, asegúrate de que la aplicación [a1]Android System Webview[/a1] tiene las actualizaciones activadas y está al día.","ios-tip":"Alternativamente, si el [b]Modo de bloqueo[/b] está activado, intenta desactivarlo para ver este contenido.","general-tip":"Intenta instalar las actualizaciones de software disponibles. También puedes probar con otro dispositivo."},"hr-HR":{"title":"Potrebno ažuriranje softvera","message":"Ovaj sadržaj nije podržan jer softver vašeg uređaja zastario.","android-tip":"Na Androidu, popravite to na način da provjerite ima li [a1]Android System Webview[/a1] aplikacija uključena ažuriranja i je ažurna.","ios-tip":"Alternativno ako je uključen [b]Lockdown mod[/b], pokušajte ga ugasiti kako bi vidjeli ovaj sadržaj.","general-tip":"Pokušajte instalirati dostupna softverska ažuriranja. Alternativno, probajte na drugom uređaju."},"pt-BR":{"title":"Atualização de software necessária","message":"Esse conteúdo não é suportado porque o software do seu dispositivo parece estar desatualizado.","android-tip":"No Android, é possível consertar esse erro certificando-se de que o aplicativo [a1]Android System Webview[/a1] tem atualizações habilitadas e está na versão mais recente.","ios-tip":"De outro modo, se o [b]Modo Lockdown[/b] está ativo, tente desligá-lo para poder ver o conteúdo.","general-tip":"Tente instalar qualquer atualização de software disponível. De outro modo, tente em um dispositivo diferente."},"zh-CN":{"title":"软件需要更新","message":"由于您设备上的软件版本过低，暂时无法运行此内容。","android-tip":"在安卓系统上，要解决这个问题，请确保 [a1]Android System Webview[/a1] 应用程序已启用自动更新并处于最新状态。","ios-tip":"如果您的设备处于[b]锁定模式[/b]，请在系统设置 - 隐私与安全性，关闭锁定模式再次尝试。","general-tip":"请尝试更新系统版本，或者更换另一台设备运行。"},"zh-TW":{"title":"軟體需要更新","message":"由於您的裝置軟體似乎已過時，因此不支援此內容。","android-tip":"在 Android 上，要解決此問題，請確保 [a1]Android System Webview[/a1] 已啟用更新並且是最新版本。","ios-tip":"另外，如果您的裝置已啟用 [b]封鎖模式[/b]，請嘗試關閉以檢視此內容。","general-tip":"嘗試更新軟體，或者嘗試在不同的裝置上執行。"}},a=navigator.languages||[navigator.language],t=function(a){var t=a.toLowerCase();for(var i in e){var o=i.toLowerCase();if(t.startsWith(o))return e[i];var n=t.split("-"),r=o.split("-");if(n[0]===r[0]&&"zh"!==n[0])return e[i]}return null},i=null;for(var o of a)if(i=t(o))break;i||(i=e["en-US"]);var n=function(e,a){var t=i[e];return t=(t=t.replace("[b]","<strong>")).replace("[/b]","</strong>"),a&&(t=(t=t.replace("[a1]",'<a href="'+a+'">')).replace("[/a1]","</a>")),t},r=[];if(!!document.createElement("canvas").getContext("webgl")||r.push("WebGL"),"undefined"==typeof WebAssembly&&r.push("WebAssembly"),window["Intl"]&&window["Intl"]["Segmenter"]||r.push("Internationalization support (Intl.Segmenter)"),window["C3_ModernJSSupport_OK"]||r.push("Modern JavaScript support"),0===r.length)window["C3_IsSupported"]=!0;else{var s=document.createElement("div");s.id="notSupportedWrap",document.body.appendChild(s);var d=document.createElement("h2");d.id="notSupportedTitle",d.textContent=n("title"),s.appendChild(d);var p=document.createElement("p");p.className="notSupportedMessage";var l=n("message"),u=navigator.userAgent;/android/i.test(u)?l+="<br><br>"+n("android-tip","https://play.google.com/store/apps/details?id=com.google.android.webview"):/iphone|ipad|ipod/i.test(u)?l+=" "+n("ios-tip"):l+=" "+n("general-tip"),l+="<br><br><em>Missing features: "+r.join(", ")+"<br>User agent: "+navigator.userAgent+"</em>",p.innerHTML=l,s.appendChild(p),document.addEventListener("deviceready",(()=>{navigator["splashscreen"]&&navigator["splashscreen"]["hide"]&&navigator["splashscreen"]["hide"]()}))}}();
</script>
<script>
// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

// workers/domHandler.js
"use strict";window.DOMHandler=class{constructor(t,i){this._iRuntime=t,this._componentId=i,this._hasTickCallback=!1,this._tickCallback=()=>this.Tick()}Attach(){}PostToRuntime(t,i,e,s){this._iRuntime.PostToRuntimeComponent(this._componentId,t,i,e,s)}PostToRuntimeAsync(t,i,e,s){return this._iRuntime.PostToRuntimeComponentAsync(this._componentId,t,i,e,s)}_PostToRuntimeMaybeSync(t,i,e){this._iRuntime.UsesWorker()?this.PostToRuntime(t,i,e):this._iRuntime._GetLocalRuntime()["_OnMessageFromDOM"]({"type":"event","component":this._componentId,"handler":t,"dispatchOpts":e||null,"data":i,"responseId":null})}AddRuntimeMessageHandler(t,i){this._iRuntime.AddRuntimeComponentMessageHandler(this._componentId,t,i)}AddRuntimeMessageHandlers(t){for(const[i,e]of t)this.AddRuntimeMessageHandler(i,e)}GetRuntimeInterface(){return this._iRuntime}GetComponentID(){return this._componentId}_StartTicking(){this._hasTickCallback||(this._iRuntime._AddRAFCallback(this._tickCallback),this._hasTickCallback=!0)}_StopTicking(){this._hasTickCallback&&(this._iRuntime._RemoveRAFCallback(this._tickCallback),this._hasTickCallback=!1)}Tick(){}},window.RateLimiter=class{constructor(t,i){this._callback=t,this._interval=i,this._timerId=-1,this._lastCallTime=-1/0,this._timerCallFunc=()=>this._OnTimer(),this._ignoreReset=!1,this._canRunImmediate=!1}SetCanRunImmediate(t){this._canRunImmediate=!!t}Call(){if(-1!==this._timerId)return;const t=Date.now(),i=t-this._lastCallTime,e=this._interval;i>=e&&this._canRunImmediate?(this._lastCallTime=t,this._RunCallback()):this._timerId=self.setTimeout(this._timerCallFunc,Math.max(e-i,4))}_RunCallback(){this._ignoreReset=!0,this._callback(),this._ignoreReset=!1}Reset(){this._ignoreReset||(this._CancelTimer(),this._lastCallTime=Date.now())}_OnTimer(){this._timerId=-1,this._lastCallTime=Date.now(),this._RunCallback()}_CancelTimer(){-1!==this._timerId&&(self.clearTimeout(this._timerId),this._timerId=-1)}Release(){this._CancelTimer(),this._callback=null,this._timerCallFunc=null}};

// workers/domElementHandler.js
"use strict";{class e{constructor(e){this._elem=e,this._hadFirstUpdate=!1,this._isVisibleFlag=!0,this._wantHtmlIndex=-1,this._actualHtmlIndex=-1,this._htmlZIndex=-1}SetVisibleFlag(e){this._isVisibleFlag=!!e}GetVisibleFlag(){return this._isVisibleFlag}HadFirstUpdate(){return this._hadFirstUpdate}SetHadFirstUpdate(){this._hadFirstUpdate=!0}GetWantHTMLIndex(){return this._wantHtmlIndex}SetWantHTMLIndex(e){this._wantHtmlIndex=e}GetActualHTMLIndex(){return this._actualHtmlIndex}SetActualHTMLIndex(e){this._actualHtmlIndex=e}SetHTMLZIndex(e){this._htmlZIndex=e}GetHTMLZIndex(){return this._htmlZIndex}GetElement(){return this._elem}}window.DOMElementHandler=class extends self.DOMHandler{constructor(e,t){super(e,t),this._elementMap=new Map,this._autoAttach=!0,this.AddRuntimeMessageHandlers([["create",e=>this._OnCreate(e)],["destroy",e=>this._OnDestroy(e)],["set-visible",e=>this._OnSetVisible(e)],["update-position",e=>this._OnUpdatePosition(e)],["update-state",e=>this._OnUpdateState(e)],["focus",e=>this._OnSetFocus(e)],["set-css-style",e=>this._OnSetCssStyle(e)],["set-attribute",e=>this._OnSetAttribute(e)],["remove-attribute",e=>this._OnRemoveAttribute(e)]]),this.AddDOMElementMessageHandler("get-element",(e=>e))}SetAutoAttach(e){this._autoAttach=!!e}AddDOMElementMessageHandler(e,t){this.AddRuntimeMessageHandler(e,(e=>{const n=e["elementId"],s=this.GetElementById(n);return t(s,e)}))}AddDOMElementMessageHandlers(e){for(const[t,n]of e)this.AddDOMElementMessageHandler(t,n)}_OnCreate(t){const n=t["elementId"],s=this.CreateElement(n,t),i=new e(s);this._elementMap.set(n,i),s.style.boxSizing="border-box",s.style.display="none",i.SetVisibleFlag(t["isVisible"]);const l=this._GetFocusElement(s);l.addEventListener("focus",(e=>this._OnFocus(n))),l.addEventListener("blur",(e=>this._OnBlur(n)));const a=t["htmlIndex"];if(i.SetWantHTMLIndex(a),i.SetHTMLZIndex(t["htmlZIndex"]),this._autoAttach){const e=this.GetRuntimeInterface().GetAvailableHTMLIndex(a);i.SetActualHTMLIndex(e);this.GetRuntimeInterface().GetHTMLWrapElement(e).appendChild(s)}}CreateElement(e,t){throw new Error("required override")}DestroyElement(e){}_OnDestroy(e){const t=e["elementId"],n=this.GetElementById(t);this.DestroyElement(n),this._autoAttach&&n.parentElement.removeChild(n),this._elementMap.delete(t)}PostToRuntimeElement(e,t,n){n||(n={}),n["elementId"]=t,this.PostToRuntime(e,n)}_PostToRuntimeElementMaybeSync(e,t,n){n||(n={}),n["elementId"]=t,this._PostToRuntimeMaybeSync(e,n)}_OnSetVisible(e){if(!this._autoAttach)return;const t=this._elementMap.get(e["elementId"]),n=t.GetElement();t.HadFirstUpdate()?n.style.display=e["isVisible"]?"":"none":t.SetVisibleFlag(e["isVisible"])}_OnUpdatePosition(e){if(!this._autoAttach)return;const t=this._elementMap.get(e["elementId"]),n=t.GetElement(),s=this.GetRuntimeInterface();n.style.left=e["left"]+"px",n.style.top=e["top"]+"px",n.style.width=e["width"]+"px",n.style.height=e["height"]+"px";const i=e["fontSize"];null!==i&&(n.style.fontSize=i+"em");const l=e["htmlIndex"];t.SetWantHTMLIndex(l);const a=s.GetAvailableHTMLIndex(l);if(a!==t.GetActualHTMLIndex()){n.remove();s.GetHTMLWrapElement(a).appendChild(n),t.SetActualHTMLIndex(a),s._UpdateHTMLElementsZOrder()}const d=e["htmlZIndex"];d!==t.GetHTMLZIndex()&&(t.SetHTMLZIndex(d),s._UpdateHTMLElementsZOrder()),t.HadFirstUpdate()||(t.SetHadFirstUpdate(),t.GetVisibleFlag()&&(n.style.display=""))}_OnHTMLLayersChanged(){if(this._autoAttach)for(const e of this._elementMap.values()){const t=this.GetRuntimeInterface().GetAvailableHTMLIndex(e.GetWantHTMLIndex()),n=e.GetActualHTMLIndex();if(-1!==t&&-1!==n&&t!==n){const n=e.GetElement();n.remove();this.GetRuntimeInterface().GetHTMLWrapElement(t).appendChild(n),e.SetActualHTMLIndex(t)}}}_GetAllElementStatesForZOrderUpdate(){return this._autoAttach?[...this._elementMap.values()]:null}_OnUpdateState(e){const t=this.GetElementById(e["elementId"]);this.UpdateState(t,e)}UpdateState(e,t){throw new Error("required override")}_GetFocusElement(e){return e}_OnFocus(e){this.PostToRuntimeElement("elem-focused",e)}_OnBlur(e){this.PostToRuntimeElement("elem-blurred",e)}_OnSetFocus(e){const t=this._GetFocusElement(this.GetElementById(e["elementId"]));e["focus"]?t.focus():t.blur()}_OnSetCssStyle(e){const t=this.GetElementById(e["elementId"]),n=e["prop"],s=e["val"];n.startsWith("--")?t.style.setProperty(n,s):t.style[n]=s}_OnSetAttribute(e){this.GetElementById(e["elementId"]).setAttribute(e["name"],e["val"])}_OnRemoveAttribute(e){this.GetElementById(e["elementId"]).removeAttribute(e["name"])}GetElementById(e){const t=this._elementMap.get(e);if(!t)throw new Error(`no element with id ${e}`);return t.GetElement()}}}

// workers/domSide.js
"use strict";{const e=/(iphone|ipod|ipad|macos|macintosh|mac os x)/i.test(navigator.userAgent),t=/android/i.test(navigator.userAgent),s=/safari/i.test(navigator.userAgent)&&!/(chrome|chromium|edg\/|OPR\/|nwjs)/i.test(navigator.userAgent);let r=0;function n(e){const t=document.createElement("script");return t.async=!1,t.type="module",e.isStringSrc?new Promise((s=>{const n="c3_resolve_"+r;++r,self[n]=s,t.textContent=e.str+`\n\nself["${n}"]();`,document.head.appendChild(t)})):new Promise(((s,r)=>{t.onload=s,t.onerror=r,t.src=e,document.head.appendChild(t)}))}async function i(){if(!navigator["userActivation"]||"undefined"==typeof OffscreenCanvas)return!1;try{let e=!1;const t=new Blob(['\n\tself.addEventListener("message", () =>\n\t{\n\t\ttry {\n\t\t\tconst offscreenCanvas = new OffscreenCanvas(32, 32);\n\t\t\tconst gl = offscreenCanvas.getContext("webgl");\n\t\t\tself.postMessage(!!gl);\n\t\t}\n\t\tcatch (err)\n\t\t{\n\t\t\tconsole.warn("Feature detection worker error:", err);\n\t\t\tself.postMessage(false);\n\t\t}\n\t});'],{"type":"text/javascript"}),s=new Worker(URL.createObjectURL(t),{get type(){e=!0}}),r=await new Promise((e=>{s.addEventListener("message",(t=>{s.terminate(),e(t.data)})),s.postMessage("")}));return e&&r}catch(e){return console.warn("Error feature detecting worker mode: ",e),!1}}let a=new Audio;const o={"audio/webm; codecs=opus":!!a.canPlayType("audio/webm; codecs=opus"),"audio/ogg; codecs=opus":!!a.canPlayType("audio/ogg; codecs=opus"),"audio/webm; codecs=vorbis":!!a.canPlayType("audio/webm; codecs=vorbis"),"audio/ogg; codecs=vorbis":!!a.canPlayType("audio/ogg; codecs=vorbis"),"audio/mp4":!!a.canPlayType("audio/mp4"),"audio/mpeg":!!a.canPlayType("audio/mpeg")};async function l(e){const t=await c(e);return new TextDecoder("utf-8").decode(t)}function c(e){return new Promise(((t,s)=>{const r=new FileReader;r.onload=e=>t(e.target.result),r.onerror=e=>s(e),r.readAsArrayBuffer(e)}))}a=null;const d=[];let h=0;const p=8;window["RealFile"]=window["File"];const m=[],u=new Map,_=new Map;let w=0;const y=[];self.runOnStartup=function(e){if("function"!=typeof e)throw new Error("runOnStartup called without a function");y.push(e)};const f=new Set(["cordova","playable-ad-single-file","playable-ad-zip","instant-games"]);function g(e){return f.has(e)}let v=!1;window.RuntimeInterface=class r{constructor(e){if(this._useWorker=e.useWorker,this._messageChannelPort=null,this._runtimeBaseUrl="",this._scriptFolder=e.scriptFolder,this._worker=null,this._localRuntime=null,this._domHandlers=[],this._runtimeDomHandler=null,this._isFirstSizeUpdate=!0,this._canvasLayers=[],this._pendingRemoveElements=[],this._pendingUpdateHTMLZOrder=!1,this._updateHTMLZOrderRAFCallback=()=>this._DoUpdateHTMLElementsZOrder(),this._isExportingToVideo=!1,this._exportToVideoDuration=0,this._jobScheduler=null,this._rafId=-1,this._rafFunc=()=>this._OnRAFCallback(),this._rafCallbacks=new Set,this._wrapperInitResolve=null,this._wrapperComponentIds=[],this._exportType=e.exportType,this._isFileProtocol="file"===location.protocol.substr(0,4),this._directoryHandles=[],"playable-ad-single-file"!==this._exportType&&"playable-ad-zip"!==this._exportType&&"instant-games"!==this._exportType||(this._useWorker=!1),s&&(this._useWorker=!1),"cordova"===this._exportType&&this._useWorker&&t){const e=/Chrome\/(\d+)/i.exec(navigator.userAgent);e&&parseInt(e[1],10)>=90||(this._useWorker=!1)}this.IsAnyWebView2Wrapper()?self["chrome"]["webview"].addEventListener("message",(e=>this._OnWrapperMessage(e.data,e["additionalObjects"]))):"macos-wkwebview"===this._exportType?self["C3WrapperOnMessage"]=e=>this._OnWrapperMessage(JSON.parse(e)):"linux-cef"===this._exportType&&self["c3_linux_cef_set_message_callback"]((e=>this._OnWrapperMessage(JSON.parse(e)))),this._localFileBlobs=null,this._localFileStrings=null,"html5"!==this._exportType||window.isSecureContext||console.warn("[Construct] Warning: the browser indicates this is not a secure context. Some features may be unavailable. Use secure (HTTPS) hosting to ensure all features are available."),this.AddRuntimeComponentMessageHandler("canvas","update-size",(e=>this._OnUpdateCanvasSize(e))),this.AddRuntimeComponentMessageHandler("canvas","set-html-layer-count",(e=>this["_OnSetHTMLLayerCount"](e))),this.AddRuntimeComponentMessageHandler("canvas","cleanup-html-layers",(()=>this._OnCleanUpHTMLLayers())),this.AddRuntimeComponentMessageHandler("canvas","update-html-layer-dom-state",(e=>this._UpdateHTMLLayerDOMProperties(e["layersDomState"]))),this.AddRuntimeComponentMessageHandler("runtime","cordova-fetch-local-file",(e=>this._OnCordovaFetchLocalFile(e))),this.AddRuntimeComponentMessageHandler("runtime","create-job-worker",(e=>this._OnCreateJobWorker(e))),this.AddRuntimeComponentMessageHandler("runtime","send-wrapper-extension-message",(e=>this._OnSendWrapperExtensionMessage(e))),"cordova"===this._exportType?document.addEventListener("deviceready",(()=>this._Init(e))):this._Init(e),this._skipAndroidVirtualKeyboardDetection=0}Release(){this._CancelAnimationFrame(),this._messageChannelPort&&(this._messageChannelPort.onmessage=null,this._messageChannelPort=null),this._worker&&(this._worker.terminate(),this._worker=null),this._localRuntime&&(this._localRuntime.Release(),this._localRuntime=null);for(const{canvas:e,htmlWrap:t}of this._canvasLayers)e.remove(),t.remove();this._canvasLayers.length=0}GetMainCanvas(){return this._canvasLayers[0].canvas}GetAvailableHTMLIndex(e){return Math.min(e,this._canvasLayers.length-1)}GetHTMLWrapElement(e){if(e<0||e>=this._canvasLayers.length)throw new RangeError("invalid canvas layer");return this._canvasLayers[e].htmlWrap}"_GetHTMLWrapElement"(e){return this.GetHTMLWrapElement(e)}GetRuntimeBaseURL(){return this._runtimeBaseUrl}UsesWorker(){return this._useWorker}GetExportType(){return this._exportType}IsFileProtocol(){return this._isFileProtocol}GetScriptFolder(){return this._scriptFolder}IsiOSCordova(){return e&&"cordova"===this._exportType}IsiOSWebView(){const t=navigator.userAgent;return e&&g(this._exportType)||navigator["standalone"]||/crios\/|fxios\/|edgios\//i.test(t)}IsAndroid(){return t}IsAndroidWebView(){return t&&g(this._exportType)}IsWindowsWebView2(){return"windows-webview2"===this._exportType||!!("preview"===this._exportType&&window["chrome"]&&window["chrome"]["webview"]&&window["chrome"]["webview"]["postMessage"])}IsAnyWebView2Wrapper(){return this.IsWindowsWebView2()||"xbox-uwp-webview2"===this._exportType}SkipNextAndroidVirtualKeyboardDetection(){this.IsAndroidWebView()&&this._skipAndroidVirtualKeyboardDetection++}CanDoAndroidVirtualKeyboardDetection(){return this._CanDoAndroidVirtualKeyboardDetection().next().value}*_CanDoAndroidVirtualKeyboardDetection(){if(!this.IsAndroidWebView())return!0;yield 0===this._skipAndroidVirtualKeyboardDetection,this._skipAndroidVirtualKeyboardDetection>0&&this._skipAndroidVirtualKeyboardDetection--}async _Init(e){if(this._useWorker){await i()||(this._useWorker=!1)}if("macos-wkwebview"===this._exportType&&this._SendWrapperMessage({"type":"ready"}),this.IsAnyWebView2Wrapper()||"macos-wkwebview"===this._exportType||"linux-cef"===this._exportType){this._SetupDesktopWrapperPolyfills();const e=await this._InitWrapper();this._wrapperComponentIds=e["registeredComponentIds"]}if("playable-ad-single-file"===this._exportType&&(this._localFileBlobs=self["c3_base64files"],this._localFileStrings={},await this._ConvertDataUrisToBlobs()),"nwjs"===this._exportType&&self["nw"]){if(self["nw"]["Window"]["get"]()["on"]("close",(()=>self["nw"]["App"]["quit"]())),self["nw"]["App"]["manifest"]["c3-steam-mode"]){let e=0;this._AddRAFCallback((()=>{e++,document.documentElement.style.opacity=e%2==0?"1":"0.999"}))}}if(e.runtimeBaseUrl)this._runtimeBaseUrl=e.runtimeBaseUrl;else{const e=location.origin;this._runtimeBaseUrl=("null"===e?"file:///":e)+location.pathname;const t=this._runtimeBaseUrl.lastIndexOf("/");-1!==t&&(this._runtimeBaseUrl=this._runtimeBaseUrl.substr(0,t+1))}const t=new MessageChannel;if(this._messageChannelPort=t.port1,this._messageChannelPort.onmessage=e=>this["_OnMessageFromRuntime"](e.data),window["c3_addPortMessageHandler"]&&window["c3_addPortMessageHandler"]((e=>this._OnMessageFromDebugger(e))),this._jobScheduler=new self.JobSchedulerDOM(this),await this._jobScheduler.Init(),"object"==typeof window["StatusBar"]&&window["StatusBar"]["hide"](),"object"==typeof window["AndroidFullScreen"])try{await new Promise(((e,t)=>{window["AndroidFullScreen"]["immersiveMode"](e,t)}))}catch(e){console.error("Failed to enter Android immersive mode: ",e)}this._useWorker?await this._InitWorker(e,t.port2):await this._InitDOM(e,t.port2)}_GetCommonRuntimeOptions(e){return{"runtimeBaseUrl":this._runtimeBaseUrl,"previewUrl":location.href,"windowInnerWidth":this._GetWindowInnerWidth(),"windowInnerHeight":this._GetWindowInnerHeight(),"cssDisplayMode":this.GetCssDisplayMode(),"devicePixelRatio":window.devicePixelRatio,"isFullscreen":r.IsDocumentFullscreen(),"swClientId":window["cr_swClientId"]||"","exportType":e.exportType,"isNWjs":"undefined"!=typeof nw,"fileMap":globalThis.c3_swFileMap??new Map(Object.entries(this._localFileBlobs??{})),"scriptFolder":this._scriptFolder,"isDebug":new URLSearchParams(self.location.search).has("debug"),"ife":!!self.ife,"jobScheduler":this._jobScheduler.GetPortData(),"supportedAudioFormats":o,"isFileProtocol":this._isFileProtocol,"isiOSCordova":this.IsiOSCordova(),"isiOSWebView":this.IsiOSWebView(),"isWindowsWebView2":this.IsWindowsWebView2(),"isAnyWebView2Wrapper":this.IsAnyWebView2Wrapper(),"wrapperComponentIds":this._wrapperComponentIds,"isFBInstantAvailable":void 0!==self["FBInstant"]}}async _InitWorker(e,t){const s=e.workerMainUrl;"preview"===this._exportType?(this._worker=new Worker("previewworker.js",{type:"module",name:"Runtime"}),await new Promise(((e,t)=>{const r=s=>{this._worker.removeEventListener("message",r),s.data&&"ok"===s.data["type"]?e():t()};this._worker.addEventListener("message",r),this._worker.postMessage({"type":"construct-worker-init","import":new URL(s,this._runtimeBaseUrl).toString()})}))):this._worker=await this.CreateWorker(s,{type:"module",name:"Runtime"});const r=document.createElement("canvas");r.style.display="none";const n=r["transferControlToOffscreen"]();document.body.appendChild(r);const i=document.createElement("div");i.className="c3htmlwrap",i.setAttribute("interactive",""),document.body.appendChild(i),this._canvasLayers.push({canvas:r,htmlWrap:i,lastHtmlLayerDomState:{isVisible:!0,opacity:1,isInteractive:!0}}),window["c3canvas"]=r,self["C3_InsertHTMLPlaceholders"]&&self["C3_InsertHTMLPlaceholders"](),this._worker.postMessage(Object.assign(this._GetCommonRuntimeOptions(e),{"type":"init-runtime","isInWorker":!0,"messagePort":t,"canvas":n,"runtimeScriptList":e.runtimeScriptList,"projectMainScriptPath":e.projectMainScriptPath,"javaScriptInEventsPath":e.javaScriptInEventsPath,"typeScriptInEventsPath":e.typeScriptInEventsPath}),[t,n,...this._jobScheduler.GetPortTransferables()]),this._domHandlers=m.map((e=>new e(this))),this._FindRuntimeDOMHandler(),this._runtimeDomHandler._AddDefaultCanvasEventHandlers(r),this._runtimeDomHandler._AddDefaultHTMLWrapEventHandlers(i),this._runtimeDomHandler._EnableWindowResizeEvent(),self["c3_callFunction"]=(e,t)=>this._runtimeDomHandler._InvokeFunctionFromJS(e,t),"preview"===this._exportType&&(self["goToLastErrorScript"]=()=>this.PostToRuntimeComponent("runtime","go-to-last-error-script"))}async _InitDOM(e,t){const s=document.createElement("canvas");s.style.display="none",document.body.appendChild(s);const r=document.createElement("div");r.className="c3htmlwrap",r.setAttribute("interactive",""),document.body.appendChild(r),this._canvasLayers.push({canvas:s,htmlWrap:r,lastHtmlLayerDomState:{isVisible:!0,opacity:1,isInteractive:!0}}),window["c3canvas"]=s,self["C3_InsertHTMLPlaceholders"]&&self["C3_InsertHTMLPlaceholders"](),this._domHandlers=m.map((e=>new e(this))),this._FindRuntimeDOMHandler(),this._runtimeDomHandler._AddDefaultCanvasEventHandlers(s),this._runtimeDomHandler._AddDefaultHTMLWrapEventHandlers(r);const i=await Promise.all(e.runtimeScriptList.map((e=>this._MaybeGetPlatformSpecificScriptURL(e))));await Promise.all(i.map((e=>n(e))));const a=e.projectMainScriptPath,o=e.javaScriptInEventsPath,l=e.typeScriptInEventsPath;if(a)try{if(await n(a),"preview"===this._exportType&&!globalThis.C3_ProjectMainScriptOK)throw new Error("main script did not run to completion")}catch(e){this._RemoveLoadingMessage(),console.error("Error loading project main script: ",e),alert(`Failed to load the project main script (${a}). Check all your JavaScript code has valid syntax, all imports are written correctly, and that an exception was not thrown running the script. Press F12 and check the console for error details.`)}if(o)try{if(await n(o),"preview"===this._exportType&&!globalThis.C3.JavaScriptInEvents)throw new Error("JavaScript in events did not run to completion")}catch(e){this._RemoveLoadingMessage(),console.error("Error loading JavaScript in events: ",e),alert("Failed to load JavaScript in events. Check all your JavaScript code has valid syntax, all imports are written correctly, and that an exception was not thrown running the 'Imports for events' script. Press F12 and check the console for error details.")}if(l)try{if(await n(l),"preview"===this._exportType&&!globalThis.C3.TypeScriptInEvents)throw new Error("TypeScript in events did not run to completion")}catch(e){this._RemoveLoadingMessage(),console.error("Error loading TypeScript in events: ",e),alert("Failed to load TypeScript in events. Check all your TypeScript code has valid syntax, all imports are written correctly, and that an exception was not thrown running the 'Imports for events' script. Press F12 and check the console for error details.")}const c=Object.assign(this._GetCommonRuntimeOptions(e),{"isInWorker":!1,"messagePort":t,"canvas":s,"runOnStartupFunctions":y});this._runtimeDomHandler._EnableWindowResizeEvent(),this._OnBeforeCreateRuntime(),this._localRuntime=self["C3_CreateRuntime"](c),await self["C3_InitRuntime"](this._localRuntime,c)}async CreateWorker(e,t){if(e.startsWith("blob:"))return new Worker(e,t);if("cordova"===this._exportType&&this._isFileProtocol){const s=await this.CordovaFetchLocalFileAsArrayBuffer(e),r=new Blob([s],{type:"application/javascript"});return new Worker(URL.createObjectURL(r),t)}if("playable-ad-single-file"===this._exportType){const s=this._localFileBlobs[e];if(!s)throw new Error("missing script: "+e);return new Worker(URL.createObjectURL(s),t)}const s=new URL(e,location.href);if(location.origin!==s.origin){const e=await fetch(s);if(!e.ok)throw new Error("failed to fetch worker script");const r=await e.blob();return new Worker(URL.createObjectURL(r),t)}return new Worker(s,t)}_GetWindowInnerWidth(){return Math.max(window.innerWidth,1)}_GetWindowInnerHeight(){return Math.max(window.innerHeight,1)}GetCssDisplayMode(){if(this.IsAnyWebView2Wrapper())return"standalone";const e=this.GetExportType();return new Set(["cordova","nwjs","macos-wkwebview","linux-cef"]).has(e)?"standalone":window.matchMedia("(display-mode: fullscreen)").matches?"fullscreen":window.matchMedia("(display-mode: standalone)").matches?"standalone":window.matchMedia("(display-mode: minimal-ui)").matches?"minimal-ui":navigator["standalone"]?"standalone":"browser"}_OnBeforeCreateRuntime(){this._RemoveLoadingMessage()}_RemoveLoadingMessage(){const e=window["cr_previewLoadingElem"];e&&(e.parentElement.removeChild(e),window["cr_previewLoadingElem"]=null)}async _OnCreateJobWorker(e){const t=await this._jobScheduler._CreateJobWorker();return{"outputPort":t,"transferables":[t]}}_OnUpdateCanvasSize(e){if(this.IsExportingToVideo())return;const t=e["styleWidth"]+"px",s=e["styleHeight"]+"px",r=e["marginLeft"]+"px",n=e["marginTop"]+"px";for(const{canvas:e,htmlWrap:i}of this._canvasLayers)e.style.width=t,e.style.height=s,e.style.marginLeft=r,e.style.marginTop=n,i.style.width=t,i.style.height=s,i.style.marginLeft=r,i.style.marginTop=n,this._isFirstSizeUpdate&&(e.style.display="",i.style.display="");document.documentElement.style.setProperty("--construct-scale",e["displayScale"]),this._isFirstSizeUpdate=!1}"_OnSetHTMLLayerCount"(e){const t=e["count"],s=e["layersDomState"],r=e["immediate"],n=e["styleWidth"]+"px",i=e["styleHeight"]+"px",a=e["marginLeft"]+"px",o=e["marginTop"]+"px",l=[],c=[];if(t<this._canvasLayers.length)for(;this._canvasLayers.length>t;){const{canvas:e,htmlWrap:t}=this._canvasLayers.pop();t.remove(),this._useWorker&&!r?this._pendingRemoveElements.push(e):e.remove()}else if(t>this._canvasLayers.length)for(let e=0,s=t-this._canvasLayers.length;e<s;++e){const e=document.createElement("canvas");if(e.classList.add("c3overlay"),this._useWorker){const t=e["transferControlToOffscreen"]();l.push(t),c.push(t)}else l.push(e);document.body.appendChild(e);const t=document.createElement("div");t.classList.add("c3htmlwrap","c3overlay"),t.setAttribute("interactive",""),document.body.appendChild(t),e.style.width=n,e.style.height=i,e.style.marginLeft=a,e.style.marginTop=o,t.style.width=n,t.style.height=i,t.style.marginLeft=a,t.style.marginTop=o,this._runtimeDomHandler._AddDefaultCanvasEventHandlers(e),this._runtimeDomHandler._AddDefaultHTMLWrapEventHandlers(t),this._canvasLayers.push({canvas:e,htmlWrap:t,lastHtmlLayerDomState:{isVisible:!0,opacity:1,isInteractive:!0}})}this._UpdateHTMLLayerDOMProperties(s);for(const e of this._domHandlers)e instanceof window.DOMElementHandler&&e._OnHTMLLayersChanged();return this._UpdateHTMLElementsZOrder(),{"addedCanvases":l,"transferables":c}}_UpdateHTMLLayerDOMProperties(e){for(let t=0,s=Math.min(this._canvasLayers.length,e.length);t<s;++t){const{htmlWrap:s,lastHtmlLayerDomState:r}=this._canvasLayers[t],n=e[t],i=n["isVisible"],a=n["opacity"],o=n["isInteractive"];i!==r.isVisible&&(s.style.display=i?"":"none",r.isVisible=i),a!==r.opacity&&(s.style.opacity=1===a?"":String(a),r.opacity=a),o!==r.isInteractive&&(s.style.pointerEvents=o?"":"none",o?s.setAttribute("interactive",""):s.removeAttribute("interactive"),r.isInteractive=o)}}_OnCleanUpHTMLLayers(){for(const e of this._pendingRemoveElements)e.remove();this._pendingRemoveElements.length=0}_UpdateHTMLElementsZOrder(){this._pendingUpdateHTMLZOrder||(this._pendingUpdateHTMLZOrder=!0,this._AddRAFCallback(this._updateHTMLZOrderRAFCallback))}_DoUpdateHTMLElementsZOrder(){this._RemoveRAFCallback(this._updateHTMLZOrderRAFCallback),this._pendingUpdateHTMLZOrder=!1;let e=[];for(const t of this._domHandlers)if(t instanceof window.DOMElementHandler){const s=t._GetAllElementStatesForZOrderUpdate();s&&e.push(...s)}e.sort(((e,t)=>{const s=e.GetActualHTMLIndex(),r=t.GetActualHTMLIndex();if(s!==r)return s-r;return e.GetHTMLZIndex()-t.GetHTMLZIndex()}));let t=0,s=0,r=0,n=e.length;for(;r<n;++r){const n=e[r];n.GetActualHTMLIndex()!==t&&(this._DoUpdateHTMLElementsZOrderOnHTMLLayer(t,e.slice(s,r)),t=n.GetActualHTMLIndex(),s=r)}s<r&&this._DoUpdateHTMLElementsZOrderOnHTMLLayer(t,e.slice(s,r))}_DoUpdateHTMLElementsZOrderOnHTMLLayer(e,t){if(t.length<=1)return;if(e>=this._canvasLayers.length)return;const s=t.map((e=>e.GetElement())),r=new Set(s),n=this.GetHTMLWrapElement(e),i=Array.from(n.children).filter((e=>r.has(e)));for(let e=0,t=0,r=s.length;e<r;++e){const r=s[e],a=i[t];r===a?++t:n["moveBefore"]?n["moveBefore"](r,a):n.insertBefore(r,a)}}_GetLocalRuntime(){if(this._useWorker)throw new Error("not available in worker mode");return this._localRuntime}PostToRuntimeComponent(e,t,s,r,n){this._messageChannelPort.postMessage({"type":"event","component":e,"handler":t,"dispatchOpts":r||null,"data":s,"responseId":null},n)}PostToRuntimeComponentAsync(e,t,s,r,n){const i=w++,a=new Promise(((e,t)=>{_.set(i,{resolve:e,reject:t})}));return this._messageChannelPort.postMessage({"type":"event","component":e,"handler":t,"dispatchOpts":r||null,"data":s,"responseId":i},n),a}"_OnMessageFromRuntime"(e){const t=e["type"];if("event"===t)return this._OnEventFromRuntime(e);if("result"===t)this._OnResultFromRuntime(e);else if("runtime-ready"===t)this._OnRuntimeReady();else if("alert-error"===t)this._RemoveLoadingMessage(),alert(e["message"]);else{if("creating-runtime"!==t)throw new Error(`unknown message '${t}'`);this._OnBeforeCreateRuntime()}}_OnEventFromRuntime(e){const t=e["component"],s=e["handler"],r=e["data"],n=e["responseId"],i=u.get(t);if(!i)return void console.warn(`[DOM] No event handlers for component '${t}'`);const a=i.get(s);if(!a)return void console.warn(`[DOM] No handler '${s}' for component '${t}'`);let o=null;try{o=a(r)}catch(e){return console.error(`Exception in '${t}' handler '${s}':`,e),void(null!==n&&this._PostResultToRuntime(n,!1,""+e))}if(null===n)return o;o&&o.then?o.then((e=>this._PostResultToRuntime(n,!0,e))).catch((e=>{console.error(`Rejection from '${t}' handler '${s}':`,e),this._PostResultToRuntime(n,!1,""+e)})):this._PostResultToRuntime(n,!0,o)}_PostResultToRuntime(e,t,s){let r;s&&s["transferables"]&&(r=s["transferables"]),this._messageChannelPort.postMessage({"type":"result","responseId":e,"isOk":t,"result":s},r)}_OnResultFromRuntime(e){const t=e["responseId"],s=e["isOk"],r=e["result"],n=_.get(t);s?n.resolve(r):n.reject(r),_.delete(t)}AddRuntimeComponentMessageHandler(e,t,s){let r=u.get(e);if(r||(r=new Map,u.set(e,r)),r.has(t))throw new Error(`[DOM] Component '${e}' already has handler '${t}'`);r.set(t,s)}static AddDOMHandlerClass(e){if(m.includes(e))throw new Error("DOM handler already added");m.push(e)}_FindRuntimeDOMHandler(){for(const e of this._domHandlers)if("runtime"===e.GetComponentID())return void(this._runtimeDomHandler=e);throw new Error("cannot find runtime DOM handler")}_OnMessageFromDebugger(e){this.PostToRuntimeComponent("debugger","message",e)}_OnRuntimeReady(){for(const e of this._domHandlers)e.Attach()}static IsDocumentFullscreen(){return!!(document["fullscreenElement"]||document["webkitFullscreenElement"]||document["mozFullScreenElement"]||v)}static _SetWrapperIsFullscreenFlag(e){v=!!e}async GetRemotePreviewStatusInfo(){return await this.PostToRuntimeComponentAsync("runtime","get-remote-preview-status-info")}_AddRAFCallback(e){this._rafCallbacks.add(e),this._RequestAnimationFrame()}_RemoveRAFCallback(e){this._rafCallbacks.delete(e),0===this._rafCallbacks.size&&this._CancelAnimationFrame()}_RequestAnimationFrame(){-1===this._rafId&&this._rafCallbacks.size>0&&(this._rafId=requestAnimationFrame(this._rafFunc))}_CancelAnimationFrame(){-1!==this._rafId&&(cancelAnimationFrame(this._rafId),this._rafId=-1)}_OnRAFCallback(){this._rafId=-1;for(const e of this._rafCallbacks)e();this._RequestAnimationFrame()}TryPlayMedia(e){this._runtimeDomHandler.TryPlayMedia(e)}RemovePendingPlay(e){this._runtimeDomHandler.RemovePendingPlay(e)}_PlayPendingMedia(){this._runtimeDomHandler._PlayPendingMedia()}SetSilent(e){this._runtimeDomHandler.SetSilent(e)}IsAudioFormatSupported(e){return!!o[e]}SetIsExportingToVideo(e){this._isExportingToVideo=!0,this._exportToVideoDuration=e}IsExportingToVideo(){return this._isExportingToVideo}GetExportToVideoDuration(){return this._exportToVideoDuration}IsAbsoluteURL(e){return/^(?:[a-z\-]+:)?\/\//.test(e)||"data:"===e.substr(0,5)||"blob:"===e.substr(0,5)}IsRelativeURL(e){return!this.IsAbsoluteURL(e)}async _MaybeGetPlatformSpecificScriptURL(e){if("cordova"===this._exportType&&(e.startsWith("file:")||this._isFileProtocol&&this.IsRelativeURL(e))){let t=e;t.startsWith(this._runtimeBaseUrl)&&(t=t.substr(this._runtimeBaseUrl.length));const s=await this.CordovaFetchLocalFileAsArrayBuffer(t),r=new Blob([s],{type:"application/javascript"});return URL.createObjectURL(r)}if("playable-ad-single-file"===this._exportType){if(this._localFileStrings.hasOwnProperty(e))return{isStringSrc:!0,str:this._localFileStrings[e]};if(this._localFileBlobs.hasOwnProperty(e))return URL.createObjectURL(this._localFileBlobs[e]);throw new Error("missing script: "+e)}return e}async _OnCordovaFetchLocalFile(e){const t=e["filename"];switch(e["as"]){case"text":return await this.CordovaFetchLocalFileAsText(t);case"buffer":return await this.CordovaFetchLocalFileAsArrayBuffer(t);default:throw new Error("unsupported type")}}CordovaFetchLocalFile(e){const t=window["cordova"]["file"]["applicationDirectory"]+"www/"+e;return new Promise(((e,s)=>{window["resolveLocalFileSystemURL"](t,(t=>{t["file"](e,s)}),s)}))}async CordovaFetchLocalFileAsText(e){const t=await this.CordovaFetchLocalFile(e);return await l(t)}_CordovaMaybeStartNextArrayBufferRead(){if(!d.length)return;if(h>=p)return;h++;const e=d.shift();this._CordovaDoFetchLocalFileAsAsArrayBuffer(e.filename,e.successCallback,e.errorCallback)}CordovaFetchLocalFileAsArrayBuffer(e){return new Promise(((t,s)=>{d.push({filename:e,successCallback:e=>{h--,this._CordovaMaybeStartNextArrayBufferRead(),t(e)},errorCallback:e=>{h--,this._CordovaMaybeStartNextArrayBufferRead(),s(e)}}),this._CordovaMaybeStartNextArrayBufferRead()}))}async _CordovaDoFetchLocalFileAsAsArrayBuffer(e,t,s){try{const s=await this.CordovaFetchLocalFile(e);t(await c(s))}catch(e){s(e)}}"_PlayableAdFetchBlob"(e){if(this._localFileBlobs.hasOwnProperty(e))return this._localFileBlobs[e];throw new Error("missing file: "+e)}_GetPermissionAPI(){const e=window["cordova"]&&window["cordova"]["plugins"]&&window["cordova"]["plugins"]["permissions"];if("object"!=typeof e)throw new Error("Permission API is not loaded");return e}_MapPermissionID(e,t){const s=e[t];if("string"!=typeof s)throw new Error("Invalid permission name");return s}_HasPermission(e){const t=this._GetPermissionAPI();return new Promise(((s,r)=>t["checkPermission"](this._MapPermissionID(t,e),(e=>s(!!e["hasPermission"])),r)))}_RequestPermission(e){const t=this._GetPermissionAPI();return new Promise(((s,r)=>t["requestPermission"](this._MapPermissionID(t,e),(e=>s(!!e["hasPermission"])),r)))}async RequestPermissions(e){if("cordova"!==this.GetExportType())return!0;if(this.IsiOSCordova())return!0;for(const t of e){if(await this._HasPermission(t))continue;if(!1===await this._RequestPermission(t))return!1}return!0}async RequirePermissions(...e){if(!1===await this.RequestPermissions(e))throw new Error("Permission not granted")}_OnWrapperMessage(e,t){if("object"!=typeof e||!e)return void console.warn("Unknown wrapper message: ",e);const s=e["type"];if("directory-handles"===s)this._directoryHandles=t;else if("wrapper-init-response"===s)this._wrapperInitResolve(e),this._wrapperInitResolve=null;else if("fullscreen-change"===s)r._SetWrapperIsFullscreenFlag(e["isFullscreen"]),this._runtimeDomHandler._OnFullscreenChange();else if("log-to-console"===s)switch(e["logType"]){case"error":console.error(e["message"]);break;case"warning":console.warn(e["message"]);break;default:console.log(e["message"])}else"extension-message"===s?this.PostToRuntimeComponent("runtime","wrapper-extension-message",e):console.warn("Unknown wrapper message: ",e)}_OnSendWrapperExtensionMessage(e){this._SendWrapperMessage({"type":"extension-message","componentId":e["componentId"],"messageId":e["messageId"],"params":e["params"]||[],"asyncId":e["asyncId"]})}_SendWrapperMessage(e){this.IsAnyWebView2Wrapper()?window["chrome"]["webview"]["postMessage"](JSON.stringify(e)):"macos-wkwebview"===this._exportType?window["webkit"]["messageHandlers"]["C3Wrapper"]["postMessage"](JSON.stringify(e)):"linux-cef"===this._exportType&&window["c3_linux_cef_sendmessage"](JSON.stringify(e))}_SetupDesktopWrapperPolyfills(){window.moveTo=(e,t)=>{this._SendWrapperMessage({"type":"set-window-position","windowX":Math.ceil(e),"windowY":Math.ceil(t)})},window.resizeTo=(e,t)=>{this._SendWrapperMessage({"type":"set-window-size","windowWidth":Math.ceil(e),"windowHeight":Math.ceil(t)})}}_InitWrapper(){return new Promise((e=>{this._wrapperInitResolve=e,this._SendWrapperMessage({"type":"wrapper-init"})}))}_GetDirectoryHandles(){return this._directoryHandles}async _ConvertDataUrisToBlobs(){const e=[];for(const[t,s]of Object.entries(this._localFileBlobs))e.push(this._ConvertDataUriToBlobs(t,s));await Promise.all(e)}async _ConvertDataUriToBlobs(e,t){if("object"==typeof t)this._localFileBlobs[e]=new Blob([t["str"]],{"type":t["type"]}),this._localFileStrings[e]=t["str"];else{let s=await this._FetchDataUri(t);s||(s=this._DataURIToBinaryBlobSync(t)),this._localFileBlobs[e]=s}}async _FetchDataUri(e){try{const t=await fetch(e);return await t.blob()}catch(e){return console.warn("Failed to fetch a data: URI. Falling back to a slower workaround. This is probably because the Content Security Policy unnecessarily blocked it. Allow data: URIs in your CSP to avoid this.",e),null}}_DataURIToBinaryBlobSync(e){const t=this._ParseDataURI(e);return this._BinaryStringToBlob(t.data,t.mime_type)}_ParseDataURI(e){const t=e.indexOf(",");if(t<0)throw new URIError("expected comma in data: uri");const s=e.substring(5,t),r=e.substring(t+1),n=s.split(";"),i=n[0]||"",a=n[1],o=n[2];let l;return l="base64"===a||"base64"===o?atob(r):decodeURIComponent(r),{mime_type:i,data:l}}_BinaryStringToBlob(e,t){let s,r,n=e.length,i=n>>2,a=new Uint8Array(n),o=new Uint32Array(a.buffer,0,i);for(s=0,r=0;s<i;++s)o[s]=e.charCodeAt(r++)|e.charCodeAt(r++)<<8|e.charCodeAt(r++)<<16|e.charCodeAt(r++)<<24;let l=3&n;for(;l--;)a[r]=e.charCodeAt(r),++r;return new Blob([a],{"type":t})}}}

// workers/runtimeDomEvents.js
"use strict";{const e=self.RuntimeInterface;function t(e){return e["sourceCapabilities"]&&e["sourceCapabilities"]["firesTouchEvents"]||e["originalEvent"]&&e["originalEvent"]["sourceCapabilities"]&&e["originalEvent"]["sourceCapabilities"]["firesTouchEvents"]}const i=new Map([["OSLeft","MetaLeft"],["OSRight","MetaRight"]]),n={"dispatchRuntimeEvent":!0,"dispatchUserScriptEvent":!0},s={"dispatchUserScriptEvent":!0},o={"dispatchRuntimeEvent":!0};async function a(e){const t=URL.createObjectURL(e);try{return await(i=t,new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=e=>t(e),n.src=i})))}finally{URL.revokeObjectURL(t)}var i}function r(e){do{if(e.parentNode&&e.hasAttribute("contenteditable"))return!0;e=e.parentNode}while(e);return!1}const d=new Set(["input","textarea","datalist","select"]);const l=new Set(["canvas","body","html"]);function c(e){if(!e.target.tagName)return;const t=e.target.tagName.toLowerCase();l.has(t)&&e.preventDefault()}function h(e){e.target.tagName&&e.target.classList.contains("c3htmlwrap")&&e.preventDefault()}function u(e){(e.metaKey||e.ctrlKey)&&e.preventDefault()}self["C3_GetSvgImageSize"]=async function(e){const t=await a(e);if(t.width>0&&t.height>0)return[t.width,t.height];{t.style.position="absolute",t.style.left="0px",t.style.top="0px",t.style.visibility="hidden",document.body.appendChild(t);const e=t.getBoundingClientRect();return document.body.removeChild(t),[e.width,e.height]}},self["C3_RasterSvgImageBlob"]=async function(e,t,i,n,s){const o=await a(e),r=document.createElement("canvas");r.width=n,r.height=s;return r.getContext("2d").drawImage(o,0,0,t,i),r};let m=!1;function g(){try{return window.parent&&window.parent.document.hasFocus()}catch(e){return!1}}document.addEventListener("pause",(()=>m=!0)),document.addEventListener("resume",(()=>m=!1));const p="runtime",_=class extends self.DOMHandler{constructor(e){super(e,p),this._enableWindowResizeEvent=!1,this._simulatedResizeTimerId=-1,this._targetOrientation="any",this._attachedDeviceOrientationEvent=!1,this._attachedDeviceMotionEvent=!1,this._pageVisibilityIsHidden=!1,this._screenReaderTextWrap=document.createElement("div"),this._screenReaderTextWrap.className="c3-screen-reader-text",this._screenReaderTextWrap.setAttribute("aria-live","polite"),document.body.appendChild(this._screenReaderTextWrap),this._debugHighlightElem=null,this._isExportToVideo=!1,this._exportVideoProgressMessage="",this._exportVideoUpdateTimerId=-1,this._enableAndroidVKDetection=!1,this._lastWindowWidth=e._GetWindowInnerWidth(),this._lastWindowHeight=e._GetWindowInnerHeight(),this._virtualKeyboardHeight=0,this._vkTranslateYOffset=0,e.AddRuntimeComponentMessageHandler("runtime","invoke-download",(e=>this._OnInvokeDownload(e))),e.AddRuntimeComponentMessageHandler("runtime","load-webfonts",(e=>this._OnLoadWebFonts(e))),e.AddRuntimeComponentMessageHandler("runtime","raster-svg-image",(e=>this._OnRasterSvgImage(e))),e.AddRuntimeComponentMessageHandler("runtime","get-svg-image-size",(e=>this._OnGetSvgImageSize(e))),e.AddRuntimeComponentMessageHandler("runtime","set-target-orientation",(e=>this._OnSetTargetOrientation(e))),e.AddRuntimeComponentMessageHandler("runtime","register-sw",(()=>this._OnRegisterSW())),e.AddRuntimeComponentMessageHandler("runtime","post-to-debugger",(e=>this._OnPostToDebugger(e))),e.AddRuntimeComponentMessageHandler("runtime","go-to-script",(e=>this._OnPostToDebugger(e))),e.AddRuntimeComponentMessageHandler("runtime","before-start-ticking",(()=>this._OnBeforeStartTicking())),e.AddRuntimeComponentMessageHandler("runtime","debug-highlight",(e=>this._OnDebugHighlight(e))),e.AddRuntimeComponentMessageHandler("runtime","enable-device-orientation",(()=>this._AttachDeviceOrientationEvent())),e.AddRuntimeComponentMessageHandler("runtime","enable-device-motion",(()=>this._AttachDeviceMotionEvent())),e.AddRuntimeComponentMessageHandler("runtime","add-stylesheet",(e=>this._OnAddStylesheet(e))),e.AddRuntimeComponentMessageHandler("runtime","script-create-worker",(e=>this._OnScriptCreateWorker(e))),e.AddRuntimeComponentMessageHandler("runtime","alert",(e=>this._OnAlert(e))),e.AddRuntimeComponentMessageHandler("runtime","screen-reader-text",(e=>this._OnScreenReaderTextEvent(e))),e.AddRuntimeComponentMessageHandler("runtime","hide-cordova-splash",(()=>this._OnHideCordovaSplash())),e.AddRuntimeComponentMessageHandler("runtime","set-exporting-to-video",(e=>this._SetExportingToVideo(e))),e.AddRuntimeComponentMessageHandler("runtime","export-to-video-progress",(e=>this._OnExportVideoProgress(e))),e.AddRuntimeComponentMessageHandler("runtime","exported-to-video",(e=>this._OnExportedToVideo(e))),e.AddRuntimeComponentMessageHandler("runtime","exported-to-image-sequence",(e=>this._OnExportedToImageSequence(e)));const t=new Set(["input","textarea","datalist"]);if(window.addEventListener("contextmenu",(e=>{const i=e.target,n=i.tagName.toLowerCase();t.has(n)||r(i)||e.preventDefault()})),window.addEventListener("selectstart",c),window.addEventListener("gesturehold",c),window.addEventListener("touchstart",c,{"passive":!1}),window.addEventListener("pointerdown",c,{"passive":!1}),this._mousePointerLastButtons=0,window.addEventListener("mousedown",(e=>{1===e.button&&e.preventDefault()})),window.addEventListener("mousewheel",u,{"passive":!1}),window.addEventListener("wheel",u,{"passive":!1}),window.addEventListener("resize",(()=>this._OnWindowResize())),window.addEventListener("fullscreenchange",(()=>this._OnFullscreenChange())),window.addEventListener("webkitfullscreenchange",(()=>this._OnFullscreenChange())),window.addEventListener("mozfullscreenchange",(()=>this._OnFullscreenChange())),window.addEventListener("fullscreenerror",(e=>this._OnFullscreenError(e))),window.addEventListener("webkitfullscreenerror",(e=>this._OnFullscreenError(e))),window.addEventListener("mozfullscreenerror",(e=>this._OnFullscreenError(e))),e.IsiOSWebView()){let e=1/0;window["visualViewport"].addEventListener("resize",(()=>{const t=window["visualViewport"].height;t>e&&(document.scrollingElement.scrollTop=0,document.scrollingElement.scrollLeft=0),e=t})),document.documentElement.setAttribute("ioswebview","")}this._mediaPendingPlay=new Set,this._mediaRemovedPendingPlay=new WeakSet,this._isSilent=!1}_AddDefaultCanvasEventHandlers(e){e.addEventListener("selectstart",c),e.addEventListener("gesturehold",c),e.addEventListener("pointerdown",c)}_AddDefaultHTMLWrapEventHandlers(e){e.addEventListener("selectstart",h),e.addEventListener("gesturehold",h),e.addEventListener("touchstart",h)}_OnBeforeStartTicking(){return self.setTimeout((()=>{this._enableAndroidVKDetection=!0}),1e3),"cordova"===this._iRuntime.GetExportType()?(document.addEventListener("pause",(()=>this._OnVisibilityChange(!0))),document.addEventListener("resume",(()=>this._OnVisibilityChange(!1)))):document.addEventListener("visibilitychange",(()=>this._OnVisibilityChange("hidden"===document.visibilityState))),this._pageVisibilityIsHidden=!("hidden"!==document.visibilityState&&!m),{"isSuspended":this._pageVisibilityIsHidden}}Attach(){window.addEventListener("focus",(()=>this._PostRuntimeEvent("window-focus"))),window.addEventListener("blur",(()=>{this._PostRuntimeEvent("window-blur",{"parentHasFocus":g()}),this._mousePointerLastButtons=0})),window.addEventListener("focusin",(e=>{var t;t=e.target,(d.has(t.tagName.toLowerCase())||r(t))&&this._PostRuntimeEvent("keyboard-blur")})),window.addEventListener("keydown",(e=>this._OnKeyEvent("keydown",e))),window.addEventListener("keyup",(e=>this._OnKeyEvent("keyup",e))),window.addEventListener("mousedown",(e=>this._OnMouseEvent("mousedown",e,s))),window.addEventListener("mousemove",(e=>this._OnMouseEvent("mousemove",e,s))),window.addEventListener("mouseup",(e=>this._OnMouseEvent("mouseup",e,s))),window.addEventListener("dblclick",(e=>this._OnMouseEvent("dblclick",e,n))),window.addEventListener("wheel",(e=>this._OnMouseWheelEvent("wheel",e,n))),window.addEventListener("pointerdown",(e=>{this._HandlePointerDownFocus(e),this._OnPointerEvent("pointerdown",e)})),this._iRuntime.UsesWorker()&&void 0!==window["onpointerrawupdate"]&&self===self.top?window.addEventListener("pointerrawupdate",(e=>this._OnPointerRawUpdate(e))):window.addEventListener("pointermove",(e=>this._OnPointerEvent("pointermove",e))),window.addEventListener("pointerup",(e=>this._OnPointerEvent("pointerup",e))),window.addEventListener("pointercancel",(e=>this._OnPointerEvent("pointercancel",e)));const e=()=>this._PlayPendingMedia();window.addEventListener("pointerup",e,!0),window.addEventListener("touchend",e,!0),window.addEventListener("click",e,!0),window.addEventListener("keydown",e,!0),window.addEventListener("gamepadconnected",e,!0),this._iRuntime.IsAndroid()&&!this._iRuntime.IsAndroidWebView()&&navigator["virtualKeyboard"]&&(navigator["virtualKeyboard"]["overlaysContent"]=!0,navigator["virtualKeyboard"].addEventListener("geometrychange",(()=>{this._OnAndroidVirtualKeyboardChange(this._GetWindowInnerHeight(),navigator["virtualKeyboard"]["boundingRect"]["height"])}))),this._iRuntime.IsiOSWebView()&&(document.scrollingElement.scrollTop=0,document.scrollingElement.scrollLeft=0)}_OnAndroidVirtualKeyboardChange(e,t){if(document.body.style.position="",document.body.style.overflow="",document.body.style.transform="",this._vkTranslateYOffset=0,t>0){const i=document.activeElement;if(i){const n=i.getBoundingClientRect();let s=(n.top+n.bottom)/2-(e-t)/2;s>t&&(s=t),s<0&&(s=0),s>0&&(document.body.style.position="absolute",document.body.style.overflow="visible",document.body.style.transform=`translateY(${-s}px)`,this._vkTranslateYOffset=s)}}}_PostRuntimeEvent(e,t){this.PostToRuntime(e,t||null,o)}_GetWindowInnerWidth(){return this._iRuntime._GetWindowInnerWidth()}_GetWindowInnerHeight(){return this._iRuntime._GetWindowInnerHeight()}_EnableWindowResizeEvent(){this._enableWindowResizeEvent=!0,this._lastWindowWidth=this._iRuntime._GetWindowInnerWidth(),this._lastWindowHeight=this._iRuntime._GetWindowInnerHeight()}_OnWindowResize(){if(this._isExportToVideo)return;if(!this._enableWindowResizeEvent)return;const t=this._GetWindowInnerWidth(),i=this._GetWindowInnerHeight();if(this._iRuntime.IsAndroidWebView())if(this._enableAndroidVKDetection){if(this._iRuntime.CanDoAndroidVirtualKeyboardDetection()&&this._lastWindowWidth===t&&i<this._lastWindowHeight)return this._virtualKeyboardHeight=this._lastWindowHeight-i,void this._OnAndroidVirtualKeyboardChange(this._lastWindowHeight,this._virtualKeyboardHeight);this._virtualKeyboardHeight>0&&(this._virtualKeyboardHeight=0,this._OnAndroidVirtualKeyboardChange(i,this._virtualKeyboardHeight)),this._lastWindowWidth=t,this._lastWindowHeight=i}else this._lastWindowWidth=t,this._lastWindowHeight=i;this.PostToRuntime("window-resize",{"innerWidth":t,"innerHeight":i,"devicePixelRatio":window.devicePixelRatio,"isFullscreen":e.IsDocumentFullscreen(),"cssDisplayMode":this._iRuntime.GetCssDisplayMode()}),this._iRuntime.IsiOSWebView()&&(-1!==this._simulatedResizeTimerId&&clearTimeout(this._simulatedResizeTimerId),this._OnSimulatedResize(t,i,0))}_ScheduleSimulatedResize(e,t,i){-1!==this._simulatedResizeTimerId&&clearTimeout(this._simulatedResizeTimerId),this._simulatedResizeTimerId=setTimeout((()=>this._OnSimulatedResize(e,t,i)),48)}_OnSimulatedResize(t,i,n){const s=this._GetWindowInnerWidth(),o=this._GetWindowInnerHeight();this._simulatedResizeTimerId=-1,s!=t||o!=i?this.PostToRuntime("window-resize",{"innerWidth":s,"innerHeight":o,"devicePixelRatio":window.devicePixelRatio,"isFullscreen":e.IsDocumentFullscreen(),"cssDisplayMode":this._iRuntime.GetCssDisplayMode()}):n<10&&this._ScheduleSimulatedResize(s,o,n+1)}_OnSetTargetOrientation(e){this._targetOrientation=e["targetOrientation"]}_TrySetTargetOrientation(){const e=this._targetOrientation;if(screen["orientation"]&&screen["orientation"]["lock"])screen["orientation"]["lock"](e).catch((e=>console.warn("[Construct] Failed to lock orientation: ",e)));else try{let t=!1;screen["lockOrientation"]?t=screen["lockOrientation"](e):screen["webkitLockOrientation"]?t=screen["webkitLockOrientation"](e):screen["mozLockOrientation"]?t=screen["mozLockOrientation"](e):screen["msLockOrientation"]&&(t=screen["msLockOrientation"](e)),t||console.warn("[Construct] Failed to lock orientation")}catch(e){console.warn("[Construct] Failed to lock orientation: ",e)}}_OnFullscreenChange(){if(this._isExportToVideo)return;const t=e.IsDocumentFullscreen();t&&"any"!==this._targetOrientation&&this._TrySetTargetOrientation(),this.PostToRuntime("fullscreenchange",{"isFullscreen":t,"innerWidth":this._GetWindowInnerWidth(),"innerHeight":this._GetWindowInnerHeight()})}_OnFullscreenError(t){console.warn("[Construct] Fullscreen request failed: ",t),this.PostToRuntime("fullscreenerror",{"isFullscreen":e.IsDocumentFullscreen(),"innerWidth":this._GetWindowInnerWidth(),"innerHeight":this._GetWindowInnerHeight()})}_OnVisibilityChange(e){if(this._pageVisibilityIsHidden!==e&&(this._pageVisibilityIsHidden=e,e?this._iRuntime._CancelAnimationFrame():this._iRuntime._RequestAnimationFrame(),this.PostToRuntime("visibilitychange",{"hidden":e}),!e&&this._iRuntime.IsiOSWebView())){const e=()=>{document.scrollingElement.scrollTop=0,document.scrollingElement.scrollLeft=0};setTimeout(e,50),setTimeout(e,100),setTimeout(e,250),setTimeout(e,500)}}_OnKeyEvent(e,t){if(void 0===t.key)return;if("Backspace"===t.key&&c(t),"nwjs"===this._iRuntime.GetExportType()&&"u"===t.key&&(t.ctrlKey||t.metaKey)&&t.preventDefault(),this._isExportToVideo)return;const s=i.get(t.code)||t.code;this._PostToRuntimeMaybeSync(e,{"code":s,"key":t.key,"which":t.which,"repeat":t.repeat,"altKey":t.altKey,"ctrlKey":t.ctrlKey,"metaKey":t.metaKey,"shiftKey":t.shiftKey,"timeStamp":t.timeStamp},n)}_OnMouseWheelEvent(e,t,i){this._isExportToVideo||this.PostToRuntime(e,{"clientX":t.clientX,"clientY":t.clientY+this._vkTranslateYOffset,"pageX":t.pageX,"pageY":t.pageY+this._vkTranslateYOffset,"deltaX":t.deltaX,"deltaY":t.deltaY,"deltaZ":t.deltaZ,"deltaMode":t.deltaMode,"timeStamp":t.timeStamp},i)}_OnMouseEvent(e,i,n){this._isExportToVideo||t(i)||this._PostToRuntimeMaybeSync(e,{"button":i.button,"buttons":i.buttons,"clientX":i.clientX,"clientY":i.clientY+this._vkTranslateYOffset,"pageX":i.pageX,"pageY":i.pageY+this._vkTranslateYOffset,"movementX":i.movementX||0,"movementY":i.movementY||0,"timeStamp":i.timeStamp},n)}_OnPointerEvent(e,t){if(this._isExportToVideo)return;let i=0;"mouse"===t.pointerType&&(i=this._mousePointerLastButtons),this._PostToRuntimeMaybeSync(e,{"pointerId":t.pointerId,"pointerType":t.pointerType,"button":t.button,"buttons":t.buttons,"lastButtons":i,"clientX":t.clientX,"clientY":t.clientY+this._vkTranslateYOffset,"pageX":t.pageX,"pageY":t.pageY+this._vkTranslateYOffset,"movementX":t.movementX||0,"movementY":t.movementY||0,"width":t.width||0,"height":t.height||0,"pressure":t.pressure||0,"tangentialPressure":t["tangentialPressure"]||0,"tiltX":t.tiltX||0,"tiltY":t.tiltY||0,"twist":t["twist"]||0,"timeStamp":t.timeStamp},n),"mouse"===t.pointerType&&(this._mousePointerLastButtons=t.buttons)}_OnPointerRawUpdate(e){this._OnPointerEvent("pointermove",e)}_OnTouchEvent(e,t){if(!this._isExportToVideo)for(let i=0,s=t.changedTouches.length;i<s;++i){const s=t.changedTouches[i];this._PostToRuntimeMaybeSync(e,{"pointerId":s.identifier,"pointerType":"touch","button":0,"buttons":0,"lastButtons":0,"clientX":s.clientX,"clientY":s.clientY+this._vkTranslateYOffset,"pageX":s.pageX,"pageY":s.pageY+this._vkTranslateYOffset,"movementX":t.movementX||0,"movementY":t.movementY||0,"width":2*(s["radiusX"]||s["webkitRadiusX"]||0),"height":2*(s["radiusY"]||s["webkitRadiusY"]||0),"pressure":s["force"]||s["webkitForce"]||0,"tangentialPressure":0,"tiltX":0,"tiltY":0,"twist":s["rotationAngle"]||0,"timeStamp":t.timeStamp},n)}}_HandlePointerDownFocus(e){window!==window.top&&window.focus(),this._IsElementCanvasOrDocument(e.target)&&document.activeElement&&!this._IsElementCanvasOrDocument(document.activeElement)&&document.activeElement.blur()}_IsElementCanvasOrDocument(e){return!e||e===document||e===window||e===document.body||"canvas"===e.tagName.toLowerCase()}_AttachDeviceOrientationEvent(){this._attachedDeviceOrientationEvent||(this._attachedDeviceOrientationEvent=!0,window.addEventListener("deviceorientation",(e=>this._OnDeviceOrientation(e))),window.addEventListener("deviceorientationabsolute",(e=>this._OnDeviceOrientationAbsolute(e))))}_AttachDeviceMotionEvent(){this._attachedDeviceMotionEvent||(this._attachedDeviceMotionEvent=!0,window.addEventListener("devicemotion",(e=>this._OnDeviceMotion(e))))}_OnDeviceOrientation(e){this._isExportToVideo||this.PostToRuntime("deviceorientation",{"absolute":!!e["absolute"],"alpha":e["alpha"]||0,"beta":e["beta"]||0,"gamma":e["gamma"]||0,"timeStamp":e.timeStamp,"webkitCompassHeading":e["webkitCompassHeading"],"webkitCompassAccuracy":e["webkitCompassAccuracy"]},n)}_OnDeviceOrientationAbsolute(e){this._isExportToVideo||this.PostToRuntime("deviceorientationabsolute",{"absolute":!!e["absolute"],"alpha":e["alpha"]||0,"beta":e["beta"]||0,"gamma":e["gamma"]||0,"timeStamp":e.timeStamp},n)}_OnDeviceMotion(e){if(this._isExportToVideo)return;let t=null;const i=e["acceleration"];i&&(t={"x":i["x"]||0,"y":i["y"]||0,"z":i["z"]||0});let s=null;const o=e["accelerationIncludingGravity"];o&&(s={"x":o["x"]||0,"y":o["y"]||0,"z":o["z"]||0});let a=null;const r=e["rotationRate"];r&&(a={"alpha":r["alpha"]||0,"beta":r["beta"]||0,"gamma":r["gamma"]||0}),this.PostToRuntime("devicemotion",{"acceleration":t,"accelerationIncludingGravity":s,"rotationRate":a,"interval":e["interval"],"timeStamp":e.timeStamp},n)}_OnInvokeDownload(e){const t=e["url"],i=e["filename"],n=document.createElement("a"),s=document.body;n.textContent=i,n.href=t,n.download=i,s.appendChild(n),n.click(),s.removeChild(n)}async _OnLoadWebFonts(e){const t=e["webfonts"];await Promise.all(t.map((async e=>{const t=new FontFace(e.name,`url('${e.url}')`);document.fonts.add(t),await t.load()})))}async _OnRasterSvgImage(e){const t=e["blob"],i=e["imageWidth"],n=e["imageHeight"],s=e["surfaceWidth"],o=e["surfaceHeight"],a=e["imageBitmapOpts"],r=await self["C3_RasterSvgImageBlob"](t,i,n,s,o);let d;return d=a?await createImageBitmap(r,a):await createImageBitmap(r),{"imageBitmap":d,"transferables":[d]}}async _OnGetSvgImageSize(e){return await self["C3_GetSvgImageSize"](e["blob"])}async _OnAddStylesheet(e){var t;await(t=e["url"],new Promise(((e,i)=>{const n=document.createElement("link");n.onload=()=>e(n),n.onerror=e=>i(e),n.rel="stylesheet",n.href=t,document.head.appendChild(n)})))}_PlayPendingMedia(){const e=[...this._mediaPendingPlay];if(this._mediaPendingPlay.clear(),!this._isSilent)for(const t of e){const e=t.play();e&&e.catch((e=>{this._mediaRemovedPendingPlay.has(t)||this._mediaPendingPlay.add(t)}))}}TryPlayMedia(e){if("function"!=typeof e.play)throw new Error("missing play function");let t;this._mediaRemovedPendingPlay.delete(e);try{t=e.play()}catch(t){return void this._mediaPendingPlay.add(e)}t&&t.catch((t=>{this._mediaRemovedPendingPlay.has(e)||this._mediaPendingPlay.add(e)}))}RemovePendingPlay(e){this._mediaPendingPlay.delete(e),this._mediaRemovedPendingPlay.add(e)}SetSilent(e){this._isSilent=!!e}_OnHideCordovaSplash(){navigator["splashscreen"]&&navigator["splashscreen"]["hide"]&&navigator["splashscreen"]["hide"]()}_OnDebugHighlight(e){if(!e["show"])return void(this._debugHighlightElem&&(this._debugHighlightElem.style.display="none"));this._debugHighlightElem||(this._debugHighlightElem=document.createElement("div"),this._debugHighlightElem.id="inspectOutline",document.body.appendChild(this._debugHighlightElem));const t=this._debugHighlightElem;t.style.display="",t.style.left=e["left"]-1+"px",t.style.top=e["top"]-1+"px",t.style.width=e["width"]+2+"px",t.style.height=e["height"]+2+"px",t.textContent=e["name"]}_OnRegisterSW(){window["C3_RegisterSW"]&&window["C3_RegisterSW"]()}_OnPostToDebugger(e){window["c3_postToMessagePort"]&&(e["from"]="runtime",window["c3_postToMessagePort"](e))}_InvokeFunctionFromJS(e,t){return this.PostToRuntimeAsync("js-invoke-function",{"name":e,"params":t})}_OnScriptCreateWorker(e){const t=e["url"],i=e["opts"],n=e["port2"];new Worker(t,i).postMessage({"type":"construct-worker-init","port2":n},[n])}_OnAlert(e){alert(e["message"])}_OnScreenReaderTextEvent(e){const t=e["type"];if("create"===t){const t=document.createElement("p");t.id="c3-sr-"+e["id"],t.textContent=e["text"],this._screenReaderTextWrap.appendChild(t)}else if("update"===t){const t=document.getElementById("c3-sr-"+e["id"]);t?t.textContent=e["text"]:console.warn(`[Construct] Missing screen reader text with id ${e["id"]}`)}else if("release"===t){const t=document.getElementById("c3-sr-"+e["id"]);t?t.remove():console.warn(`[Construct] Missing screen reader text with id ${e["id"]}`)}else console.warn(`[Construct] Unknown screen reader text update '${t}'`)}_SetExportingToVideo(e){this._isExportToVideo=!0;const t=document.createElement("h1");t.id="exportToVideoMessage",t.textContent=e["message"],document.body.prepend(t),document.body.classList.add("exportingToVideo"),this.GetRuntimeInterface().GetMainCanvas().style.display="",this._iRuntime.SetIsExportingToVideo(e["duration"])}_OnExportVideoProgress(e){this._exportVideoProgressMessage=e["message"],-1===this._exportVideoUpdateTimerId&&(this._exportVideoUpdateTimerId=setTimeout((()=>this._DoUpdateExportVideoProgressMessage()),250))}_DoUpdateExportVideoProgressMessage(){this._exportVideoUpdateTimerId=-1;const e=document.getElementById("exportToVideoMessage");e&&(e.textContent=this._exportVideoProgressMessage)}_OnExportedToVideo(e){window.c3_postToMessagePort({"type":"exported-video","arrayBuffer":e["arrayBuffer"],"contentType":e["contentType"],"time":e["time"]})}_OnExportedToImageSequence(e){window.c3_postToMessagePort({"type":"exported-image-sequence","blobArr":e["blobArr"],"time":e["time"],"gif":e["gif"]})}};e.AddDOMHandlerClass(_)}

// workers/jobSchedulerDom.js
"use strict";{const t="dispatchworker.js",r="jobworker.js";self.JobSchedulerDOM=class{constructor(t){this._runtimeInterface=t,this._maxNumWorkers=Math.min(navigator.hardwareConcurrency||2,16),this._dispatchWorker=null,this._jobWorkers=[],this._inputPort=null,this._outputPort=null}async Init(){if(this._hasInitialised)throw new Error("already initialised");this._hasInitialised=!0;const r=this._runtimeInterface.GetScriptFolder()+t;this._dispatchWorker=await this._runtimeInterface.CreateWorker(r,{name:"DispatchWorker"});const e=new MessageChannel;this._inputPort=e.port1,this._dispatchWorker.postMessage({"type":"_init","in-port":e.port2},[e.port2]),this._outputPort=await this._CreateJobWorker()}async _CreateJobWorker(){const t=this._jobWorkers.length,e=this._runtimeInterface.GetScriptFolder()+r,o=await this._runtimeInterface.CreateWorker(e,{name:"JobWorker"+t}),s=new MessageChannel,i=new MessageChannel;return this._dispatchWorker.postMessage({"type":"_addJobWorker","port":s.port1},[s.port1]),o.postMessage({"type":"init","number":t,"dispatch-port":s.port2,"output-port":i.port2},[s.port2,i.port2]),this._jobWorkers.push(o),i.port1}GetPortData(){return{"inputPort":this._inputPort,"outputPort":this._outputPort,"maxNumWorkers":this._maxNumWorkers}}GetPortTransferables(){return[this._inputPort,this._outputPort]}}}

// scripts/plugins/Keyboard/dom/domSide.js
"use strict";{const r="keyboard",o=class extends self.DOMHandler{constructor(o){super(o,r),this._isKeyboardLockSupported=!(!navigator["keyboard"]||!navigator["keyboard"]["lock"]),this.AddRuntimeMessageHandlers([["init",()=>this._OnInit()],["lock-keyboard",r=>this._OnLockKeyboard(r)],["unlock-keyboard",()=>this._OnUnlockKeyboard()]])}_OnInit(){return{"isKeyboardLockSupported":this._isKeyboardLockSupported}}async _OnLockKeyboard(r){const o=r["keysArr"];try{return 0===o.length?await navigator["keyboard"]["lock"]():await navigator["keyboard"]["lock"](o),{"isOk":!0}}catch(r){return console.error("Error locking keyboard:",r),{"isOk":!1}}}_OnUnlockKeyboard(){try{navigator["keyboard"]["unlock"]()}catch(r){console.error("Error unlocking keyboard:",r)}}};self.RuntimeInterface.AddDOMHandlerClass(o)}

// scripts/plugins/Touch/dom/domSide.js
"use strict";{const e="touch",t=class extends self.DOMHandler{constructor(t){super(t,e),this.AddRuntimeMessageHandler("request-permission",(e=>this._OnRequestPermission(e)))}async _OnRequestPermission(e){const t=e["type"];let s=!0;0===t?s=await this._RequestOrientationPermission():1===t&&(s=await this._RequestMotionPermission()),this.PostToRuntime("permission-result",{"type":t,"result":s})}async _RequestOrientationPermission(){if(!self["DeviceOrientationEvent"]||!self["DeviceOrientationEvent"]["requestPermission"])return!0;try{return"granted"===await self["DeviceOrientationEvent"]["requestPermission"]()}catch(e){return console.warn("[Touch] Failed to request orientation permission: ",e),!1}}async _RequestMotionPermission(){if(!self["DeviceMotionEvent"]||!self["DeviceMotionEvent"]["requestPermission"])return!0;try{return"granted"===await self["DeviceMotionEvent"]["requestPermission"]()}catch(e){return console.warn("[Touch] Failed to request motion permission: ",e),!1}}};self.RuntimeInterface.AddDOMHandlerClass(t)}

// start-export.js
"use strict";if(window["C3_IsSupported"]){const e=false;window["c3_runtimeInterface"]=new self.RuntimeInterface({useWorker:e,workerMainUrl:"workermain.js",runtimeScriptList:["scripts/c3main.js"],scriptFolder:"scripts/",exportType:"playable-ad-single-file"})}

</script>


</body> 
</html>